{"description":"Package 'bit64' provides fast serializable S3 atomic 64bit (signed) integers \nthat can be used in vectors, matrices, arrays and data.frames. Methods are \navailable for coercion from and to logicals, integers, doubles, characters  \nand factors as well as many elementwise and summary functions. \nVersion 0.8\nWith 'integer64' vectors you can store very large integers at the expense\nof 64 bits, which is by factor 7 better than 'int64' from package 'int64'.\nDue to the smaller memory footprint, the atomic vector architecture and  \nusing only S3 instead of S4 classes, most operations are one to three orders \nof magnitude faster: Example speedups are 4x for serialization, 250x for \nadding, 900x for coercion and 2000x for object creation. Also 'integer64' \navoids an ongoing (potentially infinite) penalty for garbage collection\nobserved during existence of 'int64' objects (see code in example section). \nVersion 0.9\nPackage 'bit64' - which extends R with fast 64-bit integers - now has fast\n(single-threaded) implementations the most important univariate algorithmic \noperations (those based on hashing and sorting). We now have methods for \n'match', '\n'quantile', 'median' and 'summary'. Regarding data management we also have \nnovel generics 'unipos' (positions of the unique values), 'tiepos' (\npositions of ties), 'keypos' (positions of foreign keys in a sorted \ndimension table) and derived methods 'as.factor' and 'as.ordered'. This 64-\nbit functionality is implemented carefully to be not slower than the \nrespective 32-bit operations in Base R and also to avoid outlying waiting \ntimes observed with 'order', 'rank' and 'table' (speedup factors 20/16/200 \nrespective). This increases the dataset size with wich we can work truly \ninteractive. The speed is achieved by simple heuristic optimizers in high-\nlevel functions choosing the best from multiple low-level algorithms and \nfurther taking advantage of a novel caching if activated. In an example R \nsession using a couple of these operations the 64-bit integers performed 22x\nfaster than base 32-bit integers, hash-caching improved this to 24x, \nsortorder-caching was most efficient with 38x (caching hashing and sorting \nis not worth it with 32x at duplicated RAM consumption).\n","example_call":"is.integer64(x)"}