[{"p":"base","o":"!","f":"hp_X.","d":"These operators act on raw, logical and number-like vectors.\n","ec":"!(x)"},{"p":"base","o":"$","f":"hp_X.","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":"&","f":"hp_X.","d":"These operators act on raw, logical and number-like vectors.\n","ec":"&(e1, e2)"},{"p":"base","o":"(","f":"hp_X.","d":"Open parenthesis, (, and open brace, {, are\n.Primitive functions in R.\n","ec":""},{"p":"base","o":"*","f":"hp_X.","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"*(e1, e2)"},{"p":"base","o":"+","f":"hp_X.","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"+(e1, e2)"},{"p":"base","o":"-","f":"hp_X.","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"-(e1, e2)"},{"p":"base","o":"/","f":"hp_X.","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"/(e1, e2)"},{"p":"base","o":":","f":"hp_X.","d":"Generate regular sequences.\n","ec":""},{"p":"base","o":"<","f":"hp_X.","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":"<(e1, e2)"},{"p":"base","o":"=","f":"hp_X.","d":"Assign a value to a name.\n","ec":""},{"p":"base","o":">","f":"hp_X.","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":">(e1, e2)"},{"p":"base","o":"as.matrix.data.frame","f":"hp_as.matrix.data.frame","d":"matrix creates a matrix from the given set of values.\n","ec":"as.matrix.data.frame(x, rownames.force = NA, ...)"},{"p":"base","o":"@","f":"hp_X.","d":"Extract or replace the contents of a slot or property of an object.\n","ec":""},{"p":"base","o":"F","f":"hp_F","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":""},{"p":"base","o":"I","f":"hp_I","d":"Change the class of an object to indicate that it should be treated\n<U+2018>as is<U+2019>.\n","ec":"I(x)"},{"p":"base","o":"registerS3methods","f":"hp_registerS3methods","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"registerS3methods(info, package, env)"},{"p":"base","o":"as.POSIXct.Date","f":"hp_as.POSIXct.Date","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXct.Date(x, tz = \"UTC\", ...)"},{"p":"base","o":"T","f":"hp_T","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":""},{"p":"base","o":"[","f":"hp_X.","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":"^","f":"hp_X.","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"^(e1, e2)"},{"p":"base","o":"c","f":"hp_c","d":"This is a generic function which combines its arguments.\n","ec":"c(...)"},{"p":"base","o":"q","f":"hp_q","d":"The function quit or its alias q terminate the current\nR session.\n","ec":"q(save = \"default\", status = 0, runLast = TRUE)"},{"p":"base","o":"t","f":"hp_t","d":"Given a matrix or data.frame x,\nt returns the transpose of x.\n","ec":"t(x)"},{"p":"base","o":"array2DF","f":"hp_array2DF","d":"array2DF converts an array, including list arrays commonly\nreturned by tapply, into data frames for use in further\nanalysis or plotting functions.\n","ec":"array2DF(x, responseName = \"Value\", sep = \"\", base = list(LETTERS), simplify = TRUE, allowLong = TRUE)"},{"p":"base","o":"{","f":"hp_X.","d":"Open parenthesis, (, and open brace, {, are\n.Primitive functions in R.\n","ec":""},{"p":"base","o":"|","f":"hp_X.","d":"These operators act on raw, logical and number-like vectors.\n","ec":"|(e1, e2)"},{"p":"base","o":"~","f":"hp_X.","d":"Tilde is used to separate the left- and right-hand sides in a model formula.\n","ec":""},{"p":"base","o":"qr.solve","f":"hp_qr.solve","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.solve(a, b, tol = 1e-07)"},{"p":"base","o":"str2expression","f":"hp_str2expression","d":"parse() returns the parsed but unevaluated expressions in an\nexpression, a <U+201C>list<U+201D> of calls.\n","ec":"str2expression(text)"},{"p":"base","o":"dynGet","f":"hp_dynGet","d":"Search by name for an object (get) or zero or more objects\n(mget).\n","ec":"dynGet(x, ifnotfound = stop(gettextf(\"%s not found\", sQuote(x)), domain = NA), minframe = 1L, inherits = FALSE)"},{"p":"base","o":"as.single","f":"hp_as.single","d":"Create, coerce to or test for a double-precision vector.\n","ec":"as.single(x, ...)"},{"p":"base","o":"interaction","f":"hp_interaction","d":"interaction computes a factor which represents the interaction\nof the given factors.  The result of interaction is always unordered.\n","ec":"interaction(..., drop = FALSE, sep = \".\", lex.order = FALSE)"},{"p":"base","o":"as.POSIXlt.default","f":"hp_as.POSIXlt.default","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.default(x, tz = \"\", optional = FALSE, ...)"},{"p":"base","o":"gamma","f":"hp_gamma","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"gamma(x)"},{"p":"base","o":"as.package_version","f":"hp_as.package_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"as.package_version(x)"},{"p":"base","o":".GlobalEnv","f":"hp_.GlobalEnv","d":"Get, set, test for and create environments.\n","ec":""},{"p":"base","o":"getNativeSymbolInfo","f":"hp_getNativeSymbolInfo","d":"This finds and returns a description of one or more dynamically loaded\nor <U+2018>exported<U+2019> built-in native symbols.  For each name, it\nreturns information about the name of the symbol, the library in which\nit is located and, if available, the number of arguments it expects\nand by which interface it should be called (i.e .Call,\n.C, .Fortran, or\n.External). Additionally, it returns the address of the\nsymbol and this can be passed to other C routines.  Specifically, this\nprovides a way to explicitly share symbols between different\ndynamically loaded package libraries.  Also, it provides a way to\nquery where symbols were resolved, and aids diagnosing strange\nbehavior associated with dynamic resolution.\n","ec":"getNativeSymbolInfo(name, PACKAGE, unlist = TRUE, withRegistrationInfo = FALSE)"},{"p":"base","o":"print.srcfile","f":"hp_print.srcfile","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"print.srcfile(x, ...)"},{"p":"base","o":"is.na<-","f":"hp_is.na..","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"is.na<-(x, value)"},{"p":"base","o":"packageHasNamespace","f":"hp_packageHasNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"packageHasNamespace(package, package.lib)"},{"p":"base","o":"!=","f":"hp_X..","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":"!=(e1, e2)"},{"p":"base","o":".handleSimpleError","f":"hp_.handleSimpleError","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":".handleSimpleError(h, msg, call)"},{"p":"base","o":"%%","f":"hp_X..","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"%%(e1, e2)"},{"p":"base","o":"&&","f":"hp_X..","d":"These operators act on raw, logical and number-like vectors.\n","ec":""},{"p":"base","o":"xtfrm.AsIs","f":"hp_xtfrm.AsIs","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.AsIs(x)"},{"p":"base","o":"colnames<-","f":"hp_colnames..","d":"Retrieve or set the row or column names of a matrix-like object.\n","ec":"colnames<-(x, value)"},{"p":"base","o":"file.choose","f":"hp_file.choose","d":"Choose a file interactively.\n","ec":"file.choose(new = FALSE)"},{"p":"base","o":"summary.connection","f":"hp_summary.connection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"summary.connection(object, ...)"},{"p":"base","o":".C","f":"hp_.C","d":"Functions to make calls to compiled code that has been loaded into R.\n","ec":".C(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)"},{"p":"base","o":"subset.default","f":"hp_subset.default","d":"Return subsets of vectors, matrices or data frames which meet conditions.\n","ec":"subset.default(x, subset, ...)"},{"p":"base","o":"warningCondition","f":"hp_warningCondition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"warningCondition(message, ..., class = NULL, call = NULL)"},{"p":"base","o":"utf8ToInt","f":"hp_utf8ToInt","d":"Conversion of UTF-8 encoded character vectors to and from integer\nvectors representing a UTF-32 encoding.\n","ec":"utf8ToInt(x)"},{"p":"base","o":"baseenv","f":"hp_baseenv","d":"Get, set, test for and create environments.\n","ec":"baseenv()"},{"p":"base","o":".set_row_names","f":"hp_.set_row_names","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".set_row_names(n)"},{"p":"base","o":"Ops.POSIXt","f":"hp_Ops.POSIXt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"Ops.POSIXt(e1, e2)"},{"p":"base","o":"quote","f":"hp_quote","d":"substitute returns the parse tree for the (unevaluated)\nexpression expr, substituting any variables bound in\nenv.\n","ec":"quote(expr)"},{"p":"base","o":"::","f":"hp_X..","d":"Accessing exported and internal variables, i.e. R objects\n(including lazy loaded data sets) in a namespace.\n","ec":"::(pkg, name)"},{"p":"base","o":"inverse.rle","f":"hp_inverse.rle","d":"Compute the lengths and values of runs of equal values in a vector\n<U+2013> or the reverse operation.\n","ec":"inverse.rle(x, ...)"},{"p":"base","o":"<-","f":"hp_X..","d":"Assign a value to a name.\n","ec":""},{"p":"base","o":"<=","f":"hp_X..","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":"<=(e1, e2)"},{"p":"base","o":"==","f":"hp_X..","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":"==(e1, e2)"},{"p":"base","o":">=","f":"hp_X..","d":"Binary operators which allow the comparison of values in atomic vectors.\n","ec":">=(e1, e2)"},{"p":"base","o":"memory.profile","f":"hp_memory.profile","d":"Lists the usage of the cons cells by SEXPREC type.\n","ec":"memory.profile()"},{"p":"base","o":"split.POSIXct","f":"hp_split.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"split.POSIXct(x, f, drop = FALSE, ...)"},{"p":"base","o":"unique.numeric_version","f":"hp_unique.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"unique.numeric_version(x, incomparables = FALSE, ...)"},{"p":"base","o":"infoRDS","f":"hp_infoRDS","d":"Functions to write a single R object to a file, and to restore it.\n","ec":"infoRDS(file)"},{"p":"base","o":"length.POSIXlt","f":"hp_length.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"length.POSIXlt(x)"},{"p":"base","o":"getOption","f":"hp_getOption","d":"Allow the user to set and examine a variety of global options\nwhich affect the way in which R computes and displays its results.\n","ec":"getOption(x, default = NULL)"},{"p":"base","o":"Im","f":"hp_Im","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"Im(z)"},{"p":"base","o":"qr.Q","f":"hp_qr.Q","d":"Returns the original matrix from which the object was constructed or\nthe components of the decomposition.\n","ec":"qr.Q(qr, complete = FALSE, Dvec)"},{"p":"base","o":"qr.R","f":"hp_qr.R","d":"Returns the original matrix from which the object was constructed or\nthe components of the decomposition.\n","ec":"qr.R(qr, complete = FALSE)"},{"p":"base","o":"rapply","f":"hp_rapply","d":"rapply is a recursive version of lapply with\nflexibility in how the result is structured (how = \"..\").\n","ec":"rapply(object, f, classes = \"ANY\", deflt = NULL, how = c(\"unlist\", \"replace\", \"list\"), ...)"},{"p":"base","o":"qr.X","f":"hp_qr.X","d":"Returns the original matrix from which the object was constructed or\nthe components of the decomposition.\n","ec":"qr.X(qr, complete = FALSE, ncol = if (complete) nrow(R) else min(dim(R)))"},{"p":"base","o":"library.dynam","f":"hp_library.dynam","d":"Load the specified file of compiled code if it has not been loaded\nalready, or unloads it.\n","ec":"library.dynam(chname, package, lib.loc, verbose = getOption(\"verbose\"), file.ext = .Platform$dynlib.ext, ...)"},{"p":"base","o":"evalq","f":"hp_evalq","d":"Evaluate an R expression in a specified environment.\n","ec":"evalq(expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv())"},{"p":"base","o":"units.difftime","f":"hp_units.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"units.difftime(x)"},{"p":"base","o":"Re","f":"hp_Re","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"Re(z)"},{"p":"base","o":"package_version","f":"hp_package_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"package_version(x, strict = TRUE)"},{"p":"base","o":"is.name","f":"hp_is.name","d":"A <U+2018>name<U+2019> (also known as a <U+2018>symbol<U+2019>) is a way to refer to\nR objects by name (rather than the value of the object, if any, bound\nto that name).\n","ec":"is.name(x)"},{"p":"base","o":"as.data.frame.matrix","f":"hp_as.data.frame.matrix","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.matrix(x, row.names = NULL, optional = FALSE, make.names = TRUE, ..., stringsAsFactors = FALSE)"},{"p":"base","o":".NotYetImplemented","f":"hp_.NotYetImplemented","d":"In order to pinpoint missing functionality, the R core team uses\nthese functions for missing R functions and not yet used arguments of\nexisting R functions (which are typically there for compatibility\npurposes).\n","ec":".NotYetImplemented()"},{"p":"base","o":"LETTERS","f":"hp_LETTERS","d":"Constants built into R.\n","ec":""},{"p":"base","o":"unique.array","f":"hp_unique.array","d":"unique returns a vector, data frame or array like x\nbut with duplicate elements/rows removed.\n","ec":"unique.array(x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...)"},{"p":"base","o":".LC.categories","f":"hp_.LC.categories","d":"Get details of or set aspects of the locale for the R process.\n","ec":""},{"p":"base","o":"[[","f":"hp_X..","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":"dimnames.data.frame","f":"hp_dimnames.data.frame","d":"Retrieve or set the dimnames of an object.\n","ec":"dimnames.data.frame(x)"},{"p":"base","o":"require","f":"hp_require","d":"library and require load and attach add-on packages.\n","ec":"require(package, lib.loc = NULL, quietly = FALSE, warn.conflicts, character.only = FALSE, mask.ok, exclude, include.only, attach.required = missing(include.only))"},{"p":"base","o":"parse","f":"hp_parse","d":"parse() returns the parsed but unevaluated expressions in an\nexpression, a <U+201C>list<U+201D> of calls.\n","ec":"parse(file = \"\", n = NULL, text = NULL, prompt = \"?\", keep.source = getOption(\"keep.source\"), srcfile = NULL, encoding = \"unknown\")"},{"p":"base","o":"by","f":"hp_by","d":"Function by is an object-oriented wrapper for\ntapply applied to data frames.\n","ec":"by(data, INDICES, FUN, ..., simplify = TRUE)"},{"p":"base","o":"gc","f":"hp_gc","d":"A call of gc causes a garbage collection to take place.\ngcinfo sets a flag so that\nautomatic collection is either silent (verbose = FALSE) or\nprints memory usage statistics (verbose = TRUE).\n","ec":"gc(verbose = getOption(\"verbose\"), reset = FALSE, full = TRUE)"},{"p":"base","o":"gl","f":"hp_gl","d":"Generate factors by specifying the pattern of their levels.\n","ec":"gl(n, k, length = n * k, labels = seq_len(n), ordered = FALSE)"},{"p":"base","o":"if","f":"hp_if.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"ls","f":"hp_ls","d":"ls and objects return a vector of character strings\ngiving the names of the objects in the specified environment.  When\ninvoked with no argument at the top level prompt, ls shows what\ndata sets and functions a user has defined.  When invoked with no\nargument inside a function, ls returns the names of the\nfunction's local variables: this is useful in conjunction with\nbrowser.\n","ec":"ls(name, pos = -1L, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE)"},{"p":"base","o":"unique.warnings","f":"hp_unique.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"unique.warnings(x, incomparables = FALSE, ...)"},{"p":"base","o":"pi","f":"hp_pi","d":"Constants built into R.\n","ec":""},{"p":"base","o":"gzcon","f":"hp_gzcon","d":"gzcon provides a modified connection that wraps an existing\nconnection, and decompresses reads or compresses writes through that\nconnection.  Standard gzip headers are assumed.\n","ec":"gzcon(con, level = 6, allowNonCompressed = TRUE, text = FALSE)"},{"p":"base","o":"qr","f":"hp_qr","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr(x, ...)"},{"p":"base","o":"lapply","f":"hp_lapply","d":"lapply returns a list of the same length as X, each\nelement of which is the result of applying FUN to the\ncorresponding element of X.\n","ec":"lapply(X, FUN, ...)"},{"p":"base","o":"rm","f":"hp_rm","d":"remove and rm are identical R functions that\ncan be used to remove objects.  These can\nbe specified successively as character strings, or in the character\nvector list, or through a combination of both.  All objects\nthus specified will be removed.\n","ec":"rm(..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE)"},{"p":"base","o":"paste","f":"hp_paste","d":"Concatenate vectors after converting to character.\nConcatenation happens in two basically different ways, determined by\ncollapse being a string or not.\n","ec":"paste(..., sep = \" \", collapse = NULL, recycle0 = FALSE)"},{"p":"base","o":"match","f":"hp_match","d":"match returns a vector of the positions of (first) matches of\nits first argument in its second.\n","ec":"match(x, table, nomatch = NA_integer_, incomparables = NULL)"},{"p":"base","o":"order","f":"hp_order","d":"order returns a permutation which rearranges its first\nargument into ascending or descending order, breaking ties by further\narguments.  sort.list does the same, using only one argument.\nSee the examples for how to use these functions to sort data frames,\netc.\n","ec":"order(..., na.last = TRUE, decreasing = FALSE, method = c(\"auto\", \"shell\", \"radix\"))"},{"p":"base","o":"xpdrows.data.frame","f":"hp_xpdrows.data.frame","d":"Internal auxiliary functions for use with data frames.\n","ec":"xpdrows.data.frame(x, old.rows, new.rows)"},{"p":"base","o":"rank","f":"hp_rank","d":"Returns the sample ranks of the values in a vector.  Ties (i.e., equal\nvalues) and missing values can be handled in several ways.\n","ec":"rank(x, na.last = TRUE, ties.method = c(\"average\", \"first\", \"last\", \"random\", \"max\", \"min\"))"},{"p":"base","o":"||","f":"hp_X..","d":"These operators act on raw, logical and number-like vectors.\n","ec":""},{"p":"base","o":"seq.default","f":"hp_seq.default","d":"Generate regular sequences.  seq is a standard generic with a\ndefault method.  seq.int is a primitive which can be\nmuch faster but has a few restrictions.  seq_along and\nseq_len are very fast primitives for two common cases.\n","ec":"seq.default(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL, ...)"},{"p":"base","o":"startsWith","f":"hp_startsWith","d":"Determines if entries of x start or end with string (entries of)\nprefix or suffix respectively, where strings are\nrecycled to common lengths.\n","ec":"startsWith(x, prefix)"},{"p":"base","o":"[<-.Date","f":"hp_X....Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"[<-.Date(x, ..., value)"},{"p":"base","o":".noGenerics","f":"hp_.noGenerics","d":"library and require load and attach add-on packages.\n","ec":""},{"p":"base","o":"aperm.default","f":"hp_aperm.default","d":"Transpose an array by permuting its dimensions and optionally resizing\nit.\n","ec":"aperm.default(a, perm = NULL, resize = TRUE, ...)"},{"p":"base","o":"kronecker","f":"hp_kronecker","d":"Computes the generalised Kronecker product of two arrays,\nX and Y.\n","ec":"kronecker(X, Y, FUN = \"*\", make.dimnames = FALSE, ...)"},{"p":"base","o":"traceback","f":"hp_traceback","d":"By default traceback() prints the call stack of the last\nuncaught error, i.e., the sequence of calls that lead to the error.\nThis is useful when an error occurs with an unidentifiable error\nmessage.  It can also be used to print the current stack or\narbitrary lists of calls.\n","ec":"traceback(x = NULL, max.lines = getOption(\"traceback.max.lines\", getOption(\"deparse.max.lines\", -1L)))"},{"p":"base","o":"as.character.hexmode","f":"hp_as.character.hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"as.character.hexmode(x, keepStr = FALSE, ...)"},{"p":"base","o":"simpleError","f":"hp_simpleError","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"simpleError(message, call = NULL)"},{"p":"base","o":"warnings","f":"hp_warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"warnings(...)"},{"p":"base","o":"as.Date.POSIXct","f":"hp_as.Date.POSIXct","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.POSIXct(x, tz = \"UTC\", ...)"},{"p":"base","o":"kappa.qr","f":"hp_kappa.qr","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":"kappa.qr(z, ...)"},{"p":"base","o":"isNamespace","f":"hp_isNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"isNamespace(ns)"},{"p":"base","o":"attr<-","f":"hp_attr..","d":"Get or set specific attributes of an object.\n","ec":"attr<-(x, which, value)"},{"p":"base","o":"is.finite.POSIXlt","f":"hp_is.finite.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"is.finite.POSIXlt(x)"},{"p":"base","o":"colMeans","f":"hp_colMeans","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":"colMeans(x, na.rm = FALSE, dims = 1L)"},{"p":"base","o":"as.Date.POSIXlt","f":"hp_as.Date.POSIXlt","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.POSIXlt(x, ...)"},{"p":"base","o":"asNamespace","f":"hp_asNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"asNamespace(ns, base.OK = TRUE)"},{"p":"base","o":"xtfrm.difftime","f":"hp_xtfrm.difftime","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.difftime(x)"},{"p":"base","o":"quit","f":"hp_quit","d":"The function quit or its alias q terminate the current\nR session.\n","ec":"quit(save = \"default\", status = 0, runLast = TRUE)"},{"p":"base","o":"kappa.lm","f":"hp_kappa.lm","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":"kappa.lm(z, ...)"},{"p":"base","o":"setSessionTimeLimit","f":"hp_setSessionTimeLimit","d":"Functions to set CPU and/or elapsed time limits for top-level\ncomputations or the current session.\n","ec":"setSessionTimeLimit(cpu = Inf, elapsed = Inf)"},{"p":"base","o":"find.package","f":"hp_find.package","d":"Find the paths to one or more packages.\n","ec":"find.package(package = NULL, lib.loc = NULL, quiet = FALSE, verbose = getOption(\"verbose\"))"},{"p":"base","o":"weekdays.POSIXt","f":"hp_weekdays.POSIXt","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"weekdays.POSIXt(x, abbreviate = FALSE)"},{"p":"base","o":"eval","f":"hp_eval","d":"Evaluate an R expression in a specified environment.\n","ec":"eval(expr, envir = parent.frame(), enclos = if (is.list(envir) || is.pairlist(envir)) parent.frame() else baseenv())"},{"p":"base","o":"c.numeric_version","f":"hp_c.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"c.numeric_version(..., recursive = FALSE)"},{"p":"base","o":"deparse1","f":"hp_deparse1","d":"Turn unevaluated expressions into character strings.\n","ec":"deparse1(expr, collapse = \" \", width.cutoff = 500L, ...)"},{"p":"base","o":"split.Date","f":"hp_split.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"split.Date(x, f, drop = FALSE, ...)"},{"p":"base","o":"readChar","f":"hp_readChar","d":"Transfer character strings to and from connections, without assuming\nthey are null-terminated on the connection.\n","ec":"readChar(con, nchars, useBytes = FALSE)"},{"p":"base","o":"autoloader","f":"hp_autoloader","d":"autoload creates a promise-to-evaluate autoloader and\nstores it with name name in .AutoloadEnv environment.\nWhen R attempts to evaluate name, autoloader is run,\nthe package is loaded and name is re-evaluated in the new\npackage's environment.  The result is that R behaves as if\npackage was loaded but it does not occupy memory.\n","ec":"autoloader(name, package, ...)"},{"p":"base","o":"[.POSIXct","f":"hp_X..POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[.POSIXct(x, ..., drop = TRUE)"},{"p":"base","o":"untracemem","f":"hp_untracemem","d":"This function marks an object so that a message is printed whenever the\ninternal code copies the object.  It is a\nmajor cause of hard-to-predict memory use in R.\n","ec":"untracemem(x)"},{"p":"base","o":"Encoding","f":"hp_Encoding","d":"Read or set the declared encodings for a character vector.\n","ec":"Encoding(x)"},{"p":"base","o":"debuggingState","f":"hp_debuggingState","d":"Set, unset or query the debugging flag on a function.\nThe text and condition arguments are the same as those\nthat can be supplied via a call to browser.  They can be retrieved\nby the user once the browser has been entered, and provide a mechanism to\nallow users to identify which breakpoint has been activated.\n","ec":"debuggingState(on = NULL)"},{"p":"base","o":"[.POSIXlt","f":"hp_X..POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[.POSIXlt(x, i, j, drop = TRUE)"},{"p":"base","o":"do.call","f":"hp_do.call","d":"do.call constructs and executes a function call from a name or\na function and a list of arguments to be passed to it.\n","ec":"do.call(what, args, quote = FALSE, envir = parent.frame())"},{"p":"base","o":".cache_class","f":"hp_.cache_class","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".cache_class(class, extends)"},{"p":"base","o":"regmatches<-","f":"hp_regmatches..","d":"Extract or replace matched substrings from match data obtained by\nregexpr, gregexpr,\nregexec or gregexec.\n","ec":"regmatches<-(x, m, invert = FALSE, value)"},{"p":"base","o":".getRequiredPackages2","f":"hp_.getRequiredPackages2","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".getRequiredPackages2(pkgInfo, quietly = FALSE, lib.loc = NULL, useImports = FALSE)"},{"p":"base","o":"chooseOpsMethod.default","f":"hp_chooseOpsMethod.default","d":"chooseOpsMethod is a function called by the Ops Group Generic when two\nsuitable methods are found for a given call. It determines which method to\nuse for the operation based on the objects being dispatched.\n","ec":"chooseOpsMethod.default(x, y, mx, my, cl, reverse)"},{"p":"base","o":"levels.default","f":"hp_levels.default","d":"levels provides access to the levels attribute of a variable.\nThe first form returns the value of the levels of its argument\nand the second sets the attribute.\n","ec":"levels.default(x)"},{"p":"base","o":"computeRestarts","f":"hp_computeRestarts","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"computeRestarts(cond = NULL)"},{"p":"base","o":"readBin","f":"hp_readBin","d":"Read binary data from or write binary data to a connection or raw vector.\n","ec":"readBin(con, what, n = 1L, size = NA_integer_, signed = TRUE, endian = .Platform$endian)"},{"p":"base","o":"[[<-","f":"hp_X....","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":"as.double.difftime","f":"hp_as.double.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"as.double.difftime(x, units = \"auto\", ...)"},{"p":"base","o":"sys.call","f":"hp_sys.call","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.call(which = 0L)"},{"p":"base","o":"length<-.difftime","f":"hp_length...difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"length<-.difftime(x, value)"},{"p":"base","o":"path.expand","f":"hp_path.expand","d":"Expand a path name, for example by replacing a leading tilde by the\nuser's home directory (if defined on that platform).\n","ec":"path.expand(path)"},{"p":"base","o":"fifo","f":"hp_fifo","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"fifo(description, open = \"\", blocking = FALSE, encoding = getOption(\"encoding\"))"},{"p":"base","o":"substitute","f":"hp_substitute","d":"substitute returns the parse tree for the (unevaluated)\nexpression expr, substituting any variables bound in\nenv.\n","ec":"substitute(expr, env)"},{"p":"base","o":"data.matrix","f":"hp_data.matrix","d":"Return the matrix obtained by converting all the variables in a data\nframe to numeric mode and then binding them together as the columns of\na matrix.  Factors and ordered factors are replaced by their internal\ncodes.\n","ec":"data.matrix(frame, rownames.force = NA)"},{"p":"base","o":"all.equal.formula","f":"hp_all.equal.formula","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.formula(target, current, ...)"},{"p":"base","o":"as.logical.factor","f":"hp_as.logical.factor","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":"as.logical.factor(x, ...)"},{"p":"base","o":"file","f":"hp_file","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"file(description = \"\", open = \"\", blocking = TRUE, encoding = getOption(\"encoding\"), raw = FALSE, method = getOption(\"url.method\", \"default\"))"},{"p":"base","o":"srcfilealias","f":"hp_srcfilealias","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"srcfilealias(filename, srcfile)"},{"p":"base","o":"determinant","f":"hp_determinant","d":"det calculates the determinant of a matrix.  determinant\nis a generic function that returns separately the modulus of the determinant,\noptionally on the logarithm scale, and the sign of the determinant.\n","ec":"determinant(x, logarithm = TRUE, ...)"},{"p":"base","o":"units<-.difftime","f":"hp_units...difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"units<-.difftime(x, value)"},{"p":"base","o":"print.noquote","f":"hp_print.noquote","d":"Print character strings without quotes.\n","ec":"print.noquote(x, quote = FALSE, right = FALSE, ...)"},{"p":"base","o":"by.default","f":"hp_by.default","d":"Function by is an object-oriented wrapper for\ntapply applied to data frames.\n","ec":"by.default(data, INDICES, FUN, ..., simplify = TRUE)"},{"p":"base","o":"Ops.ordered","f":"hp_Ops.ordered","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"Ops.ordered(e1, e2)"},{"p":"base","o":"getNamespace","f":"hp_getNamespace","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespace(name)"},{"p":"base","o":"as.POSIXct.default","f":"hp_as.POSIXct.default","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXct.default(x, tz = \"\", ...)"},{"p":"base","o":"conditionMessage.condition","f":"hp_conditionMessage.condition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"conditionMessage.condition(c)"},{"p":"base","o":".OptRequireMethods","f":"hp_.OptRequireMethods","d":"In R, the startup mechanism is as follows.\n","ec":".OptRequireMethods()"},{"p":"base","o":"mean.POSIXct","f":"hp_mean.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"mean.POSIXct(x, ...)"},{"p":"base","o":"as.POSIXct.POSIXlt","f":"hp_as.POSIXct.POSIXlt","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXct.POSIXlt(x, tz = \"\", ...)"},{"p":"base","o":"mean.POSIXlt","f":"hp_mean.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"mean.POSIXlt(x, ...)"},{"p":"base","o":"as.character.octmode","f":"hp_as.character.octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"as.character.octmode(x, keepStr = FALSE, ...)"},{"p":"base","o":".makeMessage","f":"hp_.makeMessage","d":"Generate a diagnostic message from its arguments.\n","ec":".makeMessage(..., domain = NULL, appendLF = FALSE)"},{"p":"base","o":"browserSetDebug","f":"hp_browserSetDebug","d":"A call to browser can provide context by supplying either a text\nargument or a condition argument.  These functions can be used to\nretrieve either of these arguments.\n","ec":"browserSetDebug(n = 1L)"},{"p":"base","o":"parent.env","f":"hp_parent.env","d":"Get, set, test for and create environments.\n","ec":"parent.env(env)"},{"p":"base","o":"print.listof","f":"hp_print.listof","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.listof(x, nl = TRUE, ...)"},{"p":"base","o":"close.srcfile","f":"hp_close.srcfile","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"close.srcfile(con, ...)"},{"p":"base","o":"anyNA.numeric_version","f":"hp_anyNA.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"anyNA.numeric_version(x, recursive = FALSE)"},{"p":"base","o":"*.difftime","f":"hp_X..difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"*.difftime(e1, e2)"},{"p":"base","o":"chooseOpsMethod","f":"hp_chooseOpsMethod","d":"chooseOpsMethod is a function called by the Ops Group Generic when two\nsuitable methods are found for a given call. It determines which method to\nuse for the operation based on the objects being dispatched.\n","ec":"chooseOpsMethod(x, y, mx, my, cl, reverse)"},{"p":"base","o":"socketAccept","f":"hp_socketAccept","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"socketAccept(socket, blocking = FALSE, open = \"a+\", encoding = getOption(\"encoding\"), timeout = getOption(\"timeout\"), options = getOption(\"socketOptions\"))"},{"p":"base","o":"transform.data.frame","f":"hp_transform.data.frame","d":"transform is a generic function, which<U+2014>at least\ncurrently<U+2014>only does anything useful with\ndata frames.  transform.default converts its first argument to\na data frame if possible and calls transform.data.frame.\n","ec":"transform.data.frame(`_data`, ...)"},{"p":"base","o":"interactive","f":"hp_interactive","d":"Return TRUE when R is being used interactively and\nFALSE otherwise.\n","ec":"interactive()"},{"p":"base","o":"unname","f":"hp_unname","d":"Remove the names or dimnames attribute of\nan R object.\n","ec":"unname(obj, force = FALSE)"},{"p":"base","o":"remove","f":"hp_remove","d":"remove and rm are identical R functions that\ncan be used to remove objects.  These can\nbe specified successively as character strings, or in the character\nvector list, or through a combination of both.  All objects\nthus specified will be removed.\n","ec":"remove(..., list = character(), pos = -1, envir = as.environment(pos), inherits = FALSE)"},{"p":"base","o":"sample","f":"hp_sample","d":"sample takes a sample of the specified size from the elements\nof x using either with or without replacement.\n","ec":"sample(x, size, replace = FALSE, prob = NULL)"},{"p":"base","o":"getNamespaceVersion","f":"hp_getNamespaceVersion","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespaceVersion(ns)"},{"p":"base","o":"removeTaskCallback","f":"hp_removeTaskCallback","d":"addTaskCallback registers an R function\nthat is to be called each time a top-level task\nis completed.\n","ec":"removeTaskCallback(id)"},{"p":"base","o":"scale","f":"hp_scale","d":"scale is generic function whose default method centers and/or\nscales the columns of a numeric matrix.\n","ec":"scale(x, center = TRUE, scale = TRUE)"},{"p":"base","o":"is.data.frame","f":"hp_is.data.frame","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"is.data.frame(x)"},{"p":"base","o":"textConnectionValue","f":"hp_textConnectionValue","d":"Input and output text connections.\n","ec":"textConnectionValue(con)"},{"p":"base","o":"transform","f":"hp_transform","d":"transform is a generic function, which<U+2014>at least\ncurrently<U+2014>only does anything useful with\ndata frames.  transform.default converts its first argument to\na data frame if possible and calls transform.data.frame.\n","ec":"transform(`_data`, ...)"},{"p":"base","o":"lchoose","f":"hp_lchoose","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"lchoose(n, k)"},{"p":"base","o":"format.POSIXct","f":"hp_format.POSIXct","d":"Functions to convert between character representations and objects of\nclasses \"POSIXlt\" and \"POSIXct\" representing calendar\ndates and times.\n","ec":"format.POSIXct(x, format = \"\", tz = \"\", usetz = FALSE, ...)"},{"p":"base","o":"is.call","f":"hp_is.call","d":"Create or test for objects of mode \"call\" (or\n\"(\", see Details).\n","ec":"is.call(x)"},{"p":"base","o":".packages","f":"hp_.packages","d":".packages returns information about package availability.\n","ec":".packages(all.available = FALSE, lib.loc = NULL)"},{"p":"base","o":"row.names","f":"hp_row.names","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names(x)"},{"p":"base","o":"[.octmode","f":"hp_X..octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"[.octmode(x, i)"},{"p":"base","o":"str2lang","f":"hp_str2lang","d":"parse() returns the parsed but unevaluated expressions in an\nexpression, a <U+201C>list<U+201D> of calls.\n","ec":"str2lang(s)"},{"p":"base","o":"sort_by.data.frame","f":"hp_sort_by.data.frame","d":"Generic function to sort an object in the order determined by one or\nmore other objects, typically vectors. A method is defined for data\nframes to sort its rows (typically by one or more columns), and the\ndefault method handles vector-like objects.\n","ec":"sort_by.data.frame(x, y, ...)"},{"p":"base","o":"print.factor","f":"hp_print.factor","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.factor(x, quote = FALSE, max.levels = NULL, width = getOption(\"width\"), ...)"},{"p":"base","o":"format.POSIXlt","f":"hp_format.POSIXlt","d":"Functions to convert between character representations and objects of\nclasses \"POSIXlt\" and \"POSIXct\" representing calendar\ndates and times.\n","ec":"format.POSIXlt(x, format = \"\", usetz = FALSE, digits = getOption(\"digits.secs\"), ...)"},{"p":"base","o":"switch","f":"hp_switch","d":"switch evaluates EXPR and accordingly chooses one of the\nfurther arguments (in ...).\n","ec":"switch(EXPR, ...)"},{"p":"base","o":"getElement","f":"hp_getElement","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":"getElement(object, name)"},{"p":"base","o":".amatch_costs","f":"hp_.amatch_costs","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".amatch_costs(x = NULL)"},{"p":"base","o":"lengths","f":"hp_lengths","d":"Get the length of each element of a list or atomic\nvector (is.atomic) as an integer or numeric vector.\n","ec":"lengths(x, use.names = TRUE)"},{"p":"base","o":"dimnames<-","f":"hp_dimnames..","d":"Retrieve or set the dimnames of an object.\n","ec":"dimnames<-(x, value)"},{"p":"base","o":"save","f":"hp_save","d":"save writes an external representation of R objects to the\nspecified file.  The objects can be read back from the file at a later\ndate by using the function load or attach\n(or data in some cases).\n","ec":"save(..., list = character(), file = stop(\"'file' must be specified\"), ascii = FALSE, version = NULL, envir = parent.frame(), compress = isTRUE(!ascii), compression_level, eval.promises = TRUE, precheck = TRUE)"},{"p":"base","o":"function","f":"hp_function.","d":"These functions provide the base mechanisms for defining\nnew functions in the R language.\n","ec":""},{"p":"base","o":"is.single","f":"hp_is.single","d":"is.single reports an error.  There are no single precision\nvalues in R.\n","ec":"is.single(x)"},{"p":"base","o":"default.stringsAsFactors","f":"hp_default.stringsAsFactors","d":"The functions or variables listed here are no longer part of R as\nthey are no longer needed.\n","ec":"default.stringsAsFactors()"},{"p":"base","o":"pmatch","f":"hp_pmatch","d":"pmatch seeks matches for the elements of its first argument\namong those of its second.\n","ec":"pmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE)"},{"p":"base","o":"withRestarts","f":"hp_withRestarts","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"withRestarts(expr, ...)"},{"p":"base","o":"scan","f":"hp_scan","d":"Read data into a vector or list from the console or file.\n","ec":"scan(file = \"\", what = double(), nmax = -1L, n = -1L, sep = \"\", quote = if (identical(sep, \"\\n\")) \"\" else \"'\\\"\", dec = \".\", skip = 0L, nlines = 0L, na.strings = \"NA\", flush = FALSE, fill = FALSE, strip.white = FALSE, quiet = FALSE, blank.lines.skip = TRUE, multi.line = TRUE, comment.char = \"\", allowEscapes = FALSE, fileEncoding = \"\", encoding = \"unknown\", text, skipNul = FALSE)"},{"p":"base","o":"is.null","f":"hp_is.null","d":"NULL represents the null object in R: it is a reserved\nword.  NULL is often returned by expressions and functions\nwhose value is undefined.\n","ec":"is.null(x)"},{"p":"base","o":"sink.number","f":"hp_sink.number","d":"sink diverts R output to a connection (and stops such diversions).\n","ec":"sink.number(type = c(\"output\", \"message\"))"},{"p":"base","o":"pretty","f":"hp_pretty","d":"Compute a  sequence of about n+1 equally spaced <U+2018>round<U+2019>\nvalues which cover the range of the values in x.\nThe values are chosen so that they are 1, 2 or 5 times a power of 10.\n","ec":"pretty(x, ...)"},{"p":"base","o":"Summary.Date","f":"hp_Summary.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"Summary.Date(..., na.rm)"},{"p":"base","o":"library.dynam.unload","f":"hp_library.dynam.unload","d":"Load the specified file of compiled code if it has not been loaded\nalready, or unloads it.\n","ec":"library.dynam.unload(chname, libpath, verbose = getOption(\"verbose\"), file.ext = .Platform$dynlib.ext)"},{"p":"base","o":"letters","f":"hp_letters","d":"Constants built into R.\n","ec":""},{"p":"base","o":"diff.difftime","f":"hp_diff.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"diff.difftime(x, ...)"},{"p":"base","o":"browserCondition","f":"hp_browserCondition","d":"A call to browser can provide context by supplying either a text\nargument or a condition argument.  These functions can be used to\nretrieve either of these arguments.\n","ec":"browserCondition(n = 1L)"},{"p":"base","o":"dir.exists","f":"hp_dir.exists","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"dir.exists(paths)"},{"p":"base","o":"print.srcref","f":"hp_print.srcref","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"print.srcref(x, useSource = TRUE, ...)"},{"p":"base","o":"range.POSIXct","f":"hp_range.POSIXct","d":"range returns a vector containing the minimum and maximum of\nall the given arguments.\n","ec":"range.POSIXct(..., na.rm = FALSE, finite = FALSE)"},{"p":"base","o":"arrayInd","f":"hp_arrayInd","d":"Give the TRUE indices of a logical object, allowing for array\nindices.\n","ec":"arrayInd(ind, .dim, .dimnames = NULL, useNames = FALSE)"},{"p":"base","o":"casefold","f":"hp_casefold","d":"Translate characters in character vectors, in particular from upper to\nlower case or vice versa.\n","ec":"casefold(x, upper = FALSE)"},{"p":"base","o":"anyNA","f":"hp_anyNA","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"anyNA(x, recursive = FALSE)"},{"p":"base","o":"suppressWarnings","f":"hp_suppressWarnings","d":"Generates a warning message that corresponds to its argument(s) and\n(optionally) the expression or function from which it was called.\n","ec":"suppressWarnings(expr, classes = \"warning\")"},{"p":"base","o":"seek","f":"hp_seek","d":"Functions to re-position connections.\n","ec":"seek(con, ...)"},{"p":"base","o":"is.language","f":"hp_is.language","d":"is.language returns TRUE if x is a\nvariable name, a call, or an\nexpression.\n","ec":"is.language(x)"},{"p":"base","o":"xtfrm.numeric_version","f":"hp_xtfrm.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"xtfrm.numeric_version(x)"},{"p":"base","o":"get0","f":"hp_get0","d":"Look for an R object of the given name and possibly return it\n","ec":"get0(x, envir = pos.to.env(-1L), mode = \"any\", inherits = TRUE, ifnotfound = NULL)"},{"p":"base","o":"as.vector","f":"hp_as.vector","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"as.vector(x, mode = \"any\")"},{"p":"base","o":"strftime","f":"hp_strftime","d":"Functions to convert between character representations and objects of\nclasses \"POSIXlt\" and \"POSIXct\" representing calendar\ndates and times.\n","ec":"strftime(x, format = \"\", tz = \"\", usetz = FALSE, ...)"},{"p":"base","o":"readRDS","f":"hp_readRDS","d":"Functions to write a single R object to a file, and to restore it.\n","ec":"readRDS(file, refhook = NULL)"},{"p":"base","o":"split<-.default","f":"hp_split...default","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split<-.default(x, f, drop = FALSE, ..., value)"},{"p":"base","o":"is.pairlist","f":"hp_is.pairlist","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"is.pairlist(x)"},{"p":"base","o":"chartr","f":"hp_chartr","d":"Translate characters in character vectors, in particular from upper to\nlower case or vice versa.\n","ec":"chartr(old, new, x)"},{"p":"base","o":"rep.Date","f":"hp_rep.Date","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep.Date(x, ...)"},{"p":"base","o":"isFALSE","f":"hp_isFALSE","d":"These operators act on raw, logical and number-like vectors.\n","ec":"isFALSE(x)"},{"p":"base","o":"as.pairlist","f":"hp_as.pairlist","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.pairlist(x)"},{"p":"base","o":"as.octmode","f":"hp_as.octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"as.octmode(x)"},{"p":"base","o":"is.na.numeric_version","f":"hp_is.na.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"is.na.numeric_version(x)"},{"p":"base","o":"length","f":"hp_length","d":"Get or set the length of vectors (including lists) and factors, and of\nany other R object for which a method has been defined.\n","ec":"length(x)"},{"p":"base","o":"formals","f":"hp_formals","d":"Get or set the formal arguments of a function.\n","ec":"formals(fun = sys.function(sys.parent()), envir = parent.frame())"},{"p":"base","o":"rawConnectionValue","f":"hp_rawConnectionValue","d":"Input and output raw connections.\n","ec":"rawConnectionValue(con)"},{"p":"base","o":"Math.POSIXt","f":"hp_Math.POSIXt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"Math.POSIXt(x, ...)"},{"p":"base","o":"Sys.chmod","f":"hp_Sys.chmod","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"Sys.chmod(paths, mode = \"0777\", use_umask = TRUE)"},{"p":"base","o":"formatC","f":"hp_formatC","d":"formatC() formats numbers individually and flexibly using\nC style format specifications.\n","ec":"formatC(x, digits = NULL, width = NULL, format = NULL, flag = \"\", mode = NULL, big.mark = \"\", big.interval = 3L, small.mark = \"\", small.interval = 5L, decimal.mark = getOption(\"OutDec\"), preserve.width = \"individual\", zero.print = NULL, replace.zero = TRUE, drop0trailing = FALSE)"},{"p":"base","o":"sign","f":"hp_sign","d":"sign returns a vector with the signs of the corresponding\nelements of x (the sign of a real number is 1, 0, or -1\nif the number is positive, zero, or negative, respectively).\n","ec":"sign(x)"},{"p":"base","o":"sinh","f":"hp_sinh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"sinh(x)"},{"p":"base","o":"sink","f":"hp_sink","d":"sink diverts R output to a connection (and stops such diversions).\n","ec":"sink(file = NULL, append = FALSE, type = c(\"output\", \"message\"), split = FALSE)"},{"p":"base","o":"solve","f":"hp_solve","d":"This generic function solves the equation a %*% x = b for x,\nwhere b can be either a vector or a matrix.\n","ec":"solve(a, b, ...)"},{"p":"base","o":".External.graphics","f":"hp_.External.graphics","d":"Internal versions of .Call and .External.\n","ec":".External.graphics(.NAME, ..., PACKAGE)"},{"p":"base","o":"as.data.frame.default","f":"hp_as.data.frame.default","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.default(x, ...)"},{"p":"base","o":"is.numeric.Date","f":"hp_is.numeric.Date","d":"Creates or coerces objects of type \"numeric\".\nis.numeric is a more general test of an object being\ninterpretable as numbers.\n","ec":"is.numeric.Date(x)"},{"p":"base","o":"all.equal.character","f":"hp_all.equal.character","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.character(target, current, ..., check.attributes = TRUE)"},{"p":"base","o":"unsplit","f":"hp_unsplit","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"unsplit(value, f, drop = FALSE)"},{"p":"base","o":"as.hexmode","f":"hp_as.hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"as.hexmode(x)"},{"p":"base","o":"declare","f":"hp_declare","d":"A framework for specifying information about R code for use by the\ninterpreter, compiler, and code analysis tools.\n","ec":"declare(...)"},{"p":"base","o":"globalenv","f":"hp_globalenv","d":"Get, set, test for and create environments.\n","ec":"globalenv()"},{"p":"base","o":"list.files","f":"hp_list.files","d":"These functions produce a character vector of the names of files or\ndirectories in the named directory.\n","ec":"list.files(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)"},{"p":"base","o":"loadingNamespaceInfo","f":"hp_loadingNamespaceInfo","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"loadingNamespaceInfo()"},{"p":"base","o":"packageEvent","f":"hp_packageEvent","d":"These functions allow users to set actions to be taken before packages\nare attached/detached and namespaces are (un)loaded.\n","ec":"packageEvent(pkgname, event = c(\"onLoad\", \"attach\", \"detach\", \"onUnload\"))"},{"p":"base","o":"make.unique","f":"hp_make.unique","d":"Makes the elements of a character vector unique by\nappending sequence numbers to duplicates.\n","ec":"make.unique(names, sep = \".\")"},{"p":"base","o":".decode_numeric_version","f":"hp_.decode_numeric_version","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".decode_numeric_version(x)"},{"p":"base","o":"logical","f":"hp_logical","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":"logical(length = 0L)"},{"p":"base","o":"as.vector.factor","f":"hp_as.vector.factor","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"as.vector.factor(x, mode = \"any\")"},{"p":"base","o":"noquote","f":"hp_noquote","d":"Print character strings without quotes.\n","ec":"noquote(obj, right = FALSE)"},{"p":"base","o":"as.qr","f":"hp_as.qr","d":"qr computes the QR decomposition of a matrix.\n","ec":"as.qr(x)"},{"p":"base","o":"class<-","f":"hp_class..","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"class<-(x, value)"},{"p":"base","o":"[[.Date","f":"hp_X...Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"[[.Date(x, ..., drop = TRUE)"},{"p":"base","o":"suppressPackageStartupMessages","f":"hp_suppressPackageStartupMessages","d":"Generate a diagnostic message from its arguments.\n","ec":"suppressPackageStartupMessages(expr)"},{"p":"base","o":"as.null.default","f":"hp_as.null.default","d":"NULL represents the null object in R: it is a reserved\nword.  NULL is often returned by expressions and functions\nwhose value is undefined.\n","ec":"as.null.default(x, ...)"},{"p":"base","o":"c.difftime","f":"hp_c.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"c.difftime(..., recursive = FALSE)"},{"p":"base","o":"as.data.frame.data.frame","f":"hp_as.data.frame.data.frame","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.data.frame(x, row.names = NULL, ...)"},{"p":"base","o":"summary.warnings","f":"hp_summary.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"summary.warnings(object, ...)"},{"p":"base","o":"file.show","f":"hp_file.show","d":"Display one or more (plain) text files, in a platform\nspecific way, typically via a <U+2018>pager<U+2019>.\n","ec":"file.show(..., header = rep(\"\", nfiles), title = \"R Information\", delete.file = FALSE, pager = getOption(\"pager\"), encoding = \"\")"},{"p":"base","o":".rowNamesDF<-","f":"hp_.rowNamesDF..","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":".rowNamesDF<-(x, make.names = FALSE, value)"},{"p":"base","o":"bindingIsLocked","f":"hp_bindingIsLocked","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"bindingIsLocked(sym, env)"},{"p":"base","o":".maskedMsg","f":"hp_.maskedMsg","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".maskedMsg(same, pkg, by)"},{"p":"base","o":".colSums","f":"hp_.colSums","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":".colSums(x, m, n, na.rm = FALSE)"},{"p":"base","o":"acosh","f":"hp_acosh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"acosh(x)"},{"p":"base","o":"bzfile","f":"hp_bzfile","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"bzfile(description, open = \"\", encoding = getOption(\"encoding\"), compression = 9)"},{"p":"base","o":"intersect","f":"hp_intersect","d":"Performs set union, intersection, (asymmetric!) difference,\nequality and membership on two vectors.\n","ec":"intersect(x, y)"},{"p":"base","o":"by.data.frame","f":"hp_by.data.frame","d":"Function by is an object-oriented wrapper for\ntapply applied to data frames.\n","ec":"by.data.frame(data, INDICES, FUN, ..., simplify = TRUE)"},{"p":"base","o":"summary.srcref","f":"hp_summary.srcref","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"summary.srcref(object, useSource = FALSE, ...)"},{"p":"base","o":"units<-","f":"hp_units..","d":"Get or set units.","ec":"units<-(x, value)"},{"p":"base","o":"withAutoprint","f":"hp_withAutoprint","d":"source causes R to accept its input from the named file or URL\nor connection or expressions directly.  Input is read and\nparsed from that file\nuntil the end of the file is reached, then the parsed expressions are\nevaluated sequentially in the chosen environment.\n","ec":"withAutoprint(exprs, evaluated = FALSE, local = parent.frame(), print. = TRUE, echo = TRUE, max.deparse.length = Inf, width.cutoff = max(20, getOption(\"width\")), deparseCtrl = c(\"keepInteger\", \"showAttributes\", \"keepNA\"), skip.echo = 0, ...)"},{"p":"base","o":"as.table.default","f":"hp_as.table.default","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"as.table.default(x, ...)"},{"p":"base","o":"kappa.default","f":"hp_kappa.default","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":"kappa.default(z, exact = FALSE, norm = NULL, method = c(\"qr\", \"direct\"), inv_z = solve(z), triangular = FALSE, uplo = \"U\", ...)"},{"p":"base","o":"as.list.Date","f":"hp_as.list.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"as.list.Date(x, ...)"},{"p":"base","o":".Primitive","f":"hp_.Primitive","d":".Primitive looks up by name a <U+2018>primitive<U+2019>\n(internally implemented) function.\n","ec":".Primitive(name)"},{"p":"base","o":"getDLLRegisteredRoutines.character","f":"hp_getDLLRegisteredRoutines.character","d":"This function allows us to query the set of routines\nin a DLL that are registered with R to enhance\ndynamic lookup, error handling when calling native routines,\nand potentially security in the future.\nThis function provides a description of each of the\nregistered routines in the DLL for the different interfaces,\ni.e. .C, .Call, .Fortran\nand .External.\n","ec":"getDLLRegisteredRoutines.character(dll, addNames = TRUE)"},{"p":"base","o":"gctorture2","f":"hp_gctorture2","d":"Provokes garbage collection on (nearly) every memory allocation.\nIntended to ferret out memory protection bugs.  Also makes R run\nvery slowly, unfortunately.\n","ec":"gctorture2(step, wait = step, inhibit_release = FALSE)"},{"p":"base","o":"Conj","f":"hp_Conj","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"Conj(z)"},{"p":"base","o":"normalizePath","f":"hp_normalizePath","d":"Convert file paths to canonical form for the platform, to display them\nin a user-understandable form and so that relative and absolute paths can\nbe compared.\n","ec":"normalizePath(path, winslash = \"\\\\\", mustWork = NA)"},{"p":"base","o":"sort","f":"hp_sort","d":"Sort (or order) a vector or factor (partially) into\nascending or descending order.  For ordering along more than one\nvariable, e.g., for sorting data frames, see order.\n","ec":"sort(x, decreasing = FALSE, ...)"},{"p":"base","o":"addNA","f":"hp_addNA","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"addNA(x, ifany = FALSE)"},{"p":"base","o":"is.matrix","f":"hp_is.matrix","d":"matrix creates a matrix from the given set of values.\n","ec":"is.matrix(x)"},{"p":"base","o":"[<-.factor","f":"hp_X....factor","d":"Extract or replace subsets of factors.\n","ec":"[<-.factor(x, ..., value)"},{"p":"base","o":"writeLines","f":"hp_writeLines","d":"Write text lines to a connection.\n","ec":"writeLines(text, con = stdout(), sep = \"\\n\", useBytes = FALSE)"},{"p":"base","o":"colSums","f":"hp_colSums","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":"colSums(x, na.rm = FALSE, dims = 1L)"},{"p":"base","o":"saveRDS","f":"hp_saveRDS","d":"Functions to write a single R object to a file, and to restore it.\n","ec":"saveRDS(object, file = \"\", ascii = FALSE, version = NULL, compress = TRUE, refhook = NULL)"},{"p":"base","o":"suppressMessages","f":"hp_suppressMessages","d":"Generate a diagnostic message from its arguments.\n","ec":"suppressMessages(expr, classes = \"message\")"},{"p":"base","o":"print.data.frame","f":"hp_print.data.frame","d":"Print a data frame.\n","ec":"print.data.frame(x, ..., digits = NULL, quote = FALSE, right = TRUE, row.names = TRUE, max = NULL)"},{"p":"base","o":"[[<-.factor","f":"hp_X.....factor","d":"Extract or replace subsets of factors.\n","ec":"[[<-.factor(x, ..., value)"},{"p":"base","o":"$.DLLInfo","f":"hp_X..DLLInfo","d":"This function provides a way to get a list of all the DLLs (see\ndyn.load) that are currently loaded in the R session.\n","ec":"$.DLLInfo(x, name)"},{"p":"base","o":"%*%","f":"hp_X...","d":"Multiplies two matrices, if they are conformable.  If one argument is\na vector, it will be promoted to either a row or column matrix to make\nthe two arguments conformable.  If both are vectors of the same\nlength, it will return the inner product (as a matrix).\n","ec":"%*%(x, y)"},{"p":"base","o":"undebug","f":"hp_undebug","d":"Set, unset or query the debugging flag on a function.\nThe text and condition arguments are the same as those\nthat can be supplied via a call to browser.  They can be retrieved\nby the user once the browser has been entered, and provide a mechanism to\nallow users to identify which breakpoint has been activated.\n","ec":"undebug(fun, signature = NULL)"},{"p":"base","o":"$<-","f":"hp_X...","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":"%/%","f":"hp_X...","d":"These unary and binary operators perform arithmetic on numeric or\ncomplex vectors (or objects which can be coerced to them).\n","ec":"%/%(e1, e2)"},{"p":"base","o":"tanh","f":"hp_tanh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"tanh(x)"},{"p":"base","o":"is.loaded","f":"hp_is.loaded","d":"Load or unload DLLs (also known as shared objects), and test whether a\nC function or Fortran subroutine is available.\n","ec":"is.loaded(symbol, PACKAGE = \"\", type = \"\")"},{"p":"base","o":"curlGetHeaders","f":"hp_curlGetHeaders","d":"Retrieve the headers for a URL for a supported protocol such as\n<U+2018><U+2060>http://<U+2060><U+2019>, <U+2018><U+2060>ftp://<U+2060><U+2019>, <U+2018><U+2060>https://<U+2060><U+2019> and <U+2018><U+2060>ftps://<U+2060><U+2019>.\n","ec":"curlGetHeaders(url, redirect = TRUE, verify = TRUE, timeout = 0L, TLS = \"\")"},{"p":"base","o":"sqrt","f":"hp_sqrt","d":"abs(x) computes the absolute value of x, sqrt(x) computes the\n(principal) square root of x, \\sqrt{x}.\n","ec":"sqrt(x)"},{"p":"base","o":"sample.int","f":"hp_sample.int","d":"sample takes a sample of the specified size from the elements\nof x using either with or without replacement.\n","ec":"sample.int(n, size = n, replace = FALSE, prob = NULL, useHash = (n > 1e+07 && !replace && is.null(prob) && size <= n/2))"},{"p":"base","o":"grep","f":"hp_grep","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE, fixed = FALSE, useBytes = FALSE, invert = FALSE)"},{"p":"base","o":"xtfrm.POSIXct","f":"hp_xtfrm.POSIXct","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.POSIXct(x)"},{"p":"base","o":"is.logical","f":"hp_is.logical","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":"is.logical(x)"},{"p":"base","o":"print.proc_time","f":"hp_print.proc_time","d":"proc.time determines how much real and CPU time (in seconds)\nthe currently running R process has already taken.\n","ec":"print.proc_time(x, ...)"},{"p":"base","o":"[<-.difftime","f":"hp_X....difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"[<-.difftime(x, i, value)"},{"p":"base","o":"Sys.readlink","f":"hp_Sys.readlink","d":"Find out if a file path is a symbolic link, and if so what it is\nlinked to, via the system call readlink.\n","ec":"Sys.readlink(paths)"},{"p":"base","o":"strsplit","f":"hp_strsplit","d":"Split the elements of a character vector x into substrings\naccording to the matches to substring split within them.\n","ec":"strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)"},{"p":"base","o":"xtfrm.POSIXlt","f":"hp_xtfrm.POSIXlt","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.POSIXlt(x)"},{"p":"base","o":"Cstack_info","f":"hp_Cstack_info","d":"Report information on the C stack size and usage (if available).\n","ec":"Cstack_info()"},{"p":"base","o":"dir.create","f":"hp_dir.create","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"dir.create(path, showWarnings = TRUE, recursive = FALSE, mode = \"0777\")"},{"p":"base","o":"nlevels","f":"hp_nlevels","d":"Return the number of levels which its argument has.\n","ec":"nlevels(x)"},{"p":"base","o":"aperm","f":"hp_aperm","d":"Transpose an array by permuting its dimensions and optionally resizing\nit.\n","ec":"aperm(a, perm, ...)"},{"p":"base","o":"xtfrm","f":"hp_xtfrm","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm(x)"},{"p":"base","o":"Summary.data.frame","f":"hp_Summary.data.frame","d":"Group generic methods can be defined for the following pre-specified groups of\nfunctions, Math, Ops, matrixOps, Summary and Complex.\n(There are no objects of these names in base R, but there are in the\nmethods package, not yet for matrixOps.)\n","ec":"Summary.data.frame(..., na.rm)"},{"p":"base","o":"gsub","f":"hp_gsub","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"merge.data.frame","f":"hp_merge.data.frame","d":"Merge two data frames by common columns or row names, or do other\nversions of database join operations.\n","ec":"merge.data.frame(x, y, by = intersect(names(x), names(y)), by.x = by, by.y = by, all = FALSE, all.x = all, all.y = all, sort = TRUE, suffixes = c(\".x\", \".y\"), no.dups = TRUE, incomparables = NULL, ...)"},{"p":"base","o":"as.vector.POSIXlt","f":"hp_as.vector.POSIXlt","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"as.vector.POSIXlt(x, mode = \"any\")"},{"p":"base","o":".S3PrimitiveGenerics","f":"hp_.S3PrimitiveGenerics","d":"Many R-internal functions are generic and allow\nmethods to be written for.\n","ec":""},{"p":"base","o":"stop","f":"hp_stop","d":"stop stops execution of the current expression and executes\nan error action.\n","ec":"stop(..., call. = TRUE, domain = NULL)"},{"p":"base","o":"sort.list","f":"hp_sort.list","d":"order returns a permutation which rearranges its first\nargument into ascending or descending order, breaking ties by further\narguments.  sort.list does the same, using only one argument.\nSee the examples for how to use these functions to sort data frames,\netc.\n","ec":"sort.list(x, partial = NULL, na.last = TRUE, decreasing = FALSE, method = c(\"auto\", \"shell\", \"quick\", \"radix\"))"},{"p":"base","o":"unloadNamespace","f":"hp_unloadNamespace","d":"Functions to load and unload name spaces.\n","ec":"unloadNamespace(ns)"},{"p":"base","o":"grouping","f":"hp_grouping","d":"grouping returns a permutation which rearranges its first\nargument such that identical values are adjacent to each other.  Also\nreturned as attributes are the group-wise partitioning and the maximum\ngroup size.\n","ec":"grouping(...)"},{"p":"base","o":"seek.connection","f":"hp_seek.connection","d":"Functions to re-position connections.\n","ec":"seek.connection(con, where = NA, origin = \"start\", rw = \"\", ...)"},{"p":"base","o":"as.matrix.default","f":"hp_as.matrix.default","d":"matrix creates a matrix from the given set of values.\n","ec":"as.matrix.default(x, ...)"},{"p":"base","o":"%o%","f":"hp_X.o.","d":"The outer product of the arrays X and Y is the array\nA with dimension c(dim(X), dim(Y)) where element\nA[c(arrayindex.x, arrayindex.y)]\n    = FUN(X[arrayindex.x], Y[arrayindex.y], ...).\n","ec":"%o%(X, Y)"},{"p":"base","o":"as.POSIXlt.numeric","f":"hp_as.POSIXlt.numeric","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.numeric(x, tz = \"\", origin, ...)"},{"p":"base","o":"eval.parent","f":"hp_eval.parent","d":"Evaluate an R expression in a specified environment.\n","ec":"eval.parent(expr, n = 1)"},{"p":"base","o":"%x%","f":"hp_X.x.","d":"Computes the generalised Kronecker product of two arrays,\nX and Y.\n","ec":"%x%(X, Y)"},{"p":"base","o":"diff.POSIXt","f":"hp_diff.POSIXt","d":"Returns suitably lagged and iterated differences.\n","ec":"diff.POSIXt(x, lag = 1L, differences = 1L, ...)"},{"p":"base","o":"pushBack","f":"hp_pushBack","d":"Functions to push back text lines onto a connection, and to enquire\nhow many lines are currently pushed back.\n","ec":"pushBack(data, connection, newLine = TRUE, encoding = c(\"\", \"bytes\", \"UTF-8\"))"},{"p":"base","o":"transform.default","f":"hp_transform.default","d":"transform is a generic function, which<U+2014>at least\ncurrently<U+2014>only does anything useful with\ndata frames.  transform.default converts its first argument to\na data frame if possible and calls transform.data.frame.\n","ec":"transform.default(`_data`, ...)"},{"p":"base","o":"srcfilecopy","f":"hp_srcfilecopy","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"srcfilecopy(filename, lines, timestamp = Sys.time(), isFile = FALSE)"},{"p":"base","o":"qr.coef","f":"hp_qr.coef","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.coef(qr, y)"},{"p":"base","o":"restartFormals","f":"hp_restartFormals","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"restartFormals(r)"},{"p":"base","o":"print.rle","f":"hp_print.rle","d":"Compute the lengths and values of runs of equal values in a vector\n<U+2013> or the reverse operation.\n","ec":"print.rle(x, digits = getOption(\"digits\"), prefix = \"\", ...)"},{"p":"base","o":"format.octmode","f":"hp_format.octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"format.octmode(x, width = NULL, ...)"},{"p":"base","o":"diff.Date","f":"hp_diff.Date","d":"Returns suitably lagged and iterated differences.\n","ec":"diff.Date(x, lag = 1L, differences = 1L, ...)"},{"p":"base","o":"conditionCall.condition","f":"hp_conditionCall.condition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"conditionCall.condition(c)"},{"p":"base","o":"as.matrix","f":"hp_as.matrix","d":"matrix creates a matrix from the given set of values.\n","ec":"as.matrix(x, ...)"},{"p":"base","o":"enc2utf8","f":"hp_enc2utf8","d":"Read or set the declared encodings for a character vector.\n","ec":"enc2utf8(x)"},{"p":"base","o":"sys.function","f":"hp_sys.function","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.function(which = 0L)"},{"p":"base","o":"print.DLLInfo","f":"hp_print.DLLInfo","d":"This function provides a way to get a list of all the DLLs (see\ndyn.load) that are currently loaded in the R session.\n","ec":"print.DLLInfo(x, ...)"},{"p":"base","o":"UseMethod","f":"hp_UseMethod","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class(es) of the first argument to the generic function or of\nthe object supplied as an argument to UseMethod or NextMethod.\n","ec":"UseMethod(generic, object)"},{"p":"base","o":"write.dcf","f":"hp_write.dcf","d":"Reads or writes an R object from/to a file in Debian Control File\nformat.\n","ec":"write.dcf(x, file = \"\", append = FALSE, useBytes = FALSE, indent = 0.1 * getOption(\"width\"), width = 0.9 * getOption(\"width\"), keep.white = NULL)"},{"p":"base","o":"split","f":"hp_split","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split(x, f, drop = FALSE, ...)"},{"p":"base","o":"match.call","f":"hp_match.call","d":"match.call returns a call in which all of the specified arguments are\nspecified by their full names.\n","ec":"match.call(definition = sys.function(sys.parent()), call = sys.call(sys.parent()), expand.dots = TRUE, envir = parent.frame(2L))"},{"p":"base","o":"is.numeric.POSIXt","f":"hp_is.numeric.POSIXt","d":"Creates or coerces objects of type \"numeric\".\nis.numeric is a more general test of an object being\ninterpretable as numbers.\n","ec":"is.numeric.POSIXt(x)"},{"p":"base","o":"sys.calls","f":"hp_sys.calls","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.calls()"},{"p":"base","o":".AutoloadEnv","f":"hp_.AutoloadEnv","d":"autoload creates a promise-to-evaluate autoloader and\nstores it with name name in .AutoloadEnv environment.\nWhen R attempts to evaluate name, autoloader is run,\nthe package is loaded and name is re-evaluated in the new\npackage's environment.  The result is that R behaves as if\npackage was loaded but it does not occupy memory.\n","ec":""},{"p":"base","o":"length<-.Date","f":"hp_length...Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"length<-.Date(x, value)"},{"p":"base","o":"format.numeric_version","f":"hp_format.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"format.numeric_version(x, ...)"},{"p":"base","o":"char.expand","f":"hp_char.expand","d":"Seeks a unique match of its first argument among the\nelements of its second.  If successful, it returns this element;\notherwise, it performs an action specified by the third argument.\n","ec":"char.expand(input, target, nomatch = stop(\"no match\"))"},{"p":"base","o":"signif","f":"hp_signif","d":"ceiling takes a single numeric argument x and returns a\nnumeric vector containing the smallest integers not less than the\ncorresponding elements of x.\n","ec":"signif(x, digits = 6)"},{"p":"base","o":"file.link","f":"hp_file.link","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.link(from, to)"},{"p":"base","o":".Devices","f":"hp_.Devices","d":"A pairlist of the names of open graphics devices is stored in\n.Devices. The name of the active device (see\ndev.cur) is stored in .Device.  Both are symbols\nand so appear in the base namespace.\n","ec":""},{"p":"base","o":"diff.default","f":"hp_diff.default","d":"Returns suitably lagged and iterated differences.\n","ec":"diff.default(x, lag = 1L, differences = 1L, ...)"},{"p":"base","o":"dyn.load","f":"hp_dyn.load","d":"Load or unload DLLs (also known as shared objects), and test whether a\nC function or Fortran subroutine is available.\n","ec":"dyn.load(x, local = TRUE, now = TRUE, ...)"},{"p":"base","o":".userHooksEnv","f":"hp_.userHooksEnv","d":"These functions allow users to set actions to be taken before packages\nare attached/detached and namespaces are (un)loaded.\n","ec":""},{"p":"base","o":"anyNA.POSIXlt","f":"hp_anyNA.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"anyNA.POSIXlt(x, recursive = FALSE)"},{"p":"base","o":".subset","f":"hp_.subset","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".subset(x, ...)"},{"p":"base","o":"expm1","f":"hp_expm1","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"expm1(x)"},{"p":"base","o":"is.vector","f":"hp_is.vector","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"is.vector(x, mode = \"any\")"},{"p":"base","o":"apply","f":"hp_apply","d":"Returns a vector or array or list of values obtained by applying a\nfunction to margins of an array or matrix.\n","ec":"apply(X, MARGIN, FUN, ..., simplify = TRUE)"},{"p":"base","o":"iconvlist","f":"hp_iconvlist","d":"This uses system facilities to convert a character vector between\nencodings: the <U+2018>i<U+2019> stands for <U+2018>internationalization<U+2019>.\n","ec":"iconvlist()"},{"p":"base","o":"chkDots","f":"hp_chkDots","d":"Warn about extraneous arguments in the ... of its caller.  A\nutility to be used e.g., in S3 methods which need a formal ...\nargument but do not make any use of it.  This helps catching user\nerrors in calling the function in question (which is the caller of\nchkDots()).\n","ec":"chkDots(..., which.call = -1, allowed = character(0))"},{"p":"base","o":".gt","f":"hp_.gt","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".gt(x, i, j)"},{"p":"base","o":"is.na.data.frame","f":"hp_is.na.data.frame","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"is.na.data.frame(x)"},{"p":"base","o":"library","f":"hp_library","d":"library and require load and attach add-on packages.\n","ec":"library(package, help, pos = 2, lib.loc = NULL, character.only = FALSE, logical.return = FALSE, warn.conflicts, quietly = FALSE, verbose = getOption(\"verbose\"), mask.ok, exclude, include.only, attach.required = missing(include.only))"},{"p":"base","o":"julian.POSIXt","f":"hp_julian.POSIXt","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"julian.POSIXt(x, origin = as.POSIXct(\"1970-01-01\", tz = \"GMT\"), ...)"},{"p":"base","o":"path.package","f":"hp_path.package","d":"Find the paths to one or more packages.\n","ec":"path.package(package = NULL, quiet = FALSE)"},{"p":"base","o":"as.data.frame.vector","f":"hp_as.data.frame.vector","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.vector(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"proc.time","f":"hp_proc.time","d":"proc.time determines how much real and CPU time (in seconds)\nthe currently running R process has already taken.\n","ec":"proc.time()"},{"p":"base","o":"table","f":"hp_table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"table(..., exclude = if (useNA == \"no\") c(NA, NaN), useNA = c(\"no\", \"ifany\", \"always\"), dnn = list.names(...), deparse.level = 1)"},{"p":"base","o":"enc2native","f":"hp_enc2native","d":"Read or set the declared encodings for a character vector.\n","ec":"enc2native(x)"},{"p":"base","o":"as.data.frame.table","f":"hp_as.data.frame.table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"as.data.frame.table(x, row.names = NULL, ..., responseName = \"Freq\", stringsAsFactors = TRUE, sep = \"\", base = list(LETTERS))"},{"p":"base","o":"debug","f":"hp_debug","d":"Set, unset or query the debugging flag on a function.\nThe text and condition arguments are the same as those\nthat can be supplied via a call to browser.  They can be retrieved\nby the user once the browser has been entered, and provide a mechanism to\nallow users to identify which breakpoint has been activated.\n","ec":"debug(fun, text = \"\", condition = NULL, signature = NULL)"},{"p":"base","o":"OlsonNames","f":"hp_OlsonNames","d":"Information about time zones in R.  Sys.timezone returns\nthe name of the current time zone.\n","ec":"OlsonNames(tzdir = NULL)"},{"p":"base","o":"marginSums","f":"hp_marginSums","d":"For a contingency table in array form, compute the sum of table\nentries for a given margin or set of margins.\n","ec":"marginSums(x, margin = NULL)"},{"p":"base","o":".Library","f":"hp_.Library","d":"-NA-","ec":"-NA-"},{"p":"base","o":"isOpen","f":"hp_isOpen","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"isOpen(con, rw = \"\")"},{"p":"base","o":"grepRaw","f":"hp_grepRaw","d":"grepRaw searches for substring pattern matches within a\nraw vector x.\n","ec":"grepRaw(pattern, x, offset = 1L, ignore.case = FALSE, value = FALSE, fixed = FALSE, all = FALSE, invert = FALSE)"},{"p":"base","o":"nullfile","f":"hp_nullfile","d":"Display aspects of connections.\n","ec":"nullfile()"},{"p":"base","o":"rowsum","f":"hp_rowsum","d":"Compute column sums across rows of a numeric matrix-like object for\neach level of a grouping variable.  rowsum is generic, with a\nmethod for data frames and a default method for vectors and matrices.\n","ec":"rowsum(x, group, reorder = TRUE, ...)"},{"p":"base","o":"as.list.data.frame","f":"hp_as.list.data.frame","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list.data.frame(x, ...)"},{"p":"base","o":"as.list","f":"hp_as.list","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list(x, ...)"},{"p":"base","o":"topenv","f":"hp_topenv","d":"Finding the top level environment from an environment\nenvir and its enclosing environments.\n","ec":"topenv(envir = parent.frame(), matchThisEnv = getOption(\"topLevelEnvironment\"))"},{"p":"base","o":"system.file","f":"hp_system.file","d":"Finds the full file names of files in packages etc.\n","ec":"system.file(..., package = \"base\", lib.loc = NULL, mustWork = FALSE)"},{"p":"base","o":"repeat","f":"hp_repeat.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"as.character.factor","f":"hp_as.character.factor","d":"Create or test for objects of type \"character\".\n","ec":"as.character.factor(x, ...)"},{"p":"base","o":"print.table","f":"hp_print.table","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.table(x, digits = getOption(\"digits\"), quote = FALSE, na.print = \"\", zero.print = \"0\", right = is.numeric(x) || is.complex(x), justify = \"none\", ...)"},{"p":"base","o":"lockEnvironment","f":"hp_lockEnvironment","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"lockEnvironment(env, bindings = FALSE)"},{"p":"base","o":"xtfrm.default","f":"hp_xtfrm.default","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.default(x)"},{"p":"base","o":"all.vars","f":"hp_all.vars","d":"Return a character vector containing all the names which occur in an\nexpression or call.\n","ec":"all.vars(expr, functions = FALSE, max.names = -1L, unique = TRUE)"},{"p":"base","o":"format.default","f":"hp_format.default","d":"Format an R object for pretty printing.\n","ec":"format.default(x, trim = FALSE, digits = NULL, nsmall = 0L, justify = c(\"left\", \"right\", \"centre\", \"none\"), width = NULL, na.encode = TRUE, scientific = NA, big.mark = \"\", big.interval = 3L, small.mark = \"\", small.interval = 5L, decimal.mark = getOption(\"OutDec\"), zero.print = NULL, drop0trailing = FALSE, ...)"},{"p":"base","o":"choose","f":"hp_choose","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"choose(n, k)"},{"p":"base","o":"as.expression.default","f":"hp_as.expression.default","d":"Creates or tests for objects of mode and class \"expression\".\n","ec":"as.expression.default(x, ...)"},{"p":"base","o":"bitwAnd","f":"hp_bitwAnd","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwAnd(a, b)"},{"p":"base","o":"mem.maxVSize","f":"hp_mem.maxVSize","d":"Query and set the maximal size of the vector heap and the maximal\nnumber of heap nodes for the current R process.\n","ec":"mem.maxVSize(vsize = 0)"},{"p":"base","o":"tabulate","f":"hp_tabulate","d":"tabulate takes the integer-valued vector bin and counts\nthe number of times each integer occurs in it.\n","ec":"tabulate(bin, nbins = max(1L, bin, na.rm = TRUE))"},{"p":"base","o":"cut.POSIXt","f":"hp_cut.POSIXt","d":"Method for cut applied to date-time objects.\n","ec":"cut.POSIXt(x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...)"},{"p":"base","o":"as.POSIXlt.Date","f":"hp_as.POSIXlt.Date","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.Date(x, tz = \"UTC\", ...)"},{"p":"base","o":"c.noquote","f":"hp_c.noquote","d":"Print character strings without quotes.\n","ec":"c.noquote(..., recursive = FALSE)"},{"p":"base","o":"file.size","f":"hp_file.size","d":"Utility function to extract information about files on the user's\nfile systems.\n","ec":"file.size(...)"},{"p":"base","o":"[[.POSIXct","f":"hp_X...POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[[.POSIXct(x, ..., drop = TRUE)"},{"p":"base","o":"makeActiveBinding","f":"hp_makeActiveBinding","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"makeActiveBinding(sym, fun, env)"},{"p":"base","o":":::","f":"hp_X...","d":"Accessing exported and internal variables, i.e. R objects\n(including lazy loaded data sets) in a namespace.\n","ec":":::(pkg, name)"},{"p":"base","o":"[[.POSIXlt","f":"hp_X...POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[[.POSIXlt(x, i, drop = TRUE)"},{"p":"base","o":"c.Date","f":"hp_c.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"c.Date(..., recursive = FALSE)"},{"p":"base","o":"findInterval","f":"hp_findInterval","d":"Given a vector of non-decreasing breakpoints in vec, find the\ninterval containing each element of x; i.e., if\ni <- findInterval(x,v), for each index j in x\nv_{i_j} \\le x_j < v_{i_j + 1}\nwhere v_0 := -\\infty,\nv_{N+1} := +\\infty, and N <- length(v).\nAt the two boundaries, the returned index may differ by 1, depending\non the optional arguments rightmost.closed and all.inside.\n","ec":"findInterval(x, vec, rightmost.closed = FALSE, all.inside = FALSE, left.open = FALSE)"},{"p":"base","o":"all.equal.raw","f":"hp_all.equal.raw","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.raw(target, current, ..., check.attributes = TRUE)"},{"p":"base","o":"parseNamespaceFile","f":"hp_parseNamespaceFile","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"parseNamespaceFile(package, package.lib, mustExist = TRUE)"},{"p":"base","o":"icuSetCollate","f":"hp_icuSetCollate","d":"Controls the way collation is done by ICU (an optional part of the R\nbuild).\n","ec":"icuSetCollate(...)"},{"p":"base","o":"print.numeric_version","f":"hp_print.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"print.numeric_version(x, quote = FALSE, ...)"},{"p":"base","o":"sequence.default","f":"hp_sequence.default","d":"The default method for sequence generates the sequence\nseq(from[i], by = by[i], length.out = nvec[i]) for each\nelement i in the parallel (and recycled) vectors from,\nby and nvec. It then returns the result of concatenating\nthose sequences.\n","ec":"sequence.default(nvec, from = 1L, by = 1L, ...)"},{"p":"base","o":"Sys.localeconv","f":"hp_Sys.localeconv","d":"Get details of the numerical and monetary representations in the\ncurrent locale.\n","ec":"Sys.localeconv()"},{"p":"base","o":"conditionCall","f":"hp_conditionCall","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"conditionCall(c)"},{"p":"base","o":"!.hexmode","f":"hp_X..hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"!.hexmode(a)"},{"p":"base","o":"margin.table","f":"hp_margin.table","d":"For a contingency table in array form, compute the sum of table\nentries for a given margin or set of margins.\n","ec":"margin.table(x, margin = NULL)"},{"p":"base","o":"<<-","f":"hp_X...","d":"Assign a value to a name.\n","ec":""},{"p":"base","o":"sprintf","f":"hp_sprintf","d":"A wrapper for the C function sprintf, that returns a character\nvector containing a formatted combination of text and variable values.\n","ec":"sprintf(fmt, ...)"},{"p":"base","o":"duplicated.matrix","f":"hp_duplicated.matrix","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"duplicated.matrix(x, incomparables = FALSE, MARGIN = 1L, fromLast = FALSE, ...)"},{"p":"base","o":".ArgsEnv","f":"hp_.ArgsEnv","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"cbind.data.frame","f":"hp_cbind.data.frame","d":"Take a sequence of vector, matrix or data-frame arguments and combine\nby columns or rows, respectively.  These are generic\nfunctions with methods for other R classes.\n","ec":"cbind.data.frame(..., deparse.level = 1)"},{"p":"base","o":"read.dcf","f":"hp_read.dcf","d":"Reads or writes an R object from/to a file in Debian Control File\nformat.\n","ec":"read.dcf(file, fields = NULL, all = FALSE, keep.white = NULL)"},{"p":"base","o":"names","f":"hp_names","d":"Functions to get or set the names of an object.\n","ec":"names(x)"},{"p":"base","o":"append","f":"hp_append","d":"Add elements to a vector.\n","ec":"append(x, values, after = length(x))"},{"p":"base","o":"rowsum.data.frame","f":"hp_rowsum.data.frame","d":"Compute column sums across rows of a numeric matrix-like object for\neach level of a grouping variable.  rowsum is generic, with a\nmethod for data frames and a default method for vectors and matrices.\n","ec":"rowsum.data.frame(x, group, reorder = TRUE, na.rm = FALSE, ...)"},{"p":"base","o":"mat.or.vec","f":"hp_mat.or.vec","d":"mat.or.vec creates an nr by nc zero matrix if\nnc is greater than 1, and a zero vector of length nr if\nnc equals 1.\n","ec":"mat.or.vec(nr, nc)"},{"p":"base","o":"as.POSIXlt.POSIXct","f":"hp_as.POSIXlt.POSIXct","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.POSIXct(x, tz = \"\", ...)"},{"p":"base","o":"is.na<-.default","f":"hp_is.na...default","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"is.na<-.default(x, value)"},{"p":"base","o":"split<-","f":"hp_split..","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split<-(x, f, drop = FALSE, ..., value)"},{"p":"base","o":"R.version.string","f":"hp_R.version.string","d":"-NA-","ec":"-NA-"},{"p":"base","o":"tanpi","f":"hp_tanpi","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"tanpi(x)"},{"p":"base","o":"namespaceExport","f":"hp_namespaceExport","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"namespaceExport(ns, vars)"},{"p":"base","o":"Summary.numeric_version","f":"hp_Summary.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"Summary.numeric_version(..., na.rm)"},{"p":"base","o":"prmatrix","f":"hp_prmatrix","d":"An earlier method for printing matrices, provided for S compatibility.\n","ec":"prmatrix(x, rowlab = dn[[1]], collab = dn[[2]], quote = TRUE, right = FALSE, na.print = NULL, ...)"},{"p":"base","o":"as.single.default","f":"hp_as.single.default","d":"Create, coerce to or test for a double-precision vector.\n","ec":"as.single.default(x, ...)"},{"p":"base","o":"expand.grid","f":"hp_expand.grid","d":"Create a data frame from all combinations of the supplied vectors or\nfactors.  See the description of the return value for precise details of\nthe way this is done.\n","ec":"expand.grid(..., KEEP.OUT.ATTRS = TRUE, stringsAsFactors = TRUE)"},{"p":"base","o":"vapply","f":"hp_vapply","d":"lapply returns a list of the same length as X, each\nelement of which is the result of applying FUN to the\ncorresponding element of X.\n","ec":"vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)"},{"p":"base","o":"dimnames","f":"hp_dimnames","d":"Retrieve or set the dimnames of an object.\n","ec":"dimnames(x)"},{"p":"base","o":"nameOfClass","f":"hp_nameOfClass","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"nameOfClass(x)"},{"p":"base","o":"@<-","f":"hp_X...","d":"Extract or replace the contents of a slot or property of an object.\n","ec":""},{"p":"base","o":".popath","f":"hp_.popath","d":"-NA-","ec":"-NA-"},{"p":"base","o":"kappa","f":"hp_kappa","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":"kappa(z, ...)"},{"p":"base","o":"identical","f":"hp_identical","d":"The safe and reliable way to test two objects for being\nexactly equal.  It returns TRUE in this case,\nFALSE in every other case.\n","ec":"identical(x, y, num.eq = TRUE, single.NA = TRUE, attrib.as.set = TRUE, ignore.bytecode = TRUE, ignore.environment = FALSE, ignore.srcref = TRUE, extptr.as.ref = FALSE)"},{"p":"base","o":"chol.default","f":"hp_chol.default","d":"Compute the Cholesky factorization of a real symmetric\npositive-definite square matrix.\n","ec":"chol.default(x, pivot = FALSE, LINPACK = FALSE, tol = -1, ...)"},{"p":"base","o":"sapply","f":"hp_sapply","d":"lapply returns a list of the same length as X, each\nelement of which is the result of applying FUN to the\ncorresponding element of X.\n","ec":"sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)"},{"p":"base","o":".format.zeros","f":"hp_.format.zeros","d":"formatC() formats numbers individually and flexibly using\nC style format specifications.\n","ec":".format.zeros(x, zero.print, nx = suppressWarnings(as.numeric(x)), replace = FALSE, warn.non.fitting = TRUE)"},{"p":"base","o":"gctorture","f":"hp_gctorture","d":"Provokes garbage collection on (nearly) every memory allocation.\nIntended to ferret out memory protection bugs.  Also makes R run\nvery slowly, unfortunately.\n","ec":"gctorture(on = TRUE)"},{"p":"base","o":"missing","f":"hp_missing","d":"missing can be used to test whether a value was specified\nas an argument to a function.\n","ec":"missing(x)"},{"p":"base","o":"abbreviate","f":"hp_abbreviate","d":"Abbreviate strings to at least minlength characters,\nsuch that they remain unique (if they were),\nunless strict = TRUE.\n","ec":"abbreviate(names.arg, minlength = 4L, use.classes = TRUE, dot = FALSE, strict = FALSE, method = c(\"left.kept\", \"both.sides\"), named = TRUE)"},{"p":"base","o":"showConnections","f":"hp_showConnections","d":"Display aspects of connections.\n","ec":"showConnections(all = FALSE)"},{"p":"base","o":"merge","f":"hp_merge","d":"Merge two data frames by common columns or row names, or do other\nversions of database join operations.\n","ec":"merge(x, y, ...)"},{"p":"base","o":"nargs","f":"hp_nargs","d":"When used inside a function body, nargs returns the number of\narguments supplied to that function, including positional\narguments left blank.\n","ec":"nargs()"},{"p":"base","o":"proportions","f":"hp_proportions","d":"Returns conditional proportions given margins, i.e.,\nentries of x, divided by the appropriate marginal sums.\n","ec":"proportions(x, margin = NULL)"},{"p":"base","o":"is.R","f":"hp_is.R","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"is.R()"},{"p":"base","o":"Sys.sleep","f":"hp_Sys.sleep","d":"Suspend execution of R expressions for a specified time interval.\n","ec":"Sys.sleep(time)"},{"p":"base","o":"reg.finalizer","f":"hp_reg.finalizer","d":"Registers an R function to be called upon garbage collection of\nobject or (optionally) at the end of an R session.\n","ec":"reg.finalizer(e, f, onexit = FALSE)"},{"p":"base","o":"isdebugged","f":"hp_isdebugged","d":"Set, unset or query the debugging flag on a function.\nThe text and condition arguments are the same as those\nthat can be supplied via a call to browser.  They can be retrieved\nby the user once the browser has been entered, and provide a mechanism to\nallow users to identify which breakpoint has been activated.\n","ec":"isdebugged(fun, signature = NULL)"},{"p":"base","o":".C_R_getTaskCallbackNames","f":"hp_.C_R_getTaskCallbackNames","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"range.Date","f":"hp_range.Date","d":"range returns a vector containing the minimum and maximum of\nall the given arguments.\n","ec":"range.Date(..., na.rm = FALSE, finite = FALSE)"},{"p":"base","o":"anyDuplicated.default","f":"hp_anyDuplicated.default","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"anyDuplicated.default(x, incomparables = FALSE, fromLast = FALSE, ...)"},{"p":"base","o":"mapply","f":"hp_mapply","d":"mapply is a multivariate version of sapply.\nmapply applies FUN to the first elements of each ...\nargument, the second elements, the third elements, and so on.\nArguments are recycled if necessary.\n","ec":"mapply(FUN, ..., MoreArgs = NULL, SIMPLIFY = TRUE, USE.NAMES = TRUE)"},{"p":"base","o":"asplit","f":"hp_asplit","d":"Split an array or matrix by its margins.","ec":"asplit(x, MARGIN)"},{"p":"base","o":"rep.factor","f":"hp_rep.factor","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep.factor(x, ...)"},{"p":"base","o":"zapsmall","f":"hp_zapsmall","d":"zapsmall determines a digits argument dr for\ncalling round(x, digits = dr) such that values close to\nzero (compared with the maximal absolute value in the vector) are\n<U+2018>zapped<U+2019>, i.e., replaced by 0.\n","ec":"zapsmall(x, digits = getOption(\"digits\"), mFUN = function(x, ina) max(abs(x[!ina])), min.d = 0L)"},{"p":"base","o":"outer","f":"hp_outer","d":"The outer product of the arrays X and Y is the array\nA with dimension c(dim(X), dim(Y)) where element\nA[c(arrayindex.x, arrayindex.y)]\n    = FUN(X[arrayindex.x], Y[arrayindex.y], ...).\n","ec":"outer(X, Y, FUN = \"*\", ...)"},{"p":"base","o":"print.function","f":"hp_print.function","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.function(x, useSource = TRUE, ...)"},{"p":"base","o":"qr.default","f":"hp_qr.default","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.default(x, tol = 1e-07, LAPACK = FALSE, ...)"},{"p":"base","o":"backsolve","f":"hp_backsolve","d":"Solves a triangular system of linear equations.\n","ec":"backsolve(r, x, k = ncol(r), upper.tri = TRUE, transpose = FALSE)"},{"p":"base","o":"ISOdate","f":"hp_ISOdate","d":"Convenience wrappers to create date-times from numeric representations.\n","ec":"ISOdate(year, month, day, hour = 12, min = 0, sec = 0, tz = \"GMT\")"},{"p":"base","o":"duplicated.array","f":"hp_duplicated.array","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"duplicated.array(x, incomparables = FALSE, MARGIN = 1L, fromLast = FALSE, ...)"},{"p":"base","o":"isS4","f":"hp_isS4","d":"Tests whether the object is an instance of an S4 class.\n","ec":"isS4(object)"},{"p":"base","o":"isBaseNamespace","f":"hp_isBaseNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"isBaseNamespace(ns)"},{"p":"base","o":"errorCondition","f":"hp_errorCondition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"errorCondition(message, ..., class = NULL, call = NULL)"},{"p":"base","o":".detach","f":"hp_.detach","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".detach(pos)"},{"p":"base","o":"Arg","f":"hp_Arg","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"Arg(z)"},{"p":"base","o":"file.mtime","f":"hp_file.mtime","d":"Utility function to extract information about files on the user's\nfile systems.\n","ec":"file.mtime(...)"},{"p":"base","o":"setwd","f":"hp_setwd","d":"getwd returns an absolute filepath representing the current\nworking directory of the R process; setwd(dir) is used to set\nthe working directory to dir.\n","ec":"setwd(dir)"},{"p":"base","o":".kappa_tri","f":"hp_.kappa_tri","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":".kappa_tri(z, exact = FALSE, LINPACK = TRUE, norm = NULL, uplo = \"U\", ...)"},{"p":"base","o":"is.na<-.numeric_version","f":"hp_is.na...numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"is.na<-.numeric_version(x, value)"},{"p":"base","o":"bitwNot","f":"hp_bitwNot","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwNot(a)"},{"p":"base","o":".getRequiredPackages","f":"hp_.getRequiredPackages","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".getRequiredPackages(file = \"DESCRIPTION\", lib.loc = NULL, quietly = FALSE, useImports = FALSE)"},{"p":"base","o":"getwd","f":"hp_getwd","d":"getwd returns an absolute filepath representing the current\nworking directory of the R process; setwd(dir) is used to set\nthe working directory to dir.\n","ec":"getwd()"},{"p":"base","o":"list2env","f":"hp_list2env","d":"From a named list x, create an\nenvironment containing all list components as objects, or\n<U+201C>multi-assign<U+201D> from x into a pre-existing environment.\n","ec":"list2env(x, envir = NULL, parent = parent.frame(), hash = (length(x) > 100), size = max(29L, length(x)))"},{"p":"base","o":"set.seed","f":"hp_set.seed","d":".Random.seed is an integer vector, containing the random number\ngenerator (RNG) state for random number generation in R.  It\ncan be saved and restored, but should not be altered by the user.\n","ec":"set.seed(seed, kind = NULL, normal.kind = NULL, sample.kind = NULL)"},{"p":"base","o":"[[<-.POSIXlt","f":"hp_X.....POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[[<-.POSIXlt(x, i, value)"},{"p":"base","o":".doWrap","f":"hp_.doWrap","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".doWrap(vec, decr, nalast, noNA = NA)"},{"p":"base","o":"R_compiled_by","f":"hp_R_compiled_by","d":"R.Version() provides detailed information about the version of\nR running.\n","ec":"R_compiled_by()"},{"p":"base","o":"is.primitive","f":"hp_is.primitive","d":"Checks whether its argument is a (primitive) function.","ec":"is.primitive(x)"},{"p":"base","o":"grepl","f":"hp_grepl","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"grepl(pattern, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"Ops.data.frame","f":"hp_Ops.data.frame","d":"Group generic methods can be defined for the following pre-specified groups of\nfunctions, Math, Ops, matrixOps, Summary and Complex.\n(There are no objects of these names in base R, but there are in the\nmethods package, not yet for matrixOps.)\n","ec":"Ops.data.frame(e1, e2 = NULL)"},{"p":"base","o":"format.difftime","f":"hp_format.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"format.difftime(x, ...)"},{"p":"base","o":"trigamma","f":"hp_trigamma","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"trigamma(x)"},{"p":"base","o":"as.list.difftime","f":"hp_as.list.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"as.list.difftime(x, ...)"},{"p":"base","o":"&.hexmode","f":"hp_X..hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"&.hexmode(a, b)"},{"p":"base","o":"character","f":"hp_character","d":"Create or test for objects of type \"character\".\n","ec":"character(length = 0L)"},{"p":"base","o":".col","f":"hp_.col","d":"Returns a matrix of integers indicating their column number in a\nmatrix-like object, or a factor of column labels.\n","ec":".col(dim)"},{"p":"base","o":".POSIXct","f":"hp_.POSIXct","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".POSIXct(xx, tz = NULL, cl = c(\"POSIXct\", \"POSIXt\"))"},{"p":"base","o":"returnValue","f":"hp_returnValue","d":"A call to trace allows you to insert debugging code (e.g., a\ncall to browser or recover) at chosen\nplaces in any function.  A call to untrace cancels the tracing.\nSpecified methods can be traced the same way, without tracing all\ncalls to the generic function.  Trace code (tracer) can be any\nR expression.  Tracing can be temporarily turned on or off globally\nby calling tracingState.\n","ec":"returnValue(default = NULL)"},{"p":"base","o":".POSIXlt","f":"hp_.POSIXlt","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".POSIXlt(xx, tz = NULL, cl = c(\"POSIXlt\", \"POSIXt\"))"},{"p":"base","o":"xtfrm.data.frame","f":"hp_xtfrm.data.frame","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.data.frame(x)"},{"p":"base","o":"Math.difftime","f":"hp_Math.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"Math.difftime(x, ...)"},{"p":"base","o":"version","f":"hp_version","d":"R.Version() provides detailed information about the version of\nR running.\n","ec":""},{"p":"base","o":"jitter","f":"hp_jitter","d":"Add a small amount of noise to a numeric vector.\n","ec":"jitter(x, factor = 1, amount = NULL)"},{"p":"base","o":"isNamespaceLoaded","f":"hp_isNamespaceLoaded","d":"Functions to load and unload name spaces.\n","ec":"isNamespaceLoaded(name)"},{"p":"base","o":"print.warnings","f":"hp_print.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"print.warnings(x, tags, header = ngettext(n, \"Warning message:\\n\", \"Warning messages:\\n\"), ...)"},{"p":"base","o":"simpleWarning","f":"hp_simpleWarning","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"simpleWarning(message, call = NULL)"},{"p":"base","o":"double","f":"hp_double","d":"Create, coerce to or test for a double-precision vector.\n","ec":"double(length = 0L)"},{"p":"base","o":"[.numeric_version","f":"hp_X..numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"[.numeric_version(x, i, j)"},{"p":"base","o":"as.expression","f":"hp_as.expression","d":"Creates or tests for objects of mode and class \"expression\".\n","ec":"as.expression(x, ...)"},{"p":"base","o":"summary.srcfile","f":"hp_summary.srcfile","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"summary.srcfile(object, ...)"},{"p":"base","o":"summary.data.frame","f":"hp_summary.data.frame","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"summary.data.frame(object, maxsum = 7L, digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"p":"base","o":"c.factor","f":"hp_c.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"c.factor(..., recursive = TRUE)"},{"p":"base","o":"debugonce","f":"hp_debugonce","d":"Set, unset or query the debugging flag on a function.\nThe text and condition arguments are the same as those\nthat can be supplied via a call to browser.  They can be retrieved\nby the user once the browser has been entered, and provide a mechanism to\nallow users to identify which breakpoint has been activated.\n","ec":"debugonce(fun, text = \"\", condition = NULL, signature = NULL)"},{"p":"base","o":"print","f":"hp_print","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print(x, ...)"},{"p":"base","o":".isMethodsDispatchOn","f":"hp_.isMethodsDispatchOn","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".isMethodsDispatchOn(onOff = NULL)"},{"p":"base","o":"gregexec","f":"hp_gregexec","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"gregexec(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"[.listof","f":"hp_X..listof","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":"[.listof(x, i, ...)"},{"p":"base","o":"forceAndCall","f":"hp_forceAndCall","d":"Call a function with a specified number of leading arguments forced\nbefore the call if the function is a closure.\n","ec":"forceAndCall(n, FUN, ...)"},{"p":"base","o":"close.srcfilealias","f":"hp_close.srcfilealias","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"close.srcfilealias(con, ...)"},{"p":"base","o":"Exec","f":"hp_Exec","d":"Tailcall and Exec allow writing more\nstack-space-efficient recursive functions in R.\n","ec":"Exec(expr, envir)"},{"p":"base","o":".gtn","f":"hp_.gtn","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".gtn(x, strictly)"},{"p":"base","o":".mergeExportMethods","f":"hp_.mergeExportMethods","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":".mergeExportMethods(new, ns)"},{"p":"base","o":".primTrace","f":"hp_.primTrace","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".primTrace(obj)"},{"p":"base","o":"seq.int","f":"hp_seq.int","d":"Generate regular sequences.  seq is a standard generic with a\ndefault method.  seq.int is a primitive which can be\nmuch faster but has a few restrictions.  seq_along and\nseq_len are very fast primitives for two common cases.\n","ec":"seq.int(from, to, by, length.out, along.with, ...)"},{"p":"base","o":"storage.mode<-","f":"hp_storage.mode..","d":"Get or set the <U+2018>mode<U+2019> (a kind of <U+2018>type<U+2019>), or the storage\nmode of an R object.\n","ec":"storage.mode<-(x, value)"},{"p":"base","o":"gregexpr","f":"hp_gregexpr","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"namespaceImportClasses","f":"hp_namespaceImportClasses","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"namespaceImportClasses(self, ns, vars, from = NULL)"},{"p":"base","o":"contributors","f":"hp_contributors","d":"The R Who-is-who, describing who made significant contributions to\nthe development of R.\n","ec":"contributors()"},{"p":"base","o":"unix.time","f":"hp_unix.time","d":"The functions or variables listed here are no longer part of R as\nthey are no longer needed.\n","ec":"unix.time(...)"},{"p":"base","o":"ngettext","f":"hp_ngettext","d":"Translation of text messages typically from calls to\nstop(), warning(), or message()\nhappens when Native Language Support (NLS) was enabled in this build of\nR as it is almost always, see also the bindtextdomain() example.\n","ec":"ngettext(n, msg1, msg2, domain = NULL)"},{"p":"base","o":"print.Dlist","f":"hp_print.Dlist","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.Dlist(x, ...)"},{"p":"base","o":"Find","f":"hp_Find","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Find(f, x, right = FALSE, nomatch = NULL)"},{"p":"base","o":"all.equal.envRefClass","f":"hp_all.equal.envRefClass","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.envRefClass(target, current, ...)"},{"p":"base","o":"as.name","f":"hp_as.name","d":"A <U+2018>name<U+2019> (also known as a <U+2018>symbol<U+2019>) is a way to refer to\nR objects by name (rather than the value of the object, if any, bound\nto that name).\n","ec":"as.name(x)"},{"p":"base","o":"gettext","f":"hp_gettext","d":"Translation of text messages typically from calls to\nstop(), warning(), or message()\nhappens when Native Language Support (NLS) was enabled in this build of\nR as it is almost always, see also the bindtextdomain() example.\n","ec":"gettext(..., domain = NULL, trim = TRUE)"},{"p":"base","o":"[.factor","f":"hp_X..factor","d":"Extract or replace subsets of factors.\n","ec":"[.factor(x, ..., drop = FALSE)"},{"p":"base","o":"body<-","f":"hp_body..","d":"Get or set the body of a function which is basically all of\nthe function definition but its formal arguments (formals),\nsee the <U+2018>Details<U+2019>.\n","ec":"body<-(fun, envir = environment(fun), value)"},{"p":"base","o":"rawToChar","f":"hp_rawToChar","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"rawToChar(x, multiple = FALSE)"},{"p":"base","o":"anyDuplicated.array","f":"hp_anyDuplicated.array","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"anyDuplicated.array(x, incomparables = FALSE, MARGIN = 1L, fromLast = FALSE, ...)"},{"p":"base","o":"unique.POSIXlt","f":"hp_unique.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"unique.POSIXlt(x, incomparables = FALSE, ...)"},{"p":"base","o":"as.list.POSIXct","f":"hp_as.list.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"as.list.POSIXct(x, ...)"},{"p":"base","o":"as.data.frame.character","f":"hp_as.data.frame.character","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.character(x, ..., stringsAsFactors = FALSE)"},{"p":"base","o":"importIntoEnv","f":"hp_importIntoEnv","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"importIntoEnv(impenv, impnames, expenv, expnames)"},{"p":"base","o":".internalGenerics","f":"hp_.internalGenerics","d":"Many R-internal functions are generic and allow\nmethods to be written for.\n","ec":""},{"p":"base","o":"as.list.POSIXlt","f":"hp_as.list.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"as.list.POSIXlt(x, ...)"},{"p":"base","o":"isIncomplete","f":"hp_isIncomplete","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"isIncomplete(con)"},{"p":"base","o":"qr.qy","f":"hp_qr.qy","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.qy(qr, y)"},{"p":"base","o":"bitwXor","f":"hp_bitwXor","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwXor(a, b)"},{"p":"base","o":"[<-.data.frame","f":"hp_X....data.frame","d":"Extract or replace subsets of data frames.\n","ec":"[<-.data.frame(x, i, j, value)"},{"p":"base","o":"format.factor","f":"hp_format.factor","d":"Format an R object for pretty printing.\n","ec":"format.factor(x, ...)"},{"p":"base","o":"Map","f":"hp_Map","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Map(f, ...)"},{"p":"base","o":"getTaskCallbackNames","f":"hp_getTaskCallbackNames","d":"This provides a way to get the names (or identifiers)\nfor the currently registered task callbacks\nthat are invoked at the conclusion of each top-level task.\nThese identifiers can be used to remove a callback.\n","ec":"getTaskCallbackNames()"},{"p":"base","o":"data.frame","f":"hp_data.frame","d":"The function data.frame() creates data frames, tightly coupled\ncollections of variables which share many of the properties of\nmatrices and of lists, used as the fundamental data structure by most\nof R's modeling software.\n","ec":"data.frame(..., row.names = NULL, check.rows = FALSE, check.names = TRUE, fix.empty.names = TRUE, stringsAsFactors = FALSE)"},{"p":"base","o":"Mod","f":"hp_Mod","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"Mod(z)"},{"p":"base","o":"sQuote","f":"hp_sQuote","d":"Single or double quote text by combining with appropriate single or\ndouble left and right quotation marks.\n","ec":"sQuote(x, q = getOption(\"useFancyQuotes\"))"},{"p":"base","o":"regexec","f":"hp_regexec","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"regexec(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"-.Date","f":"hp_X..Date","d":"Operators for the \"Date\" class.\n","ec":"-.Date(e1, e2)"},{"p":"base","o":"regexpr","f":"hp_regexpr","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"regexpr(pattern, text, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"packageNotFoundError","f":"hp_packageNotFoundError","d":"Find the paths to one or more packages.\n","ec":"packageNotFoundError(package, lib.loc, call = NULL)"},{"p":"base","o":"[.noquote","f":"hp_X..noquote","d":"Print character strings without quotes.\n","ec":"[.noquote(x, ...)"},{"p":"base","o":"sys.nframe","f":"hp_sys.nframe","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.nframe()"},{"p":"base","o":"as.table","f":"hp_as.table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"as.table(x, ...)"},{"p":"base","o":"sys.load.image","f":"hp_sys.load.image","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":"sys.load.image(name, quiet)"},{"p":"base","o":"source","f":"hp_source","d":"source causes R to accept its input from the named file or URL\nor connection or expressions directly.  Input is read and\nparsed from that file\nuntil the end of the file is reached, then the parsed expressions are\nevaluated sequentially in the chosen environment.\n","ec":"source(file, local = FALSE, echo = verbose, print.eval = echo, exprs, spaced = use_file, verbose = getOption(\"verbose\"), prompt.echo = getOption(\"prompt\"), max.deparse.length = 150, width.cutoff = 60L, deparseCtrl = \"showAttributes\", chdir = FALSE, catch.aborts = FALSE, encoding = getOption(\"encoding\"), continue.echo = getOption(\"continue\"), skip.echo = 0, keep.source = getOption(\"keep.source\"))"},{"p":"base","o":"objects","f":"hp_objects","d":"ls and objects return a vector of character strings\ngiving the names of the objects in the specified environment.  When\ninvoked with no argument at the top level prompt, ls shows what\ndata sets and functions a user has defined.  When invoked with no\nargument inside a function, ls returns the names of the\nfunction's local variables: this is useful in conjunction with\nbrowser.\n","ec":"objects(name, pos = -1L, envir = as.environment(pos), all.names = FALSE, pattern, sorted = TRUE)"},{"p":"base","o":"is.table","f":"hp_is.table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"is.table(x)"},{"p":"base","o":"sys.status","f":"hp_sys.status","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.status()"},{"p":"base","o":"array","f":"hp_array","d":"Creates or tests for arrays.\n","ec":"array(data = NA, dim = length(data), dimnames = NULL)"},{"p":"base","o":"search","f":"hp_search","d":"Gives a list of attached packages\n(see library), and R objects, usually\ndata.frames.\n","ec":"search()"},{"p":"base","o":"is.infinite","f":"hp_is.infinite","d":"is.finite and is.infinite return a vector of the same\nlength as x, indicating which elements are finite (not infinite\nand not missing) or infinite.\n","ec":"is.infinite(x)"},{"p":"base","o":"Sys.setLanguage","f":"hp_Sys.setLanguage","d":"Translation of text messages typically from calls to\nstop(), warning(), or message()\nhappens when Native Language Support (NLS) was enabled in this build of\nR as it is almost always, see also the bindtextdomain() example.\n","ec":"Sys.setLanguage(lang, unset = \"en\")"},{"p":"base","o":".Machine","f":"hp_.Machine","d":".Machine is a variable holding information on the numerical\ncharacteristics of the machine R is running on, such as the largest\ndouble or integer and the machine's precision.\n","ec":""},{"p":"base","o":"$<-.data.frame","f":"hp_X....data.frame","d":"Extract or replace subsets of data frames.\n","ec":"$<-.data.frame(x, name, value)"},{"p":"base","o":"weekdays.Date","f":"hp_weekdays.Date","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"weekdays.Date(x, abbreviate = FALSE)"},{"p":"base","o":"rownames","f":"hp_rownames","d":"Retrieve or set the row or column names of a matrix-like object.\n","ec":"rownames(x, do.NULL = TRUE, prefix = \"row\")"},{"p":"base","o":"readRenviron","f":"hp_readRenviron","d":"Read as file such as <U+2018>.Renviron<U+2019> or <U+2018>Renviron.site<U+2019> in the\nformat described in the help for Startup, and set environment\nvariables as defined in the file.\n","ec":"readRenviron(path)"},{"p":"base","o":"textConnection","f":"hp_textConnection","d":"Input and output text connections.\n","ec":"textConnection(object, open = \"r\", local = FALSE, name = deparse1(substitute(object)), encoding = c(\"\", \"bytes\", \"UTF-8\"))"},{"p":"base","o":".rowMeans","f":"hp_.rowMeans","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":".rowMeans(x, m, n, na.rm = FALSE)"},{"p":"base","o":"getSrcLines","f":"hp_getSrcLines","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"getSrcLines(srcfile, first, last)"},{"p":"base","o":".Call","f":"hp_.Call","d":"Functions to pass R objects to compiled C/C++ code that has been\nloaded into R.\n","ec":".Call(.NAME, ..., PACKAGE)"},{"p":"base","o":"unclass","f":"hp_unclass","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"unclass(x)"},{"p":"base","o":".expand_R_libs_env_var","f":"hp_.expand_R_libs_env_var","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".expand_R_libs_env_var(x)"},{"p":"base","o":"gc.time","f":"hp_gc.time","d":"This function reports the time spent in garbage collection so far in\nthe R session while GC timing was enabled.\n","ec":"gc.time(on = TRUE)"},{"p":"base","o":"cummax","f":"hp_cummax","d":"Returns a vector whose elements are the cumulative sums, products,\nminima or maxima of the elements of the argument.\n","ec":"cummax(x)"},{"p":"base","o":"gcinfo","f":"hp_gcinfo","d":"A call of gc causes a garbage collection to take place.\ngcinfo sets a flag so that\nautomatic collection is either silent (verbose = FALSE) or\nprints memory usage statistics (verbose = TRUE).\n","ec":"gcinfo(verbose)"},{"p":"base","o":"cummin","f":"hp_cummin","d":"Returns a vector whose elements are the cumulative sums, products,\nminima or maxima of the elements of the argument.\n","ec":"cummin(x)"},{"p":"base","o":".mergeImportMethods","f":"hp_.mergeImportMethods","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":".mergeImportMethods(impenv, expenv, metaname)"},{"p":"base","o":".subset2","f":"hp_.subset2","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".subset2(x, ...)"},{"p":"base","o":"addTaskCallback","f":"hp_addTaskCallback","d":"addTaskCallback registers an R function\nthat is to be called each time a top-level task\nis completed.\n","ec":"addTaskCallback(f, data = NULL, name = character())"},{"p":"base","o":"file.mode","f":"hp_file.mode","d":"Utility function to extract information about files on the user's\nfile systems.\n","ec":"file.mode(...)"},{"p":"base","o":".knownS3Generics","f":"hp_.knownS3Generics","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":""},{"p":"base","o":"unlockBinding","f":"hp_unlockBinding","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"unlockBinding(sym, env)"},{"p":"base","o":"solve.qr","f":"hp_solve.qr","d":"qr computes the QR decomposition of a matrix.\n","ec":"solve.qr(a, b, ...)"},{"p":"base","o":".deparseOpts","f":"hp_.deparseOpts","d":"Process the deparsing options for deparse, dput and\ndump.\n","ec":".deparseOpts(control)"},{"p":"base","o":"file.info","f":"hp_file.info","d":"Utility function to extract information about files on the user's\nfile systems.\n","ec":"file.info(..., extra_cols = TRUE)"},{"p":"base","o":".row","f":"hp_.row","d":"Returns a matrix of integers indicating their row number in a\nmatrix-like object, or a factor indicating the row labels.\n","ec":".row(dim)"},{"p":"base","o":"round.POSIXt","f":"hp_round.POSIXt","d":"Round or truncate date-time objects.\n","ec":"round.POSIXt(x, units = c(\"secs\", \"mins\", \"hours\", \"days\", \"months\", \"years\"))"},{"p":"base","o":"duplicated.POSIXlt","f":"hp_duplicated.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"duplicated.POSIXlt(x, incomparables = FALSE, ...)"},{"p":"base","o":"attachNamespace","f":"hp_attachNamespace","d":"Functions to load and unload name spaces.\n","ec":"attachNamespace(ns, pos = 2L, depends = NULL, exclude, include.only)"},{"p":"base","o":"dQuote","f":"hp_dQuote","d":"Single or double quote text by combining with appropriate single or\ndouble left and right quotation marks.\n","ec":"dQuote(x, q = getOption(\"useFancyQuotes\"))"},{"p":"base","o":"bquote","f":"hp_bquote","d":"An analogue of the LISP backquote macro.  bquote quotes its\nargument except that terms wrapped in .() are evaluated in the\nspecified where environment. If splice = TRUE then\nterms wrapped in ..() are evaluated and spliced into a call.\n","ec":"bquote(expr, where = parent.frame(), splice = FALSE)"},{"p":"base","o":"builtins","f":"hp_builtins","d":"Return the names of all the built-in objects.  These are fetched\ndirectly from the symbol table of the R interpreter.\n","ec":"builtins(internal = FALSE)"},{"p":"base","o":".standard_regexps","f":"hp_.standard_regexps","d":"Miscellaneous internal/programming utilities.","ec":".standard_regexps()"},{"p":"base","o":"length<-","f":"hp_length..","d":"Get or set the length of vectors (including lists) and factors, and of\nany other R object for which a method has been defined.\n","ec":"length<-(x, value)"},{"p":"base","o":"format.summaryDefault","f":"hp_format.summaryDefault","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"format.summaryDefault(x, digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"p":"base","o":"xzfile","f":"hp_xzfile","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"xzfile(description, open = \"\", encoding = getOption(\"encoding\"), compression = 6)"},{"p":"base","o":"cut.Date","f":"hp_cut.Date","d":"Method for cut applied to date-time objects.\n","ec":"cut.Date(x, breaks, labels = NULL, start.on.monday = TRUE, right = FALSE, ...)"},{"p":"base","o":"nchar","f":"hp_nchar","d":"nchar takes a character vector as an argument and\nreturns a vector whose elements contain the sizes of\nthe corresponding elements of x. Internally, it is a generic,\nfor which methods can be defined (see InternalMethods).\n","ec":"nchar(x, type = \"chars\", allowNA = FALSE, keepNA = NA)"},{"p":"base","o":"simplify2array","f":"hp_simplify2array","d":"lapply returns a list of the same length as X, each\nelement of which is the result of applying FUN to the\ncorresponding element of X.\n","ec":"simplify2array(x, higher = TRUE, except = c(0L, 1L))"},{"p":"base","o":"writeChar","f":"hp_writeChar","d":"Transfer character strings to and from connections, without assuming\nthey are null-terminated on the connection.\n","ec":"writeChar(object, con, nchars = nchar(object, type = \"chars\"), eos = \"\", useBytes = FALSE)"},{"p":"base","o":"La_library","f":"hp_La_library","d":"Report the name of the shared object file with LAPACK implementation\nin use.\n","ec":"La_library()"},{"p":"base","o":"strptime","f":"hp_strptime","d":"Functions to convert between character representations and objects of\nclasses \"POSIXlt\" and \"POSIXct\" representing calendar\ndates and times.\n","ec":"strptime(x, format, tz = \"\")"},{"p":"base","o":"serverSocket","f":"hp_serverSocket","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"serverSocket(port)"},{"p":"base","o":"all.equal.numeric","f":"hp_all.equal.numeric","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.numeric(target, current, tolerance = sqrt(.Machine$double.eps), scale = NULL, countEQ = FALSE, formatFUN = function(err, what) format(err), ..., check.attributes = TRUE, check.class = TRUE, giveErr = FALSE)"},{"p":"base","o":"readline","f":"hp_readline","d":"readline reads a line from the terminal (in interactive use).\n","ec":"readline(prompt = \"\")"},{"p":"base","o":"duplicated.data.frame","f":"hp_duplicated.data.frame","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"duplicated.data.frame(x, incomparables = FALSE, fromLast = FALSE, ...)"},{"p":"base","o":".__H__.rbind","f":"hp_.__H__.rbind","d":"The functions or variables listed here are no longer part of R as\nthey are no longer needed.\n","ec":".__H__.rbind(..., deparse.level = 1)"},{"p":"base","o":"registerS3method","f":"hp_registerS3method","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"registerS3method(genname, class, method, envir = parent.frame())"},{"p":"base","o":"as.list.default","f":"hp_as.list.default","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list.default(x, ...)"},{"p":"base","o":"setNamespaceInfo","f":"hp_setNamespaceInfo","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"setNamespaceInfo(ns, which, val)"},{"p":"base","o":"seq.Date","f":"hp_seq.Date","d":"The method for seq for objects of class\n\"Date\" representing calendar dates.\n","ec":"seq.Date(from, to, by, length.out = NULL, along.with = NULL, ...)"},{"p":"base","o":"getNamespaceInfo","f":"hp_getNamespaceInfo","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"getNamespaceInfo(ns, which)"},{"p":"base","o":"asinh","f":"hp_asinh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"asinh(x)"},{"p":"base","o":"sys.on.exit","f":"hp_sys.on.exit","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.on.exit()"},{"p":"base","o":"anyNA.data.frame","f":"hp_anyNA.data.frame","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"anyNA.data.frame(x, recursive = FALSE)"},{"p":"base","o":"namespaceImportMethods","f":"hp_namespaceImportMethods","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"namespaceImportMethods(self, ns, vars, from = NULL)"},{"p":"base","o":"sort.int","f":"hp_sort.int","d":"Sort (or order) a vector or factor (partially) into\nascending or descending order.  For ordering along more than one\nvariable, e.g., for sorting data frames, see order.\n","ec":"sort.int(x, partial = NULL, na.last = NA, decreasing = FALSE, method = c(\"auto\", \"shell\", \"quick\", \"radix\"), index.return = FALSE)"},{"p":"base","o":"cumsum","f":"hp_cumsum","d":"Returns a vector whose elements are the cumulative sums, products,\nminima or maxima of the elements of the argument.\n","ec":"cumsum(x)"},{"p":"base","o":"environmentName","f":"hp_environmentName","d":"Get, set, test for and create environments.\n","ec":"environmentName(env)"},{"p":"base","o":"as.list.environment","f":"hp_as.list.environment","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list.environment(x, all.names = FALSE, sorted = FALSE, ...)"},{"p":"base","o":"restartDescription","f":"hp_restartDescription","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"restartDescription(r)"},{"p":"base","o":"[<-","f":"hp_X...","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":""},{"p":"base","o":".signalSimpleWarning","f":"hp_.signalSimpleWarning","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":".signalSimpleWarning(msg, call)"},{"p":"base","o":"autoload","f":"hp_autoload","d":"autoload creates a promise-to-evaluate autoloader and\nstores it with name name in .AutoloadEnv environment.\nWhen R attempts to evaluate name, autoloader is run,\nthe package is loaded and name is re-evaluated in the new\npackage's environment.  The result is that R behaves as if\npackage was loaded but it does not occupy memory.\n","ec":"autoload(name, package, reset = FALSE, ...)"},{"p":"base","o":"format.pval","f":"hp_format.pval","d":"format.pval is intended for formatting p-values.\n","ec":"format.pval(pv, digits = max(1L, getOption(\"digits\") - 2L), eps = .Machine$double.eps, na.form = \"NA\", ...)"},{"p":"base","o":"as.data.frame","f":"hp_as.data.frame","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame(x, row.names = NULL, optional = FALSE, ...)"},{"p":"base","o":"environment<-","f":"hp_environment..","d":"Get, set, test for and create environments.\n","ec":"environment<-(fun, value)"},{"p":"base","o":"as.call","f":"hp_as.call","d":"Create or test for objects of mode \"call\" (or\n\"(\", see Details).\n","ec":"as.call(x)"},{"p":"base","o":"with","f":"hp_with","d":"Evaluate an R expression in an environment constructed from data,\npossibly modifying (a copy of) the original data.\n","ec":"with(data, expr, ...)"},{"p":"base","o":"round.Date","f":"hp_round.Date","d":"Round or truncate date-time objects.\n","ec":"round.Date(x, ...)"},{"p":"base","o":"emptyenv","f":"hp_emptyenv","d":"Get, set, test for and create environments.\n","ec":"emptyenv()"},{"p":"base","o":"[.AsIs","f":"hp_X..AsIs","d":"Change the class of an object to indicate that it should be treated\n<U+2018>as is<U+2019>.\n","ec":"[.AsIs(x, i, ...)"},{"p":"base","o":"as.list.function","f":"hp_as.list.function","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list.function(x, ...)"},{"p":"base","o":"agrepl","f":"hp_agrepl","d":"Searches for approximate matches to pattern (the first argument)\nwithin each element of the string x (the second argument) using\nthe generalized Levenshtein edit distance (the minimal possibly\nweighted number of insertions, deletions and substitutions needed to\ntransform one string into another).\n","ec":"agrepl(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = TRUE, useBytes = FALSE)"},{"p":"base","o":"comment<-","f":"hp_comment..","d":"These functions set and query a comment\nattribute for any R objects.  This is typically useful for\ndata.frames or model fits.\n","ec":"comment<-(x, value)"},{"p":"base","o":"seq_len","f":"hp_seq_len","d":"Generate regular sequences.  seq is a standard generic with a\ndefault method.  seq.int is a primitive which can be\nmuch faster but has a few restrictions.  seq_along and\nseq_len are very fast primitives for two common cases.\n","ec":"seq_len(length.out)"},{"p":"base","o":"rowsum.default","f":"hp_rowsum.default","d":"Compute column sums across rows of a numeric matrix-like object for\neach level of a grouping variable.  rowsum is generic, with a\nmethod for data frames and a default method for vectors and matrices.\n","ec":"rowsum.default(x, group, reorder = TRUE, na.rm = FALSE, ...)"},{"p":"base","o":"months.POSIXt","f":"hp_months.POSIXt","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"months.POSIXt(x, abbreviate = FALSE)"},{"p":"base","o":"besselI","f":"hp_besselI","d":"Bessel Functions of integer and fractional order, of first\nand second kind, J_{\\nu} and Y_{\\nu}, and\nModified Bessel functions (of first and third kind),\nI_{\\nu} and K_{\\nu}.\n","ec":"besselI(x, nu, expon.scaled = FALSE)"},{"p":"base","o":"besselJ","f":"hp_besselJ","d":"Bessel Functions of integer and fractional order, of first\nand second kind, J_{\\nu} and Y_{\\nu}, and\nModified Bessel functions (of first and third kind),\nI_{\\nu} and K_{\\nu}.\n","ec":"besselJ(x, nu)"},{"p":"base","o":"besselK","f":"hp_besselK","d":"Bessel Functions of integer and fractional order, of first\nand second kind, J_{\\nu} and Y_{\\nu}, and\nModified Bessel functions (of first and third kind),\nI_{\\nu} and K_{\\nu}.\n","ec":"besselK(x, nu, expon.scaled = FALSE)"},{"p":"base","o":"besselY","f":"hp_besselY","d":"Bessel Functions of integer and fractional order, of first\nand second kind, J_{\\nu} and Y_{\\nu}, and\nModified Bessel functions (of first and third kind),\nI_{\\nu} and K_{\\nu}.\n","ec":"besselY(x, nu)"},{"p":"base","o":"numeric","f":"hp_numeric","d":"Creates or coerces objects of type \"numeric\".\nis.numeric is a more general test of an object being\ninterpretable as numbers.\n","ec":"numeric(length = 0L)"},{"p":"base","o":"withCallingHandlers","f":"hp_withCallingHandlers","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"withCallingHandlers(expr, ...)"},{"p":"base","o":"open.srcfilecopy","f":"hp_open.srcfilecopy","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"open.srcfilecopy(con, line, ...)"},{"p":"base","o":"weekdays","f":"hp_weekdays","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"weekdays(x, abbreviate)"},{"p":"base","o":"formatDL","f":"hp_formatDL","d":"Format vectors of items and their descriptions as 2-column\ntables or LaTeX-style description lists.\n","ec":"formatDL(x, y, style = c(\"table\", \"list\"), width = 0.9 * getOption(\"width\"), indent = NULL)"},{"p":"base","o":"qr.fitted","f":"hp_qr.fitted","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.fitted(qr, y, k = qr$rank)"},{"p":"base","o":"system2","f":"hp_system2","d":"system2 invokes the OS command specified by command.\n","ec":"system2(command, args = character(), stdout = \"\", stderr = \"\", stdin = \"\", input = NULL, env = character(), wait = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0, receive.console.signals = wait)"},{"p":"base","o":"mostattributes<-","f":"hp_mostattributes..","d":"These functions access an object's attributes.\nThe first form below returns the object's attribute list.\nThe replacement forms uses the list on the right-hand\nside of the assignment as the object's attributes (if appropriate).\n","ec":"mostattributes<-(x, value)"},{"p":"base","o":".External2","f":"hp_.External2","d":"Internal versions of .Call and .External.\n","ec":".External2(.NAME, ..., PACKAGE)"},{"p":"base","o":"as.factor","f":"hp_as.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"as.factor(x)"},{"p":"base","o":"data.class","f":"hp_data.class","d":"Determine the class of an arbitrary R object.\n","ec":"data.class(x)"},{"p":"base","o":"is.symbol","f":"hp_is.symbol","d":"A <U+2018>name<U+2019> (also known as a <U+2018>symbol<U+2019>) is a way to refer to\nR objects by name (rather than the value of the object, if any, bound\nto that name).\n","ec":"is.symbol(x)"},{"p":"base","o":"[.difftime","f":"hp_X..difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"[.difftime(x, ..., drop = TRUE)"},{"p":"base","o":"substring<-","f":"hp_substring..","d":"Extract or replace substrings in a character vector.\n","ec":"substring<-(text, first, last = 1000000L, value)"},{"p":"base","o":"memCompress","f":"hp_memCompress","d":"In-memory compression or decompression for raw vectors.\n","ec":"memCompress(from, type = c(\"gzip\", \"bzip2\", \"xz\", \"none\"))"},{"p":"base","o":"simpleMessage","f":"hp_simpleMessage","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"simpleMessage(message, call = NULL)"},{"p":"base","o":"La_version","f":"hp_La_version","d":"Report the version of LAPACK in use.\n","ec":"La_version()"},{"p":"base","o":"as.difftime","f":"hp_as.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"as.difftime(tim, format = \"%X\", units = \"auto\", tz = \"UTC\")"},{"p":"base","o":"make.names","f":"hp_make.names","d":"Make syntactically valid names out of character vectors.\n","ec":"make.names(names, unique = FALSE, allow_ = TRUE)"},{"p":"base","o":"as.null","f":"hp_as.null","d":"NULL represents the null object in R: it is a reserved\nword.  NULL is often returned by expressions and functions\nwhose value is undefined.\n","ec":"as.null(x, ...)"},{"p":"base","o":"storage.mode","f":"hp_storage.mode","d":"Get or set the <U+2018>mode<U+2019> (a kind of <U+2018>type<U+2019>), or the storage\nmode of an R object.\n","ec":"storage.mode(x)"},{"p":"base","o":"substr<-","f":"hp_substr..","d":"Extract or replace substrings in a character vector.\n","ec":"substr<-(x, start, stop, value)"},{"p":"base","o":"getExportedValue","f":"hp_getExportedValue","d":"Internal functions to support reflection on namespace objects.\n","ec":"getExportedValue(ns, name)"},{"p":"base","o":"mean.Date","f":"hp_mean.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"mean.Date(x, ...)"},{"p":"base","o":"atan2","f":"hp_atan2","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"atan2(y, x)"},{"p":"base","o":"requireNamespace","f":"hp_requireNamespace","d":"Functions to load and unload name spaces.\n","ec":"requireNamespace(package, ..., quietly = FALSE)"},{"p":"base","o":"atanh","f":"hp_atanh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"atanh(x)"},{"p":"base","o":"is.nan","f":"hp_is.nan","d":"is.finite and is.infinite return a vector of the same\nlength as x, indicating which elements are finite (not infinite\nand not missing) or infinite.\n","ec":"is.nan(x)"},{"p":"base","o":"class","f":"hp_class","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"class(x)"},{"p":"base","o":"+.POSIXt","f":"hp_X..POSIXt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"+.POSIXt(e1, e2)"},{"p":"base","o":"length<-.factor","f":"hp_length...factor","d":"Get or set the length of vectors (including lists) and factors, and of\nany other R object for which a method has been defined.\n","ec":"length<-.factor(x, value)"},{"p":"base","o":"agrep","f":"hp_agrep","d":"Searches for approximate matches to pattern (the first argument)\nwithin each element of the string x (the second argument) using\nthe generalized Levenshtein edit distance (the minimal possibly\nweighted number of insertions, deletions and substitutions needed to\ntransform one string into another).\n","ec":"agrep(pattern, x, max.distance = 0.1, costs = NULL, ignore.case = FALSE, value = FALSE, fixed = TRUE, useBytes = FALSE)"},{"p":"base","o":"which.min","f":"hp_which.min","d":"Determines the location, i.e., index of the (first) minimum or maximum\nof a numeric (or logical) vector.\n","ec":"which.min(x)"},{"p":"base","o":"as.Date.default","f":"hp_as.Date.default","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.default(x, ...)"},{"p":"base","o":"Sys.glob","f":"hp_Sys.glob","d":"Function to do wildcard expansion (also known as <U+2018>globbing<U+2019>) on\nfile paths.\n","ec":"Sys.glob(paths, dirmark = FALSE)"},{"p":"base","o":"Sys.getpid","f":"hp_Sys.getpid","d":"Get the process ID of the R Session.  It is guaranteed by the\noperating system that two R sessions running simultaneously will\nhave different IDs, but it is possible that R sessions running at\ndifferent times will have the same ID.\n","ec":"Sys.getpid()"},{"p":"base","o":"which.max","f":"hp_which.max","d":"Determines the location, i.e., index of the (first) minimum or maximum\nof a numeric (or logical) vector.\n","ec":"which.max(x)"},{"p":"base","o":"pretty.default","f":"hp_pretty.default","d":"Compute a  sequence of about n+1 equally spaced <U+2018>round<U+2019>\nvalues which cover the range of the values in x.\nThe values are chosen so that they are 1, 2 or 5 times a power of 10.\n","ec":"pretty.default(x, n = 5L, min.n = n%/%3L, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0L, f.min = 2^-20, ...)"},{"p":"base","o":"on.exit","f":"hp_on.exit","d":"on.exit records the expression given as its argument as needing\nto be executed when the current function exits (either naturally or as\nthe result of an error).  This is useful for resetting graphical\nparameters or performing other cleanup actions.\n","ec":"on.exit(expr = NULL, add = FALSE, after = TRUE)"},{"p":"base","o":".pretty","f":"hp_.pretty","d":"Compute a  sequence of about n+1 equally spaced <U+2018>round<U+2019>\nvalues which cover the range of the values in x.\nThe values are chosen so that they are 1, 2 or 5 times a power of 10.\n","ec":".pretty(x, n = 5L, min.n = n%/%3L, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias, eps.correct = 0L, f.min = 2^-20, bounds = TRUE)"},{"p":"base","o":"tcrossprod","f":"hp_tcrossprod","d":"Given matrices x and y as arguments, return a matrix\ncross-product.  This is formally equivalent to (but faster than) the call\nt(x) %*% y (crossprod) or\nx %*% t(y) (tcrossprod).\n","ec":"tcrossprod(x, y = NULL, ...)"},{"p":"base","o":".Date","f":"hp_.Date","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".Date(xx, cl = \"Date\")"},{"p":"base","o":"crossprod","f":"hp_crossprod","d":"Given matrices x and y as arguments, return a matrix\ncross-product.  This is formally equivalent to (but faster than) the call\nt(x) %*% y (crossprod) or\nx %*% t(y) (tcrossprod).\n","ec":"crossprod(x, y = NULL, ...)"},{"p":"base","o":"anyDuplicated.data.frame","f":"hp_anyDuplicated.data.frame","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"anyDuplicated.data.frame(x, incomparables = FALSE, fromLast = FALSE, ...)"},{"p":"base","o":"abs","f":"hp_abs","d":"abs(x) computes the absolute value of x, sqrt(x) computes the\n(principal) square root of x, \\sqrt{x}.\n","ec":"abs(x)"},{"p":"base","o":"months.Date","f":"hp_months.Date","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"months.Date(x, abbreviate = FALSE)"},{"p":"base","o":"-.POSIXt","f":"hp_X..POSIXt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"-.POSIXt(e1, e2)"},{"p":"base","o":"stdin","f":"hp_stdin","d":"Display aspects of connections.\n","ec":"stdin()"},{"p":"base","o":"all","f":"hp_all","d":"Given a set of logical vectors, are all of the values true?\n","ec":"all(..., na.rm = FALSE)"},{"p":"base","o":"as.numeric","f":"hp_as.numeric","d":"Creates or coerces objects of type \"numeric\".\nis.numeric is a more general test of an object being\ninterpretable as numbers.\n","ec":"as.numeric(x, ...)"},{"p":"base","o":"any","f":"hp_any","d":"Given a set of logical vectors, is at least one of the values true?\n","ec":"any(..., na.rm = FALSE)"},{"p":"base","o":"Encoding<-","f":"hp_Encoding..","d":"Read or set the declared encodings for a character vector.\n","ec":"Encoding<-(x, value)"},{"p":"base","o":"isTRUE","f":"hp_isTRUE","d":"These operators act on raw, logical and number-like vectors.\n","ec":"isTRUE(x)"},{"p":"base","o":"charToRaw","f":"hp_charToRaw","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"charToRaw(x)"},{"p":"base","o":"Sys.time","f":"hp_Sys.time","d":"Sys.time and Sys.Date returns the system's idea of the\ncurrent date with and without time.\n","ec":"Sys.time()"},{"p":"base","o":"as.Date.numeric","f":"hp_as.Date.numeric","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.numeric(x, origin, ...)"},{"p":"base","o":"environment","f":"hp_environment","d":"Get, set, test for and create environments.\n","ec":"environment(fun = NULL)"},{"p":"base","o":"cat","f":"hp_cat","d":"Outputs the objects, concatenating the representations.  cat\nperforms much less conversion than print.\n","ec":"cat(..., file = \"\", sep = \" \", fill = FALSE, labels = NULL, append = FALSE)"},{"p":"base","o":"is.raw","f":"hp_is.raw","d":"Creates or tests for objects of type \"raw\".\n","ec":"is.raw(x)"},{"p":"base","o":"mean.difftime","f":"hp_mean.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"mean.difftime(x, ...)"},{"p":"base","o":"readLines","f":"hp_readLines","d":"Read some or all text lines from a connection.\n","ec":"readLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE, encoding = \"unknown\", skipNul = FALSE)"},{"p":"base","o":".rowSums","f":"hp_.rowSums","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":".rowSums(x, m, n, na.rm = FALSE)"},{"p":"base","o":"charmatch","f":"hp_charmatch","d":"charmatch seeks matches for the elements of its first argument\namong those of its second.\n","ec":"charmatch(x, table, nomatch = NA_integer_)"},{"p":"base","o":"col","f":"hp_col","d":"Returns a matrix of integers indicating their column number in a\nmatrix-like object, or a factor of column labels.\n","ec":"col(x, as.factor = FALSE)"},{"p":"base","o":"cos","f":"hp_cos","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"cos(x)"},{"p":"base","o":"mtfrm","f":"hp_mtfrm","d":"Transform objects for matching via match(), think\n<U+201C>match form<U+201D> -> \"mtfrm\".\nbase provides the S3 generic and a default plus\n\"POSIXct\" and \"POSIXlt\" methods.\n","ec":"mtfrm(x)"},{"p":"base","o":"Sys.Date","f":"hp_Sys.Date","d":"Sys.time and Sys.Date returns the system's idea of the\ncurrent date with and without time.\n","ec":"Sys.Date()"},{"p":"base","o":"det","f":"hp_det","d":"det calculates the determinant of a matrix.  determinant\nis a generic function that returns separately the modulus of the determinant,\noptionally on the logarithm scale, and the sign of the determinant.\n","ec":"det(x, ...)"},{"p":"base","o":"cut","f":"hp_cut","d":"cut divides the range of x into intervals\nand codes the values in x according to which\ninterval they fall.  The leftmost interval corresponds to level one,\nthe next leftmost to level two and so on.\n","ec":"cut(x, ...)"},{"p":"base","o":"dim","f":"hp_dim","d":"Retrieve or set the dimension of an object.\n","ec":"dim(x)"},{"p":"base","o":"dir","f":"hp_dir","d":"These functions produce a character vector of the names of files or\ndirectories in the named directory.\n","ec":"dir(path = \".\", pattern = NULL, all.files = FALSE, full.names = FALSE, recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)"},{"p":"base","o":"as.data.frame.raw","f":"hp_as.data.frame.raw","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.raw(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"as.symbol","f":"hp_as.symbol","d":"A <U+2018>name<U+2019> (also known as a <U+2018>symbol<U+2019>) is a way to refer to\nR objects by name (rather than the value of the object, if any, bound\nto that name).\n","ec":"as.symbol(x)"},{"p":"base","o":"[[.factor","f":"hp_X...factor","d":"Extract or replace subsets of factors.\n","ec":"[[.factor(x, ...)"},{"p":"base","o":"as.data.frame.AsIs","f":"hp_as.data.frame.AsIs","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.AsIs(x, row.names = NULL, optional = FALSE, ...)"},{"p":"base","o":"summary.factor","f":"hp_summary.factor","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"summary.factor(object, maxsum = 100L, ...)"},{"p":"base","o":"anyDuplicated.matrix","f":"hp_anyDuplicated.matrix","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"anyDuplicated.matrix(x, incomparables = FALSE, MARGIN = 1L, fromLast = FALSE, ...)"},{"p":"base","o":"getDLLRegisteredRoutines.DLLInfo","f":"hp_getDLLRegisteredRoutines.DLLInfo","d":"This function allows us to query the set of routines\nin a DLL that are registered with R to enhance\ndynamic lookup, error handling when calling native routines,\nand potentially security in the future.\nThis function provides a description of each of the\nregistered routines in the DLL for the different interfaces,\ni.e. .C, .Call, .Fortran\nand .External.\n","ec":"getDLLRegisteredRoutines.DLLInfo(dll, addNames = TRUE)"},{"p":"base","o":"exp","f":"hp_exp","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"exp(x)"},{"p":"base","o":"print.Date","f":"hp_print.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"print.Date(x, max = NULL, ...)"},{"p":"base","o":"split.data.frame","f":"hp_split.data.frame","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split.data.frame(x, f, drop = FALSE, ...)"},{"p":"base","o":"for","f":"hp_for.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"rowSums","f":"hp_rowSums","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":"rowSums(x, na.rm = FALSE, dims = 1L)"},{"p":"base","o":"rawShift","f":"hp_rawShift","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"rawShift(x, n)"},{"p":"base","o":"get","f":"hp_get","d":"Search by name for an object (get) or zero or more objects\n(mget).\n","ec":"get(x, pos = -1L, envir = as.environment(pos), mode = \"any\", inherits = TRUE)"},{"p":"base","o":"open.srcfilealias","f":"hp_open.srcfilealias","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"open.srcfilealias(con, line, ...)"},{"p":"base","o":"as.list.numeric_version","f":"hp_as.list.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"as.list.numeric_version(x, ...)"},{"p":"base","o":"identity","f":"hp_identity","d":"A trivial identity function returning its argument.\n","ec":"identity(x)"},{"p":"base","o":"Summary.factor","f":"hp_Summary.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"Summary.factor(..., na.rm)"},{"p":"base","o":"print.summaryDefault","f":"hp_print.summaryDefault","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"print.summaryDefault(x, digits = max(3L, getOption(\"digits\") - 3L), ...)"},{"p":"base","o":"toString.default","f":"hp_toString.default","d":"This is a helper function for format to produce a single\ncharacter string describing an R object.\n","ec":"toString.default(x, width = NULL, ...)"},{"p":"base","o":"pushBackLength","f":"hp_pushBackLength","d":"Functions to push back text lines onto a connection, and to enquire\nhow many lines are currently pushed back.\n","ec":"pushBackLength(connection)"},{"p":"base","o":"extSoftVersion","f":"hp_extSoftVersion","d":"Report versions of (external) third-party software used.\n","ec":"extSoftVersion()"},{"p":"base","o":"serialize","f":"hp_serialize","d":"A simple low-level interface for serializing to connections.\n","ec":"serialize(object, connection, ascii = FALSE, xdr = TRUE, version = NULL, refhook = NULL)"},{"p":"base","o":"is.complex","f":"hp_is.complex","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"is.complex(x)"},{"p":"base","o":"loadNamespace","f":"hp_loadNamespace","d":"Functions to load and unload name spaces.\n","ec":"loadNamespace(package, lib.loc = NULL, keep.source = getOption(\"keep.source.pkgs\"), partial = FALSE, versionCheck = NULL, keep.parse.data = getOption(\"keep.parse.data.pkgs\"))"},{"p":"base","o":"all.equal.default","f":"hp_all.equal.default","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.default(target, current, ..., check.class = TRUE)"},{"p":"base","o":"print.condition","f":"hp_print.condition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"print.condition(x, ...)"},{"p":"base","o":"RNGkind","f":"hp_RNGkind","d":".Random.seed is an integer vector, containing the random number\ngenerator (RNG) state for random number generation in R.  It\ncan be saved and restored, but should not be altered by the user.\n","ec":"RNGkind(kind = NULL, normal.kind = NULL, sample.kind = NULL)"},{"p":"base","o":"summary.table","f":"hp_summary.table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"summary.table(object, ...)"},{"p":"base","o":"nameOfClass.default","f":"hp_nameOfClass.default","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"nameOfClass.default(x)"},{"p":"base","o":"list","f":"hp_list","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"list(...)"},{"p":"base","o":"isa","f":"hp_isa","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"isa(x, what)"},{"p":"base","o":"print.difftime","f":"hp_print.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"print.difftime(x, digits = getOption(\"digits\"), ...)"},{"p":"base","o":"as.character.error","f":"hp_as.character.error","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"as.character.error(x, ...)"},{"p":"base","o":"strtrim","f":"hp_strtrim","d":"Trim character strings to specified display widths.\n","ec":"strtrim(x, width)"},{"p":"base","o":"licence","f":"hp_licence","d":"The license terms under which R is distributed.\n","ec":"licence()"},{"p":"base","o":"summary","f":"hp_summary","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"summary(object, ...)"},{"p":"base","o":"row.names.data.frame","f":"hp_row.names.data.frame","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names.data.frame(x)"},{"p":"base","o":"packageStartupMessage","f":"hp_packageStartupMessage","d":"Generate a diagnostic message from its arguments.\n","ec":"packageStartupMessage(..., domain = NULL, appendLF = TRUE)"},{"p":"base","o":"print.summary.warnings","f":"hp_print.summary.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"print.summary.warnings(x, ...)"},{"p":"base","o":"pmax.int","f":"hp_pmax.int","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"pmax.int(..., na.rm = FALSE)"},{"p":"base","o":"julian.Date","f":"hp_julian.Date","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"julian.Date(x, origin = as.Date(\"1970-01-01\"), ...)"},{"p":"base","o":"rownames<-","f":"hp_rownames..","d":"Retrieve or set the row or column names of a matrix-like object.\n","ec":"rownames<-(x, value)"},{"p":"base","o":"license","f":"hp_license","d":"The license terms under which R is distributed.\n","ec":"license()"},{"p":"base","o":"sys.save.image","f":"hp_sys.save.image","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":"sys.save.image(name)"},{"p":"base","o":"lazyLoadDBexec","f":"hp_lazyLoadDBexec","d":"Internal functions to lazy load a database of R objects.\n","ec":"lazyLoadDBexec(filebase, fun, filter)"},{"p":"base","o":"max.col","f":"hp_max.col","d":"Find the maximum position for each row of a matrix, breaking ties at random.\n","ec":"max.col(m, ties.method = c(\"random\", \"first\", \"last\"))"},{"p":"base","o":"invisible","f":"hp_invisible","d":"Return a (temporarily) invisible copy of an object.\n","ec":"invisible(x = NULL)"},{"p":"base","o":"open.srcfile","f":"hp_open.srcfile","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"open.srcfile(con, line, ...)"},{"p":"base","o":"searchpaths","f":"hp_searchpaths","d":"Gives a list of attached packages\n(see library), and R objects, usually\ndata.frames.\n","ec":"searchpaths()"},{"p":"base","o":".formula2varlist","f":"hp_.formula2varlist","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".formula2varlist(formula, data, warnLHS = TRUE, ignoreLHS = warnLHS)"},{"p":"base","o":"namespaceImportFrom","f":"hp_namespaceImportFrom","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"namespaceImportFrom(self, ns, vars, generics, packages, from = \"non-package environment\", except = character(0L))"},{"p":"base","o":"sys.frames","f":"hp_sys.frames","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.frames()"},{"p":"base","o":"Recall","f":"hp_Recall","d":"Recall is used as a placeholder for the name of the function\nin which it is called.  It allows the definition of recursive\nfunctions which still work after being renamed, see example below.\n","ec":"Recall(...)"},{"p":"base","o":".difftime","f":"hp_.difftime","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".difftime(xx, units, cl = \"difftime\")"},{"p":"base","o":"log","f":"hp_log","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"log(x, base = exp(1))"},{"p":"base","o":"numToBits","f":"hp_numToBits","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"numToBits(x)"},{"p":"base","o":"rawToBits","f":"hp_rawToBits","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"rawToBits(x)"},{"p":"base","o":"max","f":"hp_max","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"max(..., na.rm = FALSE)"},{"p":"base","o":"floor","f":"hp_floor","d":"ceiling takes a single numeric argument x and returns a\nnumeric vector containing the smallest integers not less than the\ncorresponding elements of x.\n","ec":"floor(x)"},{"p":"base","o":"Ops.numeric_version","f":"hp_Ops.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"Ops.numeric_version(e1, e2)"},{"p":"base","o":"close","f":"hp_close","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"close(con, ...)"},{"p":"base","o":"Math.Date","f":"hp_Math.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"Math.Date(x, ...)"},{"p":"base","o":"dimnames<-.data.frame","f":"hp_dimnames...data.frame","d":"Retrieve or set the dimnames of an object.\n","ec":"dimnames<-.data.frame(x, value)"},{"p":"base","o":"Math.data.frame","f":"hp_Math.data.frame","d":"Group generic methods can be defined for the following pre-specified groups of\nfunctions, Math, Ops, matrixOps, Summary and Complex.\n(There are no objects of these names in base R, but there are in the\nmethods package, not yet for matrixOps.)\n","ec":"Math.data.frame(x, ...)"},{"p":"base","o":"min","f":"hp_min","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"min(..., na.rm = FALSE)"},{"p":"base","o":"as.array","f":"hp_as.array","d":"Creates or tests for arrays.\n","ec":"as.array(x, ...)"},{"p":"base","o":"assign","f":"hp_assign","d":"Assign a value to a name in an environment.\n","ec":"assign(x, value, pos = -1, envir = as.environment(pos), inherits = FALSE, immediate = TRUE)"},{"p":"base","o":"taskCallbackManager","f":"hp_taskCallbackManager","d":"This provides an entirely R-language mechanism\nfor managing callbacks or actions  that are invoked at\nthe conclusion of each top-level task.  Essentially,\nwe register a single R function from this manager\nwith the underlying, native\ntask-callback mechanism and this function handles invoking the other\nR callbacks under the control of the manager.\nThe manager consists of a collection of functions that access shared\nvariables to manage the list of user-level callbacks.\n","ec":"taskCallbackManager(handlers = list(), registered = FALSE, verbose = FALSE)"},{"p":"base","o":"gettextf","f":"hp_gettextf","d":"A wrapper for the C function sprintf, that returns a character\nvector containing a formatted combination of text and variable values.\n","ec":"gettextf(fmt, ..., domain = NULL, trim = TRUE)"},{"p":"base","o":".NotYetUsed","f":"hp_.NotYetUsed","d":"In order to pinpoint missing functionality, the R core team uses\nthese functions for missing R functions and not yet used arguments of\nexisting R functions (which are typically there for compatibility\npurposes).\n","ec":".NotYetUsed(arg, error = TRUE)"},{"p":"base","o":"setHook","f":"hp_setHook","d":"These functions allow users to set actions to be taken before packages\nare attached/detached and namespaces are (un)loaded.\n","ec":"setHook(hookName, value, action = c(\"append\", \"prepend\", \"replace\"))"},{"p":"base","o":"load","f":"hp_load","d":"Reload datasets written with the function save.\n","ec":"load(file, envir = parent.frame(), verbose = FALSE)"},{"p":"base","o":"socketTimeout","f":"hp_socketTimeout","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"socketTimeout(socket, timeout = -1)"},{"p":"base","o":"Negate","f":"hp_Negate","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Negate(f)"},{"p":"base","o":"unique.matrix","f":"hp_unique.matrix","d":"unique returns a vector, data frame or array like x\nbut with duplicate elements/rows removed.\n","ec":"unique.matrix(x, incomparables = FALSE, MARGIN = 1, fromLast = FALSE, ...)"},{"p":"base","o":"log2","f":"hp_log2","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"log2(x)"},{"p":"base","o":"as.character.POSIXt","f":"hp_as.character.POSIXt","d":"Functions to convert between character representations and objects of\nclasses \"POSIXlt\" and \"POSIXct\" representing calendar\ndates and times.\n","ec":"as.character.POSIXt(x, digits = if (inherits(x, \"POSIXlt\")) 14L else 6L, OutDec = \".\", ...)"},{"p":"base","o":"untrace","f":"hp_untrace","d":"A call to trace allows you to insert debugging code (e.g., a\ncall to browser or recover) at chosen\nplaces in any function.  A call to untrace cancels the tracing.\nSpecified methods can be traced the same way, without tracing all\ncalls to the generic function.  Trace code (tracer) can be any\nR expression.  Tracing can be temporarily turned on or off globally\nby calling tracingState.\n","ec":"untrace(what, signature = NULL, where = topenv(parent.frame()))"},{"p":"base","o":"logb","f":"hp_logb","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"logb(x, base = exp(1))"},{"p":"base","o":"is.array","f":"hp_is.array","d":"Creates or tests for arrays.\n","ec":"is.array(x)"},{"p":"base","o":"droplevels.factor","f":"hp_droplevels.factor","d":"The function droplevels is used to drop unused levels from a\nfactor or, more commonly, from factors in a data frame.\n","ec":"droplevels.factor(x, exclude = if (anyNA(levels(x))) NULL else NA, ...)"},{"p":"base","o":"R.version","f":"hp_R.version","d":"R.Version() provides detailed information about the version of\nR running.\n","ec":""},{"p":"base","o":"R.Version","f":"hp_R.Version","d":"R.Version() provides detailed information about the version of\nR running.\n","ec":"R.Version()"},{"p":"base","o":"within.list","f":"hp_within.list","d":"Evaluate an R expression in an environment constructed from data,\npossibly modifying (a copy of) the original data.\n","ec":"within.list(data, expr, keepAttrs = TRUE, ...)"},{"p":"base","o":"inherits","f":"hp_inherits","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"inherits(x, what, which = FALSE)"},{"p":"base","o":"Sys.setenv","f":"hp_Sys.setenv","d":"Sys.setenv sets environment variables (for other processes\ncalled from within R or future calls to Sys.getenv from\nthis R process).\n","ec":"Sys.setenv(...)"},{"p":"base","o":"comment","f":"hp_comment","d":"These functions set and query a comment\nattribute for any R objects.  This is typically useful for\ndata.frames or model fits.\n","ec":"comment(x)"},{"p":"base","o":"as.vector.data.frame","f":"hp_as.vector.data.frame","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"as.vector.data.frame(x, mode = \"any\")"},{"p":"base","o":"print.DLLInfoList","f":"hp_print.DLLInfoList","d":"This function provides a way to get a list of all the DLLs (see\ndyn.load) that are currently loaded in the R session.\n","ec":"print.DLLInfoList(x, ...)"},{"p":"base","o":"vector","f":"hp_vector","d":"A vector in R is either an atomic vector i.e., one of the atomic\ntypes, see <U+2018>Details<U+2019>, or of type (typeof) or mode\nlist or expression.\n","ec":"vector(mode = \"logical\", length = 0L)"},{"p":"base","o":"system","f":"hp_system","d":"system invokes the OS command specified by command.\n","ec":"system(command, intern = FALSE, ignore.stdout = FALSE, ignore.stderr = FALSE, wait = TRUE, input = NULL, show.output.on.console = TRUE, minimized = FALSE, invisible = TRUE, timeout = 0, receive.console.signals = wait)"},{"p":"base","o":".First.sys","f":"hp_.First.sys","d":"In R, the startup mechanism is as follows.\n","ec":".First.sys()"},{"p":"base","o":"save.image","f":"hp_save.image","d":"save writes an external representation of R objects to the\nspecified file.  The objects can be read back from the file at a later\ndate by using the function load or attach\n(or data in some cases).\n","ec":"save.image(file = \".RData\", version = NULL, ascii = FALSE, compress = !ascii, safe = TRUE)"},{"p":"base","o":"[[<-.data.frame","f":"hp_X.....data.frame","d":"Extract or replace subsets of data frames.\n","ec":"[[<-.data.frame(x, i, j, value)"},{"p":"base","o":"row.names<-.default","f":"hp_row.names...default","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names<-.default(x, value)"},{"p":"base","o":"as.array.default","f":"hp_as.array.default","d":"Creates or tests for arrays.\n","ec":"as.array.default(x, ...)"},{"p":"base","o":"format.info","f":"hp_format.info","d":"Information is returned on how format(x, digits, nsmall)\nwould be formatted.\n","ec":"format.info(x, digits = NULL, nsmall = 0L)"},{"p":"base","o":"|.hexmode","f":"hp_X..hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"|.hexmode(a, b)"},{"p":"base","o":".F_dqrqy","f":"hp_.F_dqrqy","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"Sys.setFileTime","f":"hp_Sys.setFileTime","d":"Uses system calls to set the times on a file or directory.\n","ec":"Sys.setFileTime(path, time)"},{"p":"base","o":".F_dqrxb","f":"hp_.F_dqrxb","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"setequal","f":"hp_setequal","d":"Performs set union, intersection, (asymmetric!) difference,\nequality and membership on two vectors.\n","ec":"setequal(x, y)"},{"p":"base","o":"raw","f":"hp_raw","d":"Creates or tests for objects of type \"raw\".\n","ec":"raw(length = 0L)"},{"p":"base","o":"typeof","f":"hp_typeof","d":"typeof determines the (R internal)\ntype or storage mode of any object\n","ec":"typeof(x)"},{"p":"base","o":"rep","f":"hp_rep","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep(x, ...)"},{"p":"base","o":"rev","f":"hp_rev","d":"rev provides a reversed version of its argument.  It is generic\nfunction with a default method for vectors and one for\ndendrograms.\n","ec":"rev(x)"},{"p":"base","o":"paste0","f":"hp_paste0","d":"Concatenate vectors after converting to character.\nConcatenation happens in two basically different ways, determined by\ncollapse being a string or not.\n","ec":"paste0(..., collapse = NULL, recycle0 = FALSE)"},{"p":"base","o":"rle","f":"hp_rle","d":"Compute the lengths and values of runs of equal values in a vector\n<U+2013> or the reverse operation.\n","ec":"rle(x)"},{"p":"base","o":"conditionMessage","f":"hp_conditionMessage","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"conditionMessage(c)"},{"p":"base","o":".F_dqrcf","f":"hp_.F_dqrcf","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"row","f":"hp_row","d":"Returns a matrix of integers indicating their row number in a\nmatrix-like object, or a factor indicating the row labels.\n","ec":"row(x, as.factor = FALSE)"},{"p":"base","o":"stderr","f":"hp_stderr","d":"Display aspects of connections.\n","ec":"stderr()"},{"p":"base","o":".Last.value","f":"hp_.Last.value","d":"The value of the internal evaluation of a top-level R expression\nis always assigned to .Last.value (in package:base)\nbefore further processing (e.g., printing).\n","ec":""},{"p":"base","o":"seq","f":"hp_seq","d":"Generate regular sequences.  seq is a standard generic with a\ndefault method.  seq.int is a primitive which can be\nmuch faster but has a few restrictions.  seq_along and\nseq_len are very fast primitives for two common cases.\n","ec":"seq(...)"},{"p":"base","o":"flush","f":"hp_flush","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"flush(con)"},{"p":"base","o":"sin","f":"hp_sin","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"sin(x)"},{"p":"base","o":"intToUtf8","f":"hp_intToUtf8","d":"Conversion of UTF-8 encoded character vectors to and from integer\nvectors representing a UTF-32 encoding.\n","ec":"intToUtf8(x, multiple = FALSE, allow_surrogate_pairs = FALSE)"},{"p":"base","o":"acos","f":"hp_acos","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"acos(x)"},{"p":"base","o":"globalCallingHandlers","f":"hp_globalCallingHandlers","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"globalCallingHandlers(...)"},{"p":"base","o":"within","f":"hp_within","d":"Evaluate an R expression in an environment constructed from data,\npossibly modifying (a copy of) the original data.\n","ec":"within(data, expr, ...)"},{"p":"base","o":"tan","f":"hp_tan","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"tan(x)"},{"p":"base","o":"as.matrix.noquote","f":"hp_as.matrix.noquote","d":"Print character strings without quotes.\n","ec":"as.matrix.noquote(x, ...)"},{"p":"base","o":"libcurlVersion","f":"hp_libcurlVersion","d":"Report version of libcurl in use.\n","ec":"libcurlVersion()"},{"p":"base","o":"sub","f":"hp_sub","d":"grep, grepl, regexpr, gregexpr, \nregexec and gregexec search for matches to argument\npattern within each element of a character vector: they differ in\nthe format of and amount of detail in the results.\n","ec":"sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"base","o":"sum","f":"hp_sum","d":"sum returns the sum of all the values\npresent in its arguments.\n","ec":"sum(..., na.rm = FALSE)"},{"p":"base","o":"svd","f":"hp_svd","d":"Compute the singular-value decomposition of a rectangular matrix.\n","ec":"svd(x, nu = min(n, p), nv = min(n, p), LINPACK = FALSE)"},{"p":"base","o":"upper.tri","f":"hp_upper.tri","d":"Returns a matrix of logicals the same size of a given matrix with\nentries TRUE in the lower or upper triangle.\n","ec":"upper.tri(x, diag = FALSE)"},{"p":"base","o":"isSymmetric.matrix","f":"hp_isSymmetric.matrix","d":"Generic function to test if object is symmetric or not.\nCurrently only a matrix method is implemented, where a\ncomplex matrix Z must be <U+201C>Hermitian<U+201D> for\nisSymmetric(Z) to be true.\n","ec":"isSymmetric.matrix(object, tol = 100 * .Machine$double.eps, tol1 = 8 * tol, ...)"},{"p":"base","o":"is.factor","f":"hp_is.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"is.factor(x)"},{"p":"base","o":"$<-.POSIXlt","f":"hp_X....POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"$<-.POSIXlt(x, name, value)"},{"p":"base","o":"mean","f":"hp_mean","d":"Generic function for the (trimmed) arithmetic mean.\n","ec":"mean(x, ...)"},{"p":"base","o":"try","f":"hp_try","d":"try is a wrapper to run an expression that might fail and allow\nthe user's code to handle error-recovery.\n","ec":"try(expr, silent = FALSE, outFile = getOption(\"try.outFile\", default = stderr()))"},{"p":"base","o":"rev.default","f":"hp_rev.default","d":"rev provides a reversed version of its argument.  It is generic\nfunction with a default method for vectors and one for\ndendrograms.\n","ec":"rev.default(x)"},{"p":"base","o":"is.character","f":"hp_is.character","d":"Create or test for objects of type \"character\".\n","ec":"is.character(x)"},{"p":"base","o":"Sys.getenv","f":"hp_Sys.getenv","d":"Sys.getenv obtains the values of the environment variables.\n","ec":"Sys.getenv(x = NULL, unset = \"\", names = NA)"},{"p":"base","o":"!.octmode","f":"hp_X..octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"!.octmode(a)"},{"p":"base","o":"unz","f":"hp_unz","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"unz(description, filename, open = \"\", encoding = getOption(\"encoding\"))"},{"p":"base","o":"as.data.frame.factor","f":"hp_as.data.frame.factor","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.factor(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"url","f":"hp_url","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"url(description, open = \"\", blocking = TRUE, encoding = getOption(\"encoding\"), method = getOption(\"url.method\", \"default\"), headers = NULL)"},{"p":"base","o":"Ops.Date","f":"hp_Ops.Date","d":"Operators for the \"Date\" class.\n","ec":"Ops.Date(e1, e2)"},{"p":"base","o":"use","f":"hp_use","d":"Use packages in R scripts by loading their namespace and attaching a\npackage environment including (a subset of) their exports to the\nsearch path.\n","ec":"use(package, include.only)"},{"p":"base","o":"as.environment","f":"hp_as.environment","d":"A generic function coercing an R object to an\nenvironment.  A number or a character string is\nconverted to the corresponding environment on the search path.\n","ec":"as.environment(x)"},{"p":"base","o":"[.data.frame","f":"hp_X..data.frame","d":"Extract or replace subsets of data frames.\n","ec":"[.data.frame(x, i, j, drop = if (missing(i)) TRUE else length(cols) == 1)"},{"p":"base","o":"mget","f":"hp_mget","d":"Search by name for an object (get) or zero or more objects\n(mget).\n","ec":"mget(x, envir = as.environment(-1L), mode = \"any\", ifnotfound, inherits = FALSE)"},{"p":"base","o":"print.eigen","f":"hp_print.eigen","d":"Computes eigenvalues and eigenvectors of numeric (double, integer,\nlogical) or complex matrices.\n","ec":"print.eigen(x, ...)"},{"p":"base","o":"invokeRestartInteractively","f":"hp_invokeRestartInteractively","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"invokeRestartInteractively(r)"},{"p":"base","o":"getNamespaceExports","f":"hp_getNamespaceExports","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespaceExports(ns)"},{"p":"base","o":"subset.matrix","f":"hp_subset.matrix","d":"Return subsets of vectors, matrices or data frames which meet conditions.\n","ec":"subset.matrix(x, subset, select, drop = FALSE, ...)"},{"p":"base","o":"forwardsolve","f":"hp_forwardsolve","d":"Solves a triangular system of linear equations.\n","ec":"forwardsolve(l, x, k = ncol(l), upper.tri = FALSE, transpose = FALSE)"},{"p":"base","o":"dim<-","f":"hp_dim..","d":"Retrieve or set the dimension of an object.\n","ec":"dim<-(x, value)"},{"p":"base","o":"solve.default","f":"hp_solve.default","d":"This generic function solves the equation a %*% x = b for x,\nwhere b can be either a vector or a matrix.\n","ec":"solve.default(a, b, tol = .Machine$double.eps, LINPACK = FALSE, ...)"},{"p":"base","o":"icuGetCollate","f":"hp_icuGetCollate","d":"Controls the way collation is done by ICU (an optional part of the R\nbuild).\n","ec":"icuGetCollate(type = c(\"actual\", \"valid\"))"},{"p":"base","o":"dirname","f":"hp_dirname","d":"basename removes all of the path up to and including the last\npath separator (if any).\n","ec":"dirname(path)"},{"p":"base","o":"as.data.frame.model.matrix","f":"hp_as.data.frame.model.matrix","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.model.matrix(x, row.names = NULL, optional = FALSE, make.names = TRUE, ...)"},{"p":"base","o":"Sys.info","f":"hp_Sys.info","d":"Reports system and user information.\n","ec":"Sys.info()"},{"p":"base","o":"as.Date.character","f":"hp_as.Date.character","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.character(x, format, tryFormats = c(\"%Y-%m-%d\", \"%Y/%m/%d\"), optional = FALSE, ...)"},{"p":"base","o":".encode_numeric_version","f":"hp_.encode_numeric_version","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".encode_numeric_version(x)"},{"p":"base","o":"xor","f":"hp_xor","d":"These operators act on raw, logical and number-like vectors.\n","ec":"xor(x, y)"},{"p":"base","o":"quarters.POSIXt","f":"hp_quarters.POSIXt","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"quarters.POSIXt(x, ...)"},{"p":"base","o":"allowInterrupts","f":"hp_allowInterrupts","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"allowInterrupts(expr)"},{"p":"base","o":"%in%","f":"hp_X.in.","d":"match returns a vector of the positions of (first) matches of\nits first argument in its second.\n","ec":"%in%(x, table)"},{"p":"base","o":"julian","f":"hp_julian","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"julian(x, ...)"},{"p":"base","o":"intToBits","f":"hp_intToBits","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"intToBits(x)"},{"p":"base","o":"validUTF8","f":"hp_validUTF8","d":"Check if each element of a character vector is valid in its implied\nencoding.\n","ec":"validUTF8(x)"},{"p":"base","o":"capabilities","f":"hp_capabilities","d":"Report on the optional features which have been compiled into this\nbuild of R.\n","ec":"capabilities(what = NULL, Xchk = any(nas %in% c(\"X11\", \"jpeg\", \"png\", \"tiff\")))"},{"p":"base","o":"oldClass<-","f":"hp_oldClass..","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"oldClass<-(x, value)"},{"p":"base","o":"print.simple.list","f":"hp_print.simple.list","d":"print prints its argument and returns it invisibly (via\ninvisible(x)).  It is a generic function which means that\nnew printing methods can be easily added for new classes.\n","ec":"print.simple.list(x, ...)"},{"p":"base","o":"namespaceImport","f":"hp_namespaceImport","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"namespaceImport(self, ..., from = NULL, except = character(0L))"},{"p":"base","o":"geterrmessage","f":"hp_geterrmessage","d":"stop stops execution of the current expression and executes\nan error action.\n","ec":"geterrmessage()"},{"p":"base","o":"delayedAssign","f":"hp_delayedAssign","d":"delayedAssign creates a promise to evaluate the given\nexpression if its value is requested.  This provides direct access\nto the lazy evaluation mechanism used by R for the evaluation\nof (interpreted) functions.\n","ec":"delayedAssign(x, value, eval.env = parent.frame(1), assign.env = parent.frame(1))"},{"p":"base","o":"print.DLLRegisteredRoutines","f":"hp_print.DLLRegisteredRoutines","d":"This function allows us to query the set of routines\nin a DLL that are registered with R to enhance\ndynamic lookup, error handling when calling native routines,\nand potentially security in the future.\nThis function provides a description of each of the\nregistered routines in the DLL for the different interfaces,\ni.e. .C, .Call, .Fortran\nand .External.\n","ec":"print.DLLRegisteredRoutines(x, ...)"},{"p":"base","o":"Sys.setlocale","f":"hp_Sys.setlocale","d":"Get details of or set aspects of the locale for the R process.\n","ec":"Sys.setlocale(category = \"LC_ALL\", locale = \"\")"},{"p":"base","o":"difftime","f":"hp_difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"difftime(time1, time2, tz, units = c(\"auto\", \"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))"},{"p":"base","o":"[.Date","f":"hp_X..Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"[.Date(x, ..., drop = TRUE)"},{"p":"base","o":"..getNamespace","f":"hp_..getNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":"..getNamespace(name, where)"},{"p":"base","o":"levels<-.factor","f":"hp_levels...factor","d":"levels provides access to the levels attribute of a variable.\nThe first form returns the value of the levels of its argument\nand the second sets the attribute.\n","ec":"levels<-.factor(x, value)"},{"p":"base","o":"range","f":"hp_range","d":"range returns a vector containing the minimum and maximum of\nall the given arguments.\n","ec":"range(..., na.rm = FALSE)"},{"p":"base","o":"unique.data.frame","f":"hp_unique.data.frame","d":"unique returns a vector, data frame or array like x\nbut with duplicate elements/rows removed.\n","ec":"unique.data.frame(x, incomparables = FALSE, fromLast = FALSE, ...)"},{"p":"base","o":"deparse","f":"hp_deparse","d":"Turn unevaluated expressions into character strings.\n","ec":"deparse(expr, width.cutoff = 60L, backtick = mode(expr) %in% c(\"call\", \"expression\", \"(\", \"function\"), control = c(\"keepNA\", \"keepInteger\", \"niceNames\", \"showAttributes\"), nlines = -1L)"},{"p":"base","o":"pairlist","f":"hp_pairlist","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"pairlist(...)"},{"p":"base","o":"sinpi","f":"hp_sinpi","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"sinpi(x)"},{"p":"base","o":"summary.POSIXct","f":"hp_summary.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"summary.POSIXct(object, digits = 15L, ...)"},{"p":"base","o":"print.NativeRoutineList","f":"hp_print.NativeRoutineList","d":"This function allows us to query the set of routines\nin a DLL that are registered with R to enhance\ndynamic lookup, error handling when calling native routines,\nand potentially security in the future.\nThis function provides a description of each of the\nregistered routines in the DLL for the different interfaces,\ni.e. .C, .Call, .Fortran\nand .External.\n","ec":"print.NativeRoutineList(x, ...)"},{"p":"base","o":"psigamma","f":"hp_psigamma","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"psigamma(x, deriv = 0L)"},{"p":"base","o":"file.access","f":"hp_file.access","d":"Utility function to access information about files on the user's\nfile systems.\n","ec":"file.access(names, mode = 0)"},{"p":"base","o":"is.environment","f":"hp_is.environment","d":"Get, set, test for and create environments.\n","ec":"is.environment(x)"},{"p":"base","o":"Math.factor","f":"hp_Math.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"Math.factor(x, ...)"},{"p":"base","o":"getRversion","f":"hp_getRversion","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"getRversion()"},{"p":"base","o":"droplevels","f":"hp_droplevels","d":"The function droplevels is used to drop unused levels from a\nfactor or, more commonly, from factors in a data frame.\n","ec":"droplevels(x, ...)"},{"p":"base","o":"determinant.matrix","f":"hp_determinant.matrix","d":"det calculates the determinant of a matrix.  determinant\nis a generic function that returns separately the modulus of the determinant,\noptionally on the logarithm scale, and the sign of the determinant.\n","ec":"determinant.matrix(x, logarithm = TRUE, ...)"},{"p":"base","o":"stdout","f":"hp_stdout","d":"Display aspects of connections.\n","ec":"stdout()"},{"p":"base","o":"summary.POSIXlt","f":"hp_summary.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"summary.POSIXlt(object, digits = 15, ...)"},{"p":"base","o":"suspendInterrupts","f":"hp_suspendInterrupts","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"suspendInterrupts(expr)"},{"p":"base","o":"tapply","f":"hp_tapply","d":"Apply a function to each cell of a ragged array, that is to each\n(non-empty) group of values or data rows given by a unique\ncombination of the levels of certain factors.\n","ec":"tapply(X, INDEX, FUN = NULL, ..., default = NA, simplify = TRUE)"},{"p":"base","o":".F_dqrqty","f":"hp_.F_dqrqty","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"trace","f":"hp_trace","d":"A call to trace allows you to insert debugging code (e.g., a\ncall to browser or recover) at chosen\nplaces in any function.  A call to untrace cancels the tracing.\nSpecified methods can be traced the same way, without tracing all\ncalls to the generic function.  Trace code (tracer) can be any\nR expression.  Tracing can be temporarily turned on or off globally\nby calling tracingState.\n","ec":"trace(what, tracer, exit, at, print, signature, where = topenv(parent.frame()), edit = FALSE)"},{"p":"base","o":"callCC","f":"hp_callCC","d":"A downward-only version of Scheme's call with current continuation.\n","ec":"callCC(fun)"},{"p":"base","o":".getNamespace","f":"hp_.getNamespace","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":".getNamespace(name)"},{"p":"base","o":"as.matrix.POSIXlt","f":"hp_as.matrix.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"as.matrix.POSIXlt(x, ...)"},{"p":"base","o":"rowMeans","f":"hp_rowMeans","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":"rowMeans(x, na.rm = FALSE, dims = 1L)"},{"p":"base","o":".isOpen","f":"hp_.isOpen","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":".isOpen(srcfile)"},{"p":"base","o":"format.packageInfo","f":"hp_format.packageInfo","d":"library and require load and attach add-on packages.\n","ec":"format.packageInfo(x, ...)"},{"p":"base","o":".F_dqrrsd","f":"hp_.F_dqrrsd","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"print.default","f":"hp_print.default","d":"print.default is the default method of the generic\nprint function which prints its argument.\n","ec":"print.default(x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, width = NULL, useSource = TRUE, ...)"},{"p":"base","o":"shQuote","f":"hp_shQuote","d":"Quote a string to be passed to an operating system shell.\n","ec":"shQuote(string, type = c(\"sh\", \"csh\", \"cmd\", \"cmd2\"))"},{"p":"base","o":"cut.default","f":"hp_cut.default","d":"cut divides the range of x into intervals\nand codes the values in x according to which\ninterval they fall.  The leftmost interval corresponds to level one,\nthe next leftmost to level two and so on.\n","ec":"cut.default(x, breaks, labels = NULL, include.lowest = FALSE, right = TRUE, dig.lab = 3L, ordered_result = FALSE, ...)"},{"p":"base","o":"range.default","f":"hp_range.default","d":"range returns a vector containing the minimum and maximum of\nall the given arguments.\n","ec":"range.default(..., na.rm = FALSE, finite = FALSE)"},{"p":"base","o":"structure","f":"hp_structure","d":"structure returns the given object with further\nattributes set.\n","ec":"structure(.Data, ...)"},{"p":"base","o":"mode","f":"hp_mode","d":"Get or set the <U+2018>mode<U+2019> (a kind of <U+2018>type<U+2019>), or the storage\nmode of an R object.\n","ec":"mode(x)"},{"p":"base","o":"Ops.difftime","f":"hp_Ops.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"Ops.difftime(e1, e2)"},{"p":"base","o":"attributes","f":"hp_attributes","d":"These functions access an object's attributes.\nThe first form below returns the object's attribute list.\nThe replacement forms uses the list on the right-hand\nside of the assignment as the object's attributes (if appropriate).\n","ec":"attributes(x)"},{"p":"base","o":"as.POSIXct","f":"hp_as.POSIXct","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXct(x, tz = \"\", ...)"},{"p":"base","o":"all.names","f":"hp_all.names","d":"Return a character vector containing all the names which occur in an\nexpression or call.\n","ec":"all.names(expr, functions = TRUE, max.names = -1L, unique = FALSE)"},{"p":"base","o":"as.character","f":"hp_as.character","d":"Create or test for objects of type \"character\".\n","ec":"as.character(x, ...)"},{"p":"base","o":"as.POSIXlt","f":"hp_as.POSIXlt","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt(x, tz = \"\", ...)"},{"p":"base","o":"sort.default","f":"hp_sort.default","d":"Sort (or order) a vector or factor (partially) into\nascending or descending order.  For ordering along more than one\nvariable, e.g., for sorting data frames, see order.\n","ec":"sort.default(x, decreasing = FALSE, na.last = NA, ...)"},{"p":"base","o":"simpleCondition","f":"hp_simpleCondition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"simpleCondition(message, call = NULL)"},{"p":"base","o":"within.data.frame","f":"hp_within.data.frame","d":"Evaluate an R expression in an environment constructed from data,\npossibly modifying (a copy of) the original data.\n","ec":"within.data.frame(data, expr, ...)"},{"p":"base","o":"row.names<-.data.frame","f":"hp_row.names...data.frame","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names<-.data.frame(x, value)"},{"p":"base","o":"endsWith","f":"hp_endsWith","d":"Determines if entries of x start or end with string (entries of)\nprefix or suffix respectively, where strings are\nrecycled to common lengths.\n","ec":"endsWith(x, suffix)"},{"p":"base","o":"print.connection","f":"hp_print.connection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"print.connection(x, ...)"},{"p":"base","o":"&.octmode","f":"hp_X..octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"&.octmode(a, b)"},{"p":"base","o":"parent.env<-","f":"hp_parent.env..","d":"Get, set, test for and create environments.\n","ec":"parent.env<-(env, value)"},{"p":"base","o":"split.default","f":"hp_split.default","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split.default(x, f, drop = FALSE, sep = \".\", lex.order = FALSE, ...)"},{"p":"base","o":"asS3","f":"hp_asS3","d":"Tests whether the object is an instance of an S4 class.\n","ec":"asS3(object, flag = TRUE, complete = TRUE)"},{"p":"base","o":"asS4","f":"hp_asS4","d":"Tests whether the object is an instance of an S4 class.\n","ec":"asS4(object, flag = TRUE, complete = TRUE)"},{"p":"base","o":"with.default","f":"hp_with.default","d":"Evaluate an R expression in an environment constructed from data,\npossibly modifying (a copy of) the original data.\n","ec":"with.default(data, expr, ...)"},{"p":"base","o":"balancePOSIXlt","f":"hp_balancePOSIXlt","d":"Utilities to <U+2018>balance<U+2019> objects of class \"POSIXlt\".\n","ec":"balancePOSIXlt(x, fill.only = FALSE, classed = TRUE)"},{"p":"base","o":"args","f":"hp_args","d":"Displays the argument names and corresponding default values of a\n(non-primitive or primitive) function.\n","ec":"args(name)"},{"p":"base","o":"break","f":"hp_break.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"R_system_version","f":"hp_R_system_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"R_system_version(x, strict = TRUE)"},{"p":"base","o":"matrix","f":"hp_matrix","d":"matrix creates a matrix from the given set of values.\n","ec":"matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)"},{"p":"base","o":"is.na.POSIXlt","f":"hp_is.na.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"is.na.POSIXlt(x)"},{"p":"base","o":"basename","f":"hp_basename","d":"basename removes all of the path up to and including the last\npath separator (if any).\n","ec":"basename(path)"},{"p":"base","o":"lbeta","f":"hp_lbeta","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"lbeta(a, b)"},{"p":"base","o":"asin","f":"hp_asin","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"asin(x)"},{"p":"base","o":"summary.default","f":"hp_summary.default","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"summary.default(object, ..., digits, quantile.type = 7)"},{"p":"base","o":"file.append","f":"hp_file.append","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.append(file1, file2)"},{"p":"base","o":"srcfile","f":"hp_srcfile","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"srcfile(filename, encoding = getOption(\"encoding\"), Enc = \"unknown\")"},{"p":"base","o":"Sys.which","f":"hp_Sys.which","d":"This is an interface to the system command which, or to an\nemulation on Windows.\n","ec":"Sys.which(names)"},{"p":"base","o":"ncol","f":"hp_ncol","d":"nrow and ncol return the number of rows or columns\npresent in x.\nNCOL and NROW do the same treating a vector as\n1-column matrix, even a 0-length vector, compatibly with\nas.matrix() or cbind(), see the example.\n","ec":"ncol(x)"},{"p":"base","o":"return","f":"hp_return","d":"These functions provide the base mechanisms for defining\nnew functions in the R language.\n","ec":""},{"p":"base","o":"atan","f":"hp_atan","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"atan(x)"},{"p":"base","o":"eapply","f":"hp_eapply","d":"eapply applies FUN to the named values from an\nenvironment and returns the results as a list.  The user\ncan request that all named objects are used (normally names that begin\nwith a dot are not).  The output is not sorted and no enclosing\nenvironments are searched.\n","ec":"eapply(env, FUN, ..., all.names = FALSE, USE.NAMES = TRUE)"},{"p":"base","o":"rep.POSIXct","f":"hp_rep.POSIXct","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep.POSIXct(x, ...)"},{"p":"base","o":"rep.POSIXlt","f":"hp_rep.POSIXlt","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep.POSIXlt(x, ...)"},{"p":"base","o":"socketConnection","f":"hp_socketConnection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"socketConnection(host = \"localhost\", port, server = FALSE, blocking = FALSE, open = \"a+\", encoding = getOption(\"encoding\"), timeout = getOption(\"timeout\"), options = getOption(\"socketOptions\"))"},{"p":"base","o":"format.Date","f":"hp_format.Date","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"format.Date(x, format = \"%Y-%m-%d\", ...)"},{"p":"base","o":"getConnection","f":"hp_getConnection","d":"Display aspects of connections.\n","ec":"getConnection(what)"},{"p":"base","o":"tryCatch","f":"hp_tryCatch","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"tryCatch(expr, ..., finally)"},{"p":"base","o":"attr","f":"hp_attr","d":"Get or set specific attributes of an object.\n","ec":"attr(x, which, exact = FALSE)"},{"p":"base","o":"tracemem","f":"hp_tracemem","d":"This function marks an object so that a message is printed whenever the\ninternal code copies the object.  It is a\nmajor cause of hard-to-predict memory use in R.\n","ec":"tracemem(x)"},{"p":"base","o":"as.data.frame.ordered","f":"hp_as.data.frame.ordered","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.ordered(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"format.hexmode","f":"hp_format.hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"format.hexmode(x, width = NULL, upper.case = FALSE, ...)"},{"p":"base","o":"beta","f":"hp_beta","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"beta(a, b)"},{"p":"base","o":"seq.POSIXt","f":"hp_seq.POSIXt","d":"The method for seq for date-time classes.\n","ec":"seq.POSIXt(from, to, by, length.out = NULL, along.with = NULL, ...)"},{"p":"base","o":"summary.Date","f":"hp_summary.Date","d":"Description of the class \"Date\" representing calendar dates.\n","ec":"summary.Date(object, digits = 12L, ...)"},{"p":"base","o":"next","f":"hp_next.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"Sys.getlocale","f":"hp_Sys.getlocale","d":"Get details of or set aspects of the locale for the R process.\n","ec":"Sys.getlocale(category = \"LC_ALL\")"},{"p":"base","o":"lower.tri","f":"hp_lower.tri","d":"Returns a matrix of logicals the same size of a given matrix with\nentries TRUE in the lower or upper triangle.\n","ec":"lower.tri(x, diag = FALSE)"},{"p":"base","o":"rbind","f":"hp_rbind","d":"Take a sequence of vector, matrix or data-frame arguments and combine\nby columns or rows, respectively.  These are generic\nfunctions with methods for other R classes.\n","ec":"rbind(..., deparse.level = 1)"},{"p":"base","o":"union","f":"hp_union","d":"Performs set union, intersection, (asymmetric!) difference,\nequality and membership on two vectors.\n","ec":"union(x, y)"},{"p":"base","o":"write","f":"hp_write","d":"Write data x to a file or other connection.\n\nAs it simply calls cat(), less formatting happens than\nwith print()ing.\nIf x is a matrix you need to transpose it (and typically set\nncolumns) to get the columns in file the same as those in\nthe internal representation.\n","ec":"write(x, file = \"data\", ncolumns = if (is.character(x)) 1 else 5, append = FALSE, sep = \" \")"},{"p":"base","o":"units","f":"hp_units","d":"Get or set units.","ec":"units(x)"},{"p":"base","o":"cbind","f":"hp_cbind","d":"Take a sequence of vector, matrix or data-frame arguments and combine\nby columns or rows, respectively.  These are generic\nfunctions with methods for other R classes.\n","ec":"cbind(..., deparse.level = 1)"},{"p":"base","o":"dim.data.frame","f":"hp_dim.data.frame","d":"Retrieve or set the dimension of an object.\n","ec":"dim.data.frame(x)"},{"p":"base","o":"t.data.frame","f":"hp_t.data.frame","d":"Given a matrix or data.frame x,\nt returns the transpose of x.\n","ec":"t.data.frame(x)"},{"p":"base","o":"month.abb","f":"hp_month.abb","d":"Constants built into R.\n","ec":""},{"p":"base","o":"diag<-","f":"hp_diag..","d":"Extract or replace the diagonal of a matrix,\nor construct a diagonal matrix.\n","ec":"diag<-(x, value)"},{"p":"base","o":"Sys.unsetenv","f":"hp_Sys.unsetenv","d":"Sys.setenv sets environment variables (for other processes\ncalled from within R or future calls to Sys.getenv from\nthis R process).\n","ec":"Sys.unsetenv(x)"},{"p":"base","o":"dyn.unload","f":"hp_dyn.unload","d":"Load or unload DLLs (also known as shared objects), and test whether a\nC function or Fortran subroutine is available.\n","ec":"dyn.unload(x)"},{"p":"base","o":"scale.default","f":"hp_scale.default","d":"scale is generic function whose default method centers and/or\nscales the columns of a numeric matrix.\n","ec":"scale.default(x, center = TRUE, scale = TRUE)"},{"p":"base","o":"invokeRestart","f":"hp_invokeRestart","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"invokeRestart(r, ...)"},{"p":"base","o":"is.na<-.factor","f":"hp_is.na...factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"is.na<-.factor(x, value)"},{"p":"base","o":"as.data.frame.integer","f":"hp_as.data.frame.integer","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.integer(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"all.equal.language","f":"hp_all.equal.language","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.language(target, current, ...)"},{"p":"base","o":"bitwOr","f":"hp_bitwOr","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwOr(a, b)"},{"p":"base","o":".Library.site","f":"hp_.Library.site","d":"-NA-","ec":"-NA-"},{"p":"base","o":".packageStartupMessage","f":"hp_.packageStartupMessage","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".packageStartupMessage(message, call = NULL)"},{"p":"base","o":"close.connection","f":"hp_close.connection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"close.connection(con, type = \"rw\", ...)"},{"p":"base","o":"row.names<-","f":"hp_row.names..","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names<-(x, value)"},{"p":"base","o":"trimws","f":"hp_trimws","d":"Remove leading and/or trailing whitespace from character strings.\n","ec":"trimws(x, which = c(\"both\", \"left\", \"right\"), whitespace = \"[ \\t\\r\\n]\")"},{"p":"base","o":".Call.graphics","f":"hp_.Call.graphics","d":"Internal versions of .Call and .External.\n","ec":".Call.graphics(.NAME, ..., PACKAGE)"},{"p":"base","o":".C_R_addTaskCallback","f":"hp_.C_R_addTaskCallback","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"unserialize","f":"hp_unserialize","d":"A simple low-level interface for serializing to connections.\n","ec":"unserialize(connection, refhook = NULL)"},{"p":"base","o":"[[.data.frame","f":"hp_X...data.frame","d":"Extract or replace subsets of data frames.\n","ec":"[[.data.frame(x, ..., exact = TRUE)"},{"p":"base","o":".amatch_bounds","f":"hp_.amatch_bounds","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".amatch_bounds(x = 0.1)"},{"p":"base","o":".S3_methods_table","f":"hp_.S3_methods_table","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":""},{"p":"base","o":".row_names_info","f":"hp_.row_names_info","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".row_names_info(x, type = 1L)"},{"p":"base","o":"standardGeneric","f":"hp_standardGeneric","d":"The function standardGeneric initiates dispatch of S4\nmethods: see the references and the documentation of the\nmethods package.  Usually, calls to this function are\ngenerated automatically and not explicitly by the programmer.\n","ec":"standardGeneric(f, fdef)"},{"p":"base","o":".F_dqrdc2","f":"hp_.F_dqrdc2","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"[.Dlist","f":"hp_X..Dlist","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":"[.Dlist(x, i, ...)"},{"p":"base","o":"is.nan.POSIXlt","f":"hp_is.nan.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"is.nan.POSIXlt(x)"},{"p":"base","o":"as.data.frame.Date","f":"hp_as.data.frame.Date","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.Date(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"R.home","f":"hp_R.home","d":"Return the R home directory, or the full path to a component of the\nR installation.\n","ec":"R.home(component = \"home\")"},{"p":"base","o":"unique.default","f":"hp_unique.default","d":"unique returns a vector, data frame or array like x\nbut with duplicate elements/rows removed.\n","ec":"unique.default(x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...)"},{"p":"base","o":"sys.frame","f":"hp_sys.frame","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.frame(which = 0L)"},{"p":"base","o":"sys.source","f":"hp_sys.source","d":"Parses expressions in the given file, and then successively evaluates\nthem in the specified environment.\n","ec":"sys.source(file, envir = baseenv(), chdir = FALSE, keep.source = getOption(\"keep.source.pkgs\"), keep.parse.data = getOption(\"keep.parse.data.pkgs\"), toplevel.env = as.environment(envir))"},{"p":"base","o":"as.double.POSIXlt","f":"hp_as.double.POSIXlt","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.double.POSIXlt(x, ...)"},{"p":"base","o":"clearPushBack","f":"hp_clearPushBack","d":"Functions to push back text lines onto a connection, and to enquire\nhow many lines are currently pushed back.\n","ec":"clearPushBack(connection)"},{"p":"base","o":"%||%","f":"hp_X....","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":"%||%(x, y)"},{"p":"base","o":".leap.seconds","f":"hp_.leap.seconds","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":""},{"p":"base","o":".mapply","f":"hp_.mapply","d":"mapply is a multivariate version of sapply.\nmapply applies FUN to the first elements of each ...\nargument, the second elements, the third elements, and so on.\nArguments are recycled if necessary.\n","ec":".mapply(FUN, dots, MoreArgs)"},{"p":"base","o":"bindtextdomain","f":"hp_bindtextdomain","d":"Translation of text messages typically from calls to\nstop(), warning(), or message()\nhappens when Native Language Support (NLS) was enabled in this build of\nR as it is almost always, see also the bindtextdomain() example.\n","ec":"bindtextdomain(domain, dirname = NULL)"},{"p":"base","o":"lgamma","f":"hp_lgamma","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"lgamma(x)"},{"p":"base","o":"aperm.table","f":"hp_aperm.table","d":"Transpose an array by permuting its dimensions and optionally resizing\nit.\n","ec":"aperm.table(a, perm = NULL, resize = TRUE, keep.class = TRUE, ...)"},{"p":"base","o":"getLoadedDLLs","f":"hp_getLoadedDLLs","d":"This function provides a way to get a list of all the DLLs (see\ndyn.load) that are currently loaded in the R session.\n","ec":"getLoadedDLLs()"},{"p":"base","o":"subset.data.frame","f":"hp_subset.data.frame","d":"Return subsets of vectors, matrices or data frames which meet conditions.\n","ec":"subset.data.frame(x, subset, select, drop = FALSE, ...)"},{"p":"base","o":"as.Date.factor","f":"hp_as.Date.factor","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date.factor(x, ...)"},{"p":"base","o":"format.libraryIQR","f":"hp_format.libraryIQR","d":"library and require load and attach add-on packages.\n","ec":"format.libraryIQR(x, ...)"},{"p":"base","o":"unique","f":"hp_unique","d":"unique returns a vector, data frame or array like x\nbut with duplicate elements/rows removed.\n","ec":"unique(x, incomparables = FALSE, ...)"},{"p":"base","o":"as.data.frame.difftime","f":"hp_as.data.frame.difftime","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.difftime(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"merge.default","f":"hp_merge.default","d":"Merge two data frames by common columns or row names, or do other\nversions of database join operations.\n","ec":"merge.default(x, y, ...)"},{"p":"base","o":"ifelse","f":"hp_ifelse","d":"ifelse returns a value with the same shape as\ntest which is filled with elements selected\nfrom either yes or no\ndepending on whether the element of test\nis TRUE or FALSE.\n","ec":"ifelse(test, yes, no)"},{"p":"base","o":"is.atomic","f":"hp_is.atomic","d":"is.atomic returns TRUE if x is of an atomic type\nand FALSE otherwise.\n","ec":"is.atomic(x)"},{"p":"base","o":"+.Date","f":"hp_X..Date","d":"Operators for the \"Date\" class.\n","ec":"+.Date(e1, e2)"},{"p":"base","o":"sort_by.default","f":"hp_sort_by.default","d":"Generic function to sort an object in the order determined by one or\nmore other objects, typically vectors. A method is defined for data\nframes to sort its rows (typically by one or more columns), and the\ndefault method handles vector-like objects.\n","ec":"sort_by.default(x, y, ...)"},{"p":"base","o":"sys.parents","f":"hp_sys.parents","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.parents()"},{"p":"base","o":"body","f":"hp_body","d":"Get or set the body of a function which is basically all of\nthe function definition but its formal arguments (formals),\nsee the <U+2018>Details<U+2019>.\n","ec":"body(fun = sys.function(sys.parent()))"},{"p":"base","o":"as.character.default","f":"hp_as.character.default","d":"Create or test for objects of type \"character\".\n","ec":"as.character.default(x, ...)"},{"p":"base","o":"rep.int","f":"hp_rep.int","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep.int(x, times)"},{"p":"base","o":"as.data.frame.array","f":"hp_as.data.frame.array","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.array(x, row.names = NULL, optional = FALSE, ...)"},{"p":"base","o":"xtfrm.Date","f":"hp_xtfrm.Date","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.Date(x)"},{"p":"base","o":"norm","f":"hp_norm","d":"Computes a matrix norm of x using LAPACK.  The norm can be\nthe one (\"O\") norm, the infinity (\"I\") norm, the\nFrobenius (\"F\") norm, the maximum modulus (\"M\") among\nelements of a matrix, or the <U+201C>spectral<U+201D> or \"2\"-norm, as\ndetermined by the value of type.\n","ec":"norm(x, type = c(\"O\", \"I\", \"F\", \"M\", \"2\"))"},{"p":"base","o":"split<-.data.frame","f":"hp_split...data.frame","d":"split divides the data in the vector x into the groups\ndefined by f.  The replacement forms replace values\ncorresponding to such a division.  unsplit reverses the effect of\nsplit.\n","ec":"split<-.data.frame(x, f, drop = FALSE, ..., value)"},{"p":"base","o":"as.list.factor","f":"hp_as.list.factor","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"as.list.factor(x, ...)"},{"p":"base","o":"retracemem","f":"hp_retracemem","d":"This function marks an object so that a message is printed whenever the\ninternal code copies the object.  It is a\nmajor cause of hard-to-predict memory use in R.\n","ec":"retracemem(x, previous = NULL)"},{"p":"base","o":"local","f":"hp_local","d":"Evaluate an R expression in a specified environment.\n","ec":"local(expr, envir = new.env())"},{"p":"base","o":"expression","f":"hp_expression","d":"Creates or tests for objects of mode and class \"expression\".\n","ec":"expression(...)"},{"p":"base","o":"Reduce","f":"hp_Reduce","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Reduce(f, x, init, right = FALSE, accumulate = FALSE, simplify = TRUE)"},{"p":"base","o":"signalCondition","f":"hp_signalCondition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"signalCondition(cond)"},{"p":"base","o":"validEnc","f":"hp_validEnc","d":"Check if each element of a character vector is valid in its implied\nencoding.\n","ec":"validEnc(x)"},{"p":"base","o":"log10","f":"hp_log10","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"log10(x)"},{"p":"base","o":"isSymmetric","f":"hp_isSymmetric","d":"Generic function to test if object is symmetric or not.\nCurrently only a matrix method is implemented, where a\ncomplex matrix Z must be <U+201C>Hermitian<U+201D> for\nisSymmetric(Z) to be true.\n","ec":"isSymmetric(object, ...)"},{"p":"base","o":"log1p","f":"hp_log1p","d":"log computes logarithms, by default natural logarithms,\nlog10 computes common (i.e., base 10) logarithms, and\nlog2 computes binary (i.e., base 2) logarithms.\nThe general form log(x, base) computes logarithms with base\nbase.\n","ec":"log1p(x)"},{"p":"base","o":"is.expression","f":"hp_is.expression","d":"Creates or tests for objects of mode and class \"expression\".\n","ec":"is.expression(x)"},{"p":"base","o":"tryInvokeRestart","f":"hp_tryInvokeRestart","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"tryInvokeRestart(r, ...)"},{"p":"base","o":"is.unsorted","f":"hp_is.unsorted","d":"Test if an object is not sorted (in increasing order), without the\ncost of sorting it.\n","ec":"is.unsorted(x, na.rm = FALSE, strictly = FALSE)"},{"p":"base","o":"droplevels.data.frame","f":"hp_droplevels.data.frame","d":"The function droplevels is used to drop unused levels from a\nfactor or, more commonly, from factors in a data frame.\n","ec":"droplevels.data.frame(x, except = NULL, exclude, ...)"},{"p":"base","o":"sys.parent","f":"hp_sys.parent","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"sys.parent(n = 1L)"},{"p":"base","o":"call","f":"hp_call","d":"Create or test for objects of mode \"call\" (or\n\"(\", see Details).\n","ec":"call(name, ...)"},{"p":"base","o":"is.object","f":"hp_is.object","d":"A function mostly for internal use.  It returns TRUE if the\nobject x has the R internal OBJECT bit set, and\nFALSE otherwise.  The OBJECT bit is set when a\n\"class\" attribute is added and removed when that attribute is\nremoved, so this is a very efficient way to check if an object has a\nclass attribute.  (S4 objects always should.)\n","ec":"is.object(x)"},{"p":"base","o":"pos.to.env","f":"hp_pos.to.env","d":"Returns the environment at a specified position in the search path.\n","ec":"pos.to.env(x)"},{"p":"base","o":"as.POSIXlt.character","f":"hp_as.POSIXlt.character","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.character(x, tz = \"\", format, tryFormats = c(\"%Y-%m-%d %H:%M:%OS\", \"%Y/%m/%d %H:%M:%OS\", \"%Y-%m-%d %H:%M\", \"%Y/%m/%d %H:%M\", \"%Y-%m-%d\", \"%Y/%m/%d\"), optional = FALSE, ...)"},{"p":"base","o":"attributes<-","f":"hp_attributes..","d":"These functions access an object's attributes.\nThe first form below returns the object's attribute list.\nThe replacement forms uses the list on the right-hand\nside of the assignment as the object's attributes (if appropriate).\n","ec":"attributes<-(x, value)"},{"p":"base","o":"sweep","f":"hp_sweep","d":"Return an array obtained from an input array by sweeping out a summary\nstatistic.\n","ec":"sweep(x, MARGIN, STATS, FUN = \"-\", check.margin = TRUE, ...)"},{"p":"base","o":".C_R_removeTaskCallback","f":"hp_.C_R_removeTaskCallback","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":".libPaths","f":"hp_.libPaths","d":".libPaths gets/sets the library trees within which packages are\nlooked for.\n","ec":".libPaths(new, include.site = TRUE)"},{"p":"base","o":".getNamespaceInfo","f":"hp_.getNamespaceInfo","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":".getNamespaceInfo(ns, which)"},{"p":"base","o":"trunc.POSIXt","f":"hp_trunc.POSIXt","d":"Round or truncate date-time objects.\n","ec":"trunc.POSIXt(x, units = c(\"secs\", \"mins\", \"hours\", \"days\", \"months\", \"years\"), ...)"},{"p":"base","o":"encodeString","f":"hp_encodeString","d":"encodeString escapes the strings in a character vector in the\nsame way print.default does, and optionally fits the encoded\nstrings within a field width.\n","ec":"encodeString(x, width = 0L, quote = \"\", na.encode = TRUE, justify = c(\"left\", \"right\", \"centre\", \"none\"))"},{"p":"base","o":"trunc","f":"hp_trunc","d":"ceiling takes a single numeric argument x and returns a\nnumeric vector containing the smallest integers not less than the\ncorresponding elements of x.\n","ec":"trunc(x, ...)"},{"p":"base","o":"system.time","f":"hp_system.time","d":"Return CPU (and other) times that expr used.\n","ec":"system.time(expr, gcFirst = TRUE)"},{"p":"base","o":"all.equal.POSIXt","f":"hp_all.equal.POSIXt","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.POSIXt(target, current, ..., tolerance = 0.001, scale, check.tzone = TRUE)"},{"p":"base","o":"[.hexmode","f":"hp_X..hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"[.hexmode(x, i)"},{"p":"base","o":"bitwShiftR","f":"hp_bitwShiftR","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwShiftR(a, n)"},{"p":"base","o":"nrow","f":"hp_nrow","d":"nrow and ncol return the number of rows or columns\npresent in x.\nNCOL and NROW do the same treating a vector as\n1-column matrix, even a 0-length vector, compatibly with\nas.matrix() or cbind(), see the example.\n","ec":"nrow(x)"},{"p":"base","o":"bitwShiftL","f":"hp_bitwShiftL","d":"Logical operations on integer vectors with elements viewed as sets of bits.\n","ec":"bitwShiftL(a, n)"},{"p":"base","o":"print.restart","f":"hp_print.restart","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"print.restart(x, ...)"},{"p":"base","o":"RNGversion","f":"hp_RNGversion","d":".Random.seed is an integer vector, containing the random number\ngenerator (RNG) state for random number generation in R.  It\ncan be saved and restored, but should not be altered by the user.\n","ec":"RNGversion(vstr)"},{"p":"base","o":"sort.POSIXlt","f":"hp_sort.POSIXlt","d":"Sort (or order) a vector or factor (partially) into\nascending or descending order.  For ordering along more than one\nvariable, e.g., for sorting data frames, see order.\n","ec":"sort.POSIXlt(x, decreasing = FALSE, na.last = NA, ...)"},{"p":"base","o":"print.POSIXct","f":"hp_print.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"print.POSIXct(x, tz = \"\", usetz = TRUE, max = NULL, ...)"},{"p":"base","o":"[.table","f":"hp_X..table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"[.table(x, i, j, ..., drop = TRUE)"},{"p":"base","o":".S3method","f":"hp_.S3method","d":"Register S3 methods in R scripts.\n","ec":".S3method(generic, class, method)"},{"p":"base","o":"print.POSIXlt","f":"hp_print.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"print.POSIXlt(x, tz = \"\", usetz = TRUE, max = NULL, ...)"},{"p":"base","o":"withVisible","f":"hp_withVisible","d":"This function evaluates an expression, returning it in a two element list\ncontaining its value and a flag showing whether it would automatically print.\n","ec":"withVisible(x)"},{"p":"base","o":"file.create","f":"hp_file.create","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.create(..., showWarnings = TRUE)"},{"p":"base","o":"getHook","f":"hp_getHook","d":"These functions allow users to set actions to be taken before packages\nare attached/detached and namespaces are (un)loaded.\n","ec":"getHook(hookName)"},{"p":"base","o":"as.data.frame.list","f":"hp_as.data.frame.list","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.list(x, row.names = NULL, optional = FALSE, ..., cut.names = FALSE, col.names = names(x), fix.empty.names = TRUE, check.names = !optional, stringsAsFactors = FALSE)"},{"p":"base","o":"row.names.default","f":"hp_row.names.default","d":"All data frames have row names, a character vector of\nlength the number of rows with no duplicates nor missing values.\n","ec":"row.names.default(x)"},{"p":"base","o":"print.AsIs","f":"hp_print.AsIs","d":"Change the class of an object to indicate that it should be treated\n<U+2018>as is<U+2019>.\n","ec":"print.AsIs(x, ...)"},{"p":"base","o":"Filter","f":"hp_Filter","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Filter(f, x)"},{"p":"base","o":"options","f":"hp_options","d":"Allow the user to set and examine a variety of global options\nwhich affect the way in which R computes and displays its results.\n","ec":"options(...)"},{"p":"base","o":"single","f":"hp_single","d":"Create, coerce to or test for a double-precision vector.\n","ec":"single(length = 0L)"},{"p":"base","o":"attr.all.equal","f":"hp_attr.all.equal","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"attr.all.equal(target, current, ..., check.attributes = TRUE, check.names = TRUE)"},{"p":"base","o":"length<-.POSIXct","f":"hp_length...POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"length<-.POSIXct(x, value)"},{"p":"base","o":".primUntrace","f":"hp_.primUntrace","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".primUntrace(obj)"},{"p":"base","o":"factorial","f":"hp_factorial","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"factorial(x)"},{"p":"base","o":"lfactorial","f":"hp_lfactorial","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"lfactorial(x)"},{"p":"base","o":"length<-.POSIXlt","f":"hp_length...POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"length<-.POSIXlt(x, value)"},{"p":"base","o":"colnames","f":"hp_colnames","d":"Retrieve or set the row or column names of a matrix-like object.\n","ec":"colnames(x, do.NULL = TRUE, prefix = \"col\")"},{"p":"base","o":"dontCheck","f":"hp_dontCheck","d":"The dontCheck function is the same as identity, but \nis interpreted by R CMD check code analysis as a directive\nto suppress checking of x.  Currently this is only used by\ncheckFF(registration = TRUE)\nwhen checking the .NAME argument of foreign function calls.\n","ec":"dontCheck(x)"},{"p":"base","o":".Options","f":"hp_.Options","d":"Allow the user to set and examine a variety of global options\nwhich affect the way in which R computes and displays its results.\n","ec":""},{"p":"base","o":"all.equal.list","f":"hp_all.equal.list","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.list(target, current, ..., check.attributes = TRUE, use.names = TRUE)"},{"p":"base","o":"levels","f":"hp_levels","d":"levels provides access to the levels attribute of a variable.\nThe first form returns the value of the levels of its argument\nand the second sets the attribute.\n","ec":"levels(x)"},{"p":"base","o":".colMeans","f":"hp_.colMeans","d":"Form row and column sums and means for numeric arrays (or data frames).\n","ec":".colMeans(x, m, n, na.rm = FALSE)"},{"p":"base","o":"levels<-","f":"hp_levels..","d":"levels provides access to the levels attribute of a variable.\nThe first form returns the value of the levels of its argument\nand the second sets the attribute.\n","ec":"levels<-(x, value)"},{"p":"base","o":"labels","f":"hp_labels","d":"Find a suitable set of labels from an object for use in printing or\nplotting, for example.  A generic function.\n","ec":"labels(object, ...)"},{"p":"base","o":".dynLibs","f":"hp_.dynLibs","d":"Load the specified file of compiled code if it has not been loaded\nalready, or unloads it.\n","ec":".dynLibs(new)"},{"p":"base","o":"isatty","f":"hp_isatty","d":"Display aspects of connections.\n","ec":"isatty(con)"},{"p":"base","o":"file.remove","f":"hp_file.remove","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.remove(...)"},{"p":"base","o":"ordered","f":"hp_ordered","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"ordered(x = character(), ...)"},{"p":"base","o":"...length","f":"hp_...length","d":"... and ..1, ..2 etc are used to refer to\narguments passed down from a calling function.  These (and the\nfollowing) can only be used inside a function which has\n... among its formal arguments.\n","ec":"...length()"},{"p":"base","o":"exists","f":"hp_exists","d":"Look for an R object of the given name and possibly return it\n","ec":"exists(x, where = -1, envir = if (missing(frame)) as.environment(where) else sys.frame(frame), frame, mode = \"any\", inherits = TRUE)"},{"p":"base","o":"prettyNum","f":"hp_prettyNum","d":"formatC() formats numbers individually and flexibly using\nC style format specifications.\n","ec":"prettyNum(x, big.mark = \"\", big.interval = 3L, small.mark = \"\", small.interval = 5L, decimal.mark = getOption(\"OutDec\"), input.d.mark = decimal.mark, preserve.width = c(\"common\", \"individual\", \"none\"), zero.print = NULL, replace.zero = FALSE, drop0trailing = FALSE, is.cmplx = NA, ...)"},{"p":"base","o":"isRestart","f":"hp_isRestart","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"isRestart(x)"},{"p":"base","o":"setTimeLimit","f":"hp_setTimeLimit","d":"Functions to set CPU and/or elapsed time limits for top-level\ncomputations or the current session.\n","ec":"setTimeLimit(cpu = Inf, elapsed = Inf, transient = FALSE)"},{"p":"base","o":"names.POSIXlt","f":"hp_names.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"names.POSIXlt(x)"},{"p":"base","o":".__H__.cbind","f":"hp_.__H__.cbind","d":"The functions or variables listed here are no longer part of R as\nthey are no longer needed.\n","ec":".__H__.cbind(..., deparse.level = 1)"},{"p":"base","o":"list.dirs","f":"hp_list.dirs","d":"These functions produce a character vector of the names of files or\ndirectories in the named directory.\n","ec":"list.dirs(path = \".\", full.names = TRUE, recursive = TRUE)"},{"p":"base","o":"truncate","f":"hp_truncate","d":"Functions to re-position connections.\n","ec":"truncate(con, ...)"},{"p":"base","o":"formals<-","f":"hp_formals..","d":"Get or set the formal arguments of a function.\n","ec":"formals<-(fun, envir = environment(fun), value)"},{"p":"base","o":"Tailcall","f":"hp_Tailcall","d":"Tailcall and Exec allow writing more\nstack-space-efficient recursive functions in R.\n","ec":"Tailcall(FUN, ...)"},{"p":"base","o":"quarters","f":"hp_quarters","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"quarters(x, abbreviate)"},{"p":"base","o":".External","f":"hp_.External","d":"Functions to pass R objects to compiled C/C++ code that has been\nloaded into R.\n","ec":".External(.NAME, ..., PACKAGE)"},{"p":"base","o":"xtfrm.factor","f":"hp_xtfrm.factor","d":"A generic auxiliary function that produces a numeric vector which\nwill sort in the same order as x.\n","ec":"xtfrm.factor(x)"},{"p":"base","o":"oldClass","f":"hp_oldClass","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":"oldClass(x)"},{"p":"base","o":"as.function.default","f":"hp_as.function.default","d":"as.function is a generic function which is used to convert\nobjects to functions.\n","ec":"as.function.default(x, envir = parent.frame(), ...)"},{"p":"base","o":"chol","f":"hp_chol","d":"Compute the Cholesky factorization of a real symmetric\npositive-definite square matrix.\n","ec":"chol(x, ...)"},{"p":"base","o":"file.rename","f":"hp_file.rename","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.rename(from, to)"},{"p":"base","o":"loadedNamespaces","f":"hp_loadedNamespaces","d":"Functions to load and unload name spaces.\n","ec":"loadedNamespaces()"},{"p":"base","o":"all.equal.factor","f":"hp_all.equal.factor","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.factor(target, current, ..., check.attributes = TRUE)"},{"p":"base","o":".BaseNamespaceEnv","f":"hp_.BaseNamespaceEnv","d":"Get, set, test for and create environments.\n","ec":""},{"p":"base","o":"sort_by","f":"hp_sort_by","d":"Generic function to sort an object in the order determined by one or\nmore other objects, typically vectors. A method is defined for data\nframes to sort its rows (typically by one or more columns), and the\ndefault method handles vector-like objects.\n","ec":"sort_by(x, y, ...)"},{"p":"base","o":"truncate.connection","f":"hp_truncate.connection","d":"Functions to re-position connections.\n","ec":"truncate.connection(con, ...)"},{"p":"base","o":"is.finite","f":"hp_is.finite","d":"is.finite and is.infinite return a vector of the same\nlength as x, indicating which elements are finite (not infinite\nand not missing) or infinite.\n","ec":"is.finite(x)"},{"p":"base","o":"as.data.frame.numeric","f":"hp_as.data.frame.numeric","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.numeric(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"labels.default","f":"hp_labels.default","d":"Find a suitable set of labels from an object for use in printing or\nplotting, for example.  A generic function.\n","ec":"labels.default(object, ...)"},{"p":"base","o":"strwrap","f":"hp_strwrap","d":"Each character string in the input is first split into paragraphs (or\nlines containing whitespace only).  The paragraphs are then formatted\nby breaking lines at word boundaries.  The target columns for wrapping\nlines and the indentation of the first and all subsequent lines of a\nparagraph can be controlled independently.\n","ec":"strwrap(x, width = 0.9 * getOption(\"width\"), indent = 0, exdent = 0, prefix = \"\", simplify = TRUE, initial = prefix)"},{"p":"base","o":".Internal","f":"hp_.Internal","d":".Internal performs a call to an internal code\nwhich is built in to the R interpreter.\n","ec":".Internal(call)"},{"p":"base","o":"tolower","f":"hp_tolower","d":"Translate characters in character vectors, in particular from upper to\nlower case or vice versa.\n","ec":"tolower(x)"},{"p":"base","o":"gzfile","f":"hp_gzfile","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"gzfile(description, open = \"\", encoding = getOption(\"encoding\"), compression = 6)"},{"p":"base","o":".Fortran","f":"hp_.Fortran","d":"Functions to make calls to compiled code that has been loaded into R.\n","ec":".Fortran(.NAME, ..., NAOK = FALSE, DUP = TRUE, PACKAGE, ENCODING)"},{"p":"base","o":"last.warning","f":"hp_last.warning","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":""},{"p":"base","o":"as.character.numeric_version","f":"hp_as.character.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"as.character.numeric_version(x, ...)"},{"p":"base","o":"env.profile","f":"hp_env.profile","d":"Get, set, test for and create environments.\n","ec":"env.profile(env)"},{"p":"base","o":"is.na","f":"hp_is.na","d":"NA is a logical constant of length 1 which contains a missing\nvalue indicator.  NA can be coerced to any other vector\ntype except raw.  There are also constants NA_integer_,\nNA_real_, NA_complex_ and NA_character_ of the\nother atomic vector types which support missing values: all of these\nare reserved words in the R language.\n","ec":"is.na(x)"},{"p":"base","o":"Summary.POSIXct","f":"hp_Summary.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"Summary.POSIXct(..., na.rm, finite = FALSE)"},{"p":"base","o":"open.connection","f":"hp_open.connection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"open.connection(con, open = \"r\", blocking = TRUE, ...)"},{"p":"base","o":"is.qr","f":"hp_is.qr","d":"qr computes the QR decomposition of a matrix.\n","ec":"is.qr(x)"},{"p":"base","o":"list2DF","f":"hp_list2DF","d":"Create a data frame from a list of variables.\n","ec":"list2DF(x = list(), nrow = 0L)"},{"p":"base","o":"duplicated","f":"hp_duplicated","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"duplicated(x, incomparables = FALSE, ...)"},{"p":"base","o":"writeBin","f":"hp_writeBin","d":"Read binary data from or write binary data to a connection or raw vector.\n","ec":"writeBin(object, con, size = NA_integer_, endian = .Platform$endian, useBytes = FALSE)"},{"p":"base","o":"flush.connection","f":"hp_flush.connection","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"flush.connection(con)"},{"p":"base","o":"rcond","f":"hp_rcond","d":"The condition number of a regular (square) matrix is the product of\nthe norm of the matrix and the norm of its inverse (or\npseudo-inverse), and hence depends on the kind of matrix-norm.\n","ec":"rcond(x, norm = c(\"O\", \"I\", \"1\"), triangular = FALSE, uplo = \"U\", ...)"},{"p":"base","o":"is.ordered","f":"hp_is.ordered","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"is.ordered(x)"},{"p":"base","o":"/.difftime","f":"hp_X..difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"/.difftime(e1, e2)"},{"p":"base","o":"isSeekable","f":"hp_isSeekable","d":"Functions to re-position connections.\n","ec":"isSeekable(con)"},{"p":"base","o":"as.ordered","f":"hp_as.ordered","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"as.ordered(x)"},{"p":"base","o":"[.simple.list","f":"hp_X..simple.list","d":"Operators acting on vectors, matrices, arrays and lists to extract or\nreplace parts.\n","ec":"[.simple.list(x, i, ...)"},{"p":"base","o":"iconv","f":"hp_iconv","d":"This uses system facilities to convert a character vector between\nencodings: the <U+2018>i<U+2019> stands for <U+2018>internationalization<U+2019>.\n","ec":"iconv(x, from = \"\", to = \"\", sub = NA, mark = TRUE, toRaw = FALSE)"},{"p":"base","o":"tempdir","f":"hp_tempdir","d":"tempfile returns a vector of character strings which can be used as\nnames for temporary files.\n","ec":"tempdir(check = FALSE)"},{"p":"base","o":"Summary.POSIXlt","f":"hp_Summary.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"Summary.POSIXlt(..., na.rm, finite = FALSE)"},{"p":"base","o":"is.numeric.difftime","f":"hp_is.numeric.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"is.numeric.difftime(x)"},{"p":"base","o":"print.octmode","f":"hp_print.octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"print.octmode(x, ...)"},{"p":"base","o":"summary.proc_time","f":"hp_summary.proc_time","d":"proc.time determines how much real and CPU time (in seconds)\nthe currently running R process has already taken.\n","ec":"summary.proc_time(object, ...)"},{"p":"base","o":"chol2inv","f":"hp_chol2inv","d":"Invert a symmetric, positive definite square matrix from its Cholesky\ndecomposition.  Equivalently, compute (X'X)^{-1}\nfrom the (R part) of the QR decomposition of X.\n","ec":"chol2inv(x, size = NCOL(x), LINPACK = FALSE)"},{"p":"base","o":"as.character.Date","f":"hp_as.character.Date","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.character.Date(x, ...)"},{"p":"base","o":".sys.timezone","f":"hp_.sys.timezone","d":"-NA-","ec":"-NA-"},{"p":"base","o":"$.package_version","f":"hp_X..package_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"$.package_version(x, name)"},{"p":"base","o":"Sys.timezone","f":"hp_Sys.timezone","d":"Information about time zones in R.  Sys.timezone returns\nthe name of the current time zone.\n","ec":"Sys.timezone(location = TRUE)"},{"p":"base","o":"quarters.Date","f":"hp_quarters.Date","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"quarters.Date(x, ...)"},{"p":"base","o":"stopifnot","f":"hp_stopifnot","d":"If any of the expressions (in ... or exprs) are not\nall TRUE, stop is called, producing\nan error message indicating the first expression which was not\n(all) true.\n","ec":"stopifnot(..., exprs, exprObject, local = TRUE)"},{"p":"base","o":"as.data.frame.complex","f":"hp_as.data.frame.complex","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.complex(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"all.equal.function","f":"hp_all.equal.function","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.function(target, current, check.environment = TRUE, ...)"},{"p":"base","o":"packBits","f":"hp_packBits","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"packBits(x, type = c(\"raw\", \"integer\", \"double\"))"},{"p":"base","o":"c.POSIXct","f":"hp_c.POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"c.POSIXct(..., recursive = FALSE)"},{"p":"base","o":"rep.difftime","f":"hp_rep.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"rep.difftime(x, ...)"},{"p":"base","o":"strrep","f":"hp_strrep","d":"Repeat the character strings in a character vector a given number of\ntimes (i.e., concatenate the respective numbers of copies of the\nstrings).\n","ec":"strrep(x, times)"},{"p":"base","o":"force","f":"hp_force","d":"Forces the evaluation of a function argument.\n","ec":"force(x)"},{"p":"base","o":"c.POSIXlt","f":"hp_c.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"c.POSIXlt(..., recursive = FALSE)"},{"p":"base","o":"[<-.numeric_version","f":"hp_X....numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"[<-.numeric_version(x, i, j, value)"},{"p":"base","o":"mem.maxNSize","f":"hp_mem.maxNSize","d":"Query and set the maximal size of the vector heap and the maximal\nnumber of heap nodes for the current R process.\n","ec":"mem.maxNSize(nsize = 0)"},{"p":"base","o":"format","f":"hp_format","d":"Format an R object for pretty printing.\n","ec":"format(x, ...)"},{"p":"base","o":"NextMethod","f":"hp_NextMethod","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class(es) of the first argument to the generic function or of\nthe object supplied as an argument to UseMethod or NextMethod.\n","ec":"NextMethod(generic = NULL, object = NULL, ...)"},{"p":"base","o":"..deparseOpts","f":"hp_..deparseOpts","d":"Process the deparsing options for deparse, dput and\ndump.\n","ec":""},{"p":"base","o":".TAOCP1997init","f":"hp_.TAOCP1997init","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".TAOCP1997init(seed)"},{"p":"base","o":"Vectorize","f":"hp_Vectorize","d":"Vectorize creates a function wrapper that vectorizes the\naction of its argument FUN.\n","ec":"Vectorize(FUN, vectorize.args = arg.names, SIMPLIFY = TRUE, USE.NAMES = TRUE)"},{"p":"base","o":"getNamespaceUsers","f":"hp_getNamespaceUsers","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespaceUsers(ns)"},{"p":"base","o":"cosh","f":"hp_cosh","d":"These functions give the obvious hyperbolic functions.  They\nrespectively compute the hyperbolic cosine, sine, tangent, and their\ninverses, arc-cosine, arc-sine, arc-tangent (or <U+2018>area cosine<U+2019>,\netc).\n","ec":"cosh(x)"},{"p":"base","o":"open","f":"hp_open","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"open(con, ...)"},{"p":"base","o":"qr.qty","f":"hp_qr.qty","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.qty(qr, y)"},{"p":"base","o":"subset","f":"hp_subset","d":"Return subsets of vectors, matrices or data frames which meet conditions.\n","ec":"subset(x, ...)"},{"p":"base","o":"print.summary.table","f":"hp_print.summary.table","d":"table uses cross-classifying factors to build a contingency\ntable of the counts at each combination of factor levels.\n","ec":"print.summary.table(x, digits = max(1L, getOption(\"digits\") - 3L), ...)"},{"p":"base","o":"is.infinite.POSIXlt","f":"hp_is.infinite.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"is.infinite.POSIXlt(x)"},{"p":"base","o":"substr","f":"hp_substr","d":"Extract or replace substrings in a character vector.\n","ec":"substr(x, start, stop)"},{"p":"base","o":"cospi","f":"hp_cospi","d":"These functions give the obvious trigonometric functions.  They\nrespectively compute the cosine, sine, tangent, arc-cosine, arc-sine,\narc-tangent, and the two-argument arc-tangent.\n","ec":"cospi(x)"},{"p":"base","o":"[[<-.numeric_version","f":"hp_X.....numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"[[<-.numeric_version(x, ..., value)"},{"p":"base","o":"c.warnings","f":"hp_c.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"c.warnings(..., recursive = FALSE)"},{"p":"base","o":"[.warnings","f":"hp_X..warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"[.warnings(x, ...)"},{"p":"base","o":"print.packageInfo","f":"hp_print.packageInfo","d":"library and require load and attach add-on packages.\n","ec":"print.packageInfo(x, ...)"},{"p":"base","o":"NCOL","f":"hp_NCOL","d":"nrow and ncol return the number of rows or columns\npresent in x.\nNCOL and NROW do the same treating a vector as\n1-column matrix, even a 0-length vector, compatibly with\nas.matrix() or cbind(), see the example.\n","ec":"NCOL(x)"},{"p":"base","o":"is.numeric","f":"hp_is.numeric","d":"Creates or coerces objects of type \"numeric\".\nis.numeric is a more general test of an object being\ninterpretable as numbers.\n","ec":"is.numeric(x)"},{"p":"base","o":"strtoi","f":"hp_strtoi","d":"Convert strings to integers according to the given base using the C\nfunction strtol, or choose a suitable base following the C rules.\n","ec":"strtoi(x, base = 0L)"},{"p":"base","o":".GenericArgsEnv","f":"hp_.GenericArgsEnv","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"rep_len","f":"hp_rep_len","d":"rep replicates the values in x.  It is a generic\nfunction, and the (internal) default method is described here.\n","ec":"rep_len(x, length.out)"},{"p":"base","o":".make_numeric_version","f":"hp_.make_numeric_version","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".make_numeric_version(x, strict = TRUE, regexp, classes = NULL)"},{"p":"base","o":"date","f":"hp_date","d":"Returns a character string of the current system date and time.\n","ec":"date()"},{"p":"base","o":"names<-","f":"hp_names..","d":"Functions to get or set the names of an object.\n","ec":"names<-(x, value)"},{"p":"base","o":"closeAllConnections","f":"hp_closeAllConnections","d":"Display aspects of connections.\n","ec":"closeAllConnections()"},{"p":"base","o":"as.logical","f":"hp_as.logical","d":"Create or test for objects of type \"logical\", and the basic\nlogical constants.\n","ec":"as.logical(x, ...)"},{"p":"base","o":"getDLLRegisteredRoutines","f":"hp_getDLLRegisteredRoutines","d":"This function allows us to query the set of routines\nin a DLL that are registered with R to enhance\ndynamic lookup, error handling when calling native routines,\nand potentially security in the future.\nThis function provides a description of each of the\nregistered routines in the DLL for the different interfaces,\ni.e. .C, .Call, .Fortran\nand .External.\n","ec":"getDLLRegisteredRoutines(dll, addNames = TRUE)"},{"p":"base","o":"round","f":"hp_round","d":"ceiling takes a single numeric argument x and returns a\nnumeric vector containing the smallest integers not less than the\ncorresponding elements of x.\n","ec":"round(x, digits = 0, ...)"},{"p":"base","o":"file.exists","f":"hp_file.exists","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.exists(...)"},{"p":"base","o":".F_dtrco","f":"hp_.F_dtrco","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":""},{"p":"base","o":"polyroot","f":"hp_polyroot","d":"Find zeros of a real or complex polynomial.\n","ec":"polyroot(z)"},{"p":"base","o":".kronecker","f":"hp_.kronecker","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".kronecker(X, Y, FUN = \"*\", make.dimnames = FALSE, ...)"},{"p":"base","o":".traceback","f":"hp_.traceback","d":"By default traceback() prints the call stack of the last\nuncaught error, i.e., the sequence of calls that lead to the error.\nThis is useful when an error occurs with an unidentifiable error\nmessage.  It can also be used to print the current stack or\narbitrary lists of calls.\n","ec":".traceback(x = NULL, max.lines = getOption(\"traceback.max.lines\", getOption(\"deparse.max.lines\", -1L)))"},{"p":"base","o":"browser","f":"hp_browser","d":"Interrupt the execution of an expression and allow the inspection of\nthe environment where browser was called from.\n","ec":"browser(text = \"\", condition = NULL, expr = TRUE, skipCalls = 0L)"},{"p":"base","o":"conflictRules","f":"hp_conflictRules","d":"library and require load and attach add-on packages.\n","ec":"conflictRules(pkg, mask.ok = NULL, exclude = NULL)"},{"p":"base","o":"is.double","f":"hp_is.double","d":"Create, coerce to or test for a double-precision vector.\n","ec":"is.double(x)"},{"p":"base","o":"months","f":"hp_months","d":"Extract the weekday, month or quarter, or the Julian time\n(days since some origin).  These are generic functions: the methods\nfor the internal date-time classes are documented here.\n","ec":"months(x, abbreviate)"},{"p":"base","o":"toupper","f":"hp_toupper","d":"Translate characters in character vectors, in particular from upper to\nlower case or vice versa.\n","ec":"toupper(x)"},{"p":"base","o":"duplicated.default","f":"hp_duplicated.default","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"duplicated.default(x, incomparables = FALSE, fromLast = FALSE, nmax = NA, ...)"},{"p":"base","o":".bincode","f":"hp_.bincode","d":"Bin a numeric vector and return integer codes for the binning.\n","ec":".bincode(x, breaks, right = TRUE, include.lowest = FALSE)"},{"p":"base","o":"qr.resid","f":"hp_qr.resid","d":"qr computes the QR decomposition of a matrix.\n","ec":"qr.resid(qr, y)"},{"p":"base","o":"toString","f":"hp_toString","d":"This is a helper function for format to produce a single\ncharacter string describing an R object.\n","ec":"toString(x, ...)"},{"p":"base","o":"socketSelect","f":"hp_socketSelect","d":"Waits for the first of several socket connections and server sockets\nto become available.\n","ec":"socketSelect(socklist, write = FALSE, timeout = NULL)"},{"p":"base","o":".class2","f":"hp_.class2","d":"R possesses a simple generic function mechanism which can be used for\nan object-oriented style of programming.  Method dispatch takes place\nbased on the class of the first argument to the generic function.\n","ec":".class2(x)"},{"p":"base","o":"print.libraryIQR","f":"hp_print.libraryIQR","d":"library and require load and attach add-on packages.\n","ec":"print.libraryIQR(x, ...)"},{"p":"base","o":"prop.table","f":"hp_prop.table","d":"Returns conditional proportions given margins, i.e.,\nentries of x, divided by the appropriate marginal sums.\n","ec":"prop.table(x, margin = NULL)"},{"p":"base","o":"new.env","f":"hp_new.env","d":"Get, set, test for and create environments.\n","ec":"new.env(hash = TRUE, parent = parent.frame(), size = 29L)"},{"p":"base","o":"which","f":"hp_which","d":"Give the TRUE indices of a logical object, allowing for array\nindices.\n","ec":"which(x, arr.ind = FALSE, useNames = TRUE)"},{"p":"base","o":"duplicated.numeric_version","f":"hp_duplicated.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"duplicated.numeric_version(x, incomparables = FALSE, ...)"},{"p":"base","o":"while","f":"hp_while.","d":"These are the basic control-flow constructs of the R language.  They\nfunction in much the same way as control statements in any Algol-like\nlanguage.  They are all reserved words.\n","ec":""},{"p":"base","o":"is.element","f":"hp_is.element","d":"Performs set union, intersection, (asymmetric!) difference,\nequality and membership on two vectors.\n","ec":"is.element(el, set)"},{"p":"base","o":"as.raw","f":"hp_as.raw","d":"Creates or tests for objects of type \"raw\".\n","ec":"as.raw(x)"},{"p":"base","o":"nzchar","f":"hp_nzchar","d":"nchar takes a character vector as an argument and\nreturns a vector whose elements contain the sizes of\nthe corresponding elements of x. Internally, it is a generic,\nfor which methods can be defined (see InternalMethods).\n","ec":"nzchar(x, keepNA = FALSE)"},{"p":"base","o":"replace","f":"hp_replace","d":"replace replaces the values in x\nwith indices given in list by those given in values.\nIf necessary, the values in values are recycled.\n","ec":"replace(x, list, values)"},{"p":"base","o":"complex","f":"hp_complex","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"complex(length.out = 0L, real = numeric(), imaginary = numeric(), modulus = 1, argument = 0)"},{"p":"base","o":"dget","f":"hp_dget","d":"Writes an ASCII text representation of an R object to a file, the R\nconsole, or a connection, or uses one to recreate the object.\n","ec":"dget(file, keep.source = FALSE)"},{"p":"base","o":"environmentIsLocked","f":"hp_environmentIsLocked","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"environmentIsLocked(env)"},{"p":"base","o":".Deprecated","f":"hp_.Deprecated","d":"When an object is about to be removed from R it is first deprecated and\nshould include a call to .Deprecated.\n","ec":".Deprecated(new, package = NULL, msg, old = as.character(sys.call(sys.parent()))[1L])"},{"p":"base","o":"alist","f":"hp_alist","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"alist(...)"},{"p":"base","o":"is.list","f":"hp_is.list","d":"Functions to construct, coerce and check for both kinds of R lists.\n","ec":"is.list(x)"},{"p":"base","o":"Ops.factor","f":"hp_Ops.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"Ops.factor(e1, e2)"},{"p":"base","o":"setdiff","f":"hp_setdiff","d":"Performs set union, intersection, (asymmetric!) difference,\nequality and membership on two vectors.\n","ec":"setdiff(x, y)"},{"p":"base","o":"pmin.int","f":"hp_pmin.int","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"pmin.int(..., na.rm = FALSE)"},{"p":"base","o":"slice.index","f":"hp_slice.index","d":"Returns a matrix of integers indicating the number of their slice in a\ngiven array.\n","ec":"slice.index(x, MARGIN)"},{"p":"base","o":"getAllConnections","f":"hp_getAllConnections","d":"Display aspects of connections.\n","ec":"getAllConnections()"},{"p":"base","o":"duplicated.warnings","f":"hp_duplicated.warnings","d":"warnings and its print method print the\nvariable last.warning in a pleasing form.\n","ec":"duplicated.warnings(x, incomparables = FALSE, ...)"},{"p":"base","o":"numeric_version","f":"hp_numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"numeric_version(x, strict = TRUE)"},{"p":"base","o":"ceiling","f":"hp_ceiling","d":"ceiling takes a single numeric argument x and returns a\nnumeric vector containing the smallest integers not less than the\ncorresponding elements of x.\n","ec":"ceiling(x)"},{"p":"base","o":"diag","f":"hp_diag","d":"Extract or replace the diagonal of a matrix,\nor construct a diagonal matrix.\n","ec":"diag(x = 1, nrow, ncol, names = TRUE)"},{"p":"base","o":"as.complex","f":"hp_as.complex","d":"Basic functions which support complex arithmetic in R, in addition to\nthe arithmetic operators +, -, *, /, and ^.\n","ec":"as.complex(x, ...)"},{"p":"base","o":"sequence","f":"hp_sequence","d":"The default method for sequence generates the sequence\nseq(from[i], by = by[i], length.out = nvec[i]) for each\nelement i in the parallel (and recycled) vectors from,\nby and nvec. It then returns the result of concatenating\nthose sequences.\n","ec":"sequence(nvec, ...)"},{"p":"base","o":".check_tzones","f":"hp_.check_tzones","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".check_tzones(...)"},{"p":"base","o":"diff","f":"hp_diff","d":"Returns suitably lagged and iterated differences.\n","ec":"diff(x, ...)"},{"p":"base","o":".doSortWrap","f":"hp_.doSortWrap","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".doSortWrap(vec, decr, nalast, noNA = NA)"},{"p":"base","o":"anyDuplicated","f":"hp_anyDuplicated","d":"duplicated() determines which elements of a vector or data\nframe are duplicates\nof elements with smaller subscripts, and returns a logical vector\nindicating which elements (rows) are duplicates.\n","ec":"anyDuplicated(x, incomparables = FALSE, ...)"},{"p":"base","o":"all.equal.environment","f":"hp_all.equal.environment","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal.environment(target, current, all.names = TRUE, evaluate = TRUE, ...)"},{"p":"base","o":"pipe","f":"hp_pipe","d":"Functions to create, open and close connections, i.e.,\n<U+201C>generalized files<U+201D>, such as possibly compressed files, URLs,\npipes, etc.\n","ec":"pipe(description, open = \"\", encoding = getOption(\"encoding\"))"},{"p":"base","o":"ISOdatetime","f":"hp_ISOdatetime","d":"Convenience wrappers to create date-times from numeric representations.\n","ec":"ISOdatetime(year, month, day, hour, min, sec, tz = \"\")"},{"p":"base","o":"replicate","f":"hp_replicate","d":"lapply returns a list of the same length as X, each\nelement of which is the result of applying FUN to the\ncorresponding element of X.\n","ec":"replicate(n, expr, simplify = \"array\")"},{"p":"base","o":"rbind.data.frame","f":"hp_rbind.data.frame","d":"Take a sequence of vector, matrix or data-frame arguments and combine\nby columns or rows, respectively.  These are generic\nfunctions with methods for other R classes.\n","ec":"rbind.data.frame(..., deparse.level = 1, make.row.names = TRUE, stringsAsFactors = FALSE, factor.exclude = TRUE)"},{"p":"base","o":"lazyLoadDBfetch","f":"hp_lazyLoadDBfetch","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":"lazyLoadDBfetch(key, file, compressed, hook)"},{"p":"base","o":"conflicts","f":"hp_conflicts","d":"conflicts reports on objects that exist with the same name in\ntwo or more places on the search path, usually because\nan object in the user's workspace or a package is masking a system\nobject of the same name.  This helps discover unintentional masking.\n","ec":"conflicts(where = search(), detail = FALSE)"},{"p":"base","o":".rmpkg","f":"hp_.rmpkg","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":".rmpkg(pkg)"},{"p":"base","o":"as.Date","f":"hp_as.Date","d":"Functions to convert between character representations and objects of\nclass \"Date\" representing calendar dates.\n","ec":"as.Date(x, ...)"},{"p":"base","o":"as.data.frame.numeric_version","f":"hp_as.data.frame.numeric_version","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.numeric_version(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"mean.default","f":"hp_mean.default","d":"Generic function for the (trimmed) arithmetic mean.\n","ec":"mean.default(x, trim = 0, na.rm = FALSE, ...)"},{"p":"base","o":"cumprod","f":"hp_cumprod","d":"Returns a vector whose elements are the cumulative sums, products,\nminima or maxima of the elements of the argument.\n","ec":"cumprod(x)"},{"p":"base","o":"as.double","f":"hp_as.double","d":"Create, coerce to or test for a double-precision vector.\n","ec":"as.double(x, ...)"},{"p":"base","o":"mtfrm.POSIXct","f":"hp_mtfrm.POSIXct","d":"Transform objects for matching via match(), think\n<U+201C>match form<U+201D> -> \"mtfrm\".\nbase provides the S3 generic and a default plus\n\"POSIXct\" and \"POSIXlt\" methods.\n","ec":"mtfrm.POSIXct(x)"},{"p":"base","o":"as.data.frame.logical","f":"hp_as.data.frame.logical","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.logical(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"as.data.frame.POSIXct","f":"hp_as.data.frame.POSIXct","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.POSIXct(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"findRestart","f":"hp_findRestart","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"findRestart(name, cond = NULL)"},{"p":"base","o":"mtfrm.POSIXlt","f":"hp_mtfrm.POSIXlt","d":"Transform objects for matching via match(), think\n<U+201C>match form<U+201D> -> \"mtfrm\".\nbase provides the S3 generic and a default plus\n\"POSIXct\" and \"POSIXlt\" methods.\n","ec":"mtfrm.POSIXlt(x)"},{"p":"base","o":"as.data.frame.POSIXlt","f":"hp_as.data.frame.POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"as.data.frame.POSIXlt(x, row.names = NULL, optional = FALSE, ...)"},{"p":"base","o":"as.data.frame.ts","f":"hp_as.data.frame.ts","d":"Functions to check if an object is a data frame, or coerce it if possible.\n","ec":"as.data.frame.ts(x, ...)"},{"p":"base","o":"findPackageEnv","f":"hp_findPackageEnv","d":"Internal objects in the base package most of which are only user-visible\nbecause of the special nature of the base namespace.\n","ec":"findPackageEnv(info)"},{"p":"base","o":"plot","f":"hp_plot","d":"Generic function for plotting of R objects.\n","ec":"plot(x, y, ...)"},{"p":"base","o":"pmax","f":"hp_pmax","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"pmax(..., na.rm = FALSE)"},{"p":"base","o":"getNamespaceImports","f":"hp_getNamespaceImports","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespaceImports(ns)"},{"p":"base","o":"as.numeric_version","f":"hp_as.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"as.numeric_version(x)"},{"p":"base","o":"pmin","f":"hp_pmin","d":"Returns the (regular or parallel) maxima and minima of the\ninput values.\n","ec":"pmin(..., na.rm = FALSE)"},{"p":"base","o":"as.character.srcref","f":"hp_as.character.srcref","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"as.character.srcref(x, useSource = TRUE, to = x, ...)"},{"p":"base","o":"trunc.Date","f":"hp_trunc.Date","d":"Round or truncate date-time objects.\n","ec":"trunc.Date(x, units = c(\"secs\", \"mins\", \"hours\", \"days\", \"months\", \"years\"), ...)"},{"p":"base","o":"print.hexmode","f":"hp_print.hexmode","d":"Integers which are displayed in hexadecimal (short <U+2018>hex<U+2019>) format,\nwith as many digits as are needed to display the largest, using leading\nzeroes as necessary.\n","ec":"print.hexmode(x, ...)"},{"p":"base","o":"provideDimnames","f":"hp_provideDimnames","d":"Retrieve or set the dimnames of an object.\n","ec":"provideDimnames(x, sep = \"\", base = list(LETTERS), unique = TRUE)"},{"p":"base","o":"match.arg","f":"hp_match.arg","d":"match.arg matches a character arg against a table of\ncandidate values as specified by choices.\n","ec":"match.arg(arg, choices, several.ok = FALSE)"},{"p":"base","o":"enquote","f":"hp_enquote","d":"substitute returns the parse tree for the (unevaluated)\nexpression expr, substituting any variables bound in\nenv.\n","ec":"enquote(cl)"},{"p":"base","o":"file.path","f":"hp_file.path","d":"Construct the path to a file from components in a platform-independent\nway.\n","ec":"file.path(..., fsep = .Platform$file.sep)"},{"p":"base","o":"as.character.condition","f":"hp_as.character.condition","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":"as.character.condition(x, ...)"},{"p":"base","o":".Platform","f":"hp_.Platform","d":".Platform is a list with some details of the platform under\nwhich R was built.  This provides means to write OS-portable R\ncode.\n","ec":""},{"p":"base","o":"|.octmode","f":"hp_X..octmode","d":"Integers which are displayed in octal (base-8 number system) format, with as\nmany digits as are needed to display the largest, using leading zeroes as\nnecessary.\n","ec":"|.octmode(a, b)"},{"p":"base","o":"memDecompress","f":"hp_memDecompress","d":"In-memory compression or decompression for raw vectors.\n","ec":"memDecompress(from, type = c(\"unknown\", \"gzip\", \"bzip2\", \"xz\", \"none\"), asChar = FALSE)"},{"p":"base","o":"activeBindingFunction","f":"hp_activeBindingFunction","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"activeBindingFunction(sym, env)"},{"p":"base","o":"format.data.frame","f":"hp_format.data.frame","d":"Format an R object for pretty printing.\n","ec":"format.data.frame(x, ..., justify = \"none\")"},{"p":"base","o":"unCfillPOSIXlt","f":"hp_unCfillPOSIXlt","d":"Utilities to <U+2018>balance<U+2019> objects of class \"POSIXlt\".\n","ec":"unCfillPOSIXlt(x)"},{"p":"base","o":"lazyLoad","f":"hp_lazyLoad","d":"Internal functions to lazy load a database of R objects.\n","ec":"lazyLoad(filebase, envir = parent.frame(), filter)"},{"p":"base","o":"srcref","f":"hp_srcref","d":"These functions are for working with source files and more generally\nwith <U+201C>source references<U+201D> (\"srcref\"), i.e., references to\nsource code.  The resulting data is used for printing and source level\ndebugging, and is typically available in interactive R sessions,\nnamely when options(keep.source = TRUE).\n","ec":"srcref(srcfile, lloc)"},{"p":"base","o":"as.POSIXlt.factor","f":"hp_as.POSIXlt.factor","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXlt.factor(x, ...)"},{"p":"base","o":"t.default","f":"hp_t.default","d":"Given a matrix or data.frame x,\nt returns the transpose of x.\n","ec":"t.default(x)"},{"p":"base","o":"warning","f":"hp_warning","d":"Generates a warning message that corresponds to its argument(s) and\n(optionally) the expression or function from which it was called.\n","ec":"warning(..., call. = TRUE, immediate. = FALSE, noBreaks. = FALSE, domain = NULL)"},{"p":"base","o":".__S3MethodsTable__.","f":"hp_.__S3MethodsTable__.","d":"Internal namespace support functions.  Not intended to be called\ndirectly, and only visible because of the special nature of the\nbase namespace.\n","ec":""},{"p":"base","o":"substring","f":"hp_substring","d":"Extract or replace substrings in a character vector.\n","ec":"substring(text, first, last = 1000000L)"},{"p":"base","o":"commandArgs","f":"hp_commandArgs","d":"Provides access to a copy of the command line arguments supplied when\nthis R session was invoked.\n","ec":"commandArgs(trailingOnly = FALSE)"},{"p":"base","o":"[[.numeric_version","f":"hp_X...numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"[[.numeric_version(x, ..., exact = NA)"},{"p":"base","o":"file.symlink","f":"hp_file.symlink","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.symlink(from, to)"},{"p":"base","o":"[.DLLInfoList","f":"hp_X..DLLInfoList","d":"This function provides a way to get a list of all the DLLs (see\ndyn.load) that are currently loaded in the R session.\n","ec":"[.DLLInfoList(x, ...)"},{"p":"base","o":"getCallingDLLe","f":"hp_getCallingDLLe","d":"This is an internal function that is called from R's C code to\ndetermine the enclosing namespace of a\n.C/.Call/.Fortran/.External call which has\nno PACKAGE argument. If the call has been made from a function\nwithin a namespace, then we can find the DLL associated with that\nnamespace.  The purpose of this is to avoid having to use the\nPACKAGE argument in these native calls and so better support\nversions of packages.\n","ec":"getCallingDLLe(e)"},{"p":"base","o":"Summary.difftime","f":"hp_Summary.difftime","d":"Time intervals creation, printing, and some arithmetic.  The\nprint() method calls these <U+201C>time differences<U+201D>.\n","ec":"Summary.difftime(..., na.rm)"},{"p":"base","o":"NROW","f":"hp_NROW","d":"nrow and ncol return the number of rows or columns\npresent in x.\nNCOL and NROW do the same treating a vector as\n1-column matrix, even a 0-length vector, compatibly with\nas.matrix() or cbind(), see the example.\n","ec":"NROW(x)"},{"p":"base","o":"match.fun","f":"hp_match.fun","d":"When called inside functions that take a function as argument, extract\nthe desired function object while avoiding undesired matching to\nobjects of other types.\n","ec":"match.fun(FUN, descend = TRUE)"},{"p":"base","o":"dput","f":"hp_dput","d":"Writes an ASCII text representation of an R object to a file, the R\nconsole, or a connection, or uses one to recreate the object.\n","ec":"dput(x, file = \"\", control = c(\"keepNA\", \"keepInteger\", \"niceNames\", \"showAttributes\"))"},{"p":"base","o":"tempfile","f":"hp_tempfile","d":"tempfile returns a vector of character strings which can be used as\nnames for temporary files.\n","ec":"tempfile(pattern = \"file\", tmpdir = tempdir(), fileext = \"\")"},{"p":"base","o":"...elt","f":"hp_...elt","d":"... and ..1, ..2 etc are used to refer to\narguments passed down from a calling function.  These (and the\nfollowing) can only be used inside a function which has\n... among its formal arguments.\n","ec":"...elt(n)"},{"p":"base","o":"print.by","f":"hp_print.by","d":"Function by is an object-oriented wrapper for\ntapply applied to data frames.\n","ec":"print.by(x, ..., vsep)"},{"p":"base","o":"summary.matrix","f":"hp_summary.matrix","d":"summary is a generic function used to produce result summaries\nof the results of various model fitting functions.  The function\ninvokes particular methods which depend on the\nclass of the first argument.\n","ec":"summary.matrix(object, ...)"},{"p":"base","o":"...names","f":"hp_...names","d":"... and ..1, ..2 etc are used to refer to\narguments passed down from a calling function.  These (and the\nfollowing) can only be used inside a function which has\n... among its formal arguments.\n","ec":"...names()"},{"p":"base","o":"Summary.ordered","f":"hp_Summary.ordered","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"Summary.ordered(..., na.rm)"},{"p":"base","o":".Script","f":"hp_.Script","d":"Internal interface to run a script through its interpreter.\n","ec":".Script(interpreter, script, args, ...)"},{"p":"base","o":"mode<-","f":"hp_mode..","d":"Get or set the <U+2018>mode<U+2019> (a kind of <U+2018>type<U+2019>), or the storage\nmode of an R object.\n","ec":"mode<-(x, value)"},{"p":"base","o":"La.svd","f":"hp_La.svd","d":"Compute the singular-value decomposition of a rectangular matrix.\n","ec":"La.svd(x, nu = min(n, p), nv = min(n, p))"},{"p":"base","o":"rawConnection","f":"hp_rawConnection","d":"Input and output raw connections.\n","ec":"rawConnection(object, open = \"r\")"},{"p":"base","o":".rangeNum","f":"hp_.rangeNum","d":"range returns a vector containing the minimum and maximum of\nall the given arguments.\n","ec":".rangeNum(..., na.rm, finite, isNumeric)"},{"p":"base","o":"format.AsIs","f":"hp_format.AsIs","d":"Format an R object for pretty printing.\n","ec":"format.AsIs(x, width = 12, ...)"},{"p":"base","o":"is.integer","f":"hp_is.integer","d":"Creates or tests for objects of type \"integer\".\n","ec":"is.integer(x)"},{"p":"base","o":"prod","f":"hp_prod","d":"prod returns the product of all the values\npresent in its arguments.\n","ec":"prod(..., na.rm = FALSE)"},{"p":"base","o":"as.integer","f":"hp_as.integer","d":"Creates or tests for objects of type \"integer\".\n","ec":"as.integer(x, ...)"},{"p":"base","o":"drop","f":"hp_drop","d":"Delete the dimensions of an array which have only one level.\n","ec":"drop(x)"},{"p":"base","o":"Sys.umask","f":"hp_Sys.umask","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"Sys.umask(mode = NA)"},{"p":"base","o":".doTrace","f":"hp_.doTrace","d":"A call to trace allows you to insert debugging code (e.g., a\ncall to browser or recover) at chosen\nplaces in any function.  A call to untrace cancels the tracing.\nSpecified methods can be traced the same way, without tracing all\ncalls to the generic function.  Trace code (tracer) can be any\nR expression.  Tracing can be temporarily turned on or off globally\nby calling tracingState.\n","ec":".doTrace(expr, msg)"},{"p":"base","o":"browserText","f":"hp_browserText","d":"A call to browser can provide context by supplying either a text\nargument or a condition argument.  These functions can be used to\nretrieve either of these arguments.\n","ec":"browserText(n = 1L)"},{"p":"base","o":"is.package_version","f":"hp_is.package_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"is.package_version(x)"},{"p":"base","o":"bindingIsActive","f":"hp_bindingIsActive","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"bindingIsActive(sym, env)"},{"p":"base","o":"file.copy","f":"hp_file.copy","d":"These functions provide a low-level interface to the computer's\nfile system.\n","ec":"file.copy(from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE, copy.date = FALSE)"},{"p":"base","o":"names<-.POSIXlt","f":"hp_names...POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"names<-.POSIXlt(x, value)"},{"p":"base","o":"eigen","f":"hp_eigen","d":"Computes eigenvalues and eigenvectors of numeric (double, integer,\nlogical) or complex matrices.\n","ec":"eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE)"},{"p":"base","o":"is.function","f":"hp_is.function","d":"Checks whether its argument is a (primitive) function.","ec":"is.function(x)"},{"p":"base","o":"month.name","f":"hp_month.name","d":"Constants built into R.\n","ec":""},{"p":"base","o":"digamma","f":"hp_digamma","d":"Special mathematical functions related to the beta and gamma\nfunctions.\n","ec":"digamma(x)"},{"p":"base","o":"l10n_info","f":"hp_l10n_info","d":"Report on localization information.\n","ec":"l10n_info()"},{"p":"base","o":"detach","f":"hp_detach","d":"Detach a database, i.e., remove it from the search()\npath of available R objects.  Usually this is either a\ndata.frame which has been attached or a\npackage which was attached by library.\n","ec":"detach(name, pos = 2L, unload = FALSE, character.only = FALSE, force = FALSE)"},{"p":"base","o":"as.data.frame.noquote","f":"hp_as.data.frame.noquote","d":"These functions are provided for compatibility with older versions of\nR only, and may be defunct as soon as the next release.\n","ec":"as.data.frame.noquote(x, row.names = NULL, optional = FALSE, ..., nm = deparse1(substitute(x)))"},{"p":"base","o":"integer","f":"hp_integer","d":"Creates or tests for objects of type \"integer\".\n","ec":"integer(length = 0L)"},{"p":"base","o":"getCallingDLL","f":"hp_getCallingDLL","d":"This is an internal function that is called from R's C code to\ndetermine the enclosing namespace of a\n.C/.Call/.Fortran/.External call which has\nno PACKAGE argument. If the call has been made from a function\nwithin a namespace, then we can find the DLL associated with that\nnamespace.  The purpose of this is to avoid having to use the\nPACKAGE argument in these native calls and so better support\nversions of packages.\n","ec":"getCallingDLL(f = sys.function(-1), doStop = FALSE)"},{"p":"base","o":"tracingState","f":"hp_tracingState","d":"A call to trace allows you to insert debugging code (e.g., a\ncall to browser or recover) at chosen\nplaces in any function.  A call to untrace cancels the tracing.\nSpecified methods can be traced the same way, without tracing all\ncalls to the generic function.  Trace code (tracer) can be any\nR expression.  Tracing can be temporarily turned on or off globally\nby calling tracingState.\n","ec":"tracingState(on = NULL)"},{"p":"base","o":"as.function","f":"hp_as.function","d":"as.function is a generic function which is used to convert\nobjects to functions.\n","ec":"as.function(x, ...)"},{"p":"base","o":"attach","f":"hp_attach","d":"The database is attached to the R search path.  This means that the\ndatabase is searched by R when evaluating a variable, so objects in\nthe database can be accessed by simply giving their names.\n","ec":"attach(what, pos = 2L, name = deparse1(substitute(what), backtick = FALSE), warn.conflicts = TRUE)"},{"p":"base","o":"dump","f":"hp_dump","d":"This function takes a vector of names of R objects and produces\ntext representations of the objects on a file or connection.\nA dump file can usually be sourced into another\nR session.\n","ec":"dump(list, file = \"dumpdata.R\", append = FALSE, control = \"all\", envir = parent.frame(), evaluate = TRUE)"},{"p":"base","o":"as.POSIXct.numeric","f":"hp_as.POSIXct.numeric","d":"Functions to manipulate objects of classes \"POSIXlt\" and\n\"POSIXct\" representing calendar dates and times.\n","ec":"as.POSIXct.numeric(x, tz = \"\", origin, ...)"},{"p":"base","o":"is.recursive","f":"hp_is.recursive","d":"is.atomic returns TRUE if x is of an atomic type\nand FALSE otherwise.\n","ec":"is.recursive(x)"},{"p":"base","o":"unlink","f":"hp_unlink","d":"unlink deletes the file(s) or directories specified by x.\n","ec":"unlink(x, recursive = FALSE, force = FALSE, expand = TRUE)"},{"p":"base","o":"seq_along","f":"hp_seq_along","d":"Generate regular sequences.  seq is a standard generic with a\ndefault method.  seq.int is a primitive which can be\nmuch faster but has a few restrictions.  seq_along and\nseq_len are very fast primitives for two common cases.\n","ec":"seq_along(along.with)"},{"p":"base","o":"pcre_config","f":"hp_pcre_config","d":"Report some of the configuration options of the version of PCRE in use\nin this R session.\n","ec":"pcre_config()"},{"p":"base","o":"[<-.POSIXct","f":"hp_X....POSIXct","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[<-.POSIXct(x, ..., value)"},{"p":"base","o":"unlist","f":"hp_unlist","d":"Given a list structure x, unlist simplifies it to\nproduce a vector which contains all the atomic components\nwhich occur in x.\n","ec":"unlist(x, recursive = TRUE, use.names = TRUE)"},{"p":"base","o":"[<-.POSIXlt","f":"hp_X....POSIXlt","d":"Description of the classes \"POSIXlt\" and \"POSIXct\"\nrepresenting calendar dates and times.\n","ec":"[<-.POSIXlt(x, i, j, value)"},{"p":"base","o":"all.equal","f":"hp_all.equal","d":"all.equal(x, y) is a utility to compare R objects x\nand y testing <U+2018>near equality<U+2019>.  If they are different,\ncomparison is still made to some extent, and a report of the\ndifferences is returned.    Do not use all.equal directly in\nif expressions<U+2014>either use isTRUE(all.equal(....)) or\nidentical if appropriate.\n","ec":"all.equal(target, current, ...)"},{"p":"base","o":"regmatches","f":"hp_regmatches","d":"Extract or replace matched substrings from match data obtained by\nregexpr, gregexpr,\nregexec or gregexec.\n","ec":"regmatches(x, m, invert = FALSE)"},{"p":"base","o":"is.numeric_version","f":"hp_is.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"is.numeric_version(x)"},{"p":"base","o":".Device","f":"hp_.Device","d":"-NA-","ec":"-NA-"},{"p":"base","o":".tryResumeInterrupt","f":"hp_.tryResumeInterrupt","d":"These functions provide a mechanism for handling unusual conditions,\nincluding errors and warnings.\n","ec":".tryResumeInterrupt()"},{"p":"base","o":"getNamespaceName","f":"hp_getNamespaceName","d":"Internal functions to support reflection on namespace objects.\n","ec":"getNamespaceName(ns)"},{"p":"base","o":"parent.frame","f":"hp_parent.frame","d":"These functions provide access to environments\n(<U+2018>frames<U+2019> in S terminology) associated with functions further\nup the calling stack.\n","ec":"parent.frame(n = 1)"},{"p":"base","o":"factor","f":"hp_factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":"factor(x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA)"},{"p":"base","o":"mtfrm.default","f":"hp_mtfrm.default","d":"Transform objects for matching via match(), think\n<U+201C>match form<U+201D> -> \"mtfrm\".\nbase provides the S3 generic and a default plus\n\"POSIXct\" and \"POSIXlt\" methods.\n","ec":"mtfrm.default(x)"},{"p":"base","o":"message","f":"hp_message","d":"Generate a diagnostic message from its arguments.\n","ec":"message(..., domain = NULL, appendLF = TRUE)"},{"p":"base","o":"lockBinding","f":"hp_lockBinding","d":"These functions represent an interface for adjustments\nto environments and bindings within environments.  They allow for\nlocking environments as well as individual bindings, and for linking\na variable to a function.\n","ec":"lockBinding(sym, env)"},{"p":"base","o":"numToInts","f":"hp_numToInts","d":"Conversion to and from and manipulation of objects of type \"raw\",\nboth used as bits or <U+201C>packed<U+201D> 8 bits.\n","ec":"numToInts(x)"},{"p":"base","o":".valid.factor","f":"hp_.valid.factor","d":"The function factor is used to encode a vector as a factor (the\nterms <U+2018>category<U+2019> and <U+2018>enumerated type<U+2019> are also used for\nfactors).  If argument ordered is TRUE, the factor\nlevels are assumed to be ordered.  For compatibility with S there is\nalso a function ordered.\n","ec":".valid.factor(object)"},{"p":"base","o":"Position","f":"hp_Position","d":"If init is given, Reduce logically adds it to the start\n(when proceeding left to right) or the end of x, respectively.\nIf this possibly augmented vector v has n > 1 elements,\nReduce successively applies f to the elements of v\nfrom left to right or right to left, respectively.  I.e., a left\nreduce computes l_1 = f(v_1, v_2), l_2 = f(l_1, v_3), etc.,\nand returns l_{n-1} = f(l_{n-2}, v_n), and a right reduce does\nr_{n-1} = f(v_{n-1}, v_n), r_{n-2} = f(v_{n-2}, r_{n-1})\nand returns r_1 = f(v_1, r_2).  (E.g., if v is the\nsequence (2, 3, 4) and f is division, left and right reduce give\n(2 / 3) / 4 = 1/6 and 2 / (3 / 4) = 8/3, respectively.)\nIf v has only a single element, this is returned; if there are\nno elements, NULL is returned.  Thus, it is ensured that\nf is always called with 2 arguments.\n","ec":"Position(f, x, right = FALSE, nomatch = NA_integer_)"},{"p":"base","o":"rep.numeric_version","f":"hp_rep.numeric_version","d":"A simple S3 class for representing numeric versions\nincluding package versions, and associated methods.","ec":"rep.numeric_version(x, ...)"},{"p":"base","o":".Defunct","f":"hp_.Defunct","d":"When a function is removed from R it should be replaced by a function\nwhich calls .Defunct.\n","ec":".Defunct(new, package = NULL, msg)"},{"p":"colorspace","o":"extract_transparency","f":"hp_extract_transparency","d":"Adjust (i.e., add, remove, or modify) or extract alpha transparency of a vector of colors.\n","ec":"extract_transparency(col, mode = \"numeric\", default = 1)"},{"p":"colorspace","o":".__C__polarLAB","f":"hp_.__C__polarLAB","d":"-NA-","ec":""},{"p":"colorspace","o":"scale_color_discrete_diverging","f":"hp_scale_color_discrete_diverging","d":"Discrete ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_color_discrete_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"scale_colour_binned_diverging","f":"hp_scale_colour_binned_diverging","d":"Binned ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_colour_binned_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"coloursteps\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":".__C__LUV","f":"hp_.__C__LUV","d":"-NA-","ec":""},{"p":"colorspace","o":"swatchplot","f":"hp_swatchplot","d":"Visualization of color palettes in columns of color swatches.\n","ec":"swatchplot(x, ..., nrow = 20, border = NULL, sborder = NULL, off = NULL, mar = NULL, line = NULL, cex = NULL, font = 1:2, cvd = FALSE)"},{"p":"colorspace","o":"scale_color_discrete_divergingx","f":"hp_scale_color_discrete_divergingx","d":"Discrete ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_color_discrete_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"writehex","f":"hp_writehex","d":"Given a color object, this function writes a file containing the hexadecimal\nrepresentation of the colors in the object.\n","ec":"writehex(x, file = \"\")"},{"p":"colorspace","o":".__T__show:methods","f":"hp_.__T__show.methods","d":"-NA-","ec":""},{"p":"colorspace","o":"scale_fill_discrete_sequential","f":"hp_scale_fill_discrete_sequential","d":"Discrete ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_fill_discrete_sequential(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"scale_colour_binned_divergingx","f":"hp_scale_colour_binned_divergingx","d":"Binned ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_colour_binned_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"coloursteps\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"choose_palette","f":"hp_choose_palette","d":"A graphical user interface (GUI) for viewing, manipulating, and choosing HCL\ncolor palettes.\n","ec":"choose_palette(pal = diverging_hcl, n = 7L, parent = NULL, gui = \"tcltk\", ...)"},{"p":"colorspace","o":"scale_fill_binned_qualitative","f":"hp_scale_fill_binned_qualitative","d":"Binned ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous, binned variable using a qualitative scale.\n","ec":"scale_fill_binned_qualitative(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"simulate_cvd","f":"hp_simulate_cvd","d":"Transformation of R colors by simulating color vision deficiencies,\nbased on a CVD transform matrix.\n","ec":"simulate_cvd(col, cvd_transform, linear = TRUE)"},{"p":"colorspace","o":"readhex","f":"hp_readhex","d":"This function reads a set of hexadecimal color descriptions from a file and\ncreates a color object containing the corresponding colors.\n","ec":"readhex(file = \"\", class = \"RGB\")"},{"p":"colorspace","o":".__C__color","f":"hp_.__C__color","d":"-NA-","ec":""},{"p":"colorspace","o":"LUV","f":"hp_LUV","d":"This function creates colors of class <U+201C>LUV<U+201D>; a subclass of the virtual\ncolor-class class.\n","ec":"LUV(L, U, V, names)"},{"p":"colorspace","o":".__T__[:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"colorspace","o":"sRGB","f":"hp_sRGB","d":"This function creates colors of class sRGB; a subclass of the virtual\ncolor-class class.\n","ec":"sRGB(R, G, B, names)"},{"p":"colorspace","o":"diverging_hsv","f":"hp_diverging_hsv","d":"Color palettes based on the HCL (and HSV) color space to replace\nbase R palettes.\n","ec":"diverging_hsv(n, h = c(240, 0), s = 1, v = 1, power = 1, gamma = NULL, fixup = TRUE, alpha = 1, ...)"},{"p":"colorspace","o":"RGB","f":"hp_RGB","d":"This function creates colors of class RGB; a subclass of the virtual\ncolor-class class.\n","ec":"RGB(R, G, B, names)"},{"p":"colorspace","o":"darken","f":"hp_darken","d":"The functions lighten and darken take a vector of R colors and adjust the colors such that\nthey appear lightened or darkened, respectively.\n","ec":"darken(col, amount = 0.1, space = \"combined\", ...)"},{"p":"colorspace","o":"scale_colour_discrete_diverging","f":"hp_scale_colour_discrete_diverging","d":"Discrete ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_colour_discrete_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"protanomaly_cvd","f":"hp_protanomaly_cvd","d":"Conversion tables for simulating different types of color vision deficiency (CVD):\nProtanomaly, deutanomaly, tritanomaly.\n","ec":""},{"p":"colorspace","o":"hcl_wizard","f":"hp_hcl_wizard","d":"A graphical user interface (GUI) for viewing, manipulating, and choosing HCL\ncolor palettes.\n","ec":"hcl_wizard(n = 7L, gui = \"shiny\", ...)"},{"p":"colorspace","o":"hex","f":"hp_hex","d":"This functions converts color-class objects into hexadecimal strings.\n","ec":"hex(from, gamma = NULL, fixup = FALSE)"},{"p":"colorspace","o":"scale_fill_continuous_divergingx","f":"hp_scale_fill_continuous_divergingx","d":"Continuous ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_fill_continuous_divergingx(..., aesthetics = \"fill\")"},{"p":"colorspace","o":".__T__coords:colorspace","f":"hp_.__T__coords.colorspace","d":"-NA-","ec":""},{"p":"colorspace","o":"adjust_transparency","f":"hp_adjust_transparency","d":"Adjust (i.e., add, remove, or modify) or extract alpha transparency of a vector of colors.\n","ec":"adjust_transparency(col, alpha = TRUE)"},{"p":"colorspace","o":"scale_colour_discrete_qualitative","f":"hp_scale_colour_discrete_qualitative","d":"Discrete ggplot2 color scales using the color palettes generated by qualitative_hcl.\n","ec":"scale_colour_discrete_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"hcl_color_picker","f":"hp_hcl_color_picker","d":"The app visualizes colors either along the hue-chroma plane for a given luminance value or along the\nluminance-chroma plane for a given hue. Colors can be entered by specifying the hue (H), chroma (C),\nand luminance (L) values via sliders, by entering an RGB hex code, or by clicking on a color in the\nhue-chroma or luminance-chroma plane. It is also possible to select individual colors and add them\nto a palette for comparison and future reference.\n","ec":"hcl_color_picker(shiny.trace = FALSE)"},{"p":"colorspace","o":".__C__HSV","f":"hp_.__C__HSV","d":"-NA-","ec":""},{"p":"colorspace","o":"hclcolorpicker","f":"hp_hclcolorpicker","d":"The app visualizes colors either along the hue-chroma plane for a given luminance value or along the\nluminance-chroma plane for a given hue. Colors can be entered by specifying the hue (H), chroma (C),\nand luminance (L) values via sliders, by entering an RGB hex code, or by clicking on a color in the\nhue-chroma or luminance-chroma plane. It is also possible to select individual colors and add them\nto a palette for comparison and future reference.\n","ec":"hclcolorpicker(shiny.trace = FALSE)"},{"p":"colorspace","o":"diverge_hsv","f":"hp_diverge_hsv","d":"Color palettes based on the HCL (and HSV) color space to replace\nbase R palettes.\n","ec":"diverge_hsv(n, h = c(240, 0), s = 1, v = 1, power = 1, gamma = NULL, fixup = TRUE, alpha = 1, ...)"},{"p":"colorspace","o":"XYZ","f":"hp_XYZ","d":"This function creates colors of class XYZ; a subclass of the virtual\ncolor-class class.\n","ec":"XYZ(X, Y, Z, names)"},{"p":"colorspace","o":"coords","f":"hp_coords","d":"This function returns a matrix with three columns which give the coordinates\nof a color in its natural color space.\n","ec":"coords(color)"},{"p":"colorspace","o":"hclplot","f":"hp_hclplot","d":"Visualization of color palettes in HCL space projections.\n","ec":"hclplot(x, type = NULL, h = NULL, c = NULL, l = NULL, xlab = NULL, ylab = NULL, main = NULL, cex = 1, axes = TRUE, bg = \"white\", lwd = 1, size = 2.5, ...)"},{"p":"colorspace","o":"terrain_hcl","f":"hp_terrain_hcl","d":"Color palettes based on the HCL (and HSV) color space to replace\nbase R palettes.\n","ec":"terrain_hcl(n, h = c(130, 0), c. = c(80, 0), l = c(60, 95), power = c(1/10, 1), gamma = NULL, fixup = TRUE, alpha = 1, ...)"},{"p":"colorspace","o":"scale_fill_binned_sequential","f":"hp_scale_fill_binned_sequential","d":"Binned ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_fill_binned_sequential(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"scale_colour_continuous_divergingx","f":"hp_scale_colour_continuous_divergingx","d":"Continuous ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_colour_continuous_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"colourbar\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":".__T__plot:base","f":"hp_.__T__plot.base","d":"-NA-","ec":""},{"p":"colorspace","o":"interpolate_cvd_transform","f":"hp_interpolate_cvd_transform","d":"Transformation of R colors by simulating color vision deficiencies,\nbased on a CVD transform matrix.\n","ec":"interpolate_cvd_transform(cvd, severity = 1)"},{"p":"colorspace","o":"scale_color_continuous_divergingx","f":"hp_scale_color_continuous_divergingx","d":"Continuous ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_color_continuous_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"colourbar\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"scale_fill_discrete_divergingx","f":"hp_scale_fill_discrete_divergingx","d":"Discrete ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_fill_discrete_divergingx(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"tritanomaly_cvd","f":"hp_tritanomaly_cvd","d":"Conversion tables for simulating different types of color vision deficiency (CVD):\nProtanomaly, deutanomaly, tritanomaly.\n","ec":""},{"p":"colorspace","o":"scale_color_continuous_sequential","f":"hp_scale_color_continuous_sequential","d":"Continuous ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_color_continuous_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, begin = 0, end = 1, na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"scale_color_continuous_qualitative","f":"hp_scale_color_continuous_qualitative","d":"Continuous ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous variable using a qualitative scale.\n","ec":"scale_color_continuous_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, begin = 0, end = 1, na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"choose_color","f":"hp_choose_color","d":"The app visualizes colors either along the hue-chroma plane for a given luminance value or along the\nluminance-chroma plane for a given hue. Colors can be entered by specifying the hue (H), chroma (C),\nand luminance (L) values via sliders, by entering an RGB hex code, or by clicking on a color in the\nhue-chroma or luminance-chroma plane. It is also possible to select individual colors and add them\nto a palette for comparison and future reference.\n","ec":"choose_color(shiny.trace = FALSE)"},{"p":"colorspace","o":"cvd_emulator","f":"hp_cvd_emulator","d":"A graphical user interface (GUI) to check an existing jpg/png image for (possible)\ncolor constraints. The image will be converted to protanope vision, deuteranope vision,\nand a desaturated version (monochromatic vision).\nAllows a rapid check whether the colors used in the image show some\nconstraints with respect to color deficiency or color blindness.\n","ec":"cvd_emulator(file, overwrite = FALSE, shiny.trace = FALSE)"},{"p":"colorspace","o":"divergingx_palettes","f":"hp_divergingx_palettes","d":"Diverging HCL color palettes generated through combination of two fully\nflexible (and possibly unbalanced) multi-hue sequential palettes.\n","ec":"divergingx_palettes(palette = NULL, plot = FALSE, n = 7L, ...)"},{"p":"colorspace","o":"specplot","f":"hp_specplot","d":"Visualization of color palettes (given as hex codes) in HCL and/or RGB\ncoordinates.\n","ec":"specplot(x, y = NULL, rgb = FALSE, hcl = TRUE, fix = TRUE, cex = 1, type = \"l\", lwd = 2 * cex, lty = 1, pch = NULL, mar = NULL, oma = NULL, main = NULL, legend = TRUE, palette = TRUE, plot = TRUE, ...)"},{"p":"colorspace","o":"diverge_hcl","f":"hp_diverge_hcl","d":"Qualitative, sequential (single-hue and multi-hue), and diverging\ncolor palettes based on the HCL (hue-chroma-luminance) color model.\n","ec":"diverge_hcl(n, h = c(260, 0), c = 80, l = c(30, 90), power = 1.5, gamma = NULL, fixup = TRUE, alpha = 1, palette = NULL, rev = FALSE, register = \"\", ..., h1, h2, c1, l1, l2, p1, p2, cmax)"},{"p":"colorspace","o":"scale_fill_discrete_qualitative","f":"hp_scale_fill_discrete_qualitative","d":"Discrete ggplot2 color scales using the color palettes generated by qualitative_hcl.\n","ec":"scale_fill_discrete_qualitative(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"contrast_ratio","f":"hp_contrast_ratio","d":"Compute (and visualize) the contrast ratio of pairs of colors, as defined by the World Wide\nWeb Consortium (W3C).\n","ec":"contrast_ratio(col, col2 = \"white\", algorithm = c(\"WCAG\", \"APCA\"), plot = FALSE, border = FALSE, cex = 2, off = 0.05, mar = rep(0.5, 4), digits = 2L, ...)"},{"p":"colorspace","o":"HLS","f":"hp_HLS","d":"This function creates colors of class HLS; a subclass of the virtual\ncolor-class class.\n","ec":"HLS(H, L, S, names)"},{"p":"colorspace","o":"scale_fill_binned_divergingx","f":"hp_scale_fill_binned_divergingx","d":"Binned ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_fill_binned_divergingx(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"scale_color_discrete_sequential","f":"hp_scale_color_discrete_sequential","d":"Discrete ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_color_discrete_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"scale_colour_continuous_qualitative","f":"hp_scale_colour_continuous_qualitative","d":"Continuous ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous variable using a qualitative scale.\n","ec":"scale_colour_continuous_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, begin = 0, end = 1, na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"scale_fill_continuous_qualitative","f":"hp_scale_fill_continuous_qualitative","d":"Continuous ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous variable using a qualitative scale.\n","ec":"scale_fill_continuous_qualitative(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"LAB","f":"hp_LAB","d":"This function creates colors of class <U+201C>LAB<U+201D>; a subclass of the virtual\ncolor-class class.\n","ec":"LAB(L, A, B, names)"},{"p":"colorspace","o":"readRGB","f":"hp_readRGB","d":"This function reads a set of RGB color descriptions (of the form written by\ngcolorsel) from a file and creates a color object containing the\ncorresponding colors.\n","ec":"readRGB(file, class = \"RGB\")"},{"p":"colorspace","o":"scale_fill_continuous_diverging","f":"hp_scale_fill_continuous_diverging","d":"Continuous ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_fill_continuous_diverging(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"plot","f":"hp_plot","d":"-NA-","ec":"plot(x, y, ...)"},{"p":"colorspace","o":"scale_color_discrete_qualitative","f":"hp_scale_color_discrete_qualitative","d":"Discrete ggplot2 color scales using the color palettes generated by qualitative_hcl.\n","ec":"scale_color_discrete_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"deutan","f":"hp_deutan","d":"Transformation of R colors by simulating color vision deficiencies,\nbased on a CVD transform matrix.\n","ec":"deutan(col, severity = 1, linear = TRUE)"},{"p":"colorspace","o":"demoplot","f":"hp_demoplot","d":"Demonstration of color palettes in various kinds of statistical graphics.\n","ec":"demoplot(x, type = c(\"map\", \"heatmap\", \"scatter\", \"spine\", \"bar\", \"pie\", \"perspective\", \"mosaic\", \"lines\"), ...)"},{"p":"colorspace","o":"max_chroma","f":"hp_max_chroma","d":"Compute approximately the maximum chroma possible for a given hue and\nluminance combination in the HCL color space.\n","ec":"max_chroma(h, l, floor = FALSE)"},{"p":"colorspace","o":"mixcolor","f":"hp_mixcolor","d":"This function can be used to compute the result of color mixing, assuming\nadditive mixing (e.g., as appropriate for RGB or XYZ).\n","ec":"mixcolor(alpha, color1, color2, where = class(color1))"},{"p":"colorspace","o":"hclwizard","f":"hp_hclwizard","d":"A graphical user interface (GUI) for viewing, manipulating, and choosing HCL\ncolor palettes.\n","ec":"hclwizard(n = 7L, gui = \"shiny\", ...)"},{"p":"colorspace","o":"scale_color_binned_sequential","f":"hp_scale_color_binned_sequential","d":"Binned ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_color_binned_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, begin = 0, end = 1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":".__C__LAB","f":"hp_.__C__LAB","d":"-NA-","ec":""},{"p":"colorspace","o":".__C__RGB","f":"hp_.__C__RGB","d":"-NA-","ec":""},{"p":"colorspace","o":"scale_fill_discrete_diverging","f":"hp_scale_fill_discrete_diverging","d":"Discrete ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_fill_discrete_diverging(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"scale_colour_binned_sequential","f":"hp_scale_colour_binned_sequential","d":"Binned ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_colour_binned_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, begin = 0, end = 1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":".__C__XYZ","f":"hp_.__C__XYZ","d":"-NA-","ec":""},{"p":"colorspace","o":"polarLAB","f":"hp_polarLAB","d":"This function creates colors of class <U+201C>polarLAB<U+201D>; a subclass of the\nvirtual color-class class.\n","ec":"polarLAB(L, C, H, names)"},{"p":"colorspace","o":"scale_color_binned_diverging","f":"hp_scale_color_binned_diverging","d":"Binned ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_color_binned_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"coloursteps\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"heat_hcl","f":"hp_heat_hcl","d":"Color palettes based on the HCL (and HSV) color space to replace\nbase R palettes.\n","ec":"heat_hcl(n, h = c(0, 90), c. = c(100, 30), l = c(50, 90), power = c(1/5, 1), gamma = NULL, fixup = TRUE, alpha = 1, ...)"},{"p":"colorspace","o":"diverging_hcl","f":"hp_diverging_hcl","d":"Qualitative, sequential (single-hue and multi-hue), and diverging\ncolor palettes based on the HCL (hue-chroma-luminance) color model.\n","ec":"diverging_hcl(n, h = c(260, 0), c = 80, l = c(30, 90), power = 1.5, gamma = NULL, fixup = TRUE, alpha = 1, palette = NULL, rev = FALSE, register = \"\", ..., h1, h2, c1, l1, l2, p1, p2, cmax)"},{"p":"colorspace","o":"protan","f":"hp_protan","d":"Transformation of R colors by simulating color vision deficiencies,\nbased on a CVD transform matrix.\n","ec":"protan(col, severity = 1, linear = TRUE)"},{"p":"colorspace","o":"HSV","f":"hp_HSV","d":"This function creates colors of class HSV; a subclass of the virtual\ncolor-class class.\n","ec":"HSV(H, S, V, names)"},{"p":"colorspace","o":".__C__HLS","f":"hp_.__C__HLS","d":"-NA-","ec":""},{"p":"colorspace","o":"scale_colour_discrete_sequential","f":"hp_scale_colour_discrete_sequential","d":"Discrete ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_colour_discrete_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"scale_color_continuous_diverging","f":"hp_scale_color_continuous_diverging","d":"Continuous ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_color_continuous_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"colourbar\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"whitepoint","f":"hp_whitepoint","d":"This function can be used to control the single global whitepoint\nthat affects all color conversions within the package (that require\na whitepoint, i.e., go through XYZ).\n","ec":"whitepoint(white, ...)"},{"p":"colorspace","o":"scale_color_binned_qualitative","f":"hp_scale_color_binned_qualitative","d":"Binned ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous, binned variable using a qualitative scale.\n","ec":"scale_color_binned_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, begin = 0, end = 1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"scale_colour_binned_qualitative","f":"hp_scale_colour_binned_qualitative","d":"Binned ggplot2 color scales using the color palettes generated by qualitative_hcl. These scales are provided\nfor completeness. It is not normally a good idea to color a continuous, binned variable using a qualitative scale.\n","ec":"scale_colour_binned_qualitative(palette = NULL, c1 = NULL, l1 = NULL, h1 = NULL, h2 = NULL, alpha = 1, rev = FALSE, begin = 0, end = 1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"desaturate","f":"hp_desaturate","d":"Transform a vector of given colors to the corresponding colors with chroma\nreduced (by a tunable amount) in HCL space.\n","ec":"desaturate(col, amount = 1, ...)"},{"p":"colorspace","o":".__C__polarLUV","f":"hp_.__C__polarLUV","d":"-NA-","ec":""},{"p":"colorspace","o":"hcl_palettes","f":"hp_hcl_palettes","d":"Qualitative, sequential (single-hue and multi-hue), and diverging\ncolor palettes based on the HCL (hue-chroma-luminance) color model.\n","ec":"hcl_palettes(type = NULL, palette = NULL, plot = FALSE, n = 5L, ...)"},{"p":"colorspace","o":"scale_colour_continuous_diverging","f":"hp_scale_colour_continuous_diverging","d":"Continuous ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_colour_continuous_diverging(palette = NULL, c1 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"colourbar\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"scale_colour_discrete_divergingx","f":"hp_scale_colour_discrete_divergingx","d":"Discrete ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_colour_discrete_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, nmax = NULL, order = NULL, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"rainbow_hcl","f":"hp_rainbow_hcl","d":"Color palettes based on the HCL (and HSV) color space to replace\nbase R palettes.\n","ec":"rainbow_hcl(n, c = 50, l = 70, start = 0, end = 360 * (n - 1)/n, gamma = NULL, fixup = TRUE, alpha = 1, ...)"},{"p":"colorspace","o":"qualitative_hcl","f":"hp_qualitative_hcl","d":"Qualitative, sequential (single-hue and multi-hue), and diverging\ncolor palettes based on the HCL (hue-chroma-luminance) color model.\n","ec":"qualitative_hcl(n, h = c(0, 360 * (n - 1)/n), c = 80, l = 60, fixup = TRUE, alpha = 1, palette = NULL, rev = FALSE, register = \"\", ..., h1, h2, c1, l1)"},{"p":"colorspace","o":"scale_color_binned_divergingx","f":"hp_scale_color_binned_divergingx","d":"Binned ggplot2 color scales using the color palettes generated by divergingx_hcl.\n","ec":"scale_color_binned_divergingx(palette = \"Geyser\", c1 = NULL, c2 = NULL, c3 = NULL, l1 = NULL, l2 = NULL, l3 = NULL, h1 = NULL, h2 = NULL, h3 = NULL, p1 = NULL, p2 = NULL, p3 = NULL, p4 = NULL, cmax1 = NULL, cmax2 = NULL, alpha = 1, rev = FALSE, mid = 0, na.value = \"grey50\", guide = \"coloursteps\", n_interp = 11, aesthetics = \"colour\", ...)"},{"p":"colorspace","o":"polarLUV","f":"hp_polarLUV","d":"This function creates colors of class <U+201C>polarLUV<U+201D>; a subclass of the\nvirtual color-class class.\n","ec":"polarLUV(L, C, H, names)"},{"p":"colorspace","o":"tritan","f":"hp_tritan","d":"Transformation of R colors by simulating color vision deficiencies,\nbased on a CVD transform matrix.\n","ec":"tritan(col, severity = 1, linear = TRUE)"},{"p":"colorspace","o":"hex2RGB","f":"hp_hex2RGB","d":"This function takes a vector of strings of the form \"#RRGGBB\"\n(hexadecimal color descriptions) into sRGB objects.\n","ec":"hex2RGB(x, gamma = FALSE)"},{"p":"colorspace","o":"divergex_hcl","f":"hp_divergex_hcl","d":"Diverging HCL color palettes generated through combination of two fully\nflexible (and possibly unbalanced) multi-hue sequential palettes.\n","ec":"divergex_hcl(n, palette = \"Geyser\", ..., fixup = TRUE, alpha = 1, rev = FALSE, h1, h2, h3, c1, c2, c3, l1, l2, l3, p1, p2, p3, p4, cmax1, cmax2)"},{"p":"colorspace","o":"scale_fill_continuous_sequential","f":"hp_scale_fill_continuous_sequential","d":"Continuous ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_fill_continuous_sequential(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"scale_fill_binned_diverging","f":"hp_scale_fill_binned_diverging","d":"Binned ggplot2 color scales using the color palettes generated by diverging_hcl.\n","ec":"scale_fill_binned_diverging(..., aesthetics = \"fill\")"},{"p":"colorspace","o":"divergingx_hcl","f":"hp_divergingx_hcl","d":"Diverging HCL color palettes generated through combination of two fully\nflexible (and possibly unbalanced) multi-hue sequential palettes.\n","ec":"divergingx_hcl(n, palette = \"Geyser\", ..., fixup = TRUE, alpha = 1, rev = FALSE, h1, h2, h3, c1, c2, c3, l1, l2, l3, p1, p2, p3, p4, cmax1, cmax2)"},{"p":"colorspace","o":"scale_colour_continuous_sequential","f":"hp_scale_colour_continuous_sequential","d":"Continuous ggplot2 color scales using the color palettes generated by sequential_hcl.\n","ec":"scale_colour_continuous_sequential(palette = NULL, c1 = NULL, c2 = NULL, cmax = NULL, l1 = NULL, l2 = NULL, h1 = NULL, h2 = NULL, p1 = NULL, p2 = NULL, alpha = 1, rev = TRUE, begin = 0, end = 1, na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", n_interp = 11, ...)"},{"p":"colorspace","o":"sequential_hcl","f":"hp_sequential_hcl","d":"Qualitative, sequential (single-hue and multi-hue), and diverging\ncolor palettes based on the HCL (hue-chroma-luminance) color model.\n","ec":"sequential_hcl(n, h = 260, c = 80, l = c(30, 90), power = 1.5, gamma = NULL, fixup = TRUE, alpha = 1, palette = NULL, rev = FALSE, register = \"\", ..., h1, h2, c1, c2, l1, l2, p1, p2, cmax, c.)"},{"p":"colorspace","o":"deutanomaly_cvd","f":"hp_deutanomaly_cvd","d":"Conversion tables for simulating different types of color vision deficiency (CVD):\nProtanomaly, deutanomaly, tritanomaly.\n","ec":""},{"p":"colorspace","o":".__C__sRGB","f":"hp_.__C__sRGB","d":"-NA-","ec":""},{"p":"colorspace","o":"lighten","f":"hp_lighten","d":"The functions lighten and darken take a vector of R colors and adjust the colors such that\nthey appear lightened or darkened, respectively.\n","ec":"lighten(col, amount = 0.1, method = c(\"relative\", \"absolute\"), space = c(\"HCL\", \"HLS\", \"combined\"), fixup = TRUE)"},{"p":"crayon","o":"make_style","f":"hp_make_style","d":"Create a style, or a style function, or both. This function\nis intended for those who wish to use 256 ANSI colors,\ninstead of the more widely supported eight colors.\n","ec":"make_style(..., bg = FALSE, grey = FALSE, colors = num_colors())"},{"p":"crayon","o":"bgWhite","f":"hp_bgWhite","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgWhite(...)"},{"p":"crayon","o":"col_align","f":"hp_col_align","d":"Align an ANSI colored string\n","ec":"col_align(text, width = getOption(\"width\"), align = c(\"left\", \"center\", \"right\"), type = \"width\")"},{"p":"crayon","o":"col_strsplit","f":"hp_col_strsplit","d":"This is the color-aware counterpart of base::strsplit().\nIt works almost exactly like the original, but keeps the colors in the\nsubstrings.\n","ec":"col_strsplit(x, split, ...)"},{"p":"crayon","o":"underline","f":"hp_underline","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"underline(...)"},{"p":"crayon","o":"finish","f":"hp_finish","d":"Make a style active. The text printed to the screen from now\non will use this style.\n","ec":"finish(x, ...)"},{"p":"crayon","o":"bgYellow","f":"hp_bgYellow","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgYellow(...)"},{"p":"crayon","o":"num_ansi_colors","f":"hp_num_ansi_colors","d":"Certain Unix and Windows terminals, and also certain R GUIs, e.g.\nRStudio, support styling terminal output using special control\nsequences (ANSI sequences).\n","ec":"num_ansi_colors(stream = \"auto\")"},{"p":"crayon","o":"styles","f":"hp_styles","d":"You can use this function to list all availables crayon styles,\nvia names(styles()), or to explicitly apply an ANSI\nescape seauence to a string.\n","ec":"styles()"},{"p":"crayon","o":"%+%","f":"hp_X...","d":"The length of the two arguments must match, or\none of them must be of length one. If the length of\none argument is one, then the output's length will\nmatch the length of the other argument. See examples\nbelow.\n","ec":"%+%(lhs, rhs)"},{"p":"crayon","o":"yellow","f":"hp_yellow","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"yellow(...)"},{"p":"crayon","o":"green","f":"hp_green","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"green(...)"},{"p":"crayon","o":"bgBlue","f":"hp_bgBlue","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgBlue(...)"},{"p":"crayon","o":"drop_style","f":"hp_drop_style","d":"Remove a style\n","ec":"drop_style(style)"},{"p":"crayon","o":"show_ansi_colors","f":"hp_show_ansi_colors","d":"Show the ANSI color table on the screen\n","ec":"show_ansi_colors(colors = num_colors())"},{"p":"crayon","o":"italic","f":"hp_italic","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"italic(...)"},{"p":"crayon","o":"has_style","f":"hp_has_style","d":"Check if a string has some ANSI styling\n","ec":"has_style(string)"},{"p":"crayon","o":"style","f":"hp_style","d":"See names(styles), or the crayon manual for available styles.\n","ec":"style(string, as = NULL, bg = NULL)"},{"p":"crayon","o":"white","f":"hp_white","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"white(...)"},{"p":"crayon","o":"silver","f":"hp_silver","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"silver(...)"},{"p":"crayon","o":"bgMagenta","f":"hp_bgMagenta","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgMagenta(...)"},{"p":"crayon","o":"cyan","f":"hp_cyan","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"cyan(...)"},{"p":"crayon","o":"reset","f":"hp_reset","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"reset(...)"},{"p":"crayon","o":"has_color","f":"hp_has_color","d":"From crayon 2.0.0, this function is simply a wrapper on\nnum_ansi_colors().\n","ec":"has_color()"},{"p":"crayon","o":"bold","f":"hp_bold","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bold(...)"},{"p":"crayon","o":"inverse","f":"hp_inverse","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"inverse(...)"},{"p":"crayon","o":"black","f":"hp_black","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"black(...)"},{"p":"crayon","o":"bgRed","f":"hp_bgRed","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgRed(...)"},{"p":"crayon","o":"col_substr","f":"hp_col_substr","d":"This is a color-aware counterpart of base::substr().\nIt works exactly like the original, but keeps the colors\nin the substrings. The ANSI escape sequences are ignored when\ncalculating the positions within the string.\n","ec":"col_substr(x, start, stop)"},{"p":"crayon","o":"combine_styles","f":"hp_combine_styles","d":"Combine two or more styles or style functions into a new style function\nthat can be called on strings to style them.\n","ec":"combine_styles(...)"},{"p":"crayon","o":"red","f":"hp_red","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"red(...)"},{"p":"crayon","o":"num_colors","f":"hp_num_colors","d":"From crayon version 2.0.0, this function is a simple wrapper on\nnum_ansi_colors(), with the additional twist that the crayon.colors\noption is still obseved, and takes precedence, for compatibility.\n","ec":"num_colors(forget = FALSE)"},{"p":"crayon","o":"bgCyan","f":"hp_bgCyan","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgCyan(...)"},{"p":"crayon","o":"strikethrough","f":"hp_strikethrough","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"strikethrough(...)"},{"p":"crayon","o":"hidden","f":"hp_hidden","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"hidden(...)"},{"p":"crayon","o":"chr","f":"hp_chr","d":"This function just calls as.character(), but it is\neasier to type and read.\n","ec":"chr(x, ...)"},{"p":"crayon","o":"bgBlack","f":"hp_bgBlack","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgBlack(...)"},{"p":"crayon","o":"blurred","f":"hp_blurred","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"blurred(...)"},{"p":"crayon","o":"magenta","f":"hp_magenta","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"magenta(...)"},{"p":"crayon","o":"col_nchar","f":"hp_col_nchar","d":"This is a color-aware counterpart of base::nchar(),\nwhich does not do well, since it also counts the ANSI control\ncharacters.\n","ec":"col_nchar(x, ...)"},{"p":"crayon","o":"hyperlink","f":"hp_hyperlink","d":"Terminal Hyperlinks\n","ec":"hyperlink(text, url)"},{"p":"crayon","o":"bgGreen","f":"hp_bgGreen","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"bgGreen(...)"},{"p":"crayon","o":"strip_style","f":"hp_strip_style","d":"Remove ANSI escape sequences from a string\n","ec":"strip_style(string)"},{"p":"crayon","o":"has_hyperlink","f":"hp_has_hyperlink","d":"Terminal Hyperlinks\n","ec":"has_hyperlink()"},{"p":"crayon","o":"blue","f":"hp_blue","d":"With crayon it is easy to add color to terminal output, create styles\nfor notes, warnings, errors; and combine styles.\n","ec":"blue(...)"},{"p":"crayon","o":"col_substring","f":"hp_col_substring","d":"This is the color-aware counterpart of base::substring().\nIt works exactly like the original, but keeps the colors in the\nsubstrings. The ANSI escape sequences are ignored when\ncalculating the positions within the string.\n","ec":"col_substring(text, first, last = 1000000L)"},{"p":"datawizard","o":"data_extract","f":"hp_data_extract","d":"data_extract() (or its alias extract()) is similar to $. It extracts\neither a single column or element from an object (e.g., a data frame, list),\nor multiple columns resp. elements.\n","ec":"data_extract(data, select, ...)"},{"p":"datawizard","o":"detrend","f":"hp_detrend","d":"demean() computes group- and de-meaned versions of a variable that can be\nused in regression analysis to model the between- and within-subject effect.\ndegroup() is more generic in terms of the centering-operation. While\ndemean() always uses mean-centering, degroup() can also use the mode or\nmedian for centering.\n","ec":"detrend(x, select, by, nested = FALSE, center = \"mean\", suffix_demean = \"_within\", suffix_groupmean = \"_between\", add_attributes = TRUE, verbose = TRUE, group = NULL)"},{"p":"datawizard","o":"reverse_scale","f":"hp_reverse_scale","d":"Reverse-score variables (change the keying/scoring direction).\n","ec":"reverse_scale(x, ...)"},{"p":"datawizard","o":"slide","f":"hp_slide","d":"This functions shifts the value range of a numeric variable, so that the\nnew range starts at a given value.\n","ec":"slide(x, ...)"},{"p":"datawizard","o":"data_addprefix","f":"hp_data_addprefix","d":"Safe and intuitive functions to rename variables or rows in\ndata frames. data_rename() will rename column names, i.e. it facilitates\nrenaming variables data_addprefix() or data_addsuffix() add prefixes\nor suffixes to column names. data_rename_rows() is a convenient shortcut\nto add or rename row names of a data frame, but unlike row.names(), its\ninput and output is a data frame, thus, integrating smoothly into a possible\npipe-workflow.\n","ec":"data_addprefix(data, pattern, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_addsuffix","f":"hp_data_addsuffix","d":"Safe and intuitive functions to rename variables or rows in\ndata frames. data_rename() will rename column names, i.e. it facilitates\nrenaming variables data_addprefix() or data_addsuffix() add prefixes\nor suffixes to column names. data_rename_rows() is a convenient shortcut\nto add or rename row names of a data frame, but unlike row.names(), its\ninput and output is a data frame, thus, integrating smoothly into a possible\npipe-workflow.\n","ec":"data_addsuffix(data, pattern, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"distribution_coef_var","f":"hp_distribution_coef_var","d":"Compute the coefficient of variation (CV, ratio of the standard deviation to\nthe mean, \\sigma/\\mu) for a set of numeric values.\n","ec":"distribution_coef_var(x, ...)"},{"p":"datawizard","o":"center","f":"hp_center","d":"Performs a grand-mean centering of data.\n","ec":"center(x, ...)"},{"p":"datawizard","o":"smoothness","f":"hp_smoothness","d":"Quantify the smoothness of a vector\n","ec":"smoothness(x, method = \"cor\", lag = 1, iterations = NULL, ...)"},{"p":"datawizard","o":"winsorize","f":"hp_winsorize","d":"Winsorize data\n","ec":"winsorize(data, ...)"},{"p":"datawizard","o":"reverse","f":"hp_reverse","d":"Reverse-score variables (change the keying/scoring direction).\n","ec":"reverse(x, ...)"},{"p":"datawizard","o":"weighted_mean","f":"hp_weighted_mean","d":"Weighted Mean, Median, SD, and MAD\n","ec":"weighted_mean(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"describe_distribution","f":"hp_describe_distribution","d":"This function describes a distribution by a set of indices (e.g., measures of\ncentrality, dispersion, range, skewness, kurtosis).\n","ec":"describe_distribution(x, ...)"},{"p":"datawizard","o":"weighted_mad","f":"hp_weighted_mad","d":"Weighted Mean, Median, SD, and MAD\n","ec":"weighted_mad(x, weights = NULL, constant = 1.4826, remove_na = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"median_mad","f":"hp_median_mad","d":"Summary Helpers\n","ec":"median_mad(x, times = 1L, remove_na = TRUE, constant = 1.4826, named = TRUE, na.rm = TRUE, ...)"},{"p":"datawizard","o":"rescale","f":"hp_rescale","d":"Rescale variables to a new range. Can also be used to reverse-score variables\n(change the keying/scoring direction), or to expand a range.\n","ec":"rescale(x, ...)"},{"p":"datawizard","o":"rownames_as_column","f":"hp_rownames_as_column","d":"Tools for working with row names or row ids\n","ec":"rownames_as_column(x, var = \"rowname\")"},{"p":"datawizard","o":"colnames_to_row","f":"hp_colnames_to_row","d":"Tools for working with column names\n","ec":"colnames_to_row(x, prefix = \"x\")"},{"p":"datawizard","o":"data_find","f":"hp_data_find","d":"extract_column_names() returns column names from a data set that\nmatch a certain search pattern, while data_select() returns the found data.\n","ec":"data_find(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"reshape_ci","f":"hp_reshape_ci","d":"Reshape CI between wide/long formats.\n","ec":"reshape_ci(x, ci_type = \"CI\")"},{"p":"datawizard","o":"centre","f":"hp_centre","d":"Performs a grand-mean centering of data.\n","ec":"centre(x, ...)"},{"p":"datawizard","o":"convert_to_na","f":"hp_convert_to_na","d":"Convert non-missing values in a variable into missing values.\n","ec":"convert_to_na(x, ...)"},{"p":"datawizard","o":"data_partition","f":"hp_data_partition","d":"Creates data partitions (for instance, a training and a test set) based on a\ndata frame that can also be stratified (i.e., evenly spread a given factor)\nusing the by argument.\n","ec":"data_partition(data, proportion = 0.7, by = NULL, seed = NULL, row_id = \".row_id\", verbose = TRUE, group = NULL, ...)"},{"p":"datawizard","o":"data_read","f":"hp_data_read","d":"This functions imports data from various file types. It is a small wrapper\naround haven::read_spss(), haven::read_stata(), haven::read_sas(),\nreadxl::read_excel() and data.table::fread() resp. readr::read_delim()\n(the latter if package data.table is not installed). Thus, supported file\ntypes for importing data are data files from SPSS, SAS or Stata, Excel files\nor text files (like '.csv' files). All other file types are passed to\nrio::import(). data_write() works in a similar way.\n","ec":"data_read(path, path_catalog = NULL, encoding = NULL, convert_factors = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"rowid_as_column","f":"hp_rowid_as_column","d":"Tools for working with row names or row ids\n","ec":"rowid_as_column(x, var = \"rowid\")"},{"p":"datawizard","o":"data_join","f":"hp_data_join","d":"Merge (join) two data frames, or a list of data frames. However, unlike\nbase R's merge(), data_merge() offers a few more methods to join data\nframes, and it does not drop data frame nor column attributes.\n","ec":"data_join(x, ...)"},{"p":"datawizard","o":"assign_labels","f":"hp_assign_labels","d":"Assign variable and values labels to a variable or variables in a data frame.\nLabels are stored as attributes (\"label\" for variable labels and \"labels\")\nfor value labels.\n","ec":"assign_labels(x, ...)"},{"p":"datawizard","o":"text_concatenate","f":"hp_text_concatenate","d":"Convenience functions to manipulate and format text.\n","ec":"text_concatenate(text, sep = \", \", last = \" and \", enclose = NULL)"},{"p":"datawizard","o":"categorize","f":"hp_categorize","d":"This functions divides the range of variables into intervals and recodes\nthe values inside these intervals according to their related interval.\nIt is basically a wrapper around base R's cut(), providing a simplified\nand more accessible way to define the interval breaks (cut-off values).\n","ec":"categorize(x, ...)"},{"p":"datawizard","o":"data_unique","f":"hp_data_unique","d":"From all rows with at least one duplicated ID,\nkeep only one. Methods for selecting the duplicated row are\neither the first duplicate, the last duplicate, or the \"best\"\nduplicate (default), based on the duplicate with the smallest\nnumber of NA. In case of ties, it picks the first\nduplicate, as it is the one most likely to be valid and\nauthentic, given practice effects.\n","ec":"data_unique(data, select = NULL, keep = \"best\", exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE)"},{"p":"datawizard","o":"weighted_median","f":"hp_weighted_median","d":"Weighted Mean, Median, SD, and MAD\n","ec":"weighted_median(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"to_factor","f":"hp_to_factor","d":"Convert data to factors\n","ec":"to_factor(x, ...)"},{"p":"datawizard","o":"text_lastchar","f":"hp_text_lastchar","d":"Convenience functions to manipulate and format text.\n","ec":"text_lastchar(text, n = 1)"},{"p":"datawizard","o":"labels_to_levels","f":"hp_labels_to_levels","d":"Convert value labels into factor levels\n","ec":"labels_to_levels(x, ...)"},{"p":"datawizard","o":"extract_column_names","f":"hp_extract_column_names","d":"extract_column_names() returns column names from a data set that\nmatch a certain search pattern, while data_select() returns the found data.\n","ec":"extract_column_names(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"text_wrap","f":"hp_text_wrap","d":"Convenience functions to manipulate and format text.\n","ec":"text_wrap(text, width = NULL, ...)"},{"p":"datawizard","o":"text_fullstop","f":"hp_text_fullstop","d":"Convenience functions to manipulate and format text.\n","ec":"text_fullstop(text)"},{"p":"datawizard","o":"data_write","f":"hp_data_write","d":"This functions imports data from various file types. It is a small wrapper\naround haven::read_spss(), haven::read_stata(), haven::read_sas(),\nreadxl::read_excel() and data.table::fread() resp. readr::read_delim()\n(the latter if package data.table is not installed). Thus, supported file\ntypes for importing data are data files from SPSS, SAS or Stata, Excel files\nor text files (like '.csv' files). All other file types are passed to\nrio::import(). data_write() works in a similar way.\n","ec":"data_write(data, path, delimiter = \",\", convert_factors = FALSE, save_labels = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_to_long","f":"hp_data_to_long","d":"This function \"lengthens\" data, increasing the number of rows and decreasing\nthe number of columns. This is a dependency-free base-R equivalent of\ntidyr::pivot_longer().\n","ec":"data_to_long(data, select = \"all\", names_to = \"name\", names_prefix = NULL, names_sep = NULL, names_pattern = NULL, values_to = \"value\", values_drop_na = FALSE, rows_to = NULL, ignore_case = FALSE, regex = FALSE, ..., cols)"},{"p":"datawizard","o":"convert_na_to","f":"hp_convert_na_to","d":"Replace missing values in a variable or a data frame.\n","ec":"convert_na_to(x, ...)"},{"p":"datawizard","o":"mean_sd","f":"hp_mean_sd","d":"Summary Helpers\n","ec":"mean_sd(x, times = 1L, remove_na = TRUE, named = TRUE, na.rm = TRUE, ...)"},{"p":"datawizard","o":"data_arrange","f":"hp_data_arrange","d":"data_arrange() orders the rows of a data frame by the values of selected\ncolumns.\n","ec":"data_arrange(data, select = NULL, safe = TRUE)"},{"p":"datawizard","o":"skewness","f":"hp_skewness","d":"Compute Skewness and (Excess) Kurtosis\n","ec":"skewness(x, ...)"},{"p":"datawizard","o":"weighted_sd","f":"hp_weighted_sd","d":"Weighted Mean, Median, SD, and MAD\n","ec":"weighted_sd(x, weights = NULL, remove_na = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"unstandardize","f":"hp_unstandardize","d":"Performs a standardization of data (z-scoring), i.e., centering and scaling,\nso that the data is expressed in terms of standard deviation (i.e., mean = 0,\nSD = 1) or Median Absolute Deviance (median = 0, MAD = 1). When applied to a\nstatistical model, this function extracts the dataset, standardizes it, and\nrefits the model with this standardized version of the dataset. The\nnormalize() function can also be used to scale all numeric variables within\nthe 0 - 1 range.\n\nFor model standardization, see standardize.default().\n","ec":"unstandardize(x, ...)"},{"p":"datawizard","o":"data_group","f":"hp_data_group","d":"This function is comparable to dplyr::group_by(), but just\nfollowing the datawizard function design. data_ungroup() removes the\ngrouping information from a grouped data frame.\n","ec":"data_group(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_remove","f":"hp_data_remove","d":"data_relocate() will reorder columns to specific positions, indicated by\nbefore or after. data_reorder() will instead move selected columns to\nthe beginning of a data frame. Finally, data_remove() removes columns\nfrom a data frame. All functions support select-helpers that allow flexible\nspecification of a search pattern to find matching columns, which should\nbe reordered or removed.\n","ec":"data_remove(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = FALSE, ...)"},{"p":"datawizard","o":"data_tabulate","f":"hp_data_tabulate","d":"This function creates frequency or crosstables of variables,\nincluding the number of levels/values as well as the distribution of raw,\nvalid and cumulative percentages. For crosstables, row, column  and cell\npercentages can be calculated.\n","ec":"data_tabulate(x, ...)"},{"p":"datawizard","o":"rescale_weights","f":"hp_rescale_weights","d":"Most functions to fit multilevel and mixed effects models only\nallow to specify frequency weights, but not design (i.e. sampling or\nprobability) weights, which should be used when analyzing complex samples\nand survey data. rescale_weights() implements an algorithm proposed\nby Asparouhov (2006) and Carle (2009) to rescale design\nweights in survey data to account for the grouping structure of multilevel\nmodels, which then can be used for multilevel modelling.\n","ec":"rescale_weights(data, by, probability_weights, nest = FALSE, group = NULL)"},{"p":"datawizard","o":"format_text","f":"hp_format_text","d":"Convenience functions to manipulate and format text.\n","ec":"format_text(text, sep = \", \", last = \" and \", width = NULL, enclose = NULL, ...)"},{"p":"datawizard","o":"data_relocate","f":"hp_data_relocate","d":"data_relocate() will reorder columns to specific positions, indicated by\nbefore or after. data_reorder() will instead move selected columns to\nthe beginning of a data frame. Finally, data_remove() removes columns\nfrom a data frame. All functions support select-helpers that allow flexible\nspecification of a search pattern to find matching columns, which should\nbe reordered or removed.\n","ec":"data_relocate(data, select, before = NULL, after = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"distribution_mode","f":"hp_distribution_mode","d":"Compute mode for a statistical distribution\n","ec":"distribution_mode(x)"},{"p":"datawizard","o":"reshape_wider","f":"hp_reshape_wider","d":"This function \"widens\" data, increasing the number of columns and decreasing\nthe number of rows. This is a dependency-free base-R equivalent of\ntidyr::pivot_wider().\n","ec":"reshape_wider(data, id_cols = NULL, values_from = \"Value\", names_from = \"Name\", names_sep = \"_\", names_prefix = \"\", names_glue = NULL, values_fill = NULL, verbose = TRUE, ...)"},{"p":"datawizard","o":"remove_empty_rows","f":"hp_remove_empty_rows","d":"These functions check which rows or columns of a data frame completely\ncontain missing values, i.e. which observations or variables completely have\nmissing values, and either (1) returns their indices; or (2) removes them\nfrom the data frame.\n","ec":"remove_empty_rows(x)"},{"p":"datawizard","o":"empty_columns","f":"hp_empty_columns","d":"These functions check which rows or columns of a data frame completely\ncontain missing values, i.e. which observations or variables completely have\nmissing values, and either (1) returns their indices; or (2) removes them\nfrom the data frame.\n","ec":"empty_columns(x)"},{"p":"datawizard","o":"row_means","f":"hp_row_means","d":"This function is similar to the SPSS MEAN.n function and computes\nrow means from a data frame or matrix if at least min_valid values of a row are\nvalid (and not NA).\n","ec":"row_means(data, select = NULL, exclude = NULL, min_valid = NULL, digits = NULL, ignore_case = FALSE, regex = FALSE, remove_na = FALSE, verbose = TRUE)"},{"p":"datawizard","o":"text_format","f":"hp_text_format","d":"Convenience functions to manipulate and format text.\n","ec":"text_format(text, sep = \", \", last = \" and \", width = NULL, enclose = NULL, ...)"},{"p":"datawizard","o":"visualisation_recipe","f":"hp_visualisation_recipe","d":"This function prepares objects for visualisation by returning a list of\nlayers with data and geoms that can be easily plotted using for instance\nggplot2.\n","ec":"visualisation_recipe(x, ...)"},{"p":"datawizard","o":"data_separate","f":"hp_data_separate","d":"Separates a single variable into multiple new variables.\n","ec":"data_separate(data, select = NULL, new_columns = NULL, separator = \"[^[:alnum:]]+\", guess_columns = NULL, merge_multiple = FALSE, merge_separator = \"\", fill = \"right\", extra = \"drop_right\", convert_na = TRUE, exclude = NULL, append = FALSE, ignore_case = FALSE, verbose = TRUE, regex = FALSE, ...)"},{"p":"datawizard","o":"data_reorder","f":"hp_data_reorder","d":"data_relocate() will reorder columns to specific positions, indicated by\nbefore or after. data_reorder() will instead move selected columns to\nthe beginning of a data frame. Finally, data_remove() removes columns\nfrom a data frame. All functions support select-helpers that allow flexible\nspecification of a search pattern to find matching columns, which should\nbe reordered or removed.\n","ec":"data_reorder(data, select, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"get_columns","f":"hp_get_columns","d":"extract_column_names() returns column names from a data set that\nmatch a certain search pattern, while data_select() returns the found data.\n","ec":"get_columns(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"row_to_colnames","f":"hp_row_to_colnames","d":"Tools for working with column names\n","ec":"row_to_colnames(x, row = 1, na_prefix = \"x\", verbose = TRUE)"},{"p":"datawizard","o":"coerce_to_numeric","f":"hp_coerce_to_numeric","d":"Tries to convert vector to numeric if possible (if no warnings or errors).\nOtherwise, leaves it as is.\n","ec":"coerce_to_numeric(x)"},{"p":"datawizard","o":"remove_empty_columns","f":"hp_remove_empty_columns","d":"These functions check which rows or columns of a data frame completely\ncontain missing values, i.e. which observations or variables completely have\nmissing values, and either (1) returns their indices; or (2) removes them\nfrom the data frame.\n","ec":"remove_empty_columns(x)"},{"p":"datawizard","o":"data_codebook","f":"hp_data_codebook","d":"data_codebook() generates codebooks from data frames, i.e. overviews\nof all variables and some more information about each variable (like\nlabels, values or value range, frequencies, amount of missing values).\n","ec":"data_codebook(data, select = NULL, exclude = NULL, variable_label_width = NULL, value_label_width = NULL, max_values = 10, range_at = 6, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_replicate","f":"hp_data_replicate","d":"Expand a data frame by replicating rows based on another variable that\ncontains the counts of replications per row.\n","ec":"data_replicate(data, expand = NULL, select = NULL, exclude = NULL, remove_na = FALSE, ignore_case = FALSE, verbose = TRUE, regex = FALSE, ...)"},{"p":"datawizard","o":"data_filter","f":"hp_data_filter","d":"Return a filtered (or sliced) data frame or row indices of a data frame that\nmatch a specific condition. data_filter() works like data_match(), but works\nwith logical expressions or row indices of a data frame to specify matching\nconditions.\n","ec":"data_filter(x, ...)"},{"p":"datawizard","o":"demean","f":"hp_demean","d":"demean() computes group- and de-meaned versions of a variable that can be\nused in regression analysis to model the between- and within-subject effect.\ndegroup() is more generic in terms of the centering-operation. While\ndemean() always uses mean-centering, degroup() can also use the mode or\nmedian for centering.\n","ec":"demean(x, select, by, nested = FALSE, suffix_demean = \"_within\", suffix_groupmean = \"_between\", add_attributes = TRUE, verbose = TRUE, group = NULL)"},{"p":"datawizard","o":"contr.deviation","f":"hp_contr.deviation","d":"Build a deviation contrast matrix, a type of effects contrast matrix.\n","ec":"contr.deviation(n, base = 1, contrasts = TRUE, sparse = FALSE)"},{"p":"datawizard","o":"degroup","f":"hp_degroup","d":"demean() computes group- and de-meaned versions of a variable that can be\nused in regression analysis to model the between- and within-subject effect.\ndegroup() is more generic in terms of the centering-operation. While\ndemean() always uses mean-centering, degroup() can also use the mode or\nmedian for centering.\n","ec":"degroup(x, select, by, nested = FALSE, center = \"mean\", suffix_demean = \"_within\", suffix_groupmean = \"_between\", add_attributes = TRUE, verbose = TRUE, group = NULL)"},{"p":"datawizard","o":"means_by_group","f":"hp_means_by_group","d":"Computes summary table of means by groups.\n","ec":"means_by_group(x, ...)"},{"p":"datawizard","o":"data_match","f":"hp_data_match","d":"Return a filtered (or sliced) data frame or row indices of a data frame that\nmatch a specific condition. data_filter() works like data_match(), but works\nwith logical expressions or row indices of a data frame to specify matching\nconditions.\n","ec":"data_match(x, to, match = \"and\", return_indices = FALSE, drop_na = TRUE, ...)"},{"p":"datawizard","o":"data_modify","f":"hp_data_modify","d":"Create new variables or modify existing variables in a data frame. Unlike base::transform(), data_modify()\ncan be used on grouped data frames, and newly created variables can be directly\nused.\n","ec":"data_modify(data, ...)"},{"p":"datawizard","o":"reshape_longer","f":"hp_reshape_longer","d":"This function \"lengthens\" data, increasing the number of rows and decreasing\nthe number of columns. This is a dependency-free base-R equivalent of\ntidyr::pivot_longer().\n","ec":"reshape_longer(data, select = \"all\", names_to = \"name\", names_prefix = NULL, names_sep = NULL, names_pattern = NULL, values_to = \"value\", values_drop_na = FALSE, rows_to = NULL, ignore_case = FALSE, regex = FALSE, ..., cols)"},{"p":"datawizard","o":"replace_nan_inf","f":"hp_replace_nan_inf","d":"Replaces all infinite (Inf and -Inf) or NaN values with NA.\n","ec":"replace_nan_inf(x, ...)"},{"p":"datawizard","o":"column_as_rownames","f":"hp_column_as_rownames","d":"Tools for working with row names or row ids\n","ec":"column_as_rownames(x, var = \"rowname\")"},{"p":"datawizard","o":"kurtosis","f":"hp_kurtosis","d":"Compute Skewness and (Excess) Kurtosis\n","ec":"kurtosis(x, ...)"},{"p":"datawizard","o":"data_ungroup","f":"hp_data_ungroup","d":"This function is comparable to dplyr::group_by(), but just\nfollowing the datawizard function design. data_ungroup() removes the\ngrouping information from a grouped data frame.\n","ec":"data_ungroup(data, verbose = TRUE, ...)"},{"p":"datawizard","o":"standardise","f":"hp_standardise","d":"Performs a standardization of data (z-scoring), i.e., centering and scaling,\nso that the data is expressed in terms of standard deviation (i.e., mean = 0,\nSD = 1) or Median Absolute Deviance (median = 0, MAD = 1). When applied to a\nstatistical model, this function extracts the dataset, standardizes it, and\nrefits the model with this standardized version of the dataset. The\nnormalize() function can also be used to scale all numeric variables within\nthe 0 - 1 range.\n\nFor model standardization, see standardize.default().\n","ec":"standardise(x, ...)"},{"p":"datawizard","o":"ranktransform","f":"hp_ranktransform","d":"Transform numeric values with the integers of their rank (i.e., 1st smallest,\n2nd smallest, 3rd smallest, etc.). Setting the sign argument to TRUE will\ngive you signed ranks, where the ranking is done according to absolute size\nbut where the sign is preserved (i.e., 2, 1, -3, 4).\n","ec":"ranktransform(x, ...)"},{"p":"datawizard","o":"data_unite","f":"hp_data_unite","d":"Merge values of multiple variables per observation into one new variable.\n","ec":"data_unite(data, new_column = NULL, select = NULL, exclude = NULL, separator = \"_\", append = FALSE, remove_na = FALSE, ignore_case = FALSE, verbose = TRUE, regex = FALSE, ...)"},{"p":"datawizard","o":"recode_values","f":"hp_recode_values","d":"This functions recodes old values into new values and can be used to to\nrecode numeric or character vectors, or factors.\n","ec":"recode_values(x, ...)"},{"p":"datawizard","o":"data_seek","f":"hp_data_seek","d":"This functions seeks variables in a data frame, based on patterns\nthat either match the variable name (column name), variable labels, value labels\nor factor levels. Matching variable and value labels only works for \"labelled\"\ndata, i.e. when the variables either have a label attribute or labels\nattribute.\n","ec":"data_seek(data, pattern, seek = c(\"names\", \"labels\"), fuzzy = FALSE)"},{"p":"datawizard","o":"empty_rows","f":"hp_empty_rows","d":"These functions check which rows or columns of a data frame completely\ncontain missing values, i.e. which observations or variables completely have\nmissing values, and either (1) returns their indices; or (2) removes them\nfrom the data frame.\n","ec":"empty_rows(x)"},{"p":"datawizard","o":"data_select","f":"hp_data_select","d":"extract_column_names() returns column names from a data set that\nmatch a certain search pattern, while data_select() returns the found data.\n","ec":"data_select(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"adjust","f":"hp_adjust","d":"This function can be used to adjust the data for the effect of other\nvariables present in the dataset. It is based on an underlying fitting of\nregressions models, allowing for quite some flexibility, such as including\nfactors as random effects in mixed models (multilevel partialization),\ncontinuous variables as smooth terms in general additive models (non-linear\npartialization) and/or fitting these models under a Bayesian framework. The\nvalues returned by this function are the residuals of the regression models.\nNote that a regular correlation between two \"adjusted\" variables is\nequivalent to the partial correlation between them.\n","ec":"adjust(data, effect = NULL, select = is.numeric, exclude = NULL, multilevel = FALSE, additive = FALSE, bayesian = FALSE, keep_intercept = FALSE, ignore_case = FALSE, regex = FALSE, verbose = FALSE)"},{"p":"datawizard","o":"data_duplicated","f":"hp_data_duplicated","d":"Extract all duplicates, for visual inspection.\nNote that it also contains the first occurrence of future\nduplicates, unlike duplicated() or dplyr::distinct()). Also\ncontains an additional column reporting the number of missing\nvalues for that row, to help in the decision-making when\nselecting which duplicates to keep.\n","ec":"data_duplicated(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE)"},{"p":"datawizard","o":"unnormalize","f":"hp_unnormalize","d":"Performs a normalization of data, i.e., it scales variables in the range\n0 - 1. This is a special case of rescale(). unnormalize() is the\ncounterpart, but only works for variables that have been normalized with\nnormalize().\n","ec":"unnormalize(x, ...)"},{"p":"datawizard","o":"change_scale","f":"hp_change_scale","d":"Rescale variables to a new range. Can also be used to reverse-score variables\n(change the keying/scoring direction), or to expand a range.\n","ec":"change_scale(x, ...)"},{"p":"datawizard","o":"normalize","f":"hp_normalize","d":"Performs a normalization of data, i.e., it scales variables in the range\n0 - 1. This is a special case of rescale(). unnormalize() is the\ncounterpart, but only works for variables that have been normalized with\nnormalize().\n","ec":"normalize(x, ...)"},{"p":"datawizard","o":"data_restoretype","f":"hp_data_restoretype","d":"Restore the type of columns according to a reference data frame\n","ec":"data_restoretype(data, reference = NULL, ...)"},{"p":"datawizard","o":"to_numeric","f":"hp_to_numeric","d":"Convert data to numeric by converting characters to factors and factors to\neither numeric levels or dummy variables. The \"counterpart\" to convert\nvariables into factors is to_factor().\n","ec":"to_numeric(x, ...)"},{"p":"datawizard","o":"data_adjust","f":"hp_data_adjust","d":"This function can be used to adjust the data for the effect of other\nvariables present in the dataset. It is based on an underlying fitting of\nregressions models, allowing for quite some flexibility, such as including\nfactors as random effects in mixed models (multilevel partialization),\ncontinuous variables as smooth terms in general additive models (non-linear\npartialization) and/or fitting these models under a Bayesian framework. The\nvalues returned by this function are the residuals of the regression models.\nNote that a regular correlation between two \"adjusted\" variables is\nequivalent to the partial correlation between them.\n","ec":"data_adjust(data, effect = NULL, select = is.numeric, exclude = NULL, multilevel = FALSE, additive = FALSE, bayesian = FALSE, keep_intercept = FALSE, ignore_case = FALSE, regex = FALSE, verbose = FALSE)"},{"p":"datawizard","o":"text_paste","f":"hp_text_paste","d":"Convenience functions to manipulate and format text.\n","ec":"text_paste(text, text2 = NULL, sep = \", \", enclose = NULL, ...)"},{"p":"datawizard","o":"remove_empty","f":"hp_remove_empty","d":"These functions check which rows or columns of a data frame completely\ncontain missing values, i.e. which observations or variables completely have\nmissing values, and either (1) returns their indices; or (2) removes them\nfrom the data frame.\n","ec":"remove_empty(x)"},{"p":"datawizard","o":"data_rotate","f":"hp_data_rotate","d":"This function rotates a data frame, i.e. columns become rows and vice versa.\nIt's the equivalent of using t() but restores the data.frame class,\npreserves attributes and prints a warning if the data type is\nmodified (see example).\n","ec":"data_rotate(data, rownames = NULL, colnames = FALSE, verbose = TRUE)"},{"p":"datawizard","o":"data_merge","f":"hp_data_merge","d":"Merge (join) two data frames, or a list of data frames. However, unlike\nbase R's merge(), data_merge() offers a few more methods to join data\nframes, and it does not drop data frame nor column attributes.\n","ec":"data_merge(x, ...)"},{"p":"datawizard","o":"data_rename","f":"hp_data_rename","d":"Safe and intuitive functions to rename variables or rows in\ndata frames. data_rename() will rename column names, i.e. it facilitates\nrenaming variables data_addprefix() or data_addsuffix() add prefixes\nor suffixes to column names. data_rename_rows() is a convenient shortcut\nto add or rename row names of a data frame, but unlike row.names(), its\ninput and output is a data frame, thus, integrating smoothly into a possible\npipe-workflow.\n","ec":"data_rename(data, pattern = NULL, replacement = NULL, safe = TRUE, verbose = TRUE, ...)"},{"p":"datawizard","o":"find_columns","f":"hp_find_columns","d":"extract_column_names() returns column names from a data set that\nmatch a certain search pattern, while data_select() returns the found data.\n","ec":"find_columns(data, select = NULL, exclude = NULL, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"unstandardise","f":"hp_unstandardise","d":"Performs a standardization of data (z-scoring), i.e., centering and scaling,\nso that the data is expressed in terms of standard deviation (i.e., mean = 0,\nSD = 1) or Median Absolute Deviance (median = 0, MAD = 1). When applied to a\nstatistical model, this function extracts the dataset, standardizes it, and\nrefits the model with this standardized version of the dataset. The\nnormalize() function can also be used to scale all numeric variables within\nthe 0 - 1 range.\n\nFor model standardization, see standardize.default().\n","ec":"unstandardise(x, ...)"},{"p":"datawizard","o":"data_peek","f":"hp_data_peek","d":"This function creates a table a data frame, showing all\ncolumn names, variable types and the first values (as many as fit into\nthe screen).\n","ec":"data_peek(x, ...)"},{"p":"datawizard","o":"data_rename_rows","f":"hp_data_rename_rows","d":"Safe and intuitive functions to rename variables or rows in\ndata frames. data_rename() will rename column names, i.e. it facilitates\nrenaming variables data_addprefix() or data_addsuffix() add prefixes\nor suffixes to column names. data_rename_rows() is a convenient shortcut\nto add or rename row names of a data frame, but unlike row.names(), its\ninput and output is a data frame, thus, integrating smoothly into a possible\npipe-workflow.\n","ec":"data_rename_rows(data, rows = NULL)"},{"p":"datawizard","o":"text_remove","f":"hp_text_remove","d":"Convenience functions to manipulate and format text.\n","ec":"text_remove(text, pattern = \"\", ...)"},{"p":"datawizard","o":"standardize","f":"hp_standardize","d":"Performs a standardization of data (z-scoring), i.e., centering and scaling,\nso that the data is expressed in terms of standard deviation (i.e., mean = 0,\nSD = 1) or Median Absolute Deviance (median = 0, MAD = 1). When applied to a\nstatistical model, this function extracts the dataset, standardizes it, and\nrefits the model with this standardized version of the dataset. The\nnormalize() function can also be used to scale all numeric variables within\nthe 0 - 1 range.\n\nFor model standardization, see standardize.default().\n","ec":"standardize(x, ...)"},{"p":"datawizard","o":"change_code","f":"hp_change_code","d":"This functions recodes old values into new values and can be used to to\nrecode numeric or character vectors, or factors.\n","ec":"change_code(x, select = NULL, exclude = NULL, recode = NULL, default = NULL, preserve_na = TRUE, append = FALSE, ignore_case = FALSE, regex = FALSE, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_transpose","f":"hp_data_transpose","d":"This function rotates a data frame, i.e. columns become rows and vice versa.\nIt's the equivalent of using t() but restores the data.frame class,\npreserves attributes and prints a warning if the data type is\nmodified (see example).\n","ec":"data_transpose(data, rownames = NULL, colnames = FALSE, verbose = TRUE)"},{"p":"datawizard","o":"coef_var","f":"hp_coef_var","d":"Compute the coefficient of variation (CV, ratio of the standard deviation to\nthe mean, \\sigma/\\mu) for a set of numeric values.\n","ec":"coef_var(x, ...)"},{"p":"datawizard","o":"data_to_wide","f":"hp_data_to_wide","d":"This function \"widens\" data, increasing the number of columns and decreasing\nthe number of rows. This is a dependency-free base-R equivalent of\ntidyr::pivot_wider().\n","ec":"data_to_wide(data, id_cols = NULL, values_from = \"Value\", names_from = \"Name\", names_sep = \"_\", names_prefix = \"\", names_glue = NULL, values_fill = NULL, verbose = TRUE, ...)"},{"p":"datawizard","o":"data_summary","f":"hp_data_summary","d":"This function can be used to compute summary statistics for a\ndata frame or a matrix.\n","ec":"data_summary(x, ...)"},{"p":"datawizard","o":"recode_into","f":"hp_recode_into","d":"This functions recodes values from one or more variables into a new variable.\nIt is a convenient function to avoid nested ifelse() statements, which\nis similar to dplyr::case_when().\n","ec":"recode_into(..., data = NULL, default = NA, overwrite = TRUE, preserve_na = FALSE, verbose = TRUE)"},{"p":"dplyr","o":"slice_max","f":"hp_slice_max","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice_max(.data, order_by, ..., n, prop, by = NULL, with_ties = TRUE, na_rm = FALSE)"},{"p":"dplyr","o":"src","f":"hp_src","d":"src() is the standard constructor for srcs and is.src() tests.\n","ec":"src(subclass, ...)"},{"p":"dplyr","o":"db_desc","f":"hp_db_desc","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_desc(x)"},{"p":"dplyr","o":"group_by_drop_default","f":"hp_group_by_drop_default","d":"Default value for .drop argument of group_by\n","ec":"group_by_drop_default(.tbl)"},{"p":"dplyr","o":"db_commit","f":"hp_db_commit","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_commit(con, ...)"},{"p":"dplyr","o":"coalesce","f":"hp_coalesce","d":"Given a set of vectors, coalesce() finds the first non-missing value at\neach position. It's inspired by the SQL COALESCE function which does the\nsame thing for SQL NULLs.\n","ec":"coalesce(..., .ptype = NULL, .size = NULL)"},{"p":"dplyr","o":"summarize_if","f":"hp_summarize_if","d":"\n","ec":"summarize_if(.tbl, .predicate, .funs, ...)"},{"p":"dplyr","o":"mutate_","f":"hp_mutate_","d":"\n","ec":"mutate_(.data, ..., .dots = list())"},{"p":"dplyr","o":"db_create_index","f":"hp_db_create_index","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_create_index(con, table, columns, name = NULL, unique = FALSE, ...)"},{"p":"dplyr","o":"join_by","f":"hp_join_by","d":"join_by() constructs a specification that describes how to join two tables\nusing a small domain specific language. The result can be supplied as the\nby argument to any of the join functions (such as left_join()).\n","ec":"join_by(...)"},{"p":"dplyr","o":"check_dbplyr","f":"hp_check_dbplyr","d":"In dplyr 0.7.0, a number of database and SQL functions moved from dplyr to\ndbplyr. The generic functions stayed in dplyr (since there is no easy way\nto conditionally import a generic from different packages), but many other\nSQL and database helper functions moved. If you have written a backend,\nthese functions generate the code you need to work with both dplyr 0.5.0\ndplyr 0.7.0.\n","ec":"check_dbplyr()"},{"p":"dplyr","o":"src_tbls","f":"hp_src_tbls","d":"This is a generic method which individual src's will provide methods for.\nMost methods will not be documented because it's usually pretty obvious what\npossible results will be.\n","ec":"src_tbls(x, ...)"},{"p":"dplyr","o":"db_query_rows","f":"hp_db_query_rows","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_query_rows(con, sql, ...)"},{"p":"dplyr","o":"dense_rank","f":"hp_dense_rank","d":"Three ranking functions inspired by SQL2003. They differ primarily in how\nthey handle ties:\n","ec":"dense_rank(x)"},{"p":"dplyr","o":"slice_head","f":"hp_slice_head","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice_head(.data, ..., n, prop, by = NULL)"},{"p":"dplyr","o":"tbl","f":"hp_tbl","d":"This is a generic method that dispatches based on the first argument.\n","ec":"tbl(src, ...)"},{"p":"dplyr","o":"consecutive_id","f":"hp_consecutive_id","d":"consecutive_id() generates a unique identifier that increments every time\na variable (or combination of variables) changes. Inspired by\ndata.table::rleid().\n","ec":"consecutive_id(...)"},{"p":"dplyr","o":"first","f":"hp_first","d":"These are useful helpers for extracting a single value from a vector. They\nare guaranteed to return a meaningful value, even when the input is shorter\nthan expected. You can also provide an optional secondary vector that defines\nthe ordering.\n","ec":"first(x, order_by = NULL, default = NULL, na_rm = FALSE)"},{"p":"dplyr","o":"arrange","f":"hp_arrange","d":"arrange() orders the rows of a data frame by the values of selected\ncolumns.\n","ec":"arrange(.data, ..., .by_group = FALSE)"},{"p":"dplyr","o":"dplyr_row_slice","f":"hp_dplyr_row_slice","d":"\n","ec":"dplyr_row_slice(data, i, ...)"},{"p":"dplyr","o":"sql_semi_join","f":"hp_sql_semi_join","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_semi_join(con, x, y, anti = FALSE, by = NULL, ...)"},{"p":"dplyr","o":"is.grouped_df","f":"hp_is.grouped_df","d":"The easiest way to create a grouped data frame is to call the group_by()\nmethod on a data frame or tbl: this will take care of capturing\nthe unevaluated expressions for you.\n","ec":"is.grouped_df(x)"},{"p":"dplyr","o":"summarise_each","f":"hp_summarise_each","d":"\n","ec":"summarise_each(tbl, funs, ...)"},{"p":"dplyr","o":"group_vars","f":"hp_group_vars","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_vars(x)"},{"p":"dplyr","o":"bind_cols","f":"hp_bind_cols","d":"Bind any number of data frames by column, making a wider result.\nThis is similar to do.call(cbind, dfs).\n","ec":"bind_cols(..., .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\"))"},{"p":"dplyr","o":"last_dplyr_warnings","f":"hp_last_dplyr_warnings","d":"Warnings that occur inside a dplyr verb like mutate() are caught\nand stashed away instead of being emitted to the console. This\nprevents rowwise and grouped data frames from flooding the console\nwith warnings. To see the original warnings, use\nlast_dplyr_warnings().\n","ec":"last_dplyr_warnings(n = 5)"},{"p":"dplyr","o":"distinct_at","f":"hp_distinct_at","d":"\n","ec":"distinct_at(.tbl, .vars, .funs = list(), ..., .keep_all = FALSE)"},{"p":"dplyr","o":"mutate_all","f":"hp_mutate_all","d":"\n","ec":"mutate_all(.tbl, .funs, ...)"},{"p":"dplyr","o":"relocate","f":"hp_relocate","d":"Use relocate() to change column positions, using the same syntax as\nselect() to make it easy to move blocks of columns at once.\n","ec":"relocate(.data, ..., .before = NULL, .after = NULL)"},{"p":"dplyr","o":"compute","f":"hp_compute","d":"compute() stores results in a remote temporary table.\ncollect() retrieves data into a local tibble.\ncollapse() is slightly different: it doesn't force computation, but\ninstead forces generation of the SQL query. This is sometimes needed to work\naround bugs in dplyr's SQL generation.\n","ec":"compute(x, ...)"},{"p":"dplyr","o":"mutate_if","f":"hp_mutate_if","d":"\n","ec":"mutate_if(.tbl, .predicate, .funs, ...)"},{"p":"dplyr","o":"distinct_","f":"hp_distinct_","d":"\n","ec":"distinct_(.data, ..., .dots, .keep_all = FALSE)"},{"p":"dplyr","o":"group_indices_","f":"hp_group_indices_","d":"\n","ec":"group_indices_(.data, ..., .dots = list())"},{"p":"dplyr","o":"eval_tbls2","f":"hp_eval_tbls2","d":"\n","ec":"eval_tbls2(tbls_x, tbls_y, op)"},{"p":"dplyr","o":"rename_all","f":"hp_rename_all","d":"\n","ec":"rename_all(.tbl, .funs = list(), ...)"},{"p":"dplyr","o":"count","f":"hp_count","d":"count() lets you quickly count the unique values of one or more variables:\ndf %>% count(a, b) is roughly equivalent to\ndf %>% group_by(a, b) %>% summarise(n = n()).\ncount() is paired with tally(), a lower-level helper that is equivalent\nto df %>% summarise(n = n()). Supply wt to perform weighted counts,\nswitching the summary from n = n() to n = sum(wt).\n","ec":"count(x, ..., wt = NULL, sort = FALSE, name = NULL)"},{"p":"dplyr","o":"do_","f":"hp_do_","d":"\n","ec":"do_(.data, ..., .dots = list())"},{"p":"dplyr","o":"do","f":"hp_do","d":"\n","ec":"do(.data, ...)"},{"p":"dplyr","o":"cumany","f":"hp_cumany","d":"dplyr provides cumall(), cumany(), and cummean() to complete R's set\nof cumulative functions.\n","ec":"cumany(x)"},{"p":"dplyr","o":"wrap_dbplyr_obj","f":"hp_wrap_dbplyr_obj","d":"In dplyr 0.7.0, a number of database and SQL functions moved from dplyr to\ndbplyr. The generic functions stayed in dplyr (since there is no easy way\nto conditionally import a generic from different packages), but many other\nSQL and database helper functions moved. If you have written a backend,\nthese functions generate the code you need to work with both dplyr 0.5.0\ndplyr 0.7.0.\n","ec":"wrap_dbplyr_obj(obj_name)"},{"p":"dplyr","o":"recode_factor","f":"hp_recode_factor","d":"\n","ec":"recode_factor(.x, ..., .default = NULL, .missing = NULL, .ordered = FALSE)"},{"p":"dplyr","o":"same_src","f":"hp_same_src","d":"Figure out if two sources are the same (or two tbl have the same source)\n","ec":"same_src(x, y)"},{"p":"dplyr","o":"top_frac","f":"hp_top_frac","d":"\ntop_n() has been superseded in favour of slice_min()/slice_max().\nWhile it will not be deprecated in the near future, retirement means\nthat we will only perform critical bug fixes, so we recommend moving to the\nnewer alternatives.\n","ec":"top_frac(x, n, wt)"},{"p":"dplyr","o":"select_vars","f":"hp_select_vars","d":"\n","ec":"select_vars(vars = chr(), ..., include = chr(), exclude = chr())"},{"p":"dplyr","o":"desc","f":"hp_desc","d":"Transform a vector into a format that will be sorted in descending order.\nThis is useful within arrange().\n","ec":"desc(x)"},{"p":"dplyr","o":"db_create_indexes","f":"hp_db_create_indexes","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_create_indexes(con, table, indexes = NULL, unique = FALSE, ...)"},{"p":"dplyr","o":"lead","f":"hp_lead","d":"Find the \"previous\" (lag()) or \"next\" (lead()) values in a vector. Useful\nfor comparing values behind of or ahead of the current values.\n","ec":"lead(x, n = 1L, default = NULL, order_by = NULL, ...)"},{"p":"dplyr","o":"mutate_at","f":"hp_mutate_at","d":"\n","ec":"mutate_at(.tbl, .vars, .funs, ..., .cols = NULL)"},{"p":"dplyr","o":"distinct_prepare","f":"hp_distinct_prepare","d":"<U+2060>*_prepare()<U+2060> performs standard manipulation that is needed prior\nto actual data processing. They are only be needed by packages\nthat implement dplyr backends.\n","ec":"distinct_prepare(.data, vars, group_vars = character(), .keep_all = FALSE, caller_env = caller_env(2), error_call = caller_env())"},{"p":"dplyr","o":"src_sqlite","f":"hp_src_sqlite","d":"\n","ec":"src_sqlite(path, create = FALSE)"},{"p":"dplyr","o":"distinct_if","f":"hp_distinct_if","d":"\n","ec":"distinct_if(.tbl, .predicate, .funs = list(), ..., .keep_all = FALSE)"},{"p":"dplyr","o":"cur_column","f":"hp_cur_column","d":"These functions return information about the \"current\" group or \"current\"\nvariable, so only work inside specific contexts like summarise() and\nmutate().\n","ec":"cur_column()"},{"p":"dplyr","o":"semi_join","f":"hp_semi_join","d":"Filtering joins filter rows from x based on the presence or absence\nof matches in y:\n","ec":"semi_join(x, y, by = NULL, copy = FALSE, ...)"},{"p":"dplyr","o":"filter_if","f":"hp_filter_if","d":"\n","ec":"filter_if(.tbl, .predicate, .vars_predicate, .preserve = FALSE)"},{"p":"dplyr","o":"sql_translate_env","f":"hp_sql_translate_env","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_translate_env(con)"},{"p":"dplyr","o":"arrange_","f":"hp_arrange_","d":"\n","ec":"arrange_(.data, ..., .dots = list())"},{"p":"dplyr","o":"case_match","f":"hp_case_match","d":"This function allows you to vectorise multiple switch() statements. Each\ncase is evaluated sequentially and the first match for each element\ndetermines the corresponding value in the output vector. If no cases match,\nthe .default is used.\n","ec":"case_match(.x, ..., .default = NULL, .ptype = NULL)"},{"p":"dplyr","o":"sql_set_op","f":"hp_sql_set_op","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_set_op(con, x, y, method)"},{"p":"dplyr","o":"eval_tbls","f":"hp_eval_tbls","d":"\n","ec":"eval_tbls(tbls, op)"},{"p":"dplyr","o":"arrange_at","f":"hp_arrange_at","d":"\n","ec":"arrange_at(.tbl, .vars, .funs = list(), ..., .by_group = FALSE, .locale = NULL)"},{"p":"dplyr","o":"add_count","f":"hp_add_count","d":"count() lets you quickly count the unique values of one or more variables:\ndf %>% count(a, b) is roughly equivalent to\ndf %>% group_by(a, b) %>% summarise(n = n()).\ncount() is paired with tally(), a lower-level helper that is equivalent\nto df %>% summarise(n = n()). Supply wt to perform weighted counts,\nswitching the summary from n = n() to n = sum(wt).\n","ec":"add_count(x, ..., wt = NULL, sort = FALSE, name = NULL, .drop = deprecated())"},{"p":"dplyr","o":"dplyr_reconstruct","f":"hp_dplyr_reconstruct","d":"\n","ec":"dplyr_reconstruct(data, template)"},{"p":"dplyr","o":"slice_min","f":"hp_slice_min","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice_min(.data, order_by, ..., n, prop, by = NULL, with_ties = TRUE, na_rm = FALSE)"},{"p":"dplyr","o":"new_rowwise_df","f":"hp_new_rowwise_df","d":"new_grouped_df() and new_rowwise_df() are constructors designed to be high-performance so only\ncheck types, not values. This means it is the caller's responsibility\nto create valid values, and hence this is for expert use only.\n","ec":"new_rowwise_df(data, group_data = NULL, ..., class = character())"},{"p":"dplyr","o":"cross_join","f":"hp_cross_join","d":"Cross joins match each row in x to every row in y, resulting in a data\nframe with nrow(x) * nrow(y) rows.\n","ec":"cross_join(x, y, ..., copy = FALSE, suffix = c(\".x\", \".y\"))"},{"p":"dplyr","o":"select","f":"hp_select","d":"Select (and optionally rename) variables in a data frame, using a concise\nmini-language that makes it easy to refer to variables based on their name\n(e.g. a:f selects all columns from a on the left to f on the\nright) or type (e.g. where(is.numeric) selects all numeric columns).\n","ec":"select(.data, ...)"},{"p":"dplyr","o":"distinct_all","f":"hp_distinct_all","d":"\n","ec":"distinct_all(.tbl, .funs = list(), ..., .keep_all = FALSE)"},{"p":"dplyr","o":"src_local","f":"hp_src_local","d":"\nThis function was deprecated since it existed to support a style of testing\ndplyr backends that turned out not to be useful.\n","ec":"src_local(tbl, pkg = NULL, env = NULL)"},{"p":"dplyr","o":"as.tbl","f":"hp_as.tbl","d":"\nPlease use tibble::as_tibble() instead.\n","ec":"as.tbl(x, ...)"},{"p":"dplyr","o":"summarise","f":"hp_summarise","d":"summarise() creates a new data frame. It returns one row for each\ncombination of grouping variables; if there are no grouping variables, the\noutput will have a single row summarising all observations in the input. It\nwill contain one column for each grouping variable and one column for each of\nthe summary statistics that you have specified.\n","ec":"summarise(.data, ..., .by = NULL, .groups = NULL)"},{"p":"dplyr","o":"db_drop_table","f":"hp_db_drop_table","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_drop_table(con, table, force = FALSE, ...)"},{"p":"dplyr","o":"rows_patch","f":"hp_rows_patch","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_patch(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"cur_data","f":"hp_cur_data","d":"\n","ec":"cur_data()"},{"p":"dplyr","o":"row_number","f":"hp_row_number","d":"Three ranking functions inspired by SQL2003. They differ primarily in how\nthey handle ties:\n","ec":"row_number(x)"},{"p":"dplyr","o":"groups","f":"hp_groups","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"groups(x)"},{"p":"dplyr","o":"anti_join","f":"hp_anti_join","d":"Filtering joins filter rows from x based on the presence or absence\nof matches in y:\n","ec":"anti_join(x, y, by = NULL, copy = FALSE, ...)"},{"p":"dplyr","o":"tbl_vars","f":"hp_tbl_vars","d":"tbl_vars() returns all variables while tbl_nongroup_vars()\nreturns only non-grouping variables. The groups attribute\nof the object returned by tbl_vars() is a character vector of the\ngrouping columns.\n","ec":"tbl_vars(x)"},{"p":"dplyr","o":"cur_group_id","f":"hp_cur_group_id","d":"These functions return information about the \"current\" group or \"current\"\nvariable, so only work inside specific contexts like summarise() and\nmutate().\n","ec":"cur_group_id()"},{"p":"dplyr","o":"auto_copy","f":"hp_auto_copy","d":"Copy tables to same source, if necessary\n","ec":"auto_copy(x, y, copy = FALSE, ...)"},{"p":"dplyr","o":"sql_subquery","f":"hp_sql_subquery","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_subquery(con, from, name = random_table_name(), ...)"},{"p":"dplyr","o":"group_indices","f":"hp_group_indices","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_indices(.data, ...)"},{"p":"dplyr","o":"progress_estimated","f":"hp_progress_estimated","d":"\n","ec":"progress_estimated(n, min_time = 0)"},{"p":"dplyr","o":"transmute_all","f":"hp_transmute_all","d":"\n","ec":"transmute_all(.tbl, .funs, ...)"},{"p":"dplyr","o":"new_grouped_df","f":"hp_new_grouped_df","d":"new_grouped_df() and new_rowwise_df() are constructors designed to be high-performance so only\ncheck types, not values. This means it is the caller's responsibility\nto create valid values, and hence this is for expert use only.\n","ec":"new_grouped_df(x, groups, ..., class = character())"},{"p":"dplyr","o":"add_tally_","f":"hp_add_tally_","d":"\n","ec":"add_tally_(x, wt, sort = FALSE)"},{"p":"dplyr","o":"group_data","f":"hp_group_data","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_data(.data)"},{"p":"dplyr","o":"rows_insert","f":"hp_rows_insert","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_insert(x, y, by = NULL, ..., conflict = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"all_equal","f":"hp_all_equal","d":"\n","ec":"all_equal(target, current, ignore_col_order = TRUE, ignore_row_order = TRUE, convert = FALSE, ...)"},{"p":"dplyr","o":"group_split","f":"hp_group_split","d":"\n","ec":"group_split(.tbl, ..., .keep = TRUE)"},{"p":"dplyr","o":"tbl_ptype","f":"hp_tbl_ptype","d":"Used in <U+2060>_if<U+2060> functions to enable type-based selection even when the data\nis lazily generated. Should either return the complete tibble, or if that\ncan not be computed quickly, a 0-row tibble where the columns are of\nthe correct type.\n","ec":"tbl_ptype(.data)"},{"p":"dplyr","o":"inner_join","f":"hp_inner_join","d":"Mutating joins add columns from y to x, matching observations based on\nthe keys. There are four mutating joins: the inner join, and the three outer\njoins.\n","ec":"inner_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ..., keep = NULL)"},{"p":"dplyr","o":"db_insert_into","f":"hp_db_insert_into","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_insert_into(con, table, values, ...)"},{"p":"dplyr","o":"db_save_query","f":"hp_db_save_query","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_save_query(con, sql, name, temporary = TRUE, ...)"},{"p":"dplyr","o":"id","f":"hp_id","d":"\n","ec":"id(.variables, drop = FALSE)"},{"p":"dplyr","o":"summarise_all","f":"hp_summarise_all","d":"\n","ec":"summarise_all(.tbl, .funs, ...)"},{"p":"dplyr","o":"db_begin","f":"hp_db_begin","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_begin(con, ...)"},{"p":"dplyr","o":"left_join","f":"hp_left_join","d":"Mutating joins add columns from y to x, matching observations based on\nthe keys. There are four mutating joins: the inner join, and the three outer\njoins.\n","ec":"left_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ..., keep = NULL)"},{"p":"dplyr","o":"summarize_each_","f":"hp_summarize_each_","d":"\n","ec":"summarize_each_(tbl, funs, vars)"},{"p":"dplyr","o":"dplyr_col_modify","f":"hp_dplyr_col_modify","d":"\n","ec":"dplyr_col_modify(data, cols)"},{"p":"dplyr","o":"compare_tbls2","f":"hp_compare_tbls2","d":"\n","ec":"compare_tbls2(tbls_x, tbls_y, op, ref = NULL, compare = equal_data_frame, ...)"},{"p":"dplyr","o":"filter","f":"hp_filter","d":"The filter() function is used to subset a data frame,\nretaining all rows that satisfy your conditions.\nTo be retained, the row must produce a value of TRUE for all conditions.\nNote that when a condition evaluates to NA\nthe row will be dropped, unlike base subsetting with [.\n","ec":"filter(.data, ..., .by = NULL, .preserve = FALSE)"},{"p":"dplyr","o":"union_all","f":"hp_union_all","d":"Perform set operations using the rows of a data frame.\n","ec":"union_all(x, y, ...)"},{"p":"dplyr","o":"summarize_all","f":"hp_summarize_all","d":"\n","ec":"summarize_all(.tbl, .funs, ...)"},{"p":"dplyr","o":"slice_tail","f":"hp_slice_tail","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice_tail(.data, ..., n, prop, by = NULL)"},{"p":"dplyr","o":"n","f":"hp_n","d":"These functions return information about the \"current\" group or \"current\"\nvariable, so only work inside specific contexts like summarise() and\nmutate().\n","ec":"n()"},{"p":"dplyr","o":"add_count_","f":"hp_add_count_","d":"\n","ec":"add_count_(x, vars, wt = NULL, sort = FALSE)"},{"p":"dplyr","o":"summarize_each","f":"hp_summarize_each","d":"\n","ec":"summarize_each(tbl, funs, ...)"},{"p":"dplyr","o":"show_query","f":"hp_show_query","d":"This is a generic function which gives more details about an object than\nprint(), and is more focused on human readable output than\nstr().\n","ec":"show_query(x, ...)"},{"p":"dplyr","o":"group_cols","f":"hp_group_cols","d":"This selection helpers matches grouping variables. It can be used\nin select() or vars() selections.\n","ec":"group_cols(vars = NULL, data = NULL)"},{"p":"dplyr","o":"summarise_at","f":"hp_summarise_at","d":"\n","ec":"summarise_at(.tbl, .vars, .funs, ..., .cols = NULL)"},{"p":"dplyr","o":"n_distinct","f":"hp_n_distinct","d":"n_distinct() counts the number of unique/distinct combinations in a set\nof one or more vectors. It's a faster and more concise equivalent to\nnrow(unique(data.frame(...))).\n","ec":"n_distinct(..., na.rm = FALSE)"},{"p":"dplyr","o":"transmute_at","f":"hp_transmute_at","d":"\n","ec":"transmute_at(.tbl, .vars, .funs, ..., .cols = NULL)"},{"p":"dplyr","o":"rename","f":"hp_rename","d":"rename() changes the names of individual variables using\nnew_name = old_name syntax; rename_with() renames columns using a\nfunction.\n","ec":"rename(.data, ...)"},{"p":"dplyr","o":"reframe","f":"hp_reframe","d":"\n","ec":"reframe(.data, ..., .by = NULL)"},{"p":"dplyr","o":"select_vars_","f":"hp_select_vars_","d":"\n","ec":"select_vars_(vars, args, include = chr(), exclude = chr())"},{"p":"dplyr","o":"near","f":"hp_near","d":"This is a safe way of comparing if two vectors of floating point numbers\nare (pairwise) equal.  This is safer than using ==, because it has\na built in tolerance\n","ec":"near(x, y, tol = .Machine$double.eps^0.5)"},{"p":"dplyr","o":"pick","f":"hp_pick","d":"pick() provides a way to easily select a subset of columns from your data\nusing select() semantics while inside a\n\"data-masking\" function like mutate() or\nsummarise(). pick() returns a data frame containing the selected columns\nfor the current group.\n","ec":"pick(...)"},{"p":"dplyr","o":"n_groups","f":"hp_n_groups","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"n_groups(x)"},{"p":"dplyr","o":"across","f":"hp_across","d":"across() makes it easy to apply the same transformation to multiple\ncolumns, allowing you to use select() semantics inside in \"data-masking\"\nfunctions like summarise() and mutate(). See vignette(\"colwise\") for\nmore details.\n","ec":"across(.cols, .fns, ..., .names = NULL, .unpack = FALSE)"},{"p":"dplyr","o":"all_vars","f":"hp_all_vars","d":"\n","ec":"all_vars(expr)"},{"p":"dplyr","o":"select_all","f":"hp_select_all","d":"\n","ec":"select_all(.tbl, .funs = list(), ...)"},{"p":"dplyr","o":"slice","f":"hp_slice","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice(.data, ..., .by = NULL, .preserve = FALSE)"},{"p":"dplyr","o":"na_if","f":"hp_na_if","d":"This is a translation of the SQL command NULLIF. It is useful if you want\nto convert an annoying value to NA.\n","ec":"na_if(x, y)"},{"p":"dplyr","o":"select_if","f":"hp_select_if","d":"\n","ec":"select_if(.tbl, .predicate, .funs = list(), ...)"},{"p":"dplyr","o":"grouped_df","f":"hp_grouped_df","d":"The easiest way to create a grouped data frame is to call the group_by()\nmethod on a data frame or tbl: this will take care of capturing\nthe unevaluated expressions for you.\n","ec":"grouped_df(data, vars, drop = group_by_drop_default(data))"},{"p":"dplyr","o":"tbl_df","f":"hp_tbl_df","d":"\nPlease use tibble::as_tibble() instead.\n","ec":"tbl_df(data)"},{"p":"dplyr","o":"tally_","f":"hp_tally_","d":"\n","ec":"tally_(x, wt, sort = FALSE)"},{"p":"dplyr","o":"is.src","f":"hp_is.src","d":"src() is the standard constructor for srcs and is.src() tests.\n","ec":"is.src(x)"},{"p":"dplyr","o":"db_create_table","f":"hp_db_create_table","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_create_table(con, table, types, temporary = FALSE, ...)"},{"p":"dplyr","o":"mutate_each","f":"hp_mutate_each","d":"\n","ec":"mutate_each(tbl, funs, ...)"},{"p":"dplyr","o":"group_keys","f":"hp_group_keys","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_keys(.tbl, ...)"},{"p":"dplyr","o":"add_rownames","f":"hp_add_rownames","d":"\nPlease use tibble::rownames_to_column() instead.\n","ec":"add_rownames(df, var = \"rowname\")"},{"p":"dplyr","o":"rename_vars","f":"hp_rename_vars","d":"\n","ec":"rename_vars(vars = chr(), ..., strict = TRUE)"},{"p":"dplyr","o":"select_at","f":"hp_select_at","d":"\n","ec":"select_at(.tbl, .vars, .funs = list(), ...)"},{"p":"dplyr","o":"is.tbl","f":"hp_is.tbl","d":"This is a generic method that dispatches based on the first argument.\n","ec":"is.tbl(x)"},{"p":"dplyr","o":"arrange_all","f":"hp_arrange_all","d":"\n","ec":"arrange_all(.tbl, .funs = list(), ..., .by_group = FALSE, .locale = NULL)"},{"p":"dplyr","o":"summarize","f":"hp_summarize","d":"summarise() creates a new data frame. It returns one row for each\ncombination of grouping variables; if there are no grouping variables, the\noutput will have a single row summarising all observations in the input. It\nwill contain one column for each grouping variable and one column for each of\nthe summary statistics that you have specified.\n","ec":"summarize(.data, ..., .by = NULL, .groups = NULL)"},{"p":"dplyr","o":"cummean","f":"hp_cummean","d":"dplyr provides cumall(), cumany(), and cummean() to complete R's set\nof cumulative functions.\n","ec":"cummean(x)"},{"p":"dplyr","o":"rename_with","f":"hp_rename_with","d":"rename() changes the names of individual variables using\nnew_name = old_name syntax; rename_with() renames columns using a\nfunction.\n","ec":"rename_with(.data, .fn, .cols = everything(), ...)"},{"p":"dplyr","o":"group_map","f":"hp_group_map","d":"\n","ec":"group_map(.data, .f, ..., .keep = FALSE)"},{"p":"dplyr","o":"current_vars","f":"hp_current_vars","d":"\n","ec":"current_vars(...)"},{"p":"dplyr","o":"with_groups","f":"hp_with_groups","d":"\n","ec":"with_groups(.data, .groups, .f, ...)"},{"p":"dplyr","o":"last","f":"hp_last","d":"These are useful helpers for extracting a single value from a vector. They\nare guaranteed to return a meaningful value, even when the input is shorter\nthan expected. You can also provide an optional secondary vector that defines\nthe ordering.\n","ec":"last(x, order_by = NULL, default = NULL, na_rm = FALSE)"},{"p":"dplyr","o":"rowwise","f":"hp_rowwise","d":"rowwise() allows you to compute on a data frame a row-at-a-time.\nThis is most useful when a vectorised function doesn't exist.\n","ec":"rowwise(data, ...)"},{"p":"dplyr","o":"group_size","f":"hp_group_size","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_size(x)"},{"p":"dplyr","o":"nth","f":"hp_nth","d":"These are useful helpers for extracting a single value from a vector. They\nare guaranteed to return a meaningful value, even when the input is shorter\nthan expected. You can also provide an optional secondary vector that defines\nthe ordering.\n","ec":"nth(x, n, order_by = NULL, default = NULL, na_rm = FALSE)"},{"p":"dplyr","o":"src_postgres","f":"hp_src_postgres","d":"\n","ec":"src_postgres(dbname = NULL, host = NULL, port = NULL, user = NULL, password = NULL, ...)"},{"p":"dplyr","o":"dim_desc","f":"hp_dim_desc","d":"Prints the dimensions of an array-like object in a user-friendly manner,\nsubstituting NA with ?? (for SQL queries).\n","ec":"dim_desc(x)"},{"p":"dplyr","o":"transmute","f":"hp_transmute","d":"\n","ec":"transmute(.data, ...)"},{"p":"dplyr","o":"transmute_if","f":"hp_transmute_if","d":"\n","ec":"transmute_if(.tbl, .predicate, .funs, ...)"},{"p":"dplyr","o":"case_when","f":"hp_case_when","d":"This function allows you to vectorise multiple if_else() statements. Each\ncase is evaluated sequentially and the first match for each element\ndetermines the corresponding value in the output vector. If no cases match,\nthe .default is used as a final \"else\" statment.\n","ec":"case_when(..., .default = NULL, .ptype = NULL, .size = NULL)"},{"p":"dplyr","o":"arrange_if","f":"hp_arrange_if","d":"\n","ec":"arrange_if(.tbl, .predicate, .funs = list(), ..., .by_group = FALSE, .locale = NULL)"},{"p":"dplyr","o":"order_by","f":"hp_order_by","d":"This function makes it possible to control the ordering of window functions\nin R that don't have a specific ordering parameter. When translated to SQL\nit will modify the order clause of the OVER function.\n","ec":"order_by(order_by, call)"},{"p":"dplyr","o":"with_order","f":"hp_with_order","d":"This is used to power the ordering parameters of dplyr's window functions\n","ec":"with_order(order_by, fun, x, ...)"},{"p":"dplyr","o":"group_rows","f":"hp_group_rows","d":"This collection of functions accesses data about grouped data frames in\nvarious ways:\n","ec":"group_rows(.data)"},{"p":"dplyr","o":"any_vars","f":"hp_any_vars","d":"\n","ec":"any_vars(expr)"},{"p":"dplyr","o":"db_analyze","f":"hp_db_analyze","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_analyze(con, table, ...)"},{"p":"dplyr","o":"db_data_type","f":"hp_db_data_type","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_data_type(con, fields)"},{"p":"dplyr","o":"top_n","f":"hp_top_n","d":"\ntop_n() has been superseded in favour of slice_min()/slice_max().\nWhile it will not be deprecated in the near future, retirement means\nthat we will only perform critical bug fixes, so we recommend moving to the\nnewer alternatives.\n","ec":"top_n(x, n, wt)"},{"p":"dplyr","o":"add_tally","f":"hp_add_tally","d":"count() lets you quickly count the unique values of one or more variables:\ndf %>% count(a, b) is roughly equivalent to\ndf %>% group_by(a, b) %>% summarise(n = n()).\ncount() is paired with tally(), a lower-level helper that is equivalent\nto df %>% summarise(n = n()). Supply wt to perform weighted counts,\nswitching the summary from n = n() to n = sum(wt).\n","ec":"add_tally(x, wt = NULL, sort = FALSE, name = NULL)"},{"p":"dplyr","o":"db_query_fields","f":"hp_db_query_fields","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_query_fields(con, sql, ...)"},{"p":"dplyr","o":"group_trim","f":"hp_group_trim","d":"\nDrop unused levels of all factors that are used as grouping variables,\nthen recalculates the grouping structure.\n","ec":"group_trim(.tbl, .drop = group_by_drop_default(.tbl))"},{"p":"dplyr","o":"between","f":"hp_between","d":"This is a shortcut for x >= left & x <= right, implemented for local\nvectors and translated to the appropriate SQL for remote tables.\n","ec":"between(x, left, right)"},{"p":"dplyr","o":"select_","f":"hp_select_","d":"\n","ec":"select_(.data, ..., .dots = list())"},{"p":"dplyr","o":"lag","f":"hp_lag","d":"Find the \"previous\" (lag()) or \"next\" (lead()) values in a vector. Useful\nfor comparing values behind of or ahead of the current values.\n","ec":"lag(x, n = 1L, default = NULL, order_by = NULL, ...)"},{"p":"dplyr","o":"mutate_each_","f":"hp_mutate_each_","d":"\n","ec":"mutate_each_(tbl, funs, vars)"},{"p":"dplyr","o":"percent_rank","f":"hp_percent_rank","d":"These two ranking functions implement two slightly different ways to\ncompute a percentile. For each x_i in x:\n","ec":"percent_rank(x)"},{"p":"dplyr","o":"distinct","f":"hp_distinct","d":"Keep only unique/distinct rows from a data frame. This is similar\nto unique.data.frame() but considerably faster.\n","ec":"distinct(.data, ..., .keep_all = FALSE)"},{"p":"dplyr","o":"group_by_prepare","f":"hp_group_by_prepare","d":"<U+2060>*_prepare()<U+2060> performs standard manipulation that is needed prior\nto actual data processing. They are only be needed by packages\nthat implement dplyr backends.\n","ec":"group_by_prepare(.data, ..., .add = FALSE, .dots = deprecated(), add = deprecated(), error_call = caller_env())"},{"p":"dplyr","o":"db_explain","f":"hp_db_explain","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_explain(con, sql, ...)"},{"p":"dplyr","o":"summarise_each_","f":"hp_summarise_each_","d":"\n","ec":"summarise_each_(tbl, funs, vars)"},{"p":"dplyr","o":"tbl_nongroup_vars","f":"hp_tbl_nongroup_vars","d":"tbl_vars() returns all variables while tbl_nongroup_vars()\nreturns only non-grouping variables. The groups attribute\nof the object returned by tbl_vars() is a character vector of the\ngrouping columns.\n","ec":"tbl_nongroup_vars(x)"},{"p":"dplyr","o":"bench_tbls","f":"hp_bench_tbls","d":"\n","ec":"bench_tbls(tbls, op, ..., times = 10)"},{"p":"dplyr","o":"is_grouped_df","f":"hp_is_grouped_df","d":"The easiest way to create a grouped data frame is to call the group_by()\nmethod on a data frame or tbl: this will take care of capturing\nthe unevaluated expressions for you.\n","ec":"is_grouped_df(x)"},{"p":"dplyr","o":"right_join","f":"hp_right_join","d":"Mutating joins add columns from y to x, matching observations based on\nthe keys. There are four mutating joins: the inner join, and the three outer\njoins.\n","ec":"right_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ..., keep = NULL)"},{"p":"dplyr","o":"summarise_if","f":"hp_summarise_if","d":"\n","ec":"summarise_if(.tbl, .predicate, .funs, ...)"},{"p":"dplyr","o":"filter_","f":"hp_filter_","d":"\n","ec":"filter_(.data, ..., .dots = list())"},{"p":"dplyr","o":"cur_group_rows","f":"hp_cur_group_rows","d":"These functions return information about the \"current\" group or \"current\"\nvariable, so only work inside specific contexts like summarise() and\nmutate().\n","ec":"cur_group_rows()"},{"p":"dplyr","o":"src_mysql","f":"hp_src_mysql","d":"\n","ec":"src_mysql(dbname, host = NULL, port = 0L, username = \"root\", password = \"\", ...)"},{"p":"dplyr","o":"summarize_at","f":"hp_summarize_at","d":"\n","ec":"summarize_at(.tbl, .vars, .funs, ..., .cols = NULL)"},{"p":"dplyr","o":"rows_delete","f":"hp_rows_delete","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_delete(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"combine","f":"hp_combine","d":"\n","ec":"combine(...)"},{"p":"dplyr","o":"ntile","f":"hp_ntile","d":"ntile() is a sort of very rough rank, which breaks the input vector into\nn buckets. If length(x) is not an integer multiple of n, the size of\nthe buckets will differ by up to one, with larger buckets coming first.\n","ec":"ntile(x = row_number(), n)"},{"p":"dplyr","o":"location","f":"hp_location","d":"\n","ec":"location(df)"},{"p":"dplyr","o":"symdiff","f":"hp_symdiff","d":"Perform set operations using the rows of a data frame.\n","ec":"symdiff(x, y, ...)"},{"p":"dplyr","o":"sql_escape_string","f":"hp_sql_escape_string","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_escape_string(con, x)"},{"p":"dplyr","o":"rename_vars_","f":"hp_rename_vars_","d":"\n","ec":"rename_vars_(vars, args)"},{"p":"dplyr","o":"nest_by","f":"hp_nest_by","d":"\n","ec":"nest_by(.data, ..., .key = \"data\", .keep = FALSE)"},{"p":"dplyr","o":"db_rollback","f":"hp_db_rollback","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_rollback(con, ...)"},{"p":"dplyr","o":"filter_at","f":"hp_filter_at","d":"\n","ec":"filter_at(.tbl, .vars, .vars_predicate, .preserve = FALSE)"},{"p":"dplyr","o":"collapse","f":"hp_collapse","d":"compute() stores results in a remote temporary table.\ncollect() retrieves data into a local tibble.\ncollapse() is slightly different: it doesn't force computation, but\ninstead forces generation of the SQL query. This is sometimes needed to work\naround bugs in dplyr's SQL generation.\n","ec":"collapse(x, ...)"},{"p":"dplyr","o":"db_write_table","f":"hp_db_write_table","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_write_table(con, table, types, values, temporary = FALSE, ...)"},{"p":"dplyr","o":"db_has_table","f":"hp_db_has_table","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_has_table(con, table)"},{"p":"dplyr","o":"ungroup","f":"hp_ungroup","d":"Most data operations are done on groups defined by variables.\ngroup_by() takes an existing tbl and converts it into a grouped tbl\nwhere operations are performed \"by group\". ungroup() removes grouping.\n","ec":"ungroup(x, ...)"},{"p":"dplyr","o":"group_by","f":"hp_group_by","d":"Most data operations are done on groups defined by variables.\ngroup_by() takes an existing tbl and converts it into a grouped tbl\nwhere operations are performed \"by group\". ungroup() removes grouping.\n","ec":"group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data))"},{"p":"dplyr","o":"funs","f":"hp_funs","d":"\n","ec":"funs(..., .args = list())"},{"p":"dplyr","o":"vars","f":"hp_vars","d":"\n","ec":"vars(...)"},{"p":"dplyr","o":"if_all","f":"hp_if_all","d":"across() makes it easy to apply the same transformation to multiple\ncolumns, allowing you to use select() semantics inside in \"data-masking\"\nfunctions like summarise() and mutate(). See vignette(\"colwise\") for\nmore details.\n","ec":"if_all(.cols, .fns, ..., .names = NULL)"},{"p":"dplyr","o":"slice_sample","f":"hp_slice_sample","d":"slice() lets you index rows by their (integer) locations. It allows you\nto select, remove, and duplicate rows. It is accompanied by a number of\nhelpers for common use cases:\n","ec":"slice_sample(.data, ..., n, prop, by = NULL, weight_by = NULL, replace = FALSE)"},{"p":"dplyr","o":"recode","f":"hp_recode","d":"\n","ec":"recode(.x, ..., .default = NULL, .missing = NULL)"},{"p":"dplyr","o":"validate_rowwise_df","f":"hp_validate_rowwise_df","d":"new_grouped_df() and new_rowwise_df() are constructors designed to be high-performance so only\ncheck types, not values. This means it is the caller's responsibility\nto create valid values, and hence this is for expert use only.\n","ec":"validate_rowwise_df(x)"},{"p":"dplyr","o":"rename_","f":"hp_rename_","d":"\n","ec":"rename_(.data, ..., .dots = list())"},{"p":"dplyr","o":"cur_group","f":"hp_cur_group","d":"These functions return information about the \"current\" group or \"current\"\nvariable, so only work inside specific contexts like summarise() and\nmutate().\n","ec":"cur_group()"},{"p":"dplyr","o":"group_nest","f":"hp_group_nest","d":"\n","ec":"group_nest(.tbl, ..., .key = \"data\", keep = FALSE)"},{"p":"dplyr","o":"filter_all","f":"hp_filter_all","d":"\n","ec":"filter_all(.tbl, .vars_predicate, .preserve = FALSE)"},{"p":"dplyr","o":"src_df","f":"hp_src_df","d":"\nThis function was deprecated since it existed to support a style of testing\ndplyr backends that turned out not to be useful.\n","ec":"src_df(pkg = NULL, env = NULL)"},{"p":"dplyr","o":"summarise_","f":"hp_summarise_","d":"\n","ec":"summarise_(.data, ..., .dots = list())"},{"p":"dplyr","o":"group_by_","f":"hp_group_by_","d":"\n","ec":"group_by_(.data, ..., .dots = list(), add = FALSE)"},{"p":"dplyr","o":"copy_to","f":"hp_copy_to","d":"This function uploads a local data frame into a remote data source, creating\nthe table definition as needed. Wherever possible, the new object will be\ntemporary, limited to the current connection to the source.\n","ec":"copy_to(dest, df, name = deparse(substitute(df)), overwrite = FALSE, ...)"},{"p":"dplyr","o":"cur_data_all","f":"hp_cur_data_all","d":"\n","ec":"cur_data_all()"},{"p":"dplyr","o":"if_else","f":"hp_if_else","d":"if_else() is a vectorized if-else. Compared to the base R equivalent,\nifelse(), this function allows you to handle missing values in the\ncondition with missing and always takes true, false, and missing\ninto account when determining what the output type should be.\n","ec":"if_else(condition, true, false, missing = NULL, ..., ptype = NULL, size = NULL)"},{"p":"dplyr","o":"transmute_","f":"hp_transmute_","d":"\n","ec":"transmute_(.data, ..., .dots = list())"},{"p":"dplyr","o":"funs_","f":"hp_funs_","d":"\n","ec":"funs_(dots, args = list(), env = base_env())"},{"p":"dplyr","o":"summarize_","f":"hp_summarize_","d":"\n","ec":"summarize_(.data, ..., .dots = list())"},{"p":"dplyr","o":"failwith","f":"hp_failwith","d":"\n","ec":"failwith(default = NULL, f, quiet = FALSE)"},{"p":"dplyr","o":"compare_tbls","f":"hp_compare_tbls","d":"\n","ec":"compare_tbls(tbls, op, ref = NULL, compare = equal_data_frame, ...)"},{"p":"dplyr","o":"sample_frac","f":"hp_sample_frac","d":"\nsample_n() and sample_frac() have been superseded in favour of\nslice_sample(). While they will not be deprecated in the near future,\nretirement means that we will only perform critical bug fixes, so we recommend\nmoving to the newer alternative.\n","ec":"sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...)"},{"p":"dplyr","o":"group_by_all","f":"hp_group_by_all","d":"\n","ec":"group_by_all(.tbl, .funs = list(), ..., .add = FALSE, .drop = group_by_drop_default(.tbl))"},{"p":"dplyr","o":"explain","f":"hp_explain","d":"This is a generic function which gives more details about an object than\nprint(), and is more focused on human readable output than\nstr().\n","ec":"explain(x, ...)"},{"p":"dplyr","o":"rename_if","f":"hp_rename_if","d":"\n","ec":"rename_if(.tbl, .predicate, .funs = list(), ...)"},{"p":"dplyr","o":"sample_n","f":"hp_sample_n","d":"\nsample_n() and sample_frac() have been superseded in favour of\nslice_sample(). While they will not be deprecated in the near future,\nretirement means that we will only perform critical bug fixes, so we recommend\nmoving to the newer alternative.\n","ec":"sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)"},{"p":"dplyr","o":"group_by_if","f":"hp_group_by_if","d":"\n","ec":"group_by_if(.tbl, .predicate, .funs = list(), ..., .add = FALSE, .drop = group_by_drop_default(.tbl))"},{"p":"dplyr","o":"validate_grouped_df","f":"hp_validate_grouped_df","d":"new_grouped_df() and new_rowwise_df() are constructors designed to be high-performance so only\ncheck types, not values. This means it is the caller's responsibility\nto create valid values, and hence this is for expert use only.\n","ec":"validate_grouped_df(x, check_bounds = FALSE)"},{"p":"dplyr","o":"common_by","f":"hp_common_by","d":"Extract out common by variables\n","ec":"common_by(by = NULL, x, y)"},{"p":"dplyr","o":"group_walk","f":"hp_group_walk","d":"\n","ec":"group_walk(.data, .f, ..., .keep = FALSE)"},{"p":"dplyr","o":"changes","f":"hp_changes","d":"\n","ec":"changes(x, y)"},{"p":"dplyr","o":"make_tbl","f":"hp_make_tbl","d":"tbl() is the standard constructor for tbls. as.tbl() coerces,\nand is.tbl() tests.\n","ec":"make_tbl(subclass, ...)"},{"p":"dplyr","o":"rows_upsert","f":"hp_rows_upsert","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_upsert(x, y, by = NULL, ..., copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"cume_dist","f":"hp_cume_dist","d":"These two ranking functions implement two slightly different ways to\ncompute a percentile. For each x_i in x:\n","ec":"cume_dist(x)"},{"p":"dplyr","o":"ident","f":"hp_ident","d":"ident() takes unquoted strings and flags them as identifiers.\nident_q() assumes its input has already been quoted, and ensures\nit does not get quoted again. This is currently used only for\nschema.table.\n","ec":"ident(...)"},{"p":"dplyr","o":"rows_append","f":"hp_rows_append","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_append(x, y, ..., copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"rows_update","f":"hp_rows_update","d":"These functions provide a framework for modifying rows in a table using a\nsecond table of data. The two tables are matched by a set of key variables\nwhose values typically uniquely identify each row. The functions are inspired\nby SQL's INSERT, UPDATE, and DELETE, and can optionally modify\nin_place for selected backends.\n","ec":"rows_update(x, y, by = NULL, ..., unmatched = c(\"error\", \"ignore\"), copy = FALSE, in_place = FALSE)"},{"p":"dplyr","o":"select_var","f":"hp_select_var","d":"\n","ec":"select_var(vars, var = -1)"},{"p":"dplyr","o":"db_list_tables","f":"hp_db_list_tables","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"db_list_tables(con)"},{"p":"dplyr","o":"rename_at","f":"hp_rename_at","d":"\n","ec":"rename_at(.tbl, .vars, .funs = list(), ...)"},{"p":"dplyr","o":"sql_escape_ident","f":"hp_sql_escape_ident","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_escape_ident(con, x)"},{"p":"dplyr","o":"group_by_at","f":"hp_group_by_at","d":"\n","ec":"group_by_at(.tbl, .vars, .funs = list(), ..., .add = FALSE, .drop = group_by_drop_default(.tbl))"},{"p":"dplyr","o":"pull","f":"hp_pull","d":"pull() is similar to $. It's mostly useful because it looks a little\nnicer in pipes, it also works with remote data frames, and it can optionally\nname the output.\n","ec":"pull(.data, var = -1, name = NULL, ...)"},{"p":"dplyr","o":"mutate","f":"hp_mutate","d":"mutate() creates new columns that are functions of existing variables.\nIt can also modify (if the name is the same as an existing\ncolumn) and delete columns (by setting their value to NULL).\n","ec":"mutate(.data, ...)"},{"p":"dplyr","o":"nest_join","f":"hp_nest_join","d":"A nest join leaves x almost unchanged, except that it adds a new\nlist-column, where each element contains the rows from y that match the\ncorresponding row in x.\n","ec":"nest_join(x, y, by = NULL, copy = FALSE, keep = NULL, name = NULL, ...)"},{"p":"dplyr","o":"slice_","f":"hp_slice_","d":"\n","ec":"slice_(.data, ..., .dots = list())"},{"p":"dplyr","o":"count_","f":"hp_count_","d":"\n","ec":"count_(x, vars, wt = NULL, sort = FALSE, .drop = group_by_drop_default(x))"},{"p":"dplyr","o":"group_modify","f":"hp_group_modify","d":"\n","ec":"group_modify(.data, .f, ..., .keep = FALSE)"},{"p":"dplyr","o":"if_any","f":"hp_if_any","d":"across() makes it easy to apply the same transformation to multiple\ncolumns, allowing you to use select() semantics inside in \"data-masking\"\nfunctions like summarise() and mutate(). See vignette(\"colwise\") for\nmore details.\n","ec":"if_any(.cols, .fns, ..., .names = NULL)"},{"p":"dplyr","o":"tally","f":"hp_tally","d":"count() lets you quickly count the unique values of one or more variables:\ndf %>% count(a, b) is roughly equivalent to\ndf %>% group_by(a, b) %>% summarise(n = n()).\ncount() is paired with tally(), a lower-level helper that is equivalent\nto df %>% summarise(n = n()). Supply wt to perform weighted counts,\nswitching the summary from n = n() to n = sum(wt).\n","ec":"tally(x, wt = NULL, sort = FALSE, name = NULL)"},{"p":"dplyr","o":"bind_rows","f":"hp_bind_rows","d":"Bind any number of data frames by row, making a longer result. This is\nsimilar to do.call(rbind, dfs), but the output will contain all columns\nthat appear in any of the inputs.\n","ec":"bind_rows(..., .id = NULL)"},{"p":"dplyr","o":"c_across","f":"hp_c_across","d":"c_across() is designed to work with rowwise() to make it easy to\nperform row-wise aggregations. It has two differences from c():\n","ec":"c_across(cols)"},{"p":"dplyr","o":"cumall","f":"hp_cumall","d":"dplyr provides cumall(), cumany(), and cummean() to complete R's set\nof cumulative functions.\n","ec":"cumall(x)"},{"p":"dplyr","o":"collect","f":"hp_collect","d":"compute() stores results in a remote temporary table.\ncollect() retrieves data into a local tibble.\ncollapse() is slightly different: it doesn't force computation, but\ninstead forces generation of the SQL query. This is sometimes needed to work\naround bugs in dplyr's SQL generation.\n","ec":"collect(x, ...)"},{"p":"dplyr","o":"min_rank","f":"hp_min_rank","d":"Three ranking functions inspired by SQL2003. They differ primarily in how\nthey handle ties:\n","ec":"min_rank(x)"},{"p":"dplyr","o":"sql","f":"hp_sql","d":"These functions are critical when writing functions that translate R\nfunctions to sql functions. Typically a conversion function should escape\nall its inputs and return an sql object.\n","ec":"sql(...)"},{"p":"dplyr","o":"sql_select","f":"hp_sql_select","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_select(con, select, from, where = NULL, group_by = NULL, having = NULL, order_by = NULL, limit = NULL, distinct = FALSE, ...)"},{"p":"dplyr","o":"sql_join","f":"hp_sql_join","d":"The sql_ generics are used to build the different types of SQL queries.\nThe default implementations in dbplyr generates ANSI 92 compliant SQL.\nThe db_ generics execute actions on the database. The default\nimplementations in dbplyr typically just call the standard DBI S4\nmethod.\n","ec":"sql_join(con, x, y, vars, type = \"inner\", by = NULL, ...)"},{"p":"dplyr","o":"full_join","f":"hp_full_join","d":"Mutating joins add columns from y to x, matching observations based on\nthe keys. There are four mutating joins: the inner join, and the three outer\njoins.\n","ec":"full_join(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\"), ..., keep = NULL)"},{"p":"farver","o":"multiply_channel","f":"hp_multiply_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"multiply_channel(colour, channel, value, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"decode_colour","f":"hp_decode_colour","d":"This is a version of grDevices::col2rgb() that returns the colour values in\nthe standard form expected by farver (matrix with a row per colour). As with\nencode_colour() it can do colour conversion on the fly, meaning that you can\ndecode a hex string directly into any of the supported colour spaces.\n","ec":"decode_colour(colour, alpha = FALSE, to = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"add_to_channel","f":"hp_add_to_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"add_to_channel(colour, channel, value, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"decode_native","f":"hp_decode_native","d":"Colours in R are internally encoded as integers when they are passed around\nto graphics devices. The encoding splits the 32 bit in the integer between\nred, green, blue, and alpha, so that each get 8 bit, equivalent to 256\nvalues. It is very seldom that an R user is subjected to this representation,\nbut it is present in the nativeRaster format which can be obtained from\ne.g. capturing the content of a graphic device (using dev.capture()) or reading\nin PNG files using png::readPNG(native = TRUE). It is very rare that you\nmight need to convert back and forth between this format, but it is provided\nhere for completeness.\n","ec":"decode_native(colour)"},{"p":"farver","o":"compare_colour","f":"hp_compare_colour","d":"There are many ways to measure the distance between colours. farver\nprovides 5 different algorithms, ranging from simple euclidean distance in\nRGB space, to different perceptual measures such as CIE2000.\n","ec":"compare_colour(from, to = NULL, from_space, to_space = from_space, method = \"euclidean\", white_from = \"D65\", white_to = white_from, lightness = 2, chroma = 1)"},{"p":"farver","o":"set_channel","f":"hp_set_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"set_channel(colour, channel, value, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"cap_channel","f":"hp_cap_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"cap_channel(colour, channel, value, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"encode_native","f":"hp_encode_native","d":"Colours in R are internally encoded as integers when they are passed around\nto graphics devices. The encoding splits the 32 bit in the integer between\nred, green, blue, and alpha, so that each get 8 bit, equivalent to 256\nvalues. It is very seldom that an R user is subjected to this representation,\nbut it is present in the nativeRaster format which can be obtained from\ne.g. capturing the content of a graphic device (using dev.capture()) or reading\nin PNG files using png::readPNG(native = TRUE). It is very rare that you\nmight need to convert back and forth between this format, but it is provided\nhere for completeness.\n","ec":"encode_native(colour, ...)"},{"p":"farver","o":"raise_channel","f":"hp_raise_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"raise_channel(colour, channel, value, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"farver","o":"convert_colour","f":"hp_convert_colour","d":"This function lets you convert between different representations of colours.\nThe API is reminiscent of grDevices::convertColor(), but the performance is\nmuch better. It is not assured that grDevices::convertColor() and\nconvert_colour() provide numerically equivalent conversion at 16bit level as\nthe formula used are potentially slightly different. For all intend and\npurpose, the resulting colours will be equivalent though.\n","ec":"convert_colour(colour, from, to, white_from = \"D65\", white_to = white_from)"},{"p":"farver","o":"encode_colour","f":"hp_encode_colour","d":"This is a version of grDevices::rgb() that works with the standard colour\nformat used in farver (matrix or data.frame with colours in rows). It further\nsupport taking input from any colour space.\n","ec":"encode_colour(colour, alpha = NULL, from = \"rgb\", white = \"D65\")"},{"p":"farver","o":"as_white_ref","f":"hp_as_white_ref","d":"This function can take either the name of a standardised illuminants, x\nand y chromaticity coordinates or X, Y, and Z tristimulus values and converts\nit to tristimulus values normalised to Y=100. All Illuminant series A-F are\nsupported and can be queried both on the CIE 1931 2 and CIE 1964 10\nchromaticity coordinates.\n","ec":"as_white_ref(x, fow = 2)"},{"p":"farver","o":"get_channel","f":"hp_get_channel","d":"This set of functions allows you to modify colours as given by strings,\nwhithout first decoding them. For large vectors of colour values this should\nprovide a considerable speedup.\n","ec":"get_channel(colour, channel, space = \"rgb\", white = \"D65\", na_value = NA)"},{"p":"forcats","o":"fct_relabel","f":"hp_fct_relabel","d":"Relabel factor levels with a function, collapsing as necessary\n","ec":"fct_relabel(.f, .fun, ...)"},{"p":"forcats","o":"fct_relevel","f":"hp_fct_relevel","d":"This is a generalisation of stats::relevel() that allows you to move any\nnumber of levels to any location.\n","ec":"fct_relevel(.f, ..., after = 0L)"},{"p":"forcats","o":"fct_anon","f":"hp_fct_anon","d":"Replaces factor levels with arbitrary numeric identifiers. Neither\nthe values nor the order of the levels are preserved.\n","ec":"fct_anon(f, prefix = \"\")"},{"p":"forcats","o":"fct_c","f":"hp_fct_c","d":"This is a useful way of patching together factors from multiple sources\nthat really should have the same levels but don't.\n","ec":"fct_c(...)"},{"p":"forcats","o":"lvls_reorder","f":"hp_lvls_reorder","d":"lvls_reorder leaves values as they are, but changes the order.\nlvls_revalue changes the values of existing levels; there must\nbe one new level for each old level.\nlvls_expand expands the set of levels; the new levels must\ninclude the old levels.\n","ec":"lvls_reorder(f, idx, ordered = NA)"},{"p":"forcats","o":"lvls_expand","f":"hp_lvls_expand","d":"lvls_reorder leaves values as they are, but changes the order.\nlvls_revalue changes the values of existing levels; there must\nbe one new level for each old level.\nlvls_expand expands the set of levels; the new levels must\ninclude the old levels.\n","ec":"lvls_expand(f, new_levels)"},{"p":"forcats","o":"fct_na_level_to_value","f":"hp_fct_na_level_to_value","d":"There are two ways to represent missing values in factors: in the values\nand in the levels. NAs in the values are most useful for data analysis\n(since is.na() returns what you expect), but because the NA is not\nexplicitly recorded in the levels, there's no way to control its position\n(it's almost always displayed last or not at all). Putting the NAs in the levels allows\nyou to control its display, at the cost of losing accurate is.na()\nreporting.\n","ec":"fct_na_level_to_value(f, extra_levels = NULL)"},{"p":"forcats","o":"fct_lump_prop","f":"hp_fct_lump_prop","d":"A family for lumping together levels that meet some criteria.\n","ec":"fct_lump_prop(f, prop, w = NULL, other_level = \"Other\")"},{"p":"forcats","o":"as_factor","f":"hp_as_factor","d":"Compared to base R, when x is a character, this function creates\nlevels in the order in which they appear, which will be the same on every\nplatform. (Base R sorts in the current locale which can vary from place\nto place.) When x is numeric, the ordering is based on the numeric\nvalue and consistent with base R.\n","ec":"as_factor(x, ...)"},{"p":"forcats","o":"fct_na_value_to_level","f":"hp_fct_na_value_to_level","d":"There are two ways to represent missing values in factors: in the values\nand in the levels. NAs in the values are most useful for data analysis\n(since is.na() returns what you expect), but because the NA is not\nexplicitly recorded in the levels, there's no way to control its position\n(it's almost always displayed last or not at all). Putting the NAs in the levels allows\nyou to control its display, at the cost of losing accurate is.na()\nreporting.\n","ec":"fct_na_value_to_level(f, level = NA)"},{"p":"forcats","o":"fct_shuffle","f":"hp_fct_shuffle","d":"Randomly permute factor levels\n","ec":"fct_shuffle(f)"},{"p":"forcats","o":"fct_drop","f":"hp_fct_drop","d":"Compared to base::droplevels(), does not drop NA levels that have values.\n","ec":"fct_drop(f, only = NULL)"},{"p":"forcats","o":"fct_unify","f":"hp_fct_unify","d":"Unify the levels in a list of factors\n","ec":"fct_unify(fs, levels = lvls_union(fs))"},{"p":"forcats","o":"lvls_revalue","f":"hp_lvls_revalue","d":"lvls_reorder leaves values as they are, but changes the order.\nlvls_revalue changes the values of existing levels; there must\nbe one new level for each old level.\nlvls_expand expands the set of levels; the new levels must\ninclude the old levels.\n","ec":"lvls_revalue(f, new_levels)"},{"p":"forcats","o":"fct_lump_min","f":"hp_fct_lump_min","d":"A family for lumping together levels that meet some criteria.\n","ec":"fct_lump_min(f, min, w = NULL, other_level = \"Other\")"},{"p":"forcats","o":"fct_unique","f":"hp_fct_unique","d":"fct_unique() extracts the complete set of possible values from the\nlevels of the factor, rather than looking at the actual values, like\nunique().\n","ec":"fct_unique(f)"},{"p":"forcats","o":"fct_infreq","f":"hp_fct_infreq","d":"This family of functions changes only the order of the levels.\n","ec":"fct_infreq(f, w = NULL, ordered = NA)"},{"p":"forcats","o":"fct_shift","f":"hp_fct_shift","d":"This is useful when the levels of an ordered factor are actually cyclical,\nwith different conventions on the starting point.\n","ec":"fct_shift(f, n = 1L)"},{"p":"forcats","o":"fct_reorder","f":"hp_fct_reorder","d":"fct_reorder() is useful for 1d displays where the factor is mapped to\nposition; fct_reorder2() for 2d displays where the factor is mapped to\na non-position aesthetic. last2() and first2() are helpers for fct_reorder2();\nlast2() finds the last value of y when sorted by x; first2() finds the first value.\n","ec":"fct_reorder(.f, .x, .fun = median, ..., .na_rm = NULL, .default = Inf, .desc = FALSE)"},{"p":"forcats","o":"fct_explicit_na","f":"hp_fct_explicit_na","d":"\n","ec":"fct_explicit_na(f, na_level = \"(Missing)\")"},{"p":"forcats","o":"fct_rev","f":"hp_fct_rev","d":"This is sometimes useful when plotting a factor.\n","ec":"fct_rev(f)"},{"p":"forcats","o":"lvls_union","f":"hp_lvls_union","d":"Find all levels in a list of factors\n","ec":"lvls_union(fs)"},{"p":"forcats","o":"fct_lump","f":"hp_fct_lump","d":"A family for lumping together levels that meet some criteria.\n","ec":"fct_lump(f, n, prop, w = NULL, other_level = \"Other\", ties.method = c(\"min\", \"average\", \"first\", \"last\", \"random\", \"max\"))"},{"p":"forcats","o":"fct_inorder","f":"hp_fct_inorder","d":"This family of functions changes only the order of the levels.\n","ec":"fct_inorder(f, ordered = NA)"},{"p":"forcats","o":"first2","f":"hp_first2","d":"fct_reorder() is useful for 1d displays where the factor is mapped to\nposition; fct_reorder2() for 2d displays where the factor is mapped to\na non-position aesthetic. last2() and first2() are helpers for fct_reorder2();\nlast2() finds the last value of y when sorted by x; first2() finds the first value.\n","ec":"first2(.x, .y)"},{"p":"forcats","o":"fct","f":"hp_fct","d":"fct() is a stricter version of factor() that errors if your\nspecification of levels is inconsistent with the values in x.\n","ec":"fct(x = character(), levels = NULL, na = character())"},{"p":"forcats","o":"fct_count","f":"hp_fct_count","d":"Count entries in a factor\n","ec":"fct_count(f, sort = FALSE, prop = FALSE)"},{"p":"forcats","o":"last2","f":"hp_last2","d":"fct_reorder() is useful for 1d displays where the factor is mapped to\nposition; fct_reorder2() for 2d displays where the factor is mapped to\na non-position aesthetic. last2() and first2() are helpers for fct_reorder2();\nlast2() finds the last value of y when sorted by x; first2() finds the first value.\n","ec":"last2(.x, .y)"},{"p":"forcats","o":"fct_inseq","f":"hp_fct_inseq","d":"This family of functions changes only the order of the levels.\n","ec":"fct_inseq(f, ordered = NA)"},{"p":"forcats","o":"fct_lump_n","f":"hp_fct_lump_n","d":"A family for lumping together levels that meet some criteria.\n","ec":"fct_lump_n(f, n, w = NULL, other_level = \"Other\", ties.method = c(\"min\", \"average\", \"first\", \"last\", \"random\", \"max\"))"},{"p":"forcats","o":"fct_other","f":"hp_fct_other","d":"Manually replace levels with \"other\"\n","ec":"fct_other(f, keep, drop, other_level = \"Other\")"},{"p":"forcats","o":"fct_reorder2","f":"hp_fct_reorder2","d":"fct_reorder() is useful for 1d displays where the factor is mapped to\nposition; fct_reorder2() for 2d displays where the factor is mapped to\na non-position aesthetic. last2() and first2() are helpers for fct_reorder2();\nlast2() finds the last value of y when sorted by x; first2() finds the first value.\n","ec":"fct_reorder2(.f, .x, .y, .fun = last2, ..., .na_rm = NULL, .default = -Inf, .desc = TRUE)"},{"p":"forcats","o":"fct_lump_lowfreq","f":"hp_fct_lump_lowfreq","d":"A family for lumping together levels that meet some criteria.\n","ec":"fct_lump_lowfreq(f, w = NULL, other_level = \"Other\")"},{"p":"forcats","o":"fct_recode","f":"hp_fct_recode","d":"Change factor levels by hand\n","ec":"fct_recode(.f, ...)"},{"p":"forcats","o":"fct_match","f":"hp_fct_match","d":"Do any of lvls occur in f? Compared to %in%, this function validates\nlvls to ensure that they're actually present in f. In other words,\nx %in% \"not present\" will return FALSE, but fct_match(x, \"not present\")\nwill throw an error.\n","ec":"fct_match(f, lvls)"},{"p":"forcats","o":"fct_cross","f":"hp_fct_cross","d":"Computes a factor whose levels are all the combinations of the levels of the input factors.\n","ec":"fct_cross(..., sep = \":\", keep_empty = FALSE)"},{"p":"forcats","o":"fct_collapse","f":"hp_fct_collapse","d":"Collapse factor levels into manually defined groups\n","ec":"fct_collapse(.f, ..., other_level = NULL, group_other = \"DEPRECATED\")"},{"p":"forcats","o":"fct_expand","f":"hp_fct_expand","d":"Add additional levels to a factor\n","ec":"fct_expand(f, ..., after = Inf)"},{"p":"fs","o":"as_fs_perms","f":"hp_as_fs_perms","d":"fs_perms() objects help one create and modify file permissions easily.\nThey support both numeric input, octal and symbolic character\nrepresentations. Compared to octmode they support symbolic representations\nand display the mode the same format as ls on POSIX systems.\n","ec":"as_fs_perms(x, ...)"},{"p":"fs","o":"as_fs_path","f":"hp_as_fs_path","d":"Tidy file paths, character vectors which are coloured by file type on\ncapable terminals.\n","ec":"as_fs_path(x)"},{"p":"fs","o":"file_info","f":"hp_file_info","d":"Compared to file.info() the full results of a stat(2) system call are\nreturned and some columns are returned as S3 classes to make manipulation\nmore natural. On systems which do not support all metadata (such as Windows)\ndefault values are used.\n","ec":"file_info(path, fail = TRUE, follow = FALSE)"},{"p":"fs","o":"path_filter","f":"hp_path_filter","d":"Filter paths\n","ec":"path_filter(path, glob = NULL, regexp = NULL, invert = FALSE, ...)"},{"p":"fs","o":"path_home_r","f":"hp_path_home_r","d":"path_expand() differs from base::path.expand() in the interpretation of\nthe home directory of Windows. In particular path_expand() uses the path\nset in the USERPROFILE environment variable and, if unset, then uses\nHOMEDRIVE/HOMEPATH.\n","ec":"path_home_r(...)"},{"p":"fs","o":"is_file_empty","f":"hp_is_file_empty","d":"Functions to test for file types\n","ec":"is_file_empty(path, follow = TRUE)"},{"p":"fs","o":"link_path","f":"hp_link_path","d":"Read the value of a symbolic link\n","ec":"link_path(path)"},{"p":"fs","o":"dir_map","f":"hp_dir_map","d":"dir_ls() is equivalent to the ls command. It returns filenames as a\nnamed fs_path character vector. The names are equivalent to the values,\nwhich is useful for passing onto functions like purrr::map_dfr().\n","ec":"dir_map(path = \".\", fun, all = FALSE, recurse = FALSE, type = \"any\", fail = TRUE)"},{"p":"fs","o":"group_ids","f":"hp_group_ids","d":"These functions use the GETPWENT(3) and GETGRENT(3) system calls to query\nusers and groups respectively.\n","ec":"group_ids()"},{"p":"fs","o":"path","f":"hp_path","d":"path() constructs a relative path, path_wd() constructs an absolute path\nfrom the current working directory.\n","ec":"path(..., ext = \"\")"},{"p":"fs","o":"fs_bytes","f":"hp_fs_bytes","d":"Construct, manipulate and display vectors of file sizes. These are numeric\nvectors, so you can compare them numerically, but they can also be compared\nto human readable values such as '10MB'.\n","ec":"fs_bytes(x)"},{"p":"fs","o":"is_link","f":"hp_is_link","d":"Functions to test for file types\n","ec":"is_link(path)"},{"p":"fs","o":"fs_path","f":"hp_fs_path","d":"Tidy file paths, character vectors which are coloured by file type on\ncapable terminals.\n","ec":"fs_path(x)"},{"p":"fs","o":"path_ext_remove","f":"hp_path_ext_remove","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_ext_remove(path)"},{"p":"fs","o":"dir_ls","f":"hp_dir_ls","d":"dir_ls() is equivalent to the ls command. It returns filenames as a\nnamed fs_path character vector. The names are equivalent to the values,\nwhich is useful for passing onto functions like purrr::map_dfr().\n","ec":"dir_ls(path = \".\", all = FALSE, recurse = FALSE, type = \"any\", glob = NULL, regexp = NULL, invert = FALSE, fail = TRUE, ..., recursive)"},{"p":"fs","o":"dir_copy","f":"hp_dir_copy","d":"file_copy() copies files.\n","ec":"dir_copy(path, new_path, overwrite = FALSE)"},{"p":"fs","o":"dir_tree","f":"hp_dir_tree","d":"Print contents of directories in a tree-like format\n","ec":"dir_tree(path = \".\", recurse = TRUE, ...)"},{"p":"fs","o":"dir_info","f":"hp_dir_info","d":"dir_ls() is equivalent to the ls command. It returns filenames as a\nnamed fs_path character vector. The names are equivalent to the values,\nwhich is useful for passing onto functions like purrr::map_dfr().\n","ec":"dir_info(path = \".\", all = FALSE, recurse = FALSE, type = \"any\", regexp = NULL, glob = NULL, fail = TRUE, ...)"},{"p":"fs","o":"file_move","f":"hp_file_move","d":"Compared to file.rename file_move() always fails if it is unable to move\na file, rather than signaling a Warning and returning an error code.\n","ec":"file_move(path, new_path)"},{"p":"fs","o":"path_package","f":"hp_path_package","d":"path_package differs from system.file() in that it always returns an\nerror if the package does not exist. It also returns a different error if\nthe file within the package does not exist.\n","ec":"path_package(package, ...)"},{"p":"fs","o":"file_temp_pop","f":"hp_file_temp_pop","d":"file_temp() returns the name which can be used as a temporary file.\n","ec":"file_temp_pop()"},{"p":"fs","o":"is_dir","f":"hp_is_dir","d":"Functions to test for file types\n","ec":"is_dir(path, follow = TRUE)"},{"p":"fs","o":"path_split","f":"hp_path_split","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_split(path)"},{"p":"fs","o":"path_ext_set","f":"hp_path_ext_set","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_ext_set(path, ext)"},{"p":"fs","o":"as_fs_bytes","f":"hp_as_fs_bytes","d":"Construct, manipulate and display vectors of file sizes. These are numeric\nvectors, so you can compare them numerically, but they can also be compared\nto human readable values such as '10MB'.\n","ec":"as_fs_bytes(x)"},{"p":"fs","o":"path_tidy","f":"hp_path_tidy","d":"untidy paths are all different, tidy paths are all the same.\nTidy paths always use / to delimit directories, never have\nmultiple / or trailing / and have colourised output based on the file\ntype.\n","ec":"path_tidy(path)"},{"p":"fs","o":"file_create","f":"hp_file_create","d":"The functions file_create() and dir_create() ensure that path exists;\nif it already exists it will be left unchanged. That means that compared to\nfile.create(), file_create() will not truncate an existing file, and\ncompared to dir.create(), dir_create() will silently ignore existing\ndirectories.\n","ec":"file_create(path, ..., mode = \"u=rw,go=r\")"},{"p":"fs","o":"path_abs","f":"hp_path_abs","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_abs(path, start = \".\")"},{"p":"fs","o":"file_exists","f":"hp_file_exists","d":"file_exists(path) is a shortcut for file_access(x, \"exists\");\ndir_exists(path) and link_exists(path) are similar but also check that\nthe path is a directory or link, respectively. (file_exists(path) returns\nTRUE if path exists and it is a directory.)\n","ec":"file_exists(path)"},{"p":"fs","o":"user_ids","f":"hp_user_ids","d":"These functions use the GETPWENT(3) and GETGRENT(3) system calls to query\nusers and groups respectively.\n","ec":"user_ids()"},{"p":"fs","o":"path_wd","f":"hp_path_wd","d":"path() constructs a relative path, path_wd() constructs an absolute path\nfrom the current working directory.\n","ec":"path_wd(..., ext = \"\")"},{"p":"fs","o":"dir_create","f":"hp_dir_create","d":"The functions file_create() and dir_create() ensure that path exists;\nif it already exists it will be left unchanged. That means that compared to\nfile.create(), file_create() will not truncate an existing file, and\ncompared to dir.create(), dir_create() will silently ignore existing\ndirectories.\n","ec":"dir_create(path, ..., mode = \"u=rwx,go=rx\", recurse = TRUE, recursive)"},{"p":"fs","o":"file_show","f":"hp_file_show","d":"Open files or directories\n","ec":"file_show(path = \".\", browser = getOption(\"browser\"))"},{"p":"fs","o":"is_file","f":"hp_is_file","d":"Functions to test for file types\n","ec":"is_file(path, follow = TRUE)"},{"p":"fs","o":"path_ext","f":"hp_path_ext","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_ext(path)"},{"p":"fs","o":"file_chmod","f":"hp_file_chmod","d":"Change file permissions\n","ec":"file_chmod(path, mode)"},{"p":"fs","o":"file_size","f":"hp_file_size","d":"Compared to file.info() the full results of a stat(2) system call are\nreturned and some columns are returned as S3 classes to make manipulation\nmore natural. On systems which do not support all metadata (such as Windows)\ndefault values are used.\n","ec":"file_size(path, fail = TRUE)"},{"p":"fs","o":"path_has_parent","f":"hp_path_has_parent","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_has_parent(path, parent)"},{"p":"fs","o":"file_access","f":"hp_file_access","d":"file_exists(path) is a shortcut for file_access(x, \"exists\");\ndir_exists(path) and link_exists(path) are similar but also check that\nthe path is a directory or link, respectively. (file_exists(path) returns\nTRUE if path exists and it is a directory.)\n","ec":"file_access(path, mode = \"exists\")"},{"p":"fs","o":"fs_perms","f":"hp_fs_perms","d":"fs_perms() objects help one create and modify file permissions easily.\nThey support both numeric input, octal and symbolic character\nrepresentations. Compared to octmode they support symbolic representations\nand display the mode the same format as ls on POSIX systems.\n","ec":"fs_perms(x, ...)"},{"p":"fs","o":"path_sanitize","f":"hp_path_sanitize","d":"path_sanitize() removes the following:\n","ec":"path_sanitize(filename, replacement = \"\")"},{"p":"fs","o":"file_temp_push","f":"hp_file_temp_push","d":"file_temp() returns the name which can be used as a temporary file.\n","ec":"file_temp_push(path)"},{"p":"fs","o":"link_create","f":"hp_link_create","d":"The functions file_create() and dir_create() ensure that path exists;\nif it already exists it will be left unchanged. That means that compared to\nfile.create(), file_create() will not truncate an existing file, and\ncompared to dir.create(), dir_create() will silently ignore existing\ndirectories.\n","ec":"link_create(path, new_path, symbolic = TRUE)"},{"p":"fs","o":"path_home","f":"hp_path_home","d":"path_expand() differs from base::path.expand() in the interpretation of\nthe home directory of Windows. In particular path_expand() uses the path\nset in the USERPROFILE environment variable and, if unset, then uses\nHOMEDRIVE/HOMEPATH.\n","ec":"path_home(...)"},{"p":"fs","o":"path_real","f":"hp_path_real","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_real(path)"},{"p":"fs","o":"file_touch","f":"hp_file_touch","d":"Unlike the touch POSIX utility this does not create the file if it does not\nexist. Use file_create() to do this if needed.\n","ec":"file_touch(path, access_time = Sys.time(), modification_time = access_time)"},{"p":"fs","o":"path_ext<-","f":"hp_path_ext..","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_ext<-(path, value)"},{"p":"fs","o":"link_delete","f":"hp_link_delete","d":"file_delete() and link_delete() delete file and links. Compared to\nfile.remove they always fail if they cannot delete the object rather than\nchanging return value or signalling a warning. If any inputs are\ndirectories, they are passed to dir_delete(), so file_delete() can\ntherefore be used to delete any filesystem object.\n","ec":"link_delete(path)"},{"p":"fs","o":"path_temp","f":"hp_path_temp","d":"file_temp() returns the name which can be used as a temporary file.\n","ec":"path_temp(...)"},{"p":"fs","o":"dir_exists","f":"hp_dir_exists","d":"file_exists(path) is a shortcut for file_access(x, \"exists\");\ndir_exists(path) and link_exists(path) are similar but also check that\nthe path is a directory or link, respectively. (file_exists(path) returns\nTRUE if path exists and it is a directory.)\n","ec":"dir_exists(path)"},{"p":"fs","o":"path_file","f":"hp_path_file","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_file(path)"},{"p":"fs","o":"is_absolute_path","f":"hp_is_absolute_path","d":"Test if a path is an absolute path\n","ec":"is_absolute_path(path)"},{"p":"fs","o":"dir_delete","f":"hp_dir_delete","d":"file_delete() and link_delete() delete file and links. Compared to\nfile.remove they always fail if they cannot delete the object rather than\nchanging return value or signalling a warning. If any inputs are\ndirectories, they are passed to dir_delete(), so file_delete() can\ntherefore be used to delete any filesystem object.\n","ec":"dir_delete(path)"},{"p":"fs","o":"path_expand","f":"hp_path_expand","d":"path_expand() differs from base::path.expand() in the interpretation of\nthe home directory of Windows. In particular path_expand() uses the path\nset in the USERPROFILE environment variable and, if unset, then uses\nHOMEDRIVE/HOMEPATH.\n","ec":"path_expand(path)"},{"p":"fs","o":"file_chown","f":"hp_file_chown","d":"Change owner or group of a file\n","ec":"file_chown(path, user_id = NULL, group_id = NULL)"},{"p":"fs","o":"dir_walk","f":"hp_dir_walk","d":"dir_ls() is equivalent to the ls command. It returns filenames as a\nnamed fs_path character vector. The names are equivalent to the values,\nwhich is useful for passing onto functions like purrr::map_dfr().\n","ec":"dir_walk(path = \".\", fun, all = FALSE, recurse = FALSE, type = \"any\", fail = TRUE)"},{"p":"fs","o":"path_norm","f":"hp_path_norm","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_norm(path)"},{"p":"fs","o":"path_dir","f":"hp_path_dir","d":"path_file() returns the filename portion of the path, path_dir() returns\nthe directory portion. path_ext() returns the last extension (if any) for a\npath. path_ext_remove() removes the last extension and returns the rest of\nthe path. path_ext_set() replaces the extension with a new extension. If\nthere is no existing extension the new extension is appended.\n","ec":"path_dir(path)"},{"p":"fs","o":"path_rel","f":"hp_path_rel","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_rel(path, start = \".\")"},{"p":"fs","o":"file_delete","f":"hp_file_delete","d":"file_delete() and link_delete() delete file and links. Compared to\nfile.remove they always fail if they cannot delete the object rather than\nchanging return value or signalling a warning. If any inputs are\ndirectories, they are passed to dir_delete(), so file_delete() can\ntherefore be used to delete any filesystem object.\n","ec":"file_delete(path)"},{"p":"fs","o":"link_exists","f":"hp_link_exists","d":"file_exists(path) is a shortcut for file_access(x, \"exists\");\ndir_exists(path) and link_exists(path) are similar but also check that\nthe path is a directory or link, respectively. (file_exists(path) returns\nTRUE if path exists and it is a directory.)\n","ec":"link_exists(path)"},{"p":"fs","o":"file_copy","f":"hp_file_copy","d":"file_copy() copies files.\n","ec":"file_copy(path, new_path, overwrite = FALSE)"},{"p":"fs","o":"path_join","f":"hp_path_join","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_join(parts)"},{"p":"fs","o":"link_copy","f":"hp_link_copy","d":"file_copy() copies files.\n","ec":"link_copy(path, new_path, overwrite = FALSE)"},{"p":"fs","o":"path_common","f":"hp_path_common","d":"All functions apart from path_real() are purely path computations, so the\nfiles in question do not need to exist on the filesystem.\n","ec":"path_common(path)"},{"p":"fs","o":"path_expand_r","f":"hp_path_expand_r","d":"path_expand() differs from base::path.expand() in the interpretation of\nthe home directory of Windows. In particular path_expand() uses the path\nset in the USERPROFILE environment variable and, if unset, then uses\nHOMEDRIVE/HOMEPATH.\n","ec":"path_expand_r(path)"},{"p":"fs","o":"file_temp","f":"hp_file_temp","d":"file_temp() returns the name which can be used as a temporary file.\n","ec":"file_temp(pattern = \"file\", tmp_dir = tempdir(), ext = \"\")"},{"p":"generics","o":"union","f":"hp_union","d":"Union (union()), intersect (intersect()), difference (setdiff()),\nand equality (setequal()) for two vectors representing sets. Determine\nmembership with is.element().\n","ec":"union(x, y, ...)"},{"p":"generics","o":"rank_results","f":"hp_rank_results","d":"rank_results() computes relative ranks of a collection of objects and\nreturns a summary of the results.\n","ec":"rank_results(x, ...)"},{"p":"generics","o":"fit","f":"hp_fit","d":"Estimates parameters for a given model from a set of data.\n","ec":"fit(object, ...)"},{"p":"generics","o":"estfun","f":"hp_estfun","d":"Extracting the estimating functions of a fitted model.\n","ec":"estfun(x, ...)"},{"p":"generics","o":"var_imp","f":"hp_var_imp","d":"A generic method for calculating variable importance for model objects.\n","ec":"var_imp(object, ...)"},{"p":"generics","o":"train","f":"hp_train","d":"Estimates parameters for a given model from a set of data.\n","ec":"train(x, ...)"},{"p":"generics","o":"forecast","f":"hp_forecast","d":"The functions allow producing forecasts based on the provided object.\n","ec":"forecast(object, ...)"},{"p":"generics","o":"hypothesize","f":"hp_hypothesize","d":"Construct hypotheses.\n","ec":"hypothesize(x, ...)"},{"p":"generics","o":"setdiff","f":"hp_setdiff","d":"Union (union()), intersect (intersect()), difference (setdiff()),\nand equality (setequal()) for two vectors representing sets. Determine\nmembership with is.element().\n","ec":"setdiff(x, y, ...)"},{"p":"generics","o":"glance","f":"hp_glance","d":"Construct a single row summary \"glance\" of a model, fit, or other\nobject\n","ec":"glance(x, ...)"},{"p":"generics","o":"visualize","f":"hp_visualize","d":"Visualize a data set or object.\n","ec":"visualize(x, ...)"},{"p":"generics","o":"fit_xy","f":"hp_fit_xy","d":"Estimates parameters for a given model from a set of data in the form of\na set of predictors (x) and outcome(s) (y).\n","ec":"fit_xy(object, ...)"},{"p":"generics","o":"learn","f":"hp_learn","d":"Estimates parameters for a given model from a set of data.\n","ec":"learn(x, ...)"},{"p":"generics","o":"accuracy","f":"hp_accuracy","d":"Returns range of summary measures of the forecast accuracy.\n","ec":"accuracy(object, ...)"},{"p":"generics","o":"equation","f":"hp_equation","d":"Display the mathematical representation of a fitted model.\n","ec":"equation(object, ...)"},{"p":"generics","o":"prune","f":"hp_prune","d":"Prune or reduce an object\n","ec":"prune(tree, ...)"},{"p":"generics","o":"evaluate","f":"hp_evaluate","d":"Evaluate an object.\n","ec":"evaluate(x, ...)"},{"p":"generics","o":"refit","f":"hp_refit","d":"Refitting models\n","ec":"refit(object, ...)"},{"p":"generics","o":"calculate","f":"hp_calculate","d":"Calculate statistics.\n","ec":"calculate(x, ...)"},{"p":"generics","o":"min_grid","f":"hp_min_grid","d":"min_grid() determines exactly what models should be fit in order to\nevaluate the entire set of tuning parameter combinations. This is for\ninternal use only and the API may change in the near future.\n","ec":"min_grid(x, grid, ...)"},{"p":"generics","o":"is.element","f":"hp_is.element","d":"Union (union()), intersect (intersect()), difference (setdiff()),\nand equality (setequal()) for two vectors representing sets. Determine\nmembership with is.element().\n","ec":"is.element(el, set, ...)"},{"p":"generics","o":"tunable","f":"hp_tunable","d":"Returns information on potential hyper-parameters that can be optimized.\n","ec":"tunable(x, ...)"},{"p":"generics","o":"as.difftime","f":"hp_as.difftime","d":"Coercion functions for creating difftime objects from other\nexisting objects.\n","ec":"as.difftime(tim, ...)"},{"p":"generics","o":"varying_args","f":"hp_varying_args","d":"Find any arguments that are not fully specified.\n","ec":"varying_args(object, ...)"},{"p":"generics","o":"explore","f":"hp_explore","d":"explore() invokes a function that starts an interactive, pre-defined widget\n(e.g. plotly visualization, shiny app, etc.) to investigate the results.\n","ec":"explore(x, ...)"},{"p":"generics","o":"as.ordered","f":"hp_as.ordered","d":"Coercion functions for creating factors from other existing objects.\n","ec":"as.ordered(x, ...)"},{"p":"generics","o":"intersect","f":"hp_intersect","d":"Union (union()), intersect (intersect()), difference (setdiff()),\nand equality (setequal()) for two vectors representing sets. Determine\nmembership with is.element().\n","ec":"intersect(x, y, ...)"},{"p":"generics","o":"augment","f":"hp_augment","d":"Augment data with information from an object\n","ec":"augment(x, ...)"},{"p":"generics","o":"tune_args","f":"hp_tune_args","d":"tune_args() takes an object such as a model specification or a recipe and\nreturns a tibble of information on all possible tunable arguments and\nwhether or not they are actually tunable.\n","ec":"tune_args(object, ...)"},{"p":"generics","o":"explain","f":"hp_explain","d":"Explain details of an object\n","ec":"explain(x, ...)"},{"p":"generics","o":"specify","f":"hp_specify","d":"Specify variables or other quantities.\n","ec":"specify(x, ...)"},{"p":"generics","o":"setequal","f":"hp_setequal","d":"Union (union()), intersect (intersect()), difference (setdiff()),\nand equality (setequal()) for two vectors representing sets. Determine\nmembership with is.element().\n","ec":"setequal(x, y, ...)"},{"p":"generics","o":"as.factor","f":"hp_as.factor","d":"Coercion functions for creating factors from other existing objects.\n","ec":"as.factor(x, ...)"},{"p":"generics","o":"tidy","f":"hp_tidy","d":"Turn an object into a tidy tibble\n","ec":"tidy(x, ...)"},{"p":"generics","o":"components","f":"hp_components","d":"components can be used to extract elements from an object.\n","ec":"components(object, ...)"},{"p":"generics","o":"compile","f":"hp_compile","d":"Finalizes or completes an object.\n","ec":"compile(object, ...)"},{"p":"generics","o":"required_pkgs","f":"hp_required_pkgs","d":"Determine packages required by objects\n","ec":"required_pkgs(x, ...)"},{"p":"generics","o":"interpolate","f":"hp_interpolate","d":"Interpolates missing values provided in the training dataset using the\nfitted model.\n","ec":"interpolate(object, ...)"},{"p":"generics","o":"generate","f":"hp_generate","d":"Generate values based on inputs\n","ec":"generate(x, ...)"},{"p":"ggplot2","o":"update_geom_defaults","f":"hp_update_geom_defaults","d":"Modify geom/stat aesthetic defaults for future plots\n","ec":"update_geom_defaults(geom, new)"},{"p":"ggplot2","o":"stat_count","f":"hp_stat_count","d":"There are two types of bar charts: geom_bar() and geom_col().\ngeom_bar() makes the height of the bar proportional to the number of\ncases in each group (or if the weight aesthetic is supplied, the sum\nof the weights). If you want the heights of the bars to represent values\nin the data, use geom_col() instead. geom_bar() uses stat_count() by\ndefault: it counts the number of cases at each x position. geom_col()\nuses stat_identity(): it leaves the data as is.\n","ec":"stat_count(mapping = NULL, data = NULL, geom = \"bar\", position = \"stack\", ..., width = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"StatQq","f":"hp_StatQq","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"guide_custom","f":"hp_guide_custom","d":"This is a special guide that can be used to display any graphical object\n(grob) along with the regular guides. This guide has no associated scale.\n","ec":"guide_custom(grob, width = grobWidth(grob), height = grobHeight(grob), title = NULL, theme = NULL, position = NULL, order = 0)"},{"p":"ggplot2","o":"GeomLine","f":"hp_GeomLine","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"render_strips","f":"hp_render_strips","d":"All positions are rendered and it is up to the facet to decide which to use\n","ec":"render_strips(x = NULL, y = NULL, labeller, theme)"},{"p":"ggplot2","o":"GeomLogticks","f":"hp_GeomLogticks","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"%+replace%","f":"hp_X..replace.","d":"The current/active theme (see theme()) is automatically applied to every\nplot you draw. Use theme_get() to get the current theme, and theme_set() to\ncompletely override it. theme_update() and theme_replace() are shorthands for\nchanging individual elements.\n","ec":"%+replace%(e1, e2)"},{"p":"ggplot2","o":"GeomPolygon","f":"hp_GeomPolygon","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_qq","f":"hp_stat_qq","d":"geom_qq() and stat_qq() produce quantile-quantile plots. geom_qq_line() and\nstat_qq_line() compute the slope and intercept of the line connecting the\npoints at specified quartiles of the theoretical and sample distributions.\n","ec":"stat_qq(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", ..., distribution = stats::qnorm, dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomBoxplot","f":"hp_GeomBoxplot","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"cut_width","f":"hp_cut_width","d":"cut_interval() makes n groups with equal range, cut_number()\nmakes n groups with (approximately) equal numbers of observations;\ncut_width() makes groups of width width.\n","ec":"cut_width(x, width, center = NULL, boundary = NULL, closed = \"right\", ...)"},{"p":"ggplot2","o":"scale_linewidth_ordinal","f":"hp_scale_linewidth_ordinal","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_ordinal(name = waiver(), ..., range = c(2, 6))"},{"p":"ggplot2","o":"ScaleBinnedPosition","f":"hp_ScaleBinnedPosition","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomAnnotationMap","f":"hp_GeomAnnotationMap","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomDensity","f":"hp_GeomDensity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_fermenter","f":"hp_scale_fill_fermenter","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_fill_fermenter(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"get_alt_text","f":"hp_get_alt_text","d":"This function returns a text that can be used as alt-text in webpages etc.\nCurrently it will use the alt label, added with <U+2060>+ labs(alt = <...>)<U+2060>, or\na return an empty string, but in the future it might try to generate an alt\ntext from the information stored in the plot.\n","ec":"get_alt_text(p, ...)"},{"p":"ggplot2","o":"scale_linetype_manual","f":"hp_scale_linetype_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_linetype_manual(..., values, breaks = waiver(), na.value = \"blank\")"},{"p":"ggplot2","o":"map_data","f":"hp_map_data","d":"Easily turn data from the maps package into a data frame suitable\nfor plotting with ggplot2.\n","ec":"map_data(map, region = \".\", exact = FALSE, ...)"},{"p":"ggplot2","o":"scale_color_viridis_b","f":"hp_scale_color_viridis_b","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_color_viridis_b(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"ScaleContinuousIdentity","f":"hp_ScaleContinuousIdentity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_viridis_c","f":"hp_scale_color_viridis_c","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_color_viridis_c(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"scale_color_viridis_d","f":"hp_scale_color_viridis_d","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_color_viridis_d(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"stat_summary_2d","f":"hp_stat_summary_2d","d":"stat_summary_2d() is a 2d variation of stat_summary().\nstat_summary_hex() is a hexagonal variation of\nstat_summary_2d(). The data are divided into bins defined\nby x and y, and then the values of z in each cell is\nare summarised with fun.\n","ec":"stat_summary_2d(mapping = NULL, data = NULL, geom = \"tile\", position = \"identity\", ..., bins = 30, binwidth = NULL, drop = TRUE, fun = \"mean\", fun.args = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"CoordSf","f":"hp_CoordSf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":""},{"p":"ggplot2","o":"geom_count","f":"hp_geom_count","d":"This is a variant geom_point() that counts the number of\nobservations at each location, then maps the count to point area. It\nuseful when you have discrete data and overplotting.\n","ec":"geom_count(mapping = NULL, data = NULL, stat = \"sum\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"CoordFixed","f":"hp_CoordFixed","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_ordinal","f":"hp_scale_fill_ordinal","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_fill_ordinal(..., type = getOption(\"ggplot2.ordinal.fill\", getOption(\"ggplot2.ordinal.colour\")))"},{"p":"ggplot2","o":"sf_transform_xy","f":"hp_sf_transform_xy","d":"Helper function that can transform spatial position data (pairs of x, y\nvalues) among coordinate systems. This is implemented as a thin wrapper\naround sf::sf_project().\n","ec":"sf_transform_xy(data, target_crs, source_crs, authority_compliant = FALSE)"},{"p":"ggplot2","o":"StatSf","f":"hp_StatSf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":""},{"p":"ggplot2","o":"draw_key_pointrange","f":"hp_draw_key_pointrange","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_pointrange(data, params, size)"},{"p":"ggplot2","o":"is.Coord","f":"hp_is.Coord","d":"Is this object a coordinate system?\n","ec":"is.Coord(x)"},{"p":"ggplot2","o":"PositionDodge2","f":"hp_PositionDodge2","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_alpha_identity","f":"hp_scale_alpha_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_alpha_identity(name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"should_stop","f":"hp_should_stop","d":"Used in examples to illustrate when errors should occur.\n","ec":"should_stop(expr)"},{"p":"ggplot2","o":"GeomCurve","f":"hp_GeomCurve","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_size_datetime","f":"hp_scale_size_datetime","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_datetime(name = waiver(), ..., range = c(1, 6))"},{"p":"ggplot2","o":"scale_linetype_discrete","f":"hp_scale_linetype_discrete","d":"Default line types based on a set supplied by Richard Pearson,\nUniversity of Manchester. Continuous values can not be mapped to\nline types unless scale_linetype_binned() is used. Still, as linetypes has\nno inherent order, this use is not advised.\n","ec":"scale_linetype_discrete(name = waiver(), ..., na.value = \"blank\")"},{"p":"ggplot2","o":"StatBoxplot","f":"hp_StatBoxplot","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_discrete","f":"hp_scale_color_discrete","d":"The default discrete colour scale. Defaults to scale_fill_hue()/scale_fill_brewer()\nunless type (which defaults to the ggplot2.discrete.fill/ggplot2.discrete.colour options)\nis specified.\n","ec":"scale_color_discrete(..., type = getOption(\"ggplot2.discrete.colour\"))"},{"p":"ggplot2","o":"GeomStep","f":"hp_GeomStep","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"fortify","f":"hp_fortify","d":"Rather than using this function, I now recommend using the broom\npackage, which implements a much wider range of methods. fortify()\nmay be deprecated in the future.\n","ec":"fortify(model, data, ...)"},{"p":"ggplot2","o":"CoordFlip","f":"hp_CoordFlip","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":".ignore_data","f":"hp_.ignore_data","d":"The .ignore_data() function is used to hide <U+2060><AsIs><U+2060> columns during\nscale interactions in ggplot_build(). The .expose_data() function is\nused to restore hidden columns.\n","ec":".ignore_data(data)"},{"p":"ggplot2","o":"geom_crossbar","f":"hp_geom_crossbar","d":"Various ways of representing a vertical interval defined by x,\nymin and ymax. Each case draws a single graphical object.\n","ec":"geom_crossbar(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., fatten = 2.5, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"discrete_scale","f":"hp_discrete_scale","d":"Discrete scale constructor\n","ec":"discrete_scale(aesthetics, scale_name = deprecated(), palette, name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), na.translate = TRUE, na.value = NA, drop = TRUE, guide = \"legend\", position = \"left\", call = caller_call(), super = ScaleDiscrete)"},{"p":"ggplot2","o":"scale_shape_continuous","f":"hp_scale_shape_continuous","d":"scale_shape() maps discrete variables to six easily discernible shapes.\nIf you have more than six levels, you will get a warning message, and the\nseventh and subsequent levels will not appear on the plot. Use\nscale_shape_manual() to supply your own values. You can not map\na continuous variable to shape unless scale_shape_binned() is used. Still,\nas shape has no inherent order, this use is not advised.\n","ec":"scale_shape_continuous(...)"},{"p":"ggplot2","o":"stat_sf_coordinates","f":"hp_stat_sf_coordinates","d":"stat_sf_coordinates() extracts the coordinates from 'sf' objects and\nsummarises them to one pair of coordinates (x and y) per geometry. This is\nconvenient when you draw an sf object as geoms like text and labels (so\ngeom_sf_text() and geom_sf_label() relies on this).\n","ec":"stat_sf_coordinates(mapping = aes(), data = NULL, geom = \"point\", position = \"identity\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, fun.geometry = NULL, ...)"},{"p":"ggplot2","o":"StatBin2d","f":"hp_StatBin2d","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"draw_key_label","f":"hp_draw_key_label","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_label(data, params, size)"},{"p":"ggplot2","o":".pt","f":"hp_.pt","d":"Multiply size in mm by these constants in order to convert to the units\nthat grid uses internally for lwd and fontsize.\n","ec":""},{"p":"ggplot2","o":"derive","f":"hp_derive","d":"This function is used in conjunction with a position scale to create a\nsecondary axis, positioned opposite of the primary axis. All secondary\naxes must be based on a one-to-one transformation of the primary axes.\n","ec":"derive()"},{"p":"ggplot2","o":"aes_all","f":"hp_aes_all","d":"Given a character vector, create a set of identity mappings\n","ec":"aes_all(vars)"},{"p":"ggplot2","o":"PositionStack","f":"hp_PositionStack","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomViolin","f":"hp_GeomViolin","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"StatBin","f":"hp_StatBin","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_shape_binned","f":"hp_scale_shape_binned","d":"scale_shape() maps discrete variables to six easily discernible shapes.\nIf you have more than six levels, you will get a warning message, and the\nseventh and subsequent levels will not appear on the plot. Use\nscale_shape_manual() to supply your own values. You can not map\na continuous variable to shape unless scale_shape_binned() is used. Still,\nas shape has no inherent order, this use is not advised.\n","ec":"scale_shape_binned(name = waiver(), ..., solid = TRUE)"},{"p":"ggplot2","o":"stat_quantile","f":"hp_stat_quantile","d":"This fits a quantile regression to the data and draws the fitted quantiles\nwith lines. This is as a continuous analogue to geom_boxplot().\n","ec":"stat_quantile(mapping = NULL, data = NULL, geom = \"quantile\", position = \"identity\", ..., quantiles = c(0.25, 0.5, 0.75), formula = NULL, method = \"rq\", method.args = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomErrorbarh","f":"hp_GeomErrorbarh","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"position_dodge2","f":"hp_position_dodge2","d":"Dodging preserves the vertical position of an geom while adjusting the\nhorizontal position. position_dodge() requires the grouping variable to be\nbe specified in the global or <U+2060>geom_*<U+2060> layer. Unlike position_dodge(),\nposition_dodge2() works without a grouping variable in a layer.\nposition_dodge2() works with bars and rectangles, but is\nparticularly useful for arranging box plots, which\ncan have variable widths.\n","ec":"position_dodge2(width = NULL, preserve = \"total\", padding = 0.1, reverse = FALSE)"},{"p":"ggplot2","o":"layer_sf","f":"hp_layer_sf","d":"The layer_sf() function is a variant of layer() meant to be used by\nextension developers who are writing new sf-based geoms or stats.\nThe sf layer checks whether the data contains a geometry column, and\nif one is found it is automatically mapped to the geometry aesthetic.\n","ec":"layer_sf(geom = NULL, stat = NULL, data = NULL, mapping = NULL, position = NULL, params = list(), inherit.aes = TRUE, check.aes = TRUE, check.param = TRUE, show.legend = NA)"},{"p":"ggplot2","o":"Geom","f":"hp_Geom","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_y_discrete","f":"hp_scale_y_discrete","d":"scale_x_discrete() and scale_y_discrete() are used to set the values for\ndiscrete x and y scale aesthetics. For simple manipulation of scale labels\nand limits, you may wish to use labs() and lims() instead.\n","ec":"scale_y_discrete(name = waiver(), ..., expand = waiver(), guide = waiver(), position = \"left\")"},{"p":"ggplot2","o":"scale_colour_grey","f":"hp_scale_colour_grey","d":"Based on gray.colors(). This is black and white equivalent\nof scale_colour_gradient().\n","ec":"scale_colour_grey(name = waiver(), ..., start = 0.2, end = 0.8, na.value = \"red\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"mean_cl_normal","f":"hp_mean_cl_normal","d":"These are wrappers around functions from Hmisc designed to make them\neasier to use with stat_summary(). See the Hmisc documentation\nfor more details:\n","ec":"mean_cl_normal(x, ...)"},{"p":"ggplot2","o":"summarise_layout","f":"hp_summarise_layout","d":"These functions provide summarised information about built ggplot objects.\n","ec":"summarise_layout(p)"},{"p":"ggplot2","o":"Position","f":"hp_Position","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"Coord","f":"hp_Coord","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_line","f":"hp_geom_line","d":"geom_path() connects the observations in the order in which they appear\nin the data. geom_line() connects them in order of the variable on the\nx axis. geom_step() creates a stairstep plot, highlighting exactly\nwhen changes occur. The group aesthetic determines which cases are\nconnected together.\n","ec":"geom_line(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, ...)"},{"p":"ggplot2","o":"standardise_aes_names","f":"hp_standardise_aes_names","d":"This function standardises aesthetic names by converting color to colour\n(also in substrings, e.g. point_color to point_colour) and translating old style\nR names to ggplot names (eg. pch to shape, cex to size).\n","ec":"standardise_aes_names(x)"},{"p":"ggplot2","o":"CoordPolar","f":"hp_CoordPolar","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"ylim","f":"hp_ylim","d":"This is a shortcut for supplying the limits argument to the individual\nscales. By default, any values outside the limits specified are replaced with\nNA. Be warned that this will remove data outside the limits and this can\nproduce unintended results. For changing x or y axis limits without\ndropping data observations, see coord_cartesian().\n","ec":"ylim(...)"},{"p":"ggplot2","o":"scale_colour_gradient2","f":"hp_scale_colour_gradient2","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_colour_gradient2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"stat_density2d_filled","f":"hp_stat_density2d_filled","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"stat_density2d_filled(mapping = NULL, data = NULL, geom = \"density_2d_filled\", position = \"identity\", ..., contour = TRUE, contour_var = \"density\", n = 100, h = NULL, adjust = c(1, 1), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"draw_key_vpath","f":"hp_draw_key_vpath","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_vpath(data, params, size)"},{"p":"ggplot2","o":"continuous_scale","f":"hp_continuous_scale","d":"Continuous scale constructor\n","ec":"continuous_scale(aesthetics, scale_name = deprecated(), palette, name = waiver(), breaks = waiver(), minor_breaks = waiver(), n.breaks = NULL, labels = waiver(), limits = NULL, rescaler = rescale, oob = censor, expand = waiver(), na.value = NA_real_, transform = \"identity\", trans = deprecated(), guide = \"legend\", position = \"left\", call = caller_call(), super = ScaleContinuous)"},{"p":"ggplot2","o":"stat_density","f":"hp_stat_density","d":"Computes and draws kernel density estimate, which is a smoothed version of\nthe histogram. This is a useful alternative to the histogram for continuous\ndata that comes from an underlying smooth distribution.\n","ec":"stat_density(mapping = NULL, data = NULL, geom = \"area\", position = \"stack\", ..., bw = \"nrd0\", adjust = 1, kernel = \"gaussian\", n = 512, trim = FALSE, na.rm = FALSE, bounds = c(-Inf, Inf), orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"cut_interval","f":"hp_cut_interval","d":"cut_interval() makes n groups with equal range, cut_number()\nmakes n groups with (approximately) equal numbers of observations;\ncut_width() makes groups of width width.\n","ec":"cut_interval(x, n = NULL, length = NULL, ...)"},{"p":"ggplot2","o":"PositionJitterdodge","f":"hp_PositionJitterdodge","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_label","f":"hp_geom_label","d":"Text geoms are useful for labeling plots. They can be used by themselves as\nscatterplots or in combination with other geoms, for example, for labeling\npoints or for annotating the height of bars. geom_text() adds only text\nto the plot. geom_label() draws a rectangle behind the text, making it\neasier to read.\n","ec":"geom_label(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., parse = FALSE, nudge_x = 0, nudge_y = 0, label.padding = unit(0.25, \"lines\"), label.r = unit(0.15, \"lines\"), label.size = 0.25, size.unit = \"mm\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_fill_grey","f":"hp_scale_fill_grey","d":"Based on gray.colors(). This is black and white equivalent\nof scale_colour_gradient().\n","ec":"scale_fill_grey(name = waiver(), ..., start = 0.2, end = 0.8, na.value = \"red\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"qplot","f":"hp_qplot","d":"qplot() is now deprecated in order to encourage the users to\nlearn ggplot() as it makes it easier to create complex graphics.\n","ec":"qplot(x, y, ..., data, facets = NULL, margins = FALSE, geom = \"auto\", xlim = c(NA, NA), ylim = c(NA, NA), log = \"\", main = NULL, xlab = NULL, ylab = NULL, asp = NA, stat = deprecated(), position = deprecated())"},{"p":"ggplot2","o":"label_both","f":"hp_label_both","d":"Labeller functions are in charge of formatting the strip labels of\nfacet grids and wraps. Most of them accept a multi_line\nargument to control whether multiple factors (defined in formulae\nsuch as ~first + second) should be displayed on a single\nline separated with commas, or each on their own line.\n","ec":"label_both(labels, multi_line = TRUE, sep = \": \")"},{"p":"ggplot2","o":"coord_trans","f":"hp_coord_trans","d":"coord_trans() is different to scale transformations in that it occurs after\nstatistical transformation and will affect the visual appearance of geoms - there is\nno guarantee that straight lines will continue to be straight.\n","ec":"coord_trans(x = \"identity\", y = \"identity\", xlim = NULL, ylim = NULL, limx = deprecated(), limy = deprecated(), clip = \"on\", expand = TRUE)"},{"p":"ggplot2","o":"facet_null","f":"hp_facet_null","d":"Facet specification: a single panel.\n","ec":"facet_null(shrink = TRUE)"},{"p":"ggplot2","o":"scale_fill_distiller","f":"hp_scale_fill_distiller","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_fill_distiller(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"StatQuantile","f":"hp_StatQuantile","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_colour_identity","f":"hp_scale_colour_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_colour_identity(name = waiver(), ..., guide = \"none\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"GeomPointrange","f":"hp_GeomPointrange","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_y_date","f":"hp_scale_y_date","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_y_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver(), oob = censor, guide = waiver(), position = \"left\", sec.axis = waiver())"},{"p":"ggplot2","o":"StatBindot","f":"hp_StatBindot","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GuideColoursteps","f":"hp_GuideColoursteps","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"ggplotGrob","f":"hp_ggplotGrob","d":"Generate a ggplot2 plot grob.\n","ec":"ggplotGrob(x)"},{"p":"ggplot2","o":"scale_alpha","f":"hp_scale_alpha","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"label_wrap_gen","f":"hp_label_wrap_gen","d":"Labeller functions are in charge of formatting the strip labels of\nfacet grids and wraps. Most of them accept a multi_line\nargument to control whether multiple factors (defined in formulae\nsuch as ~first + second) should be displayed on a single\nline separated with commas, or each on their own line.\n","ec":"label_wrap_gen(width = 25, multi_line = TRUE)"},{"p":"ggplot2","o":"scale_alpha_ordinal","f":"hp_scale_alpha_ordinal","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_ordinal(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"scale_fill_steps","f":"hp_scale_fill_steps","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_fill_steps(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"GeomSpoke","f":"hp_GeomSpoke","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"draw_key_smooth","f":"hp_draw_key_smooth","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_smooth(data, params, size)"},{"p":"ggplot2","o":"labeller","f":"hp_labeller","d":"This function makes it easy to assign different labellers to\ndifferent factors. The labeller can be a function or it can be a\nnamed character vectors that will serve as a lookup table.\n","ec":"labeller(..., .rows = NULL, .cols = NULL, keep.as.numeric = deprecated(), .multi_line = TRUE, .default = label_value)"},{"p":"ggplot2","o":"geom_blank","f":"hp_geom_blank","d":"The blank geom draws nothing, but can be a useful way of ensuring common\nscales between different plots. See expand_limits() for\nmore details.\n","ec":"geom_blank(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_alpha_manual","f":"hp_scale_alpha_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_alpha_manual(..., values, breaks = waiver(), na.value = NA)"},{"p":"ggplot2","o":"draw_key_path","f":"hp_draw_key_path","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_path(data, params, size)"},{"p":"ggplot2","o":"draw_key_rect","f":"hp_draw_key_rect","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_rect(data, params, size)"},{"p":"ggplot2","o":"ggplot","f":"hp_ggplot","d":"ggplot() initializes a ggplot object. It can be used to\ndeclare the input data frame for a graphic and to specify the\nset of plot aesthetics intended to be common throughout all\nsubsequent layers unless specifically overridden.\n","ec":"ggplot(data = NULL, mapping = aes(), ..., environment = parent.frame())"},{"p":"ggplot2","o":"geom_text","f":"hp_geom_text","d":"Text geoms are useful for labeling plots. They can be used by themselves as\nscatterplots or in combination with other geoms, for example, for labeling\npoints or for annotating the height of bars. geom_text() adds only text\nto the plot. geom_label() draws a rectangle behind the text, making it\neasier to read.\n","ec":"geom_text(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., parse = FALSE, nudge_x = 0, nudge_y = 0, check_overlap = FALSE, size.unit = \"mm\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"position_identity","f":"hp_position_identity","d":"Don't adjust position\n","ec":"position_identity()"},{"p":"ggplot2","o":"panel_cols","f":"hp_panel_cols","d":"These functions help detect the placement of panels in a gtable, if they are\nnamed with \"panel\" in the beginning. find_panel() returns the extend of\nthe panel area, while panel_cols() and panel_rows() returns the\ncolumns and rows that contains panels respectively.\n","ec":"panel_cols(table)"},{"p":"ggplot2","o":"scale_alpha_binned","f":"hp_scale_alpha_binned","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_binned(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"scale_size_binned","f":"hp_scale_size_binned","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_binned(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), n.breaks = NULL, nice.breaks = TRUE, transform = \"identity\", trans = deprecated(), guide = \"bins\")"},{"p":"ggplot2","o":"scale_fill_discrete","f":"hp_scale_fill_discrete","d":"The default discrete colour scale. Defaults to scale_fill_hue()/scale_fill_brewer()\nunless type (which defaults to the ggplot2.discrete.fill/ggplot2.discrete.colour options)\nis specified.\n","ec":"scale_fill_discrete(..., type = getOption(\"ggplot2.discrete.fill\"))"},{"p":"ggplot2","o":"theme_void","f":"hp_theme_void","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_void(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"scale_x_datetime","f":"hp_scale_x_datetime","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_x_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL, limits = NULL, expand = waiver(), oob = censor, guide = waiver(), position = \"bottom\", sec.axis = waiver())"},{"p":"ggplot2","o":".stroke","f":"hp_.stroke","d":"Multiply size in mm by these constants in order to convert to the units\nthat grid uses internally for lwd and fontsize.\n","ec":""},{"p":"ggplot2","o":"scale_y_time","f":"hp_scale_y_time","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_y_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, guide = waiver(), position = \"left\", sec.axis = waiver())"},{"p":"ggplot2","o":"StatFunction","f":"hp_StatFunction","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_binhex","f":"hp_stat_binhex","d":"Divides the plane into regular hexagons, counts the number of cases in\neach hexagon, and then (by default) maps the number of cases to the hexagon\nfill.  Hexagon bins avoid the visual artefacts sometimes generated by\nthe very regular alignment of geom_bin_2d().\n","ec":"stat_binhex(mapping = NULL, data = NULL, geom = \"hex\", position = \"identity\", ..., bins = 30, binwidth = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"StatUnique","f":"hp_StatUnique","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_steps","f":"hp_scale_color_steps","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_color_steps(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"scale_y_continuous","f":"hp_scale_y_continuous","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_y_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), n.breaks = NULL, labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, transform = \"identity\", trans = deprecated(), guide = waiver(), position = \"left\", sec.axis = waiver())"},{"p":"ggplot2","o":"scale_colour_viridis_b","f":"hp_scale_colour_viridis_b","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_colour_viridis_b(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"stat_qq_line","f":"hp_stat_qq_line","d":"geom_qq() and stat_qq() produce quantile-quantile plots. geom_qq_line() and\nstat_qq_line() compute the slope and intercept of the line connecting the\npoints at specified quartiles of the theoretical and sample distributions.\n","ec":"stat_qq_line(mapping = NULL, data = NULL, geom = \"path\", position = \"identity\", ..., distribution = stats::qnorm, dparams = list(), line.p = c(0.25, 0.75), fullrange = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_viridis_c","f":"hp_scale_colour_viridis_c","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_colour_viridis_c(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"position_fill","f":"hp_position_fill","d":"position_stack() stacks bars on top of each other;\nposition_fill() stacks bars and standardises each stack to have\nconstant height.\n","ec":"position_fill(vjust = 1, reverse = FALSE)"},{"p":"ggplot2","o":"guide_merge","f":"hp_guide_merge","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"guide_merge(guide, new_guide)"},{"p":"ggplot2","o":"scale_colour_viridis_d","f":"hp_scale_colour_viridis_d","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_colour_viridis_d(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"el_def","f":"hp_el_def","d":"The underlying structure of a ggplot2 theme is defined via the element tree, which\nspecifies for each theme element what type it should have and whether it inherits from\na parent element. In some use cases, it may be necessary to modify or extend this\nelement tree and provide default settings for newly defined theme elements.\n","ec":"el_def(class = NULL, inherit = NULL, description = NULL)"},{"p":"ggplot2","o":"guide_colourbar","f":"hp_guide_colourbar","d":"Colour bar guide shows continuous colour scales mapped onto values.\nColour bar is available with scale_fill and scale_colour.\nFor more information, see the inspiration for this function:\nMatlab's colorbar function.\n","ec":"guide_colourbar(title = waiver(), theme = NULL, nbin = NULL, display = \"raster\", raster = deprecated(), alpha = NA, draw.ulim = TRUE, draw.llim = TRUE, position = NULL, direction = NULL, reverse = FALSE, order = 0, available_aes = c(\"colour\", \"color\", \"fill\"), ...)"},{"p":"ggplot2","o":"geom_step","f":"hp_geom_step","d":"geom_path() connects the observations in the order in which they appear\nin the data. geom_line() connects them in order of the variable on the\nx axis. geom_step() creates a stairstep plot, highlighting exactly\nwhen changes occur. The group aesthetic determines which cases are\nconnected together.\n","ec":"geom_step(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", direction = \"hv\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...)"},{"p":"ggplot2","o":"stat_density_2d_filled","f":"hp_stat_density_2d_filled","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"stat_density_2d_filled(mapping = NULL, data = NULL, geom = \"density_2d_filled\", position = \"identity\", ..., contour = TRUE, contour_var = \"density\", n = 100, h = NULL, adjust = c(1, 1), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_size","f":"hp_scale_size","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), transform = \"identity\", trans = deprecated(), guide = \"legend\")"},{"p":"ggplot2","o":"scale_alpha_continuous","f":"hp_scale_alpha_continuous","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_continuous(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"scale_x_log10","f":"hp_scale_x_log10","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_x_log10(...)"},{"p":"ggplot2","o":"scale_color_datetime","f":"hp_scale_color_datetime","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_color_datetime(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"update_stat_defaults","f":"hp_update_stat_defaults","d":"Modify geom/stat aesthetic defaults for future plots\n","ec":"update_stat_defaults(stat, new)"},{"p":"ggplot2","o":"stat_unique","f":"hp_stat_unique","d":"Remove duplicates\n","ec":"stat_unique(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_stepsn","f":"hp_scale_colour_stepsn","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_colour_stepsn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", colors)"},{"p":"ggplot2","o":"position_nudge","f":"hp_position_nudge","d":"position_nudge() is generally useful for adjusting the position of\nitems on discrete scales by a small amount. Nudging is built in to\ngeom_text() because it's so useful for moving labels a small\ndistance from what they're labelling.\n","ec":"position_nudge(x = 0, y = 0)"},{"p":"ggplot2","o":"scale_color_gradient","f":"hp_scale_color_gradient","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_color_gradient(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"stat_bin","f":"hp_stat_bin","d":"Visualise the distribution of a single continuous variable by dividing\nthe x axis into bins and counting the number of observations in each bin.\nHistograms (geom_histogram()) display the counts with bars; frequency\npolygons (geom_freqpoly()) display the counts with lines. Frequency\npolygons are more suitable when you want to compare the distribution\nacross the levels of a categorical variable.\n","ec":"stat_bin(mapping = NULL, data = NULL, geom = \"bar\", position = \"stack\", ..., binwidth = NULL, bins = NULL, center = NULL, boundary = NULL, breaks = NULL, closed = c(\"right\", \"left\"), pad = FALSE, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomQuantile","f":"hp_GeomQuantile","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"Guide","f":"hp_Guide","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_discrete_manual","f":"hp_scale_discrete_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_discrete_manual(aesthetics, ..., values, breaks = waiver())"},{"p":"ggplot2","o":"geom_point","f":"hp_geom_point","d":"The point geom is used to create scatterplots. The scatterplot is most\nuseful for displaying the relationship between two continuous variables.\nIt can be used to compare one continuous and one categorical variable, or\ntwo categorical variables, but a variation like geom_jitter(),\ngeom_count(), or geom_bin_2d() is usually more\nappropriate. A bubblechart is a scatterplot with a third variable\nmapped to the size of points.\n","ec":"geom_point(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"aes_string","f":"hp_aes_string","d":"\n","ec":"aes_string(x, y, ...)"},{"p":"ggplot2","o":"draw_key_text","f":"hp_draw_key_text","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_text(data, params, size)"},{"p":"ggplot2","o":"draw_key_dotplot","f":"hp_draw_key_dotplot","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_dotplot(data, params, size)"},{"p":"ggplot2","o":"coord_equal","f":"hp_coord_equal","d":"A fixed scale coordinate system forces a specified ratio between the\nphysical representation of data units on the axes. The ratio represents the\nnumber of units on the y-axis equivalent to one unit on the x-axis. The\ndefault, ratio = 1, ensures that one unit on the x-axis is the same\nlength as one unit on the y-axis. Ratios higher than one make units on the\ny axis longer than units on the x-axis, and vice versa. This is similar to\nMASS::eqscplot(), but it works for all types of graphics.\n","ec":"coord_equal(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = \"on\")"},{"p":"ggplot2","o":"render_axes","f":"hp_render_axes","d":"These helpers facilitates generating theme compliant axes when\nbuilding up the plot.\n","ec":"render_axes(x = NULL, y = NULL, coord, theme, transpose = FALSE)"},{"p":"ggplot2","o":"scale_x_binned","f":"hp_scale_x_binned","d":"scale_x_binned() and scale_y_binned() are scales that discretize\ncontinuous position data. You can use these scales to transform continuous\ninputs before using it with a geom that requires discrete positions. An\nexample is using scale_x_binned() with geom_bar() to create a histogram.\n","ec":"scale_x_binned(name = waiver(), n.breaks = 10, nice.breaks = TRUE, breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = squish, na.value = NA_real_, right = TRUE, show.limits = FALSE, transform = \"identity\", trans = deprecated(), guide = waiver(), position = \"bottom\")"},{"p":"ggplot2","o":"scale_fill_steps2","f":"hp_scale_fill_steps2","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_fill_steps2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"coloursteps\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"layer_data","f":"hp_layer_data","d":"ggplot_build() takes the plot object, and performs all steps necessary\nto produce an object that can be rendered.  This function outputs two pieces:\na list of data frames (one for each layer), and a panel object, which\ncontain all information about axis limits, breaks etc.\n","ec":"layer_data(plot = last_plot(), i = 1L)"},{"p":"ggplot2","o":"scale_linewidth","f":"hp_scale_linewidth","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), transform = \"identity\", trans = deprecated(), guide = \"legend\")"},{"p":"ggplot2","o":"find_panel","f":"hp_find_panel","d":"These functions help detect the placement of panels in a gtable, if they are\nnamed with \"panel\" in the beginning. find_panel() returns the extend of\nthe panel area, while panel_cols() and panel_rows() returns the\ncolumns and rows that contains panels respectively.\n","ec":"find_panel(table)"},{"p":"ggplot2","o":"stat_bin_hex","f":"hp_stat_bin_hex","d":"Divides the plane into regular hexagons, counts the number of cases in\neach hexagon, and then (by default) maps the number of cases to the hexagon\nfill.  Hexagon bins avoid the visual artefacts sometimes generated by\nthe very regular alignment of geom_bin_2d().\n","ec":"stat_bin_hex(mapping = NULL, data = NULL, geom = \"hex\", position = \"identity\", ..., bins = 30, binwidth = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GuideNone","f":"hp_GuideNone","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"set_last_plot","f":"hp_set_last_plot","d":"Set the last plot to be fetched by lastplot()\n","ec":"set_last_plot(value)"},{"p":"ggplot2","o":"position_dodge","f":"hp_position_dodge","d":"Dodging preserves the vertical position of an geom while adjusting the\nhorizontal position. position_dodge() requires the grouping variable to be\nbe specified in the global or <U+2060>geom_*<U+2060> layer. Unlike position_dodge(),\nposition_dodge2() works without a grouping variable in a layer.\nposition_dodge2() works with bars and rectangles, but is\nparticularly useful for arranging box plots, which\ncan have variable widths.\n","ec":"position_dodge(width = NULL, preserve = \"total\")"},{"p":"ggplot2","o":"geom_curve","f":"hp_geom_curve","d":"geom_segment() draws a straight line between points (x, y) and\n(xend, yend). geom_curve() draws a curved line. See the underlying\ndrawing function grid::curveGrob() for the parameters that\ncontrol the curve.\n","ec":"geom_curve(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., curvature = 0.5, angle = 90, ncp = 5, arrow = NULL, arrow.fill = NULL, lineend = \"butt\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"geom_bin_2d","f":"hp_geom_bin_2d","d":"Divides the plane into rectangles, counts the number of cases in\neach rectangle, and then (by default) maps the number of cases to the\nrectangle's fill. This is a useful alternative to geom_point()\nin the presence of overplotting.\n","ec":"geom_bin_2d(mapping = NULL, data = NULL, stat = \"bin2d\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_color_gradient2","f":"hp_scale_color_gradient2","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_color_gradient2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"PositionIdentity","f":"hp_PositionIdentity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_gradient","f":"hp_scale_fill_gradient","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_fill_gradient(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"scale_color_grey","f":"hp_scale_color_grey","d":"Based on gray.colors(). This is black and white equivalent\nof scale_colour_gradient().\n","ec":"scale_color_grey(name = waiver(), ..., start = 0.2, end = 0.8, na.value = \"red\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"annotate","f":"hp_annotate","d":"This function adds geoms to a plot, but unlike a typical geom function,\nthe properties of the geoms are not mapped from variables of a data frame,\nbut are instead passed in as vectors. This is useful for adding small annotations\n(such as text labels) or if you have your data in vectors, and for some\nreason don't want to put them in a data frame.\n","ec":"annotate(geom, x = NULL, y = NULL, xmin = NULL, xmax = NULL, ymin = NULL, ymax = NULL, xend = NULL, yend = NULL, ..., na.rm = FALSE)"},{"p":"ggplot2","o":"ScaleBinned","f":"hp_ScaleBinned","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GuideCustom","f":"hp_GuideCustom","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_density2d","f":"hp_geom_density2d","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"geom_density2d(mapping = NULL, data = NULL, stat = \"density_2d\", position = \"identity\", ..., contour_var = \"density\", lineend = \"butt\", linejoin = \"round\", linemitre = 10, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"panel_rows","f":"hp_panel_rows","d":"These functions help detect the placement of panels in a gtable, if they are\nnamed with \"panel\" in the beginning. find_panel() returns the extend of\nthe panel area, while panel_cols() and panel_rows() returns the\ncolumns and rows that contains panels respectively.\n","ec":"panel_rows(table)"},{"p":"ggplot2","o":"ScaleContinuousPosition","f":"hp_ScaleContinuousPosition","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"theme_dark","f":"hp_theme_dark","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_dark(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"geom_density","f":"hp_geom_density","d":"Computes and draws kernel density estimate, which is a smoothed version of\nthe histogram. This is a useful alternative to the histogram for continuous\ndata that comes from an underlying smooth distribution.\n","ec":"geom_density(mapping = NULL, data = NULL, stat = \"density\", position = \"identity\", ..., na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, outline.type = \"upper\")"},{"p":"ggplot2","o":"GuideAxis","f":"hp_GuideAxis","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_density_2d","f":"hp_geom_density_2d","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"geom_density_2d(mapping = NULL, data = NULL, stat = \"density_2d\", position = \"identity\", ..., contour_var = \"density\", lineend = \"butt\", linejoin = \"round\", linemitre = 10, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_gradientn","f":"hp_scale_colour_gradientn","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_colour_gradientn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", colors)"},{"p":"ggplot2","o":"GeomLabel","f":"hp_GeomLabel","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"PositionFill","f":"hp_PositionFill","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"new_guide","f":"hp_new_guide","d":"A constructor function for guides, which performs some standard compatibility\nchecks between the guide and provided arguments.\n","ec":"new_guide(..., available_aes = \"any\", super)"},{"p":"ggplot2","o":"scale_size_discrete","f":"hp_scale_size_discrete","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_discrete(...)"},{"p":"ggplot2","o":"expansion","f":"hp_expansion","d":"This is a convenience function for generating scale expansion vectors\nfor the expand argument of scale_(x|y)_continuous\nand scale_(x|y)_discrete. The expansion vectors are used to\nadd some space between the data and the axes.\n","ec":"expansion(mult = 0, add = 0)"},{"p":"ggplot2","o":"stat_boxplot","f":"hp_stat_boxplot","d":"The boxplot compactly displays the distribution of a continuous variable.\nIt visualises five summary statistics (the median, two hinges\nand two whiskers), and all \"outlying\" points individually.\n","ec":"stat_boxplot(mapping = NULL, data = NULL, geom = \"boxplot\", position = \"dodge2\", ..., coef = 1.5, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"PositionNudge","f":"hp_PositionNudge","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_size_identity","f":"hp_scale_size_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_size_identity(name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"scale_color_ordinal","f":"hp_scale_color_ordinal","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_color_ordinal(..., type = getOption(\"ggplot2.ordinal.colour\", getOption(\"ggplot2.ordinal.fill\")))"},{"p":"ggplot2","o":"scale_alpha_discrete","f":"hp_scale_alpha_discrete","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_discrete(...)"},{"p":"ggplot2","o":"scale_colour_steps","f":"hp_scale_colour_steps","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_colour_steps(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"lims","f":"hp_lims","d":"This is a shortcut for supplying the limits argument to the individual\nscales. By default, any values outside the limits specified are replaced with\nNA. Be warned that this will remove data outside the limits and this can\nproduce unintended results. For changing x or y axis limits without\ndropping data observations, see coord_cartesian().\n","ec":"lims(...)"},{"p":"ggplot2","o":"theme_set","f":"hp_theme_set","d":"The current/active theme (see theme()) is automatically applied to every\nplot you draw. Use theme_get() to get the current theme, and theme_set() to\ncompletely override it. theme_update() and theme_replace() are shorthands for\nchanging individual elements.\n","ec":"theme_set(new)"},{"p":"ggplot2","o":"layer_scales","f":"hp_layer_scales","d":"ggplot_build() takes the plot object, and performs all steps necessary\nto produce an object that can be rendered.  This function outputs two pieces:\na list of data frames (one for each layer), and a panel object, which\ncontain all information about axis limits, breaks etc.\n","ec":"layer_scales(plot = last_plot(), i = 1L, j = 1L)"},{"p":"ggplot2","o":"GeomPoint","f":"hp_GeomPoint","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomDensity2d","f":"hp_GeomDensity2d","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_histogram","f":"hp_geom_histogram","d":"Visualise the distribution of a single continuous variable by dividing\nthe x axis into bins and counting the number of observations in each bin.\nHistograms (geom_histogram()) display the counts with bars; frequency\npolygons (geom_freqpoly()) display the counts with lines. Frequency\npolygons are more suitable when you want to compare the distribution\nacross the levels of a categorical variable.\n","ec":"geom_histogram(mapping = NULL, data = NULL, stat = \"bin\", position = \"stack\", ..., binwidth = NULL, bins = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"StatContourFilled","f":"hp_StatContourFilled","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_alpha_datetime","f":"hp_scale_alpha_datetime","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_datetime(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"geom_density2d_filled","f":"hp_geom_density2d_filled","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"geom_density2d_filled(mapping = NULL, data = NULL, stat = \"density_2d_filled\", position = \"identity\", ..., contour_var = \"density\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"sec_axis","f":"hp_sec_axis","d":"This function is used in conjunction with a position scale to create a\nsecondary axis, positioned opposite of the primary axis. All secondary\naxes must be based on a one-to-one transformation of the primary axes.\n","ec":"sec_axis(transform = NULL, name = waiver(), breaks = waiver(), labels = waiver(), guide = waiver(), trans = deprecated())"},{"p":"ggplot2","o":"scale_linetype_identity","f":"hp_scale_linetype_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_linetype_identity(name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"combine_vars","f":"hp_combine_vars","d":"Take input data and define a mapping between faceting variables and ROW,\nCOL and PANEL keys\n","ec":"combine_vars(data, env = emptyenv(), vars = NULL, drop = TRUE)"},{"p":"ggplot2","o":"Facet","f":"hp_Facet","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_map","f":"hp_geom_map","d":"Display polygons as a map. This is meant as annotation, so it does not\naffect position scales. Note that this function predates the geom_sf()\nframework and does not work with sf geometry columns as input. However,\nit can be used in conjunction with geom_sf() layers and/or\ncoord_sf() (see examples).\n","ec":"geom_map(mapping = NULL, data = NULL, stat = \"identity\", ..., map, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"draw_key_blank","f":"hp_draw_key_blank","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_blank(data, params, size)"},{"p":"ggplot2","o":"coord_sf","f":"hp_coord_sf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":"coord_sf(xlim = NULL, ylim = NULL, expand = TRUE, crs = NULL, default_crs = NULL, datum = sf::st_crs(4326), label_graticule = waiver(), label_axes = waiver(), lims_method = \"cross\", ndiscr = 100, default = FALSE, clip = \"on\")"},{"p":"ggplot2","o":"scale_size_continuous","f":"hp_scale_size_continuous","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_continuous(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), transform = \"identity\", trans = deprecated(), guide = \"legend\")"},{"p":"ggplot2","o":"ScaleContinuousDatetime","f":"hp_ScaleContinuousDatetime","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"annotation_custom","f":"hp_annotation_custom","d":"This is a special geom intended for use as static annotations\nthat are the same in every panel. These annotations will not\naffect scales (i.e. the x and y axes will not grow to cover the range\nof the grob, and the grob will not be modified by any ggplot settings\nor mappings).\n","ec":"annotation_custom(grob, xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf)"},{"p":"ggplot2","o":"scale_color_fermenter","f":"hp_scale_color_fermenter","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_color_fermenter(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"fill_alpha","f":"hp_fill_alpha","d":"This works much like alpha() in that it modifies the\ntransparency of fill colours. It differs in that fill_alpha() also attempts\nto set the transparency of <U+2060><GridPattern><U+2060> objects.\n","ec":"fill_alpha(fill, alpha)"},{"p":"ggplot2","o":"CoordRadial","f":"hp_CoordRadial","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"coord_map","f":"hp_coord_map","d":"\n","ec":"coord_map(projection = \"mercator\", ..., parameters = NULL, orientation = NULL, xlim = NULL, ylim = NULL, clip = \"on\")"},{"p":"ggplot2","o":"GeomRibbon","f":"hp_GeomRibbon","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"ScaleDiscretePosition","f":"hp_ScaleDiscretePosition","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"vars","f":"hp_vars","d":"Just like aes(), vars() is a quoting function\nthat takes inputs to be evaluated in the context of a dataset.\nThese inputs can be:\n","ec":"vars(...)"},{"p":"ggplot2","o":"StatBinhex","f":"hp_StatBinhex","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_contour","f":"hp_stat_contour","d":"ggplot2 can not draw true 3D surfaces, but you can use geom_contour(),\ngeom_contour_filled(), and geom_tile() to visualise 3D surfaces in 2D.\n","ec":"stat_contour(mapping = NULL, data = NULL, geom = \"contour\", position = \"identity\", ..., bins = NULL, binwidth = NULL, breaks = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"xlab","f":"hp_xlab","d":"Good labels are critical for making your plots accessible to a wider\naudience. Always ensure the axis and legend labels display the full\nvariable name. Use the plot title and subtitle to explain the\nmain findings. It's common to use the caption to provide information\nabout the data source. tag can be used for adding identification tags\nto differentiate between multiple plots.\n","ec":"xlab(label)"},{"p":"ggplot2","o":"draw_key_vline","f":"hp_draw_key_vline","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_vline(data, params, size)"},{"p":"ggplot2","o":"geom_hex","f":"hp_geom_hex","d":"Divides the plane into regular hexagons, counts the number of cases in\neach hexagon, and then (by default) maps the number of cases to the hexagon\nfill.  Hexagon bins avoid the visual artefacts sometimes generated by\nthe very regular alignment of geom_bin_2d().\n","ec":"geom_hex(mapping = NULL, data = NULL, stat = \"binhex\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_fill_continuous","f":"hp_scale_fill_continuous","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_fill_continuous(..., type = getOption(\"ggplot2.continuous.fill\"))"},{"p":"ggplot2","o":"StatIdentity","f":"hp_StatIdentity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_x_discrete","f":"hp_scale_x_discrete","d":"scale_x_discrete() and scale_y_discrete() are used to set the values for\ndiscrete x and y scale aesthetics. For simple manipulation of scale labels\nand limits, you may wish to use labs() and lims() instead.\n","ec":"scale_x_discrete(name = waiver(), ..., expand = waiver(), guide = waiver(), position = \"bottom\")"},{"p":"ggplot2","o":"draw_key_crossbar","f":"hp_draw_key_crossbar","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_crossbar(data, params, size)"},{"p":"ggplot2","o":"scale_color_date","f":"hp_scale_color_date","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_color_date(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"coord_cartesian","f":"hp_coord_cartesian","d":"The Cartesian coordinate system is the most familiar, and common, type of\ncoordinate system. Setting limits on the coordinate system will zoom the\nplot (like you're looking at it with a magnifying glass), and will not\nchange the underlying data like setting limits on a scale will.\n","ec":"coord_cartesian(xlim = NULL, ylim = NULL, expand = TRUE, default = FALSE, clip = \"on\")"},{"p":"ggplot2","o":"rel","f":"hp_rel","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"rel(x)"},{"p":"ggplot2","o":"stat_smooth","f":"hp_stat_smooth","d":"Aids the eye in seeing patterns in the presence of overplotting.\ngeom_smooth() and stat_smooth() are effectively aliases: they\nboth use the same arguments. Use stat_smooth() if you want to\ndisplay the results with a non-standard geom.\n","ec":"stat_smooth(mapping = NULL, data = NULL, geom = \"smooth\", position = \"identity\", ..., method = NULL, formula = NULL, se = TRUE, n = 80, span = 0.75, fullrange = FALSE, xseq = NULL, level = 0.95, method.args = list(), na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"cut_number","f":"hp_cut_number","d":"cut_interval() makes n groups with equal range, cut_number()\nmakes n groups with (approximately) equal numbers of observations;\ncut_width() makes groups of width width.\n","ec":"cut_number(x, n = NULL, ...)"},{"p":"ggplot2","o":"label_bquote","f":"hp_label_bquote","d":"label_bquote() offers a flexible way of labelling\nfacet rows or columns with plotmath expressions. Backquoted\nvariables will be replaced with their value in the facet.\n","ec":"label_bquote(rows = NULL, cols = NULL, default)"},{"p":"ggplot2","o":"GeomDensity2dFilled","f":"hp_GeomDensity2dFilled","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_density_2d","f":"hp_stat_density_2d","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"stat_density_2d(mapping = NULL, data = NULL, geom = \"density_2d\", position = \"identity\", ..., contour = TRUE, contour_var = \"density\", n = 100, h = NULL, adjust = c(1, 1), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"geom_path","f":"hp_geom_path","d":"geom_path() connects the observations in the order in which they appear\nin the data. geom_line() connects them in order of the variable on the\nx axis. geom_step() creates a stairstep plot, highlighting exactly\nwhen changes occur. The group aesthetic determines which cases are\nconnected together.\n","ec":"geom_path(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., lineend = \"butt\", linejoin = \"round\", linemitre = 10, arrow = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"StatAlign","f":"hp_StatAlign","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_spoke","f":"hp_geom_spoke","d":"This is a polar parameterisation of geom_segment(). It is\nuseful when you have variables that describe direction and distance.\nThe angles start from east and increase counterclockwise.\n","ec":"geom_spoke(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"get_guide_data","f":"hp_get_guide_data","d":"get_guide_data() builds a plot and extracts information from guide keys. This\ninformation typically contains positions, values and/or labels, depending\non which aesthetic is queried or guide is used.\n","ec":"get_guide_data(plot = last_plot(), aesthetic, panel = 1L)"},{"p":"ggplot2","o":"geom_abline","f":"hp_geom_abline","d":"These geoms add reference lines (sometimes called rules) to a plot, either\nhorizontal, vertical, or diagonal (specified by slope and intercept).\nThese are useful for annotating plots.\n","ec":"geom_abline(mapping = NULL, data = NULL, ..., slope, intercept, na.rm = FALSE, show.legend = NA)"},{"p":"ggplot2","o":"geom_quantile","f":"hp_geom_quantile","d":"This fits a quantile regression to the data and draws the fitted quantiles\nwith lines. This is as a continuous analogue to geom_boxplot().\n","ec":"geom_quantile(mapping = NULL, data = NULL, stat = \"quantile\", position = \"identity\", ..., lineend = \"butt\", linejoin = \"round\", linemitre = 10, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_binned","f":"hp_scale_colour_binned","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_colour_binned(..., type = getOption(\"ggplot2.binned.colour\"))"},{"p":"ggplot2","o":"GeomTile","f":"hp_GeomTile","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_sum","f":"hp_stat_sum","d":"This is a variant geom_point() that counts the number of\nobservations at each location, then maps the count to point area. It\nuseful when you have discrete data and overplotting.\n","ec":"stat_sum(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"Stat","f":"hp_Stat","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"autoplot","f":"hp_autoplot","d":"autoplot() uses ggplot2 to draw a particular plot for an object of a\nparticular class in a single command. This defines the S3 generic that\nother classes and packages can extend.\n","ec":"autoplot(object, ...)"},{"p":"ggplot2","o":"geom_violin","f":"hp_geom_violin","d":"A violin plot is a compact display of a continuous distribution. It is a\nblend of geom_boxplot() and geom_density(): a\nviolin plot is a mirrored density plot displayed in the same way as a\nboxplot.\n","ec":"geom_violin(mapping = NULL, data = NULL, stat = \"ydensity\", position = \"dodge\", ..., draw_quantiles = NULL, trim = TRUE, bounds = c(-Inf, Inf), scale = \"area\", na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_linewidth_continuous","f":"hp_scale_linewidth_continuous","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_continuous(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), transform = \"identity\", trans = deprecated(), guide = \"legend\")"},{"p":"ggplot2","o":"scale_fill_identity","f":"hp_scale_fill_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_fill_identity(name = waiver(), ..., guide = \"none\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"GeomContour","f":"hp_GeomContour","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_shape_discrete","f":"hp_scale_shape_discrete","d":"scale_shape() maps discrete variables to six easily discernible shapes.\nIf you have more than six levels, you will get a warning message, and the\nseventh and subsequent levels will not appear on the plot. Use\nscale_shape_manual() to supply your own values. You can not map\na continuous variable to shape unless scale_shape_binned() is used. Still,\nas shape has no inherent order, this use is not advised.\n","ec":"scale_shape_discrete(name = waiver(), ..., solid = TRUE)"},{"p":"ggplot2","o":"borders","f":"hp_borders","d":"This is a quick and dirty way to get map data (from the maps package)\nonto your plot. This is a good place to start if you need some crude\nreference lines, but you'll typically want something more sophisticated\nfor communication graphics.\n","ec":"borders(database = \"world\", regions = \".\", fill = NA, colour = \"grey50\", xlim = NULL, ylim = NULL, ...)"},{"p":"ggplot2","o":"transform_position","f":"hp_transform_position","d":"Convenience function to transform all position variables.\n","ec":"transform_position(df, trans_x = NULL, trans_y = NULL, ...)"},{"p":"ggplot2","o":"flip_data","f":"hp_flip_data","d":"These functions are what underpins the ability of certain geoms to work\nautomatically in both directions. See the Extending ggplot2 vignette for\nhow they are used when implementing Geom, Stat, and Position classes.\n","ec":"flip_data(data, flip = NULL)"},{"p":"ggplot2","o":"StatSmooth","f":"hp_StatSmooth","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_brewer","f":"hp_scale_color_brewer","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_color_brewer(name = waiver(), ..., type = \"seq\", palette = 1, direction = 1, aesthetics = \"colour\")"},{"p":"ggplot2","o":"GeomCol","f":"hp_GeomCol","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"guide_legend","f":"hp_guide_legend","d":"Legend type guide shows key (i.e., geoms) mapped onto values.\nLegend guides for various scales are integrated if possible.\n","ec":"guide_legend(title = waiver(), theme = NULL, position = NULL, direction = NULL, override.aes = list(), nrow = NULL, ncol = NULL, reverse = FALSE, order = 0, ...)"},{"p":"ggplot2","o":"scale_x_sqrt","f":"hp_scale_x_sqrt","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_x_sqrt(...)"},{"p":"ggplot2","o":"scale_size_manual","f":"hp_scale_size_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_size_manual(..., values, breaks = waiver(), na.value = NA)"},{"p":"ggplot2","o":"coord_polar","f":"hp_coord_polar","d":"The polar coordinate system is most commonly used for pie charts, which\nare a stacked bar chart in polar coordinates. coord_radial() has extended\noptions.\n","ec":"coord_polar(theta = \"x\", start = 0, direction = 1, clip = \"on\")"},{"p":"ggplot2","o":"ScaleContinuousDate","f":"hp_ScaleContinuousDate","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"coord_fixed","f":"hp_coord_fixed","d":"A fixed scale coordinate system forces a specified ratio between the\nphysical representation of data units on the axes. The ratio represents the\nnumber of units on the y-axis equivalent to one unit on the x-axis. The\ndefault, ratio = 1, ensures that one unit on the x-axis is the same\nlength as one unit on the y-axis. Ratios higher than one make units on the\ny axis longer than units on the x-axis, and vice versa. This is similar to\nMASS::eqscplot(), but it works for all types of graphics.\n","ec":"coord_fixed(ratio = 1, xlim = NULL, ylim = NULL, expand = TRUE, clip = \"on\")"},{"p":"ggplot2","o":"wrap_dims","f":"hp_wrap_dims","d":"Arrange 1d structure into a grid\n","ec":"wrap_dims(n, nrow = NULL, ncol = NULL)"},{"p":"ggplot2","o":"scale_size_date","f":"hp_scale_size_date","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_date(name = waiver(), ..., range = c(1, 6))"},{"p":"ggplot2","o":"GeomSmooth","f":"hp_GeomSmooth","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_colour_gradient","f":"hp_scale_colour_gradient","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_colour_gradient(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"scale_linewidth_manual","f":"hp_scale_linewidth_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_linewidth_manual(..., values, breaks = waiver(), na.value = NA)"},{"p":"ggplot2","o":"scale_fill_binned","f":"hp_scale_fill_binned","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_fill_binned(..., type = getOption(\"ggplot2.binned.fill\"))"},{"p":"ggplot2","o":"stat_bin_2d","f":"hp_stat_bin_2d","d":"Divides the plane into rectangles, counts the number of cases in\neach rectangle, and then (by default) maps the number of cases to the\nrectangle's fill. This is a useful alternative to geom_point()\nin the presence of overplotting.\n","ec":"stat_bin_2d(mapping = NULL, data = NULL, geom = \"tile\", position = \"identity\", ..., bins = 30, binwidth = NULL, drop = TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_linewidth_identity","f":"hp_scale_linewidth_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_linewidth_identity(name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"aes","f":"hp_aes","d":"Aesthetic mappings describe how variables in the data are mapped to visual\nproperties (aesthetics) of geoms. Aesthetic mappings can be set in\nggplot() and in individual layers.\n","ec":"aes(x, y, ...)"},{"p":"ggplot2","o":"element_rect","f":"hp_element_rect","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"element_rect(fill = NULL, colour = NULL, linewidth = NULL, linetype = NULL, color = NULL, inherit.blank = FALSE, size = deprecated())"},{"p":"ggplot2","o":"quickplot","f":"hp_quickplot","d":"qplot() is now deprecated in order to encourage the users to\nlearn ggplot() as it makes it easier to create complex graphics.\n","ec":"quickplot(x, y, ..., data, facets = NULL, margins = FALSE, geom = \"auto\", xlim = c(NA, NA), ylim = c(NA, NA), log = \"\", main = NULL, xlab = NULL, ylab = NULL, asp = NA, stat = deprecated(), position = deprecated())"},{"p":"ggplot2","o":"after_scale","f":"hp_after_scale","d":"Most aesthetics are mapped from variables found in the data.\nSometimes, however, you want to delay the mapping until later in the\nrendering process. ggplot2 has three stages of the data that you can map\naesthetics from, and three functions to control at which stage aesthetics\nshould be evaluated.\n","ec":"after_scale(x)"},{"p":"ggplot2","o":"GeomRaster","f":"hp_GeomRaster","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomSegment","f":"hp_GeomSegment","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_hline","f":"hp_geom_hline","d":"These geoms add reference lines (sometimes called rules) to a plot, either\nhorizontal, vertical, or diagonal (specified by slope and intercept).\nThese are useful for annotating plots.\n","ec":"geom_hline(mapping = NULL, data = NULL, ..., yintercept, na.rm = FALSE, show.legend = NA)"},{"p":"ggplot2","o":"draw_key_abline","f":"hp_draw_key_abline","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_abline(data, params, size)"},{"p":"ggplot2","o":"scale_size_ordinal","f":"hp_scale_size_ordinal","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_ordinal(name = waiver(), ..., range = c(2, 6))"},{"p":"ggplot2","o":"margin","f":"hp_margin","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"margin(t = 0, r = 0, b = 0, l = 0, unit = \"pt\")"},{"p":"ggplot2","o":"draw_key_timeseries","f":"hp_draw_key_timeseries","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_timeseries(data, params, size)"},{"p":"ggplot2","o":"element_render","f":"hp_element_render","d":"Given a theme object and element name, returns a grob for the element.\nUses element_grob() to generate the grob.\n","ec":"element_render(theme, element, ..., name = NULL)"},{"p":"ggplot2","o":"StatYdensity","f":"hp_StatYdensity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomDotplot","f":"hp_GeomDotplot","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"draw_key_linerange","f":"hp_draw_key_linerange","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_linerange(data, params, size)"},{"p":"ggplot2","o":"expand_scale","f":"hp_expand_scale","d":"This is a convenience function for generating scale expansion vectors\nfor the expand argument of scale_(x|y)_continuous\nand scale_(x|y)_discrete. The expansion vectors are used to\nadd some space between the data and the axes.\n","ec":"expand_scale(mult = 0, add = 0)"},{"p":"ggplot2","o":"GuideLegend","f":"hp_GuideLegend","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"element_blank","f":"hp_element_blank","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"element_blank()"},{"p":"ggplot2","o":"scale_fill_date","f":"hp_scale_fill_date","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_fill_date(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"CoordCartesian","f":"hp_CoordCartesian","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"label_parsed","f":"hp_label_parsed","d":"Labeller functions are in charge of formatting the strip labels of\nfacet grids and wraps. Most of them accept a multi_line\nargument to control whether multiple factors (defined in formulae\nsuch as ~first + second) should be displayed on a single\nline separated with commas, or each on their own line.\n","ec":"label_parsed(labels, multi_line = TRUE)"},{"p":"ggplot2","o":"scale_color_distiller","f":"hp_scale_color_distiller","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_color_distiller(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"geom_ribbon","f":"hp_geom_ribbon","d":"For each x value, geom_ribbon() displays a y interval defined\nby ymin and ymax. geom_area() is a special case of\ngeom_ribbon(), where the ymin is fixed to 0 and y is used instead\nof ymax.\n","ec":"geom_ribbon(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, outline.type = \"both\")"},{"p":"ggplot2","o":"PositionJitter","f":"hp_PositionJitter","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomMap","f":"hp_GeomMap","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_function","f":"hp_stat_function","d":"Computes and draws a function as a continuous curve. This makes it easy to\nsuperimpose a function on top of an existing plot. The function is called\nwith a grid of evenly spaced values along the x axis, and the results are\ndrawn (by default) with a line.\n","ec":"stat_function(mapping = NULL, data = NULL, geom = \"function\", position = \"identity\", ..., fun, xlim = NULL, n = 101, args = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"facet_grid","f":"hp_facet_grid","d":"facet_grid() forms a matrix of panels defined by row and column\nfaceting variables. It is most useful when you have two discrete\nvariables, and all combinations of the variables exist in the data.\nIf you have only one variable with many levels, try facet_wrap().\n","ec":"facet_grid(rows = NULL, cols = NULL, scales = \"fixed\", space = \"fixed\", shrink = TRUE, labeller = \"label_value\", as.table = TRUE, switch = NULL, drop = TRUE, margins = FALSE, axes = \"margins\", axis.labels = \"all\", facets = deprecated())"},{"p":"ggplot2","o":"AxisSecondary","f":"hp_AxisSecondary","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomPath","f":"hp_GeomPath","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"has_flipped_aes","f":"hp_has_flipped_aes","d":"These functions are what underpins the ability of certain geoms to work\nautomatically in both directions. See the Extending ggplot2 vignette for\nhow they are used when implementing Geom, Stat, and Position classes.\n","ec":"has_flipped_aes(data, params = list(), main_is_orthogonal = NA, range_is_orthogonal = NA, group_has_equal = FALSE, ambiguous = FALSE, main_is_continuous = FALSE, main_is_optional = FALSE)"},{"p":"ggplot2","o":"as_labeller","f":"hp_as_labeller","d":"This transforms objects to labeller functions. Used internally by\nlabeller().\n","ec":"as_labeller(x, default = label_value, multi_line = TRUE)"},{"p":"ggplot2","o":"scale_continuous_identity","f":"hp_scale_continuous_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_continuous_identity(aesthetics, name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"geom_bin2d","f":"hp_geom_bin2d","d":"Divides the plane into rectangles, counts the number of cases in\neach rectangle, and then (by default) maps the number of cases to the\nrectangle's fill. This is a useful alternative to geom_point()\nin the presence of overplotting.\n","ec":"geom_bin2d(mapping = NULL, data = NULL, stat = \"bin2d\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"stat_ydensity","f":"hp_stat_ydensity","d":"A violin plot is a compact display of a continuous distribution. It is a\nblend of geom_boxplot() and geom_density(): a\nviolin plot is a mirrored density plot displayed in the same way as a\nboxplot.\n","ec":"stat_ydensity(mapping = NULL, data = NULL, geom = \"violin\", position = \"dodge\", ..., bw = \"nrd0\", adjust = 1, kernel = \"gaussian\", trim = TRUE, scale = \"area\", drop = TRUE, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, bounds = c(-Inf, Inf))"},{"p":"ggplot2","o":"geom_contour_filled","f":"hp_geom_contour_filled","d":"ggplot2 can not draw true 3D surfaces, but you can use geom_contour(),\ngeom_contour_filled(), and geom_tile() to visualise 3D surfaces in 2D.\n","ec":"geom_contour_filled(mapping = NULL, data = NULL, stat = \"contour_filled\", position = \"identity\", ..., bins = NULL, binwidth = NULL, breaks = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_hue","f":"hp_scale_colour_hue","d":"Maps each level to an evenly spaced hue on the colour wheel.\nIt does not generate colour-blind safe palettes.\n","ec":"scale_colour_hue(name = waiver(), ..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1, na.value = \"grey50\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"theme_classic","f":"hp_theme_classic","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_classic(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"geom_polygon","f":"hp_geom_polygon","d":"Polygons are very similar to paths (as drawn by geom_path())\nexcept that the start and end points are connected and the inside is\ncoloured by fill. The group aesthetic determines which cases\nare connected together into a polygon. From R 3.6 and onwards it is possible\nto draw polygons with holes by providing a subgroup aesthetic that\ndifferentiates the outer ring points from those describing holes in the\npolygon.\n","ec":"geom_polygon(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", rule = \"evenodd\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"summarise_coord","f":"hp_summarise_coord","d":"These functions provide summarised information about built ggplot objects.\n","ec":"summarise_coord(p)"},{"p":"ggplot2","o":"geom_tile","f":"hp_geom_tile","d":"geom_rect() and geom_tile() do the same thing, but are\nparameterised differently: geom_rect() uses the locations of the four\ncorners (xmin, xmax, ymin and ymax), while\ngeom_tile() uses the center of the tile and its size (x,\ny, width, height). geom_raster() is a high\nperformance special case for when all the tiles are the same size, and no\npattern fills are applied.\n","ec":"geom_tile(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., linejoin = \"mitre\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomBlank","f":"hp_GeomBlank","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomCrossbar","f":"hp_GeomCrossbar","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_manual","f":"hp_scale_color_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_color_manual(..., values, aesthetics = \"colour\", breaks = waiver(), na.value = \"grey50\")"},{"p":"ggplot2","o":"scale_color_stepsn","f":"hp_scale_color_stepsn","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_color_stepsn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\", colors)"},{"p":"ggplot2","o":"stat_density2d","f":"hp_stat_density2d","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"stat_density2d(mapping = NULL, data = NULL, geom = \"density_2d\", position = \"identity\", ..., contour = TRUE, contour_var = \"density\", n = 100, h = NULL, adjust = c(1, 1), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_linetype_continuous","f":"hp_scale_linetype_continuous","d":"Default line types based on a set supplied by Richard Pearson,\nUniversity of Manchester. Continuous values can not be mapped to\nline types unless scale_linetype_binned() is used. Still, as linetypes has\nno inherent order, this use is not advised.\n","ec":"scale_linetype_continuous(...)"},{"p":"ggplot2","o":"CoordMap","f":"hp_CoordMap","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"layer_grob","f":"hp_layer_grob","d":"ggplot_build() takes the plot object, and performs all steps necessary\nto produce an object that can be rendered.  This function outputs two pieces:\na list of data frames (one for each layer), and a panel object, which\ncontain all information about axis limits, breaks etc.\n","ec":"layer_grob(plot = last_plot(), i = 1L)"},{"p":"ggplot2","o":"stat_ellipse","f":"hp_stat_ellipse","d":"The method for calculating the ellipses has been modified from\ncar::dataEllipse (Fox and Weisberg 2011, Friendly and Monette 2013)\n","ec":"stat_ellipse(mapping = NULL, data = NULL, geom = \"path\", position = \"identity\", ..., type = \"t\", level = 0.95, segments = 51, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"ScaleDiscreteIdentity","f":"hp_ScaleDiscreteIdentity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_continuous","f":"hp_scale_color_continuous","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_color_continuous(..., type = getOption(\"ggplot2.continuous.colour\"))"},{"p":"ggplot2","o":"geom_errorbar","f":"hp_geom_errorbar","d":"Various ways of representing a vertical interval defined by x,\nymin and ymax. Each case draws a single graphical object.\n","ec":"geom_errorbar(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"element_line","f":"hp_element_line","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"element_line(colour = NULL, linewidth = NULL, linetype = NULL, lineend = NULL, color = NULL, arrow = NULL, inherit.blank = FALSE, size = deprecated())"},{"p":"ggplot2","o":"median_hilow","f":"hp_median_hilow","d":"These are wrappers around functions from Hmisc designed to make them\neasier to use with stat_summary(). See the Hmisc documentation\nfor more details:\n","ec":"median_hilow(x, ...)"},{"p":"ggplot2","o":"stat","f":"hp_stat","d":"Most aesthetics are mapped from variables found in the data.\nSometimes, however, you want to delay the mapping until later in the\nrendering process. ggplot2 has three stages of the data that you can map\naesthetics from, and three functions to control at which stage aesthetics\nshould be evaluated.\n","ec":"stat(x)"},{"p":"ggplot2","o":"stat_spoke","f":"hp_stat_spoke","d":"This is a polar parameterisation of geom_segment(). It is\nuseful when you have variables that describe direction and distance.\nThe angles start from east and increase counterclockwise.\n","ec":"stat_spoke(...)"},{"p":"ggplot2","o":"element_grob","f":"hp_element_grob","d":"Generate grid grob from theme element\n","ec":"element_grob(element, ...)"},{"p":"ggplot2","o":"scale_x_continuous","f":"hp_scale_x_continuous","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_x_continuous(name = waiver(), breaks = waiver(), minor_breaks = waiver(), n.breaks = NULL, labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, transform = \"identity\", trans = deprecated(), guide = waiver(), position = \"bottom\", sec.axis = waiver())"},{"p":"ggplot2","o":"ggplot_gtable","f":"hp_ggplot_gtable","d":"This function builds all grobs necessary for displaying the plot, and\nstores them in a special data structure called a gtable().\nThis object is amenable to programmatic manipulation, should you want\nto (e.g.) make the legend box 2 cm wide, or combine multiple plots into\na single display, preserving aspect ratios across the plots.\n","ec":"ggplot_gtable(data)"},{"p":"ggplot2","o":"geom_qq","f":"hp_geom_qq","d":"geom_qq() and stat_qq() produce quantile-quantile plots. geom_qq_line() and\nstat_qq_line() compute the slope and intercept of the line connecting the\npoints at specified quartiles of the theoretical and sample distributions.\n","ec":"geom_qq(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", ..., distribution = stats::qnorm, dparams = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"Layout","f":"hp_Layout","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_binned","f":"hp_scale_color_binned","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_color_binned(..., type = getOption(\"ggplot2.binned.colour\"))"},{"p":"ggplot2","o":"geom_contour","f":"hp_geom_contour","d":"ggplot2 can not draw true 3D surfaces, but you can use geom_contour(),\ngeom_contour_filled(), and geom_tile() to visualise 3D surfaces in 2D.\n","ec":"geom_contour(mapping = NULL, data = NULL, stat = \"contour\", position = \"identity\", ..., bins = NULL, binwidth = NULL, breaks = NULL, lineend = \"butt\", linejoin = \"round\", linemitre = 10, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"binned_scale","f":"hp_binned_scale","d":"Binning scale constructor\n","ec":"binned_scale(aesthetics, scale_name = deprecated(), palette, name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, rescaler = rescale, oob = squish, expand = waiver(), na.value = NA_real_, n.breaks = NULL, nice.breaks = TRUE, right = TRUE, transform = \"identity\", trans = deprecated(), show.limits = FALSE, guide = \"bins\", position = \"left\", call = caller_call(), super = ScaleBinned)"},{"p":"ggplot2","o":"scale_shape","f":"hp_scale_shape","d":"scale_shape() maps discrete variables to six easily discernible shapes.\nIf you have more than six levels, you will get a warning message, and the\nseventh and subsequent levels will not appear on the plot. Use\nscale_shape_manual() to supply your own values. You can not map\na continuous variable to shape unless scale_shape_binned() is used. Still,\nas shape has no inherent order, this use is not advised.\n","ec":"scale_shape(name = waiver(), ..., solid = TRUE)"},{"p":"ggplot2","o":"stat_summary_bin","f":"hp_stat_summary_bin","d":"stat_summary() operates on unique x or y; stat_summary_bin()\noperates on binned x or y. They are more flexible versions of\nstat_bin(): instead of just counting, they can compute any\naggregate.\n","ec":"stat_summary_bin(mapping = NULL, data = NULL, geom = \"pointrange\", position = \"identity\", ..., fun.data = NULL, fun = NULL, fun.max = NULL, fun.min = NULL, fun.args = list(), bins = 30, binwidth = NULL, breaks = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, fun.y = deprecated(), fun.ymin = deprecated(), fun.ymax = deprecated())"},{"p":"ggplot2","o":"StatCount","f":"hp_StatCount","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"calc_element","f":"hp_calc_element","d":"Calculate the element properties, by inheriting properties from its parents\n","ec":"calc_element(element, theme, verbose = FALSE, skip_blank = FALSE, call = caller_env())"},{"p":"ggplot2","o":"layer","f":"hp_layer","d":"A layer is a combination of data, stat and geom with a potential position\nadjustment. Usually layers are created using <U+2060>geom_*<U+2060> or <U+2060>stat_*<U+2060>\ncalls but it can also be created directly using this function.\n","ec":"layer(geom = NULL, stat = NULL, data = NULL, mapping = NULL, position = NULL, params = list(), inherit.aes = TRUE, check.aes = TRUE, check.param = TRUE, show.legend = NA, key_glyph = NULL, layer_class = Layer)"},{"p":"ggplot2","o":"guide_geom","f":"hp_guide_geom","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"guide_geom(guide, layers, default_mapping = NULL)"},{"p":"ggplot2","o":"guide_axis","f":"hp_guide_axis","d":"Axis guides are the visual representation of position scales like those\ncreated with scale_(x|y)_continuous() and\nscale_(x|y)_discrete().\n","ec":"guide_axis(title = waiver(), theme = NULL, check.overlap = FALSE, angle = waiver(), n.dodge = 1, minor.ticks = FALSE, cap = \"none\", order = 0, position = waiver())"},{"p":"ggplot2","o":"ScaleContinuous","f":"hp_ScaleContinuous","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"aes_q","f":"hp_aes_q","d":"\n","ec":"aes_q(x, y, ...)"},{"p":"ggplot2","o":"annotation_raster","f":"hp_annotation_raster","d":"This is a special version of geom_raster() optimised for static\nannotations that are the same in every panel. These annotations will not\naffect scales (i.e. the x and y axes will not grow to cover the range\nof the raster, and the raster must already have its own colours). This\nis useful for adding bitmap images.\n","ec":"annotation_raster(raster, xmin, xmax, ymin, ymax, interpolate = FALSE)"},{"p":"ggplot2","o":"FacetWrap","f":"hp_FacetWrap","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_y_log10","f":"hp_scale_y_log10","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_y_log10(...)"},{"p":"ggplot2","o":"scale_colour_brewer","f":"hp_scale_colour_brewer","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_colour_brewer(name = waiver(), ..., type = \"seq\", palette = 1, direction = 1, aesthetics = \"colour\")"},{"p":"ggplot2","o":"GuideAxisTheta","f":"hp_GuideAxisTheta","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_datetime","f":"hp_scale_fill_datetime","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_fill_datetime(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"dup_axis","f":"hp_dup_axis","d":"This function is used in conjunction with a position scale to create a\nsecondary axis, positioned opposite of the primary axis. All secondary\naxes must be based on a one-to-one transformation of the primary axes.\n","ec":"dup_axis(transform = ~., name = derive(), breaks = derive(), labels = derive(), guide = derive(), trans = deprecated())"},{"p":"ggplot2","o":"guide_transform","f":"hp_guide_transform","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"guide_transform(guide, coord, panel_params)"},{"p":"ggplot2","o":"gg_dep","f":"hp_gg_dep","d":"\n","ec":"gg_dep(version, msg)"},{"p":"ggplot2","o":"scale_fill_stepsn","f":"hp_scale_fill_stepsn","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_fill_stepsn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"fill\", colors)"},{"p":"ggplot2","o":"is.ggplot","f":"hp_is.ggplot","d":"Reports whether x is a ggplot object\n","ec":"is.ggplot(x)"},{"p":"ggplot2","o":"scale_colour_discrete","f":"hp_scale_colour_discrete","d":"The default discrete colour scale. Defaults to scale_fill_hue()/scale_fill_brewer()\nunless type (which defaults to the ggplot2.discrete.fill/ggplot2.discrete.colour options)\nis specified.\n","ec":"scale_colour_discrete(..., type = getOption(\"ggplot2.discrete.colour\"))"},{"p":"ggplot2","o":"geom_area","f":"hp_geom_area","d":"For each x value, geom_ribbon() displays a y interval defined\nby ymin and ymax. geom_area() is a special case of\ngeom_ribbon(), where the ymin is fixed to 0 and y is used instead\nof ymax.\n","ec":"geom_area(mapping = NULL, data = NULL, stat = \"align\", position = \"stack\", na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, ..., outline.type = \"upper\")"},{"p":"ggplot2","o":"scale_fill_viridis_b","f":"hp_scale_fill_viridis_b","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_fill_viridis_b(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"scale_linewidth_date","f":"hp_scale_linewidth_date","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_date(name = waiver(), ..., range = c(1, 6))"},{"p":"ggplot2","o":"geom_sf","f":"hp_geom_sf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":"geom_sf(mapping = aes(), data = NULL, stat = \"sf\", position = \"identity\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...)"},{"p":"ggplot2","o":"scale_fill_viridis_c","f":"hp_scale_fill_viridis_c","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_fill_viridis_c(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"GuideColourbar","f":"hp_GuideColourbar","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_viridis_d","f":"hp_scale_fill_viridis_d","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_fill_viridis_d(name = waiver(), ..., alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"aes_auto","f":"hp_aes_auto","d":"\n","ec":"aes_auto(data = NULL, ...)"},{"p":"ggplot2","o":"max_width","f":"hp_max_width","d":"Get the maximal width/length of a list of grobs\n","ec":"max_width(grobs, value_only = FALSE)"},{"p":"ggplot2","o":"scale_shape_ordinal","f":"hp_scale_shape_ordinal","d":"scale_shape() maps discrete variables to six easily discernible shapes.\nIf you have more than six levels, you will get a warning message, and the\nseventh and subsequent levels will not appear on the plot. Use\nscale_shape_manual() to supply your own values. You can not map\na continuous variable to shape unless scale_shape_binned() is used. Still,\nas shape has no inherent order, this use is not advised.\n","ec":"scale_shape_ordinal(...)"},{"p":"ggplot2","o":"StatSum","f":"hp_StatSum","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_align","f":"hp_stat_align","d":"For each x value, geom_ribbon() displays a y interval defined\nby ymin and ymax. geom_area() is a special case of\ngeom_ribbon(), where the ymin is fixed to 0 and y is used instead\nof ymax.\n","ec":"stat_align(mapping = NULL, data = NULL, geom = \"area\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"facet_wrap","f":"hp_facet_wrap","d":"facet_wrap() wraps a 1d sequence of panels into 2d. This is generally\na better use of screen space than facet_grid() because most\ndisplays are roughly rectangular.\n","ec":"facet_wrap(facets, nrow = NULL, ncol = NULL, scales = \"fixed\", shrink = TRUE, labeller = \"label_value\", as.table = TRUE, switch = deprecated(), drop = TRUE, dir = \"h\", strip.position = \"top\", axes = \"margins\", axis.labels = \"all\")"},{"p":"ggplot2","o":"geom_rug","f":"hp_geom_rug","d":"A rug plot is a compact visualisation designed to supplement a 2d display\nwith the two 1d marginal distributions. Rug plots display individual\ncases so are best used with smaller datasets.\n","ec":"geom_rug(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., outside = FALSE, sides = \"bl\", length = unit(0.03, \"npc\"), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"theme_test","f":"hp_theme_test","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_test(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"theme_linedraw","f":"hp_theme_linedraw","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_linedraw(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"StatQqLine","f":"hp_StatQqLine","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"draw_key_point","f":"hp_draw_key_point","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_point(data, params, size)"},{"p":"ggplot2","o":"scale_colour_distiller","f":"hp_scale_colour_distiller","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_colour_distiller(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"label_context","f":"hp_label_context","d":"Labeller functions are in charge of formatting the strip labels of\nfacet grids and wraps. Most of them accept a multi_line\nargument to control whether multiple factors (defined in formulae\nsuch as ~first + second) should be displayed on a single\nline separated with commas, or each on their own line.\n","ec":"label_context(labels, multi_line = TRUE, sep = \": \")"},{"p":"ggplot2","o":"mean_se","f":"hp_mean_se","d":"For use with stat_summary()\n","ec":"mean_se(x, mult = 1)"},{"p":"ggplot2","o":"GuideAxisLogticks","f":"hp_GuideAxisLogticks","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"ggproto_parent","f":"hp_ggproto_parent","d":"Construct a new object with ggproto(), test with is.ggproto(),\nand access parent methods/fields with ggproto_parent().\n","ec":"ggproto_parent(parent, self)"},{"p":"ggplot2","o":"scale_x_reverse","f":"hp_scale_x_reverse","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_x_reverse(...)"},{"p":"ggplot2","o":"scale_colour_ordinal","f":"hp_scale_colour_ordinal","d":"The viridis scales provide colour maps that are perceptually uniform in both\ncolour and black-and-white. They are also designed to be perceived by viewers\nwith common forms of colour blindness. See also\nhttps://bids.github.io/colormap/.\n","ec":"scale_colour_ordinal(..., type = getOption(\"ggplot2.ordinal.colour\", getOption(\"ggplot2.ordinal.fill\")))"},{"p":"ggplot2","o":"geom_bar","f":"hp_geom_bar","d":"There are two types of bar charts: geom_bar() and geom_col().\ngeom_bar() makes the height of the bar proportional to the number of\ncases in each group (or if the weight aesthetic is supplied, the sum\nof the weights). If you want the heights of the bars to represent values\nin the data, use geom_col() instead. geom_bar() uses stat_count() by\ndefault: it counts the number of cases at each x position. geom_col()\nuses stat_identity(): it leaves the data as is.\n","ec":"geom_bar(mapping = NULL, data = NULL, stat = \"count\", position = \"stack\", ..., just = 0.5, width = NULL, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"expand_limits","f":"hp_expand_limits","d":"Sometimes you may want to ensure limits include a single value, for all\npanels or all plots.  This function is a thin wrapper around\ngeom_blank() that makes it easy to add such values.\n","ec":"expand_limits(...)"},{"p":"ggplot2","o":"scale_fill_brewer","f":"hp_scale_fill_brewer","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_fill_brewer(name = waiver(), ..., type = \"seq\", palette = 1, direction = 1, aesthetics = \"fill\")"},{"p":"ggplot2","o":"check_device","f":"hp_check_device","d":"This function makes an attempt to estimate whether the graphics device is\nable to render newer graphics features.\n","ec":"check_device(feature, action = \"warn\", op = NULL, maybe = FALSE, call = caller_env())"},{"p":"ggplot2","o":"GuideAxisStack","f":"hp_GuideAxisStack","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"draw_key_boxplot","f":"hp_draw_key_boxplot","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_boxplot(data, params, size)"},{"p":"ggplot2","o":"geom_sf_label","f":"hp_geom_sf_label","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":"geom_sf_label(mapping = aes(), data = NULL, stat = \"sf_coordinates\", position = \"identity\", ..., parse = FALSE, nudge_x = 0, nudge_y = 0, label.padding = unit(0.25, \"lines\"), label.r = unit(0.15, \"lines\"), label.size = 0.25, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, fun.geometry = NULL)"},{"p":"ggplot2","o":"xlim","f":"hp_xlim","d":"This is a shortcut for supplying the limits argument to the individual\nscales. By default, any values outside the limits specified are replaced with\nNA. Be warned that this will remove data outside the limits and this can\nproduce unintended results. For changing x or y axis limits without\ndropping data observations, see coord_cartesian().\n","ec":"xlim(...)"},{"p":"ggplot2","o":"reset_theme_settings","f":"hp_reset_theme_settings","d":"The underlying structure of a ggplot2 theme is defined via the element tree, which\nspecifies for each theme element what type it should have and whether it inherits from\na parent element. In some use cases, it may be necessary to modify or extend this\nelement tree and provide default settings for newly defined theme elements.\n","ec":"reset_theme_settings(reset_current = TRUE)"},{"p":"ggplot2","o":"coord_munch","f":"hp_coord_munch","d":"This function \"munches\" lines, dividing each line into many small pieces\nso they can be transformed independently. Used inside geom functions.\n","ec":"coord_munch(coord, data, range, segment_length = 0.01, is_closed = FALSE)"},{"p":"ggplot2","o":"guide_colorsteps","f":"hp_guide_colorsteps","d":"This guide is version of guide_colourbar() for binned colour and fill\nscales. It shows areas between breaks as a single constant colour instead of\nthe gradient known from the colourbar counterpart.\n","ec":"guide_colorsteps(title = waiver(), theme = NULL, alpha = NA, even.steps = TRUE, show.limits = NULL, direction = NULL, reverse = FALSE, order = 0, available_aes = c(\"colour\", \"color\", \"fill\"), ...)"},{"p":"ggplot2","o":"scale_linewidth_binned","f":"hp_scale_linewidth_binned","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_binned(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), n.breaks = NULL, nice.breaks = TRUE, transform = \"identity\", trans = deprecated(), guide = \"bins\")"},{"p":"ggplot2","o":"scale_alpha_date","f":"hp_scale_alpha_date","d":"Alpha-transparency scales are not tremendously useful, but can be a\nconvenient way to visually down-weight less important observations.\nscale_alpha() is an alias for scale_alpha_continuous() since\nthat is the most common use of alpha, and it saves a bit of typing.\n","ec":"scale_alpha_date(name = waiver(), ..., range = c(0.1, 1))"},{"p":"ggplot2","o":"scale_size_area","f":"hp_scale_size_area","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_area(name = waiver(), ..., max_size = 6)"},{"p":"ggplot2","o":"scale_colour_steps2","f":"hp_scale_colour_steps2","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_colour_steps2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"scale_type","f":"hp_scale_type","d":"You will need to define a method for this method if you want to extend\nggplot2 to handle new types of data. If you simply want to pass the vector\nthrough as an additional aesthetic, return \"identity\".\n","ec":"scale_type(x)"},{"p":"ggplot2","o":"scale_colour_manual","f":"hp_scale_colour_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_colour_manual(..., values, aesthetics = \"colour\", breaks = waiver(), na.value = \"grey50\")"},{"p":"ggplot2","o":"geom_rect","f":"hp_geom_rect","d":"geom_rect() and geom_tile() do the same thing, but are\nparameterised differently: geom_rect() uses the locations of the four\ncorners (xmin, xmax, ymin and ymax), while\ngeom_tile() uses the center of the tile and its size (x,\ny, width, height). geom_raster() is a high\nperformance special case for when all the tiles are the same size, and no\npattern fills are applied.\n","ec":"geom_rect(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., linejoin = \"mitre\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"theme_minimal","f":"hp_theme_minimal","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_minimal(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"scale_color_gradientn","f":"hp_scale_color_gradientn","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_color_gradientn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"colour\", colors)"},{"p":"ggplot2","o":"scale_fill_hue","f":"hp_scale_fill_hue","d":"Maps each level to an evenly spaced hue on the colour wheel.\nIt does not generate colour-blind safe palettes.\n","ec":"scale_fill_hue(name = waiver(), ..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1, na.value = \"grey50\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"StatDensity2d","f":"hp_StatDensity2d","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_errorbarh","f":"hp_geom_errorbarh","d":"A rotated version of geom_errorbar().\n","ec":"geom_errorbarh(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"position_jitter","f":"hp_position_jitter","d":"Counterintuitively adding random noise to a plot can sometimes make it\neasier to read. Jittering is particularly useful for small datasets with\nat least one discrete position.\n","ec":"position_jitter(width = NULL, height = NULL, seed = NA)"},{"p":"ggplot2","o":"geom_qq_line","f":"hp_geom_qq_line","d":"geom_qq() and stat_qq() produce quantile-quantile plots. geom_qq_line() and\nstat_qq_line() compute the slope and intercept of the line connecting the\npoints at specified quartiles of the theoretical and sample distributions.\n","ec":"geom_qq_line(mapping = NULL, data = NULL, geom = \"path\", position = \"identity\", ..., distribution = stats::qnorm, dparams = list(), line.p = c(0.25, 0.75), fullrange = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GuideOld","f":"hp_GuideOld","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"FacetNull","f":"hp_FacetNull","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"guide_gengrob","f":"hp_guide_gengrob","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"guide_gengrob(guide, theme)"},{"p":"ggplot2","o":"guide_colorbar","f":"hp_guide_colorbar","d":"Colour bar guide shows continuous colour scales mapped onto values.\nColour bar is available with scale_fill and scale_colour.\nFor more information, see the inspiration for this function:\nMatlab's colorbar function.\n","ec":"guide_colorbar(title = waiver(), theme = NULL, nbin = NULL, display = \"raster\", raster = deprecated(), alpha = NA, draw.ulim = TRUE, draw.llim = TRUE, position = NULL, direction = NULL, reverse = FALSE, order = 0, available_aes = c(\"colour\", \"color\", \"fill\"), ...)"},{"p":"ggplot2","o":"PositionDodge","f":"hp_PositionDodge","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_linetype_binned","f":"hp_scale_linetype_binned","d":"Default line types based on a set supplied by Richard Pearson,\nUniversity of Manchester. Continuous values can not be mapped to\nline types unless scale_linetype_binned() is used. Still, as linetypes has\nno inherent order, this use is not advised.\n","ec":"scale_linetype_binned(name = waiver(), ..., na.value = \"blank\")"},{"p":"ggplot2","o":"scale_x_date","f":"hp_scale_x_date","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_x_date(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), limits = NULL, expand = waiver(), oob = censor, guide = waiver(), position = \"bottom\", sec.axis = waiver())"},{"p":"ggplot2","o":"scale_shape_manual","f":"hp_scale_shape_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_shape_manual(..., values, breaks = waiver(), na.value = NA)"},{"p":"ggplot2","o":"guides","f":"hp_guides","d":"Guides for each scale can be set scale-by-scale with the guide\nargument, or en masse with guides().\n","ec":"guides(...)"},{"p":"ggplot2","o":"stat_summary_hex","f":"hp_stat_summary_hex","d":"stat_summary_2d() is a 2d variation of stat_summary().\nstat_summary_hex() is a hexagonal variation of\nstat_summary_2d(). The data are divided into bins defined\nby x and y, and then the values of z in each cell is\nare summarised with fun.\n","ec":"stat_summary_hex(mapping = NULL, data = NULL, geom = \"hex\", position = \"identity\", ..., bins = 30, binwidth = NULL, drop = TRUE, fun = \"mean\", fun.args = list(), na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_radius","f":"hp_scale_radius","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_radius(name = waiver(), breaks = waiver(), labels = waiver(), limits = NULL, range = c(1, 6), transform = \"identity\", trans = deprecated(), guide = \"legend\")"},{"p":"ggplot2","o":"StatSummary","f":"hp_StatSummary","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"Scale","f":"hp_Scale","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"annotation_map","f":"hp_annotation_map","d":"Display a fixed map on a plot. This function predates the geom_sf()\nframework and does not work with sf geometry columns as input. However,\nit can be used in conjunction with geom_sf() layers and/or\ncoord_sf() (see examples).\n","ec":"annotation_map(map, ...)"},{"p":"ggplot2","o":"GeomContourFilled","f":"hp_GeomContourFilled","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_boxplot","f":"hp_geom_boxplot","d":"The boxplot compactly displays the distribution of a continuous variable.\nIt visualises five summary statistics (the median, two hinges\nand two whiskers), and all \"outlying\" points individually.\n","ec":"geom_boxplot(mapping = NULL, data = NULL, stat = \"boxplot\", position = \"dodge2\", ..., outliers = TRUE, outlier.colour = NULL, outlier.color = NULL, outlier.fill = NULL, outlier.shape = 19, outlier.size = 1.5, outlier.stroke = 0.5, outlier.alpha = NULL, notch = FALSE, notchwidth = 0.5, staplewidth = 0, varwidth = FALSE, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"after_stat","f":"hp_after_stat","d":"Most aesthetics are mapped from variables found in the data.\nSometimes, however, you want to delay the mapping until later in the\nrendering process. ggplot2 has three stages of the data that you can map\naesthetics from, and three functions to control at which stage aesthetics\nshould be evaluated.\n","ec":"after_stat(x)"},{"p":"ggplot2","o":"stat_ecdf","f":"hp_stat_ecdf","d":"The empirical cumulative distribution function (ECDF) provides an alternative\nvisualisation of distribution. Compared to other visualisations that rely on\ndensity (like geom_histogram()), the ECDF doesn't require any\ntuning parameters and handles both continuous and categorical variables.\nThe downside is that it requires more training to accurately interpret,\nand the underlying visual tasks are somewhat more challenging.\n","ec":"stat_ecdf(mapping = NULL, data = NULL, geom = \"step\", position = \"identity\", ..., n = NULL, pad = TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomArea","f":"hp_GeomArea","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"theme_update","f":"hp_theme_update","d":"The current/active theme (see theme()) is automatically applied to every\nplot you draw. Use theme_get() to get the current theme, and theme_set() to\ncompletely override it. theme_update() and theme_replace() are shorthands for\nchanging individual elements.\n","ec":"theme_update(...)"},{"p":"ggplot2","o":"ggplot_add","f":"hp_ggplot_add","d":"This generic allows you to add your own methods for adding custom objects to\na ggplot with +.gg.\n","ec":"ggplot_add(object, plot, object_name)"},{"p":"ggplot2","o":"geom_sf_text","f":"hp_geom_sf_text","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":"geom_sf_text(mapping = aes(), data = NULL, stat = \"sf_coordinates\", position = \"identity\", ..., parse = FALSE, nudge_x = 0, nudge_y = 0, check_overlap = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, fun.geometry = NULL)"},{"p":"ggplot2","o":"update_labels","f":"hp_update_labels","d":"Update axis/legend labels\n","ec":"update_labels(p, labels)"},{"p":"ggplot2","o":"geom_dotplot","f":"hp_geom_dotplot","d":"In a dot plot, the width of a dot corresponds to the bin width\n(or maximum width, depending on the binning algorithm), and dots are\nstacked, with each dot representing one observation.\n","ec":"geom_dotplot(mapping = NULL, data = NULL, position = \"identity\", ..., binwidth = NULL, binaxis = \"x\", method = \"dotdensity\", binpositions = \"bygroup\", stackdir = \"up\", stackratio = 1, dotsize = 1, stackgroups = FALSE, origin = NULL, right = TRUE, width = 0.9, drop = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"theme_light","f":"hp_theme_light","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_light(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"labs","f":"hp_labs","d":"Good labels are critical for making your plots accessible to a wider\naudience. Always ensure the axis and legend labels display the full\nvariable name. Use the plot title and subtitle to explain the\nmain findings. It's common to use the caption to provide information\nabout the data source. tag can be used for adding identification tags\nto differentiate between multiple plots.\n","ec":"labs(..., title = waiver(), subtitle = waiver(), caption = waiver(), tag = waiver(), alt = waiver(), alt_insight = waiver())"},{"p":"ggplot2","o":"scale_color_identity","f":"hp_scale_color_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_color_identity(name = waiver(), ..., guide = \"none\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"GeomBar","f":"hp_GeomBar","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomRasterAnn","f":"hp_GeomRasterAnn","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_raster","f":"hp_geom_raster","d":"geom_rect() and geom_tile() do the same thing, but are\nparameterised differently: geom_rect() uses the locations of the four\ncorners (xmin, xmax, ymin and ymax), while\ngeom_tile() uses the center of the tile and its size (x,\ny, width, height). geom_raster() is a high\nperformance special case for when all the tiles are the same size, and no\npattern fills are applied.\n","ec":"geom_raster(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., hjust = 0.5, vjust = 0.5, interpolate = FALSE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"theme_replace","f":"hp_theme_replace","d":"The current/active theme (see theme()) is automatically applied to every\nplot you draw. Use theme_get() to get the current theme, and theme_set() to\ncompletely override it. theme_update() and theme_replace() are shorthands for\nchanging individual elements.\n","ec":"theme_replace(...)"},{"p":"ggplot2","o":"theme","f":"hp_theme","d":"Themes are a powerful way to customize the non-data components of your plots:\ni.e. titles, labels, fonts, background, gridlines, and legends. Themes can be\nused to give plots a consistent customized look. Modify a single plot's theme\nusing theme(); see theme_update() if you want modify the active theme, to\naffect all subsequent plots. Use the themes available in complete themes if you would like to use a complete theme such as\ntheme_bw(), theme_minimal(), and more. Theme elements are documented\ntogether according to inheritance, read more about theme inheritance below.\n","ec":"theme(..., line, rect, text, title, aspect.ratio, axis.title, axis.title.x, axis.title.x.top, axis.title.x.bottom, axis.title.y, axis.title.y.left, axis.title.y.right, axis.text, axis.text.x, axis.text.x.top, axis.text.x.bottom, axis.text.y, axis.text.y.left, axis.text.y.right, axis.text.theta, axis.text.r, axis.ticks, axis.ticks.x, axis.ticks.x.top, axis.ticks.x.bottom, axis.ticks.y, axis.ticks.y.left, axis.ticks.y.right, axis.ticks.theta, axis.ticks.r, axis.minor.ticks.x.top, axis.minor.ticks.x.bottom, axis.minor.ticks.y.left, axis.minor.ticks.y.right, axis.minor.ticks.theta, axis.minor.ticks.r, axis.ticks.length, axis.ticks.length.x, axis.ticks.length.x.top, axis.ticks.length.x.bottom, axis.ticks.length.y, axis.ticks.length.y.left, axis.ticks.length.y.right, axis.ticks.length.theta, axis.ticks.length.r, axis.minor.ticks.length, axis.minor.ticks.length.x, axis.minor.ticks.length.x.top, axis.minor.ticks.length.x.bottom, axis.minor.ticks.length.y, axis.minor.ticks.length.y.left, axis.minor.ticks.length.y.right, axis.minor.ticks.length.theta, axis.minor.ticks.length.r, axis.line, axis.line.x, axis.line.x.top, axis.line.x.bottom, axis.line.y, axis.line.y.left, axis.line.y.right, axis.line.theta, axis.line.r, legend.background, legend.margin, legend.spacing, legend.spacing.x, legend.spacing.y, legend.key, legend.key.size, legend.key.height, legend.key.width, legend.key.spacing, legend.key.spacing.x, legend.key.spacing.y, legend.frame, legend.ticks, legend.ticks.length, legend.axis.line, legend.text, legend.text.position, legend.title, legend.title.position, legend.position, legend.position.inside, legend.direction, legend.byrow, legend.justification, legend.justification.top, legend.justification.bottom, legend.justification.left, legend.justification.right, legend.justification.inside, legend.location, legend.box, legend.box.just, legend.box.margin, legend.box.background, legend.box.spacing, panel.background, panel.border, panel.spacing, panel.spacing.x, panel.spacing.y, panel.grid, panel.grid.major, panel.grid.minor, panel.grid.major.x, panel.grid.major.y, panel.grid.minor.x, panel.grid.minor.y, panel.ontop, plot.background, plot.title, plot.title.position, plot.subtitle, plot.caption, plot.caption.position, plot.tag, plot.tag.position, plot.tag.location, plot.margin, strip.background, strip.background.x, strip.background.y, strip.clip, strip.placement, strip.text, strip.text.x, strip.text.x.bottom, strip.text.x.top, strip.text.y, strip.text.y.left, strip.text.y.right, strip.switch.pad.grid, strip.switch.pad.wrap, complete = FALSE, validate = TRUE)"},{"p":"ggplot2","o":"GeomVline","f":"hp_GeomVline","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_summary","f":"hp_stat_summary","d":"stat_summary() operates on unique x or y; stat_summary_bin()\noperates on binned x or y. They are more flexible versions of\nstat_bin(): instead of just counting, they can compute any\naggregate.\n","ec":"stat_summary(mapping = NULL, data = NULL, geom = \"pointrange\", position = \"identity\", ..., fun.data = NULL, fun = NULL, fun.max = NULL, fun.min = NULL, fun.args = list(), na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE, fun.y = deprecated(), fun.ymin = deprecated(), fun.ymax = deprecated())"},{"p":"ggplot2","o":"is.ggproto","f":"hp_is.ggproto","d":"Construct a new object with ggproto(), test with is.ggproto(),\nand access parent methods/fields with ggproto_parent().\n","ec":"is.ggproto(x)"},{"p":"ggplot2","o":"scale_x_time","f":"hp_scale_x_time","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_x_time(name = waiver(), breaks = waiver(), minor_breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = censor, na.value = NA_real_, guide = waiver(), position = \"bottom\", sec.axis = waiver())"},{"p":"ggplot2","o":"scale_color_steps2","f":"hp_scale_color_steps2","d":"<U+2060>scale_*_steps<U+2060> creates a two colour binned gradient (low-high),\n<U+2060>scale_*_steps2<U+2060> creates a diverging binned colour gradient (low-mid-high),\nand <U+2060>scale_*_stepsn<U+2060> creates a n-colour binned gradient. These scales are\nbinned variants of the gradient scale family and\nworks in the same way.\n","ec":"scale_color_steps2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"GeomHline","f":"hp_GeomHline","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_fill_manual","f":"hp_scale_fill_manual","d":"These functions allow you to specify your own set of mappings from levels in the\ndata to aesthetic values.\n","ec":"scale_fill_manual(..., values, aesthetics = \"fill\", breaks = waiver(), na.value = \"grey50\")"},{"p":"ggplot2","o":"geom_vline","f":"hp_geom_vline","d":"These geoms add reference lines (sometimes called rules) to a plot, either\nhorizontal, vertical, or diagonal (specified by slope and intercept).\nThese are useful for annotating plots.\n","ec":"geom_vline(mapping = NULL, data = NULL, ..., xintercept, na.rm = FALSE, show.legend = NA)"},{"p":"ggplot2","o":"CoordTrans","f":"hp_CoordTrans","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"datetime_scale","f":"hp_datetime_scale","d":"Date/time scale constructor\n","ec":"datetime_scale(aesthetics, transform, trans = deprecated(), palette, breaks = pretty_breaks(), minor_breaks = waiver(), labels = waiver(), date_breaks = waiver(), date_labels = waiver(), date_minor_breaks = waiver(), timezone = NULL, guide = \"legend\", call = caller_call(), ...)"},{"p":"ggplot2","o":"StatEcdf","f":"hp_StatEcdf","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"geom_density_2d_filled","f":"hp_geom_density_2d_filled","d":"Perform a 2D kernel density estimation using MASS::kde2d() and\ndisplay the results with contours. This can be useful for dealing with\noverplotting. This is a 2D version of geom_density(). geom_density_2d()\ndraws contour lines, and geom_density_2d_filled() draws filled contour\nbands.\n","ec":"geom_density_2d_filled(mapping = NULL, data = NULL, stat = \"density_2d_filled\", position = \"identity\", ..., contour_var = \"density\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomFunction","f":"hp_GeomFunction","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomAbline","f":"hp_GeomAbline","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"label_value","f":"hp_label_value","d":"Labeller functions are in charge of formatting the strip labels of\nfacet grids and wraps. Most of them accept a multi_line\nargument to control whether multiple factors (defined in formulae\nsuch as ~first + second) should be displayed on a single\nline separated with commas, or each on their own line.\n","ec":"label_value(labels, multi_line = TRUE)"},{"p":"ggplot2","o":".expose_data","f":"hp_.expose_data","d":"The .ignore_data() function is used to hide <U+2060><AsIs><U+2060> columns during\nscale interactions in ggplot_build(). The .expose_data() function is\nused to restore hidden columns.\n","ec":".expose_data(data)"},{"p":"ggplot2","o":"theme_grey","f":"hp_theme_grey","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_grey(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"coord_flip","f":"hp_coord_flip","d":"\n","ec":"coord_flip(xlim = NULL, ylim = NULL, expand = TRUE, clip = \"on\")"},{"p":"ggplot2","o":"position_stack","f":"hp_position_stack","d":"position_stack() stacks bars on top of each other;\nposition_fill() stacks bars and standardises each stack to have\nconstant height.\n","ec":"position_stack(vjust = 1, reverse = FALSE)"},{"p":"ggplot2","o":"StatSummaryHex","f":"hp_StatSummaryHex","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"is.facet","f":"hp_is.facet","d":"Is this object a faceting specification?\n","ec":"is.facet(x)"},{"p":"ggplot2","o":"geom_function","f":"hp_geom_function","d":"Computes and draws a function as a continuous curve. This makes it easy to\nsuperimpose a function on top of an existing plot. The function is called\nwith a grid of evenly spaced values along the x axis, and the results are\ndrawn (by default) with a line.\n","ec":"geom_function(mapping = NULL, data = NULL, stat = \"function\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"ggtitle","f":"hp_ggtitle","d":"Good labels are critical for making your plots accessible to a wider\naudience. Always ensure the axis and legend labels display the full\nvariable name. Use the plot title and subtitle to explain the\nmain findings. It's common to use the caption to provide information\nabout the data source. tag can be used for adding identification tags\nto differentiate between multiple plots.\n","ec":"ggtitle(label, subtitle = waiver())"},{"p":"ggplot2","o":"benchplot","f":"hp_benchplot","d":"Benchmark plot creation time.\nBroken down into construct, build, render and draw times.\n","ec":"benchplot(x)"},{"p":"ggplot2","o":"GeomHex","f":"hp_GeomHex","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"stat_bin2d","f":"hp_stat_bin2d","d":"Divides the plane into rectangles, counts the number of cases in\neach rectangle, and then (by default) maps the number of cases to the\nrectangle's fill. This is a useful alternative to geom_point()\nin the presence of overplotting.\n","ec":"stat_bin2d(mapping = NULL, data = NULL, geom = \"tile\", position = \"identity\", ..., bins = 30, binwidth = NULL, drop = TRUE, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"stat_identity","f":"hp_stat_identity","d":"The identity statistic leaves the data unchanged.\n","ec":"stat_identity(mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", ..., show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"ggsave","f":"hp_ggsave","d":"ggsave() is a convenient function for saving a plot. It defaults to\nsaving the last plot that you displayed, using the size of the current\ngraphics device. It also guesses the type of graphics device from the\nextension.\n","ec":"ggsave(filename, plot = last_plot(), device = NULL, path = NULL, scale = 1, width = NA, height = NA, units = c(\"in\", \"cm\", \"mm\", \"px\"), dpi = 300, limitsize = TRUE, bg = NULL, create.dir = FALSE, ...)"},{"p":"ggplot2","o":"scale_colour_fermenter","f":"hp_scale_colour_fermenter","d":"The brewer scales provide sequential, diverging and qualitative\ncolour schemes from ColorBrewer. These are particularly well suited to\ndisplay discrete values on a map. See https://colorbrewer2.org for\nmore information.\n","ec":"scale_colour_fermenter(name = waiver(), ..., type = \"seq\", palette = 1, direction = -1, na.value = \"grey50\", guide = \"coloursteps\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"geom_jitter","f":"hp_geom_jitter","d":"The jitter geom is a convenient shortcut for\ngeom_point(position = \"jitter\"). It adds a small amount of random\nvariation to the location of each point, and is a useful way of handling\noverplotting caused by discreteness in smaller datasets.\n","ec":"geom_jitter(mapping = NULL, data = NULL, stat = \"identity\", position = \"jitter\", ..., width = NULL, height = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomRug","f":"hp_GeomRug","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_linewidth_discrete","f":"hp_scale_linewidth_discrete","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_discrete(...)"},{"p":"ggplot2","o":"ylab","f":"hp_ylab","d":"Good labels are critical for making your plots accessible to a wider\naudience. Always ensure the axis and legend labels display the full\nvariable name. Use the plot title and subtitle to explain the\nmain findings. It's common to use the caption to provide information\nabout the data source. tag can be used for adding identification tags\nto differentiate between multiple plots.\n","ec":"ylab(label)"},{"p":"ggplot2","o":"get_element_tree","f":"hp_get_element_tree","d":"The underlying structure of a ggplot2 theme is defined via the element tree, which\nspecifies for each theme element what type it should have and whether it inherits from\na parent element. In some use cases, it may be necessary to modify or extend this\nelement tree and provide default settings for newly defined theme elements.\n","ec":"get_element_tree()"},{"p":"ggplot2","o":"remove_missing","f":"hp_remove_missing","d":"Remove all non-complete rows, with a warning if na.rm = FALSE.\nggplot is somewhat more accommodating of missing values than R generally.\nFor those stats which require complete data, missing values will be\nautomatically removed with a warning. If na.rm = TRUE is supplied\nto the statistic, the warning will be suppressed.\n","ec":"remove_missing(df, na.rm = FALSE, vars = names(df), name = \"\", finite = FALSE)"},{"p":"ggplot2","o":"scale_linewidth_datetime","f":"hp_scale_linewidth_datetime","d":"scale_linewidth scales the width of lines and polygon strokes. Due to\nhistorical reasons, it is also possible to control this with the size\naesthetic, but using linewidth is encourage to clearly differentiate area\naesthetics from stroke width aesthetics.\n","ec":"scale_linewidth_datetime(name = waiver(), ..., range = c(1, 6))"},{"p":"ggplot2","o":"geom_segment","f":"hp_geom_segment","d":"geom_segment() draws a straight line between points (x, y) and\n(xend, yend). geom_curve() draws a curved line. See the underlying\ndrawing function grid::curveGrob() for the parameters that\ncontrol the curve.\n","ec":"geom_segment(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., arrow = NULL, arrow.fill = NULL, lineend = \"butt\", linejoin = \"round\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"stage","f":"hp_stage","d":"Most aesthetics are mapped from variables found in the data.\nSometimes, however, you want to delay the mapping until later in the\nrendering process. ggplot2 has three stages of the data that you can map\naesthetics from, and three functions to control at which stage aesthetics\nshould be evaluated.\n","ec":"stage(start = NULL, after_stat = NULL, after_scale = NULL)"},{"p":"ggplot2","o":"scale_fill_gradientn","f":"hp_scale_fill_gradientn","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_fill_gradientn(name = waiver(), ..., colours, values = NULL, space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\", aesthetics = \"fill\", colors)"},{"p":"ggplot2","o":"autolayer","f":"hp_autolayer","d":"autolayer() uses ggplot2 to draw a particular layer for an object of a\nparticular class in a single command. This defines the S3 generic that\nother classes and packages can extend.\n","ec":"autolayer(object, ...)"},{"p":"ggplot2","o":"StatEllipse","f":"hp_StatEllipse","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"FacetGrid","f":"hp_FacetGrid","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomLinerange","f":"hp_GeomLinerange","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_y_datetime","f":"hp_scale_y_datetime","d":"These are the default scales for the three date/time class. These will\nusually be added automatically. To override manually, use\n<U+2060>scale_*_date<U+2060> for dates (class Date),\n<U+2060>scale_*_datetime<U+2060> for datetimes (class POSIXct), and\n<U+2060>scale_*_time<U+2060> for times (class hms).\n","ec":"scale_y_datetime(name = waiver(), breaks = waiver(), date_breaks = waiver(), labels = waiver(), date_labels = waiver(), minor_breaks = waiver(), date_minor_breaks = waiver(), timezone = NULL, limits = NULL, expand = waiver(), oob = censor, guide = waiver(), position = \"left\", sec.axis = waiver())"},{"p":"ggplot2","o":"theme_get","f":"hp_theme_get","d":"The current/active theme (see theme()) is automatically applied to every\nplot you draw. Use theme_get() to get the current theme, and theme_set() to\ncompletely override it. theme_update() and theme_replace() are shorthands for\nchanging individual elements.\n","ec":"theme_get()"},{"p":"ggplot2","o":"is.theme","f":"hp_is.theme","d":"Reports whether x is a theme object\n","ec":"is.theme(x)"},{"p":"ggplot2","o":"guide_none","f":"hp_guide_none","d":"This guide draws nothing.\n","ec":"guide_none(title = waiver(), position = waiver())"},{"p":"ggplot2","o":"scale_shape_identity","f":"hp_scale_shape_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_shape_identity(name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"merge_element","f":"hp_merge_element","d":"This is a generic and element classes must provide an implementation of this\nmethod\n","ec":"merge_element(new, old)"},{"p":"ggplot2","o":"StatDensity","f":"hp_StatDensity","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomErrorbar","f":"hp_GeomErrorbar","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_color_hue","f":"hp_scale_color_hue","d":"Maps each level to an evenly spaced hue on the colour wheel.\nIt does not generate colour-blind safe palettes.\n","ec":"scale_color_hue(name = waiver(), ..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1, na.value = \"grey50\", aesthetics = \"colour\")"},{"p":"ggplot2","o":"geom_col","f":"hp_geom_col","d":"There are two types of bar charts: geom_bar() and geom_col().\ngeom_bar() makes the height of the bar proportional to the number of\ncases in each group (or if the weight aesthetic is supplied, the sum\nof the weights). If you want the heights of the bars to represent values\nin the data, use geom_col() instead. geom_bar() uses stat_count() by\ndefault: it counts the number of cases at each x position. geom_col()\nuses stat_identity(): it leaves the data as is.\n","ec":"geom_col(mapping = NULL, data = NULL, position = \"stack\", ..., just = 0.5, width = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"translate_shape_string","f":"hp_translate_shape_string","d":"translate_shape_string() is a helper function for translating point shapes\ngiven as a character vector into integers that are interpreted by the\ngrid system.\n","ec":"translate_shape_string(shape_string)"},{"p":"ggplot2","o":"theme_bw","f":"hp_theme_bw","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_bw(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"coord_radial","f":"hp_coord_radial","d":"The polar coordinate system is most commonly used for pie charts, which\nare a stacked bar chart in polar coordinates. coord_radial() has extended\noptions.\n","ec":"coord_radial(theta = \"x\", start = 0, end = NULL, expand = TRUE, direction = 1, clip = \"off\", r.axis.inside = NULL, rotate.angle = FALSE, inner.radius = 0, r_axis_inside = deprecated(), rotate_angle = deprecated())"},{"p":"ggplot2","o":"guide_coloursteps","f":"hp_guide_coloursteps","d":"This guide is version of guide_colourbar() for binned colour and fill\nscales. It shows areas between breaks as a single constant colour instead of\nthe gradient known from the colourbar counterpart.\n","ec":"guide_coloursteps(title = waiver(), theme = NULL, alpha = NA, even.steps = TRUE, show.limits = NULL, direction = NULL, reverse = FALSE, order = 0, available_aes = c(\"colour\", \"color\", \"fill\"), ...)"},{"p":"ggplot2","o":"aes_","f":"hp_aes_","d":"\n","ec":"aes_(x, y, ...)"},{"p":"ggplot2","o":"draw_key_polygon","f":"hp_draw_key_polygon","d":"Each geom has an associated function that draws the key when the geom needs\nto be displayed in a legend. These functions are called <U+2060>draw_key_*()<U+2060>, where\n* stands for the name of the respective key glyph. The key glyphs can be\ncustomized for individual geoms by providing a geom with the key_glyph\nargument (see layer() or examples below.)\n","ec":"draw_key_polygon(data, params, size)"},{"p":"ggplot2","o":"ggproto","f":"hp_ggproto","d":"Construct a new object with ggproto(), test with is.ggproto(),\nand access parent methods/fields with ggproto_parent().\n","ec":"ggproto(`_class` = NULL, `_inherit` = NULL, ...)"},{"p":"ggplot2","o":"StatDensity2dFilled","f":"hp_StatDensity2dFilled","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"pattern_alpha","f":"hp_pattern_alpha","d":"This generic allows you to add your own methods for adding transparency to\npattern-like objects.\n","ec":"pattern_alpha(x, alpha)"},{"p":"ggplot2","o":"position_jitterdodge","f":"hp_position_jitterdodge","d":"This is primarily used for aligning points generated through\ngeom_point() with dodged boxplots (e.g., a geom_boxplot() with\na fill aesthetic supplied).\n","ec":"position_jitterdodge(jitter.width = NULL, jitter.height = 0, dodge.width = 0.75, seed = NA)"},{"p":"ggplot2","o":"scale_y_sqrt","f":"hp_scale_y_sqrt","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_y_sqrt(...)"},{"p":"ggplot2","o":"scale_y_binned","f":"hp_scale_y_binned","d":"scale_x_binned() and scale_y_binned() are scales that discretize\ncontinuous position data. You can use these scales to transform continuous\ninputs before using it with a geom that requires discrete positions. An\nexample is using scale_x_binned() with geom_bar() to create a histogram.\n","ec":"scale_y_binned(name = waiver(), n.breaks = 10, nice.breaks = TRUE, breaks = waiver(), labels = waiver(), limits = NULL, expand = waiver(), oob = squish, na.value = NA_real_, right = TRUE, show.limits = FALSE, transform = \"identity\", trans = deprecated(), guide = waiver(), position = \"left\")"},{"p":"ggplot2","o":"geom_smooth","f":"hp_geom_smooth","d":"Aids the eye in seeing patterns in the presence of overplotting.\ngeom_smooth() and stat_smooth() are effectively aliases: they\nboth use the same arguments. Use stat_smooth() if you want to\ndisplay the results with a non-standard geom.\n","ec":"geom_smooth(mapping = NULL, data = NULL, stat = \"smooth\", position = \"identity\", ..., method = NULL, formula = NULL, se = TRUE, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"last_plot","f":"hp_last_plot","d":"Retrieve the last plot to be modified or created.\n","ec":"last_plot()"},{"p":"ggplot2","o":"scale_colour_datetime","f":"hp_scale_colour_datetime","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_colour_datetime(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"StatSfCoordinates","f":"hp_StatSfCoordinates","d":"stat_sf_coordinates() extracts the coordinates from 'sf' objects and\nsummarises them to one pair of coordinates (x and y) per geometry. This is\nconvenient when you draw an sf object as geoms like text and labels (so\ngeom_sf_text() and geom_sf_label() relies on this).\n","ec":""},{"p":"ggplot2","o":"annotation_logticks","f":"hp_annotation_logticks","d":"\n","ec":"annotation_logticks(base = 10, sides = \"bl\", outside = FALSE, scaled = TRUE, short = unit(0.1, \"cm\"), mid = unit(0.2, \"cm\"), long = unit(0.3, \"cm\"), colour = \"black\", linewidth = 0.5, linetype = 1, alpha = 1, color = NULL, ..., size = deprecated())"},{"p":"ggplot2","o":"scale_y_reverse","f":"hp_scale_y_reverse","d":"scale_x_continuous() and scale_y_continuous() are the default\nscales for continuous x and y aesthetics. There are three variants\nthat set the transform argument for commonly used transformations:\n<U+2060>scale_*_log10()<U+2060>, <U+2060>scale_*_sqrt()<U+2060> and <U+2060>scale_*_reverse()<U+2060>.\n","ec":"scale_y_reverse(...)"},{"p":"ggplot2","o":"resolution","f":"hp_resolution","d":"The resolution is the smallest non-zero distance between adjacent\nvalues.  If there is only one unique value, then the resolution is defined\nto be one. If x is an integer vector, then it is assumed to represent a\ndiscrete variable, and the resolution is 1.\n","ec":"resolution(x, zero = TRUE, discrete = FALSE)"},{"p":"ggplot2","o":"coord_quickmap","f":"hp_coord_quickmap","d":"\n","ec":"coord_quickmap(xlim = NULL, ylim = NULL, expand = TRUE, clip = \"on\")"},{"p":"ggplot2","o":"%+%","f":"hp_X...","d":"+ is the key to constructing sophisticated ggplot2 graphics. It\nallows you to start simple, then get more and more complex, checking your\nwork at each step.\n","ec":"%+%(e1, e2)"},{"p":"ggplot2","o":"scale_fill_gradient2","f":"hp_scale_fill_gradient2","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_fill_gradient2(name = waiver(), ..., low = muted(\"red\"), mid = \"white\", high = muted(\"blue\"), midpoint = 0, space = \"Lab\", na.value = \"grey50\", transform = \"identity\", guide = \"colourbar\", aesthetics = \"fill\")"},{"p":"ggplot2","o":"geom_freqpoly","f":"hp_geom_freqpoly","d":"Visualise the distribution of a single continuous variable by dividing\nthe x axis into bins and counting the number of observations in each bin.\nHistograms (geom_histogram()) display the counts with bars; frequency\npolygons (geom_freqpoly()) display the counts with lines. Frequency\npolygons are more suitable when you want to compare the distribution\nacross the levels of a categorical variable.\n","ec":"geom_freqpoly(mapping = NULL, data = NULL, stat = \"bin\", position = \"identity\", ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"guide_axis_logticks","f":"hp_guide_axis_logticks","d":"This axis guide replaces the placement of ticks marks at intervals in\nlog10 space.\n","ec":"guide_axis_logticks(long = 2.25, mid = 1.5, short = 0.75, prescale.base = NULL, negative.small = 0.1, short.theme = element_line(), expanded = TRUE, cap = \"none\", theme = NULL, prescale_base = deprecated(), negative_small = deprecated(), short_theme = deprecated(), ...)"},{"p":"ggplot2","o":"element_text","f":"hp_element_text","d":"In conjunction with the theme system, the element_ functions\nspecify the display of how non-data components of the plot are drawn.\n","ec":"element_text(family = NULL, face = NULL, colour = NULL, size = NULL, hjust = NULL, vjust = NULL, angle = NULL, lineheight = NULL, color = NULL, margin = NULL, debug = NULL, inherit.blank = FALSE)"},{"p":"ggplot2","o":"old_guide","f":"hp_old_guide","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"old_guide(guide)"},{"p":"ggplot2","o":"GeomCustomAnn","f":"hp_GeomCustomAnn","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"StatSummary2d","f":"hp_StatSummary2d","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GuideBins","f":"hp_GuideBins","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"GeomSf","f":"hp_GeomSf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":""},{"p":"ggplot2","o":"guide_axis_stack","f":"hp_guide_axis_stack","d":"This guide can stack other position guides that represent position scales,\nlike those created with scale_(x|y)_continuous() and\nscale_(x|y)_discrete().\n","ec":"guide_axis_stack(first = \"axis\", ..., title = waiver(), theme = NULL, spacing = NULL, order = 0, position = waiver())"},{"p":"ggplot2","o":"scale_colour_date","f":"hp_scale_colour_date","d":"<U+2060>scale_*_gradient<U+2060> creates a two colour gradient (low-high),\n<U+2060>scale_*_gradient2<U+2060> creates a diverging colour gradient (low-mid-high),\n<U+2060>scale_*_gradientn<U+2060> creates a n-colour gradient. For binned variants of\nthese scales, see the color steps scales.\n","ec":"scale_colour_date(name = waiver(), ..., low = \"#132B43\", high = \"#56B1F7\", space = \"Lab\", na.value = \"grey50\", guide = \"colourbar\")"},{"p":"ggplot2","o":"geom_pointrange","f":"hp_geom_pointrange","d":"Various ways of representing a vertical interval defined by x,\nymin and ymax. Each case draws a single graphical object.\n","ec":"geom_pointrange(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., fatten = 4, na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"GeomText","f":"hp_GeomText","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"waiver","f":"hp_waiver","d":"A waiver is a \"flag\" object, similar to NULL, that indicates the\ncalling function should just use the default value.  It is used in certain\nfunctions to distinguish between displaying nothing (NULL) and\ndisplaying a default value calculated elsewhere (waiver())\n","ec":"waiver()"},{"p":"ggplot2","o":"StatContour","f":"hp_StatContour","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"ScaleDiscrete","f":"hp_ScaleDiscrete","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"theme_gray","f":"hp_theme_gray","d":"These are complete themes which control all non-data display. Use\ntheme() if you just need to tweak the display of an existing\ntheme.\n","ec":"theme_gray(base_size = 11, base_family = \"\", base_line_size = base_size/22, base_rect_size = base_size/22)"},{"p":"ggplot2","o":"guide_bins","f":"hp_guide_bins","d":"This guide is a version of the guide_legend() guide for binned scales. It\ndiffers in that it places ticks correctly between the keys, and sports a\nsmall axis to better show the binning. Like guide_legend() it can be used\nfor all non-position aesthetics though colour and fill defaults to\nguide_coloursteps(), and it will merge aesthetics together into the same\nguide if they are mapped in the same way.\n","ec":"guide_bins(title = waiver(), theme = NULL, position = NULL, direction = NULL, override.aes = list(), reverse = FALSE, order = 0, show.limits = NULL, ...)"},{"p":"ggplot2","o":"CoordQuickmap","f":"hp_CoordQuickmap","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"StatSummaryBin","f":"hp_StatSummaryBin","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"scale_linetype","f":"hp_scale_linetype","d":"Default line types based on a set supplied by Richard Pearson,\nUniversity of Manchester. Continuous values can not be mapped to\nline types unless scale_linetype_binned() is used. Still, as linetypes has\nno inherent order, this use is not advised.\n","ec":"scale_linetype(name = waiver(), ..., na.value = \"blank\")"},{"p":"ggplot2","o":"summarise_layers","f":"hp_summarise_layers","d":"These functions provide summarised information about built ggplot objects.\n","ec":"summarise_layers(p)"},{"p":"ggplot2","o":"stat_contour_filled","f":"hp_stat_contour_filled","d":"ggplot2 can not draw true 3D surfaces, but you can use geom_contour(),\ngeom_contour_filled(), and geom_tile() to visualise 3D surfaces in 2D.\n","ec":"stat_contour_filled(mapping = NULL, data = NULL, geom = \"contour_filled\", position = \"identity\", ..., bins = NULL, binwidth = NULL, breaks = NULL, na.rm = FALSE, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"flipped_names","f":"hp_flipped_names","d":"These functions are what underpins the ability of certain geoms to work\nautomatically in both directions. See the Extending ggplot2 vignette for\nhow they are used when implementing Geom, Stat, and Position classes.\n","ec":"flipped_names(flip = FALSE)"},{"p":"ggplot2","o":"scale_size_binned_area","f":"hp_scale_size_binned_area","d":"scale_size() scales area, scale_radius() scales radius. The size\naesthetic is most commonly used for points and text, and humans perceive\nthe area of points (not their radius), so this provides for optimal\nperception. scale_size_area() ensures that a value of 0 is mapped\nto a size of 0. scale_size_binned() is a binned version of scale_size() that\nscales by area (but does not ensure 0 equals an area of zero). For a binned\nequivalent of scale_size_area() use scale_size_binned_area().\n","ec":"scale_size_binned_area(name = waiver(), ..., max_size = 6)"},{"p":"ggplot2","o":"scale_discrete_identity","f":"hp_scale_discrete_identity","d":"Use this set of scales when your data has already been scaled, i.e. it\nalready represents aesthetic values that ggplot2 can handle directly.\nThese scales will not produce a legend unless you also supply the breaks,\nlabels, and type of guide you want.\n","ec":"scale_discrete_identity(aesthetics, name = waiver(), ..., guide = \"none\")"},{"p":"ggplot2","o":"guide_train","f":"hp_guide_train","d":"The guide system has been overhauled to use the ggproto infrastructure to\naccommodate guide extensions with the same flexibility as layers, scales and\nother ggplot2 objects. In rewriting, the old S3 system has become defunct,\nmeaning that the previous methods for guides have been superseded by ggproto\nmethods. As a fallback option, the generics, but not the methods, that the\nprevious S3 system used are encapsulated in the GuideOld ggproto class.\n","ec":"guide_train(guide, scale, aesthetic = NULL)"},{"p":"ggplot2","o":"GeomRect","f":"hp_GeomRect","d":"If you are creating a new geom, stat, position, or scale in another package,\nyou'll need to extend from ggplot2::Geom, ggplot2::Stat,\nggplot2::Position, or ggplot2::Scale.\n","ec":""},{"p":"ggplot2","o":"register_theme_elements","f":"hp_register_theme_elements","d":"The underlying structure of a ggplot2 theme is defined via the element tree, which\nspecifies for each theme element what type it should have and whether it inherits from\na parent element. In some use cases, it may be necessary to modify or extend this\nelement tree and provide default settings for newly defined theme elements.\n","ec":"register_theme_elements(..., element_tree = NULL, complete = TRUE)"},{"p":"ggplot2","o":"zeroGrob","f":"hp_zeroGrob","d":"The zero grob draws nothing and has zero size.\n","ec":"zeroGrob()"},{"p":"ggplot2","o":"mean_sdl","f":"hp_mean_sdl","d":"These are wrappers around functions from Hmisc designed to make them\neasier to use with stat_summary(). See the Hmisc documentation\nfor more details:\n","ec":"mean_sdl(x, ...)"},{"p":"ggplot2","o":"stat_summary2d","f":"hp_stat_summary2d","d":"stat_summary_2d() is a 2d variation of stat_summary().\nstat_summary_hex() is a hexagonal variation of\nstat_summary_2d(). The data are divided into bins defined\nby x and y, and then the values of z in each cell is\nare summarised with fun.\n","ec":"stat_summary2d(...)"},{"p":"ggplot2","o":"guide_axis_theta","f":"hp_guide_axis_theta","d":"This is a specialised guide used in coord_radial() to represent the theta\nposition scale.\n","ec":"guide_axis_theta(title = waiver(), theme = NULL, angle = waiver(), minor.ticks = FALSE, cap = \"none\", order = 0, position = waiver())"},{"p":"ggplot2","o":"stat_sf","f":"hp_stat_sf","d":"This set of geom, stat, and coord are used to visualise simple feature (sf)\nobjects. For simple plots, you will only need geom_sf() as it\nuses stat_sf() and adds coord_sf() for you. geom_sf() is\nan unusual geom because it will draw different geometric objects depending\non what simple features are present in the data: you can get points, lines,\nor polygons.\nFor text and labels, you can use geom_sf_text() and geom_sf_label().\n","ec":"stat_sf(mapping = NULL, data = NULL, geom = \"rect\", position = \"identity\", na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...)"},{"p":"ggplot2","o":"geom_linerange","f":"hp_geom_linerange","d":"Various ways of representing a vertical interval defined by x,\nymin and ymax. Each case draws a single graphical object.\n","ec":"geom_linerange(mapping = NULL, data = NULL, stat = \"identity\", position = \"identity\", ..., na.rm = FALSE, orientation = NA, show.legend = NA, inherit.aes = TRUE)"},{"p":"ggplot2","o":"scale_colour_continuous","f":"hp_scale_colour_continuous","d":"The scales scale_colour_continuous() and scale_fill_continuous() are\nthe default colour scales ggplot2 uses when continuous data values are\nmapped onto the colour or fill aesthetics, respectively. The scales\nscale_colour_binned() and scale_fill_binned() are equivalent scale\nfunctions that assign discrete color bins to the continuous values\ninstead of using a continuous color spectrum.\n","ec":"scale_colour_continuous(..., type = getOption(\"ggplot2.continuous.colour\"))"},{"p":"ggplot2","o":"max_height","f":"hp_max_height","d":"Get the maximal width/length of a list of grobs\n","ec":"max_height(grobs, value_only = FALSE)"},{"p":"ggplot2","o":"mean_cl_boot","f":"hp_mean_cl_boot","d":"These are wrappers around functions from Hmisc designed to make them\neasier to use with stat_summary(). See the Hmisc documentation\nfor more details:\n","ec":"mean_cl_boot(x, ...)"},{"p":"ggplot2","o":"ggplot_build","f":"hp_ggplot_build","d":"ggplot_build() takes the plot object, and performs all steps necessary\nto produce an object that can be rendered.  This function outputs two pieces:\na list of data frames (one for each layer), and a panel object, which\ncontain all information about axis limits, breaks etc.\n","ec":"ggplot_build(plot)"},{"p":"glue","o":"glue_safe","f":"hp_glue_safe","d":"glue_safe() and glue_data_safe() differ from glue() and glue_data()\nin that the safe versions only look up symbols from an environment using\nget(). They do not execute any R code. This makes them suitable for use\nwith untrusted input, such as inputs in a Shiny application, where using the\nnormal functions would allow an attacker to execute arbitrary code.\n","ec":"glue_safe(..., .envir = parent.frame())"},{"p":"glue","o":"trim","f":"hp_trim","d":"This trims a character vector according to the trimming rules used by glue.\nThese follow similar rules to Python Docstrings,\nwith the following features.\n","ec":"trim(x)"},{"p":"glue","o":"glue_sql","f":"hp_glue_sql","d":"SQL databases often have custom quotation syntax for identifiers and strings\nwhich make writing SQL queries error prone and cumbersome to do. glue_sql() and\nglue_data_sql() are analogs to glue() and glue_data() which handle the\nSQL quoting. glue_sql_collapse() can be used to collapse DBI::SQL() objects.\n","ec":"glue_sql(..., .con, .sep = \"\", .envir = parent.frame(), .open = \"{\", .close = \"}\", .na = DBI::SQL(\"NULL\"), .null = character(), .comment = \"#\", .literal = FALSE, .trim = TRUE)"},{"p":"glue","o":"single_quote","f":"hp_single_quote","d":"These functions make it easy to quote each individual element and are useful\nin conjunction with glue_collapse(). These are thin wrappers around\nbase::encodeString().\n","ec":"single_quote(x)"},{"p":"glue","o":"as_glue","f":"hp_as_glue","d":"A glue object is a character vector with S3 class \"glue\". The \"glue\"\nclass implements a print method that shows the literal contents (rather than\nthe string implementation) and a + method, so that you can concatenate with\nthe addition operator.\n","ec":"as_glue(x, ...)"},{"p":"glue","o":"glue_data_safe","f":"hp_glue_data_safe","d":"glue_safe() and glue_data_safe() differ from glue() and glue_data()\nin that the safe versions only look up symbols from an environment using\nget(). They do not execute any R code. This makes them suitable for use\nwith untrusted input, such as inputs in a Shiny application, where using the\nnormal functions would allow an attacker to execute arbitrary code.\n","ec":"glue_data_safe(.x, ..., .envir = parent.frame())"},{"p":"glue","o":"glue_col","f":"hp_glue_col","d":"The crayon package defines a number of functions used to\ncolor terminal output. glue_col() and glue_data_col() functions provide\nadditional syntax to make using these functions in glue strings easier.\n","ec":"glue_col(..., .envir = parent.frame(), .na = \"NA\", .literal = FALSE)"},{"p":"glue","o":"glue","f":"hp_glue","d":"Expressions enclosed by braces will be evaluated as R code. Long strings are\nbroken by line and concatenated together. Leading whitespace and blank lines\nfrom the first and last lines are automatically trimmed.\n","ec":"glue(..., .sep = \"\", .envir = parent.frame(), .open = \"{\", .close = \"}\", .na = \"NA\", .null = character(), .comment = \"#\", .literal = FALSE, .transformer = identity_transformer, .trim = TRUE)"},{"p":"glue","o":"backtick","f":"hp_backtick","d":"These functions make it easy to quote each individual element and are useful\nin conjunction with glue_collapse(). These are thin wrappers around\nbase::encodeString().\n","ec":"backtick(x)"},{"p":"glue","o":"glue_collapse","f":"hp_glue_collapse","d":"glue_collapse() collapses a character vector of any length into a length 1 vector.\nglue_sql_collapse() does the same but returns a <U+2060>[DBI::SQL()]<U+2060>\nobject rather than a glue object.\n","ec":"glue_collapse(x, sep = \"\", width = Inf, last = \"\")"},{"p":"glue","o":"glue_sql_collapse","f":"hp_glue_sql_collapse","d":"glue_collapse() collapses a character vector of any length into a length 1 vector.\nglue_sql_collapse() does the same but returns a <U+2060>[DBI::SQL()]<U+2060>\nobject rather than a glue object.\n","ec":"glue_sql_collapse(x, sep = \"\", width = Inf, last = \"\")"},{"p":"glue","o":"glue_data_sql","f":"hp_glue_data_sql","d":"SQL databases often have custom quotation syntax for identifiers and strings\nwhich make writing SQL queries error prone and cumbersome to do. glue_sql() and\nglue_data_sql() are analogs to glue() and glue_data() which handle the\nSQL quoting. glue_sql_collapse() can be used to collapse DBI::SQL() objects.\n","ec":"glue_data_sql(.x, ..., .con, .sep = \"\", .envir = parent.frame(), .open = \"{\", .close = \"}\", .na = DBI::SQL(\"NULL\"), .null = character(), .comment = \"#\", .literal = FALSE, .trim = TRUE)"},{"p":"glue","o":"glue_data","f":"hp_glue_data","d":"Expressions enclosed by braces will be evaluated as R code. Long strings are\nbroken by line and concatenated together. Leading whitespace and blank lines\nfrom the first and last lines are automatically trimmed.\n","ec":"glue_data(.x, ..., .sep = \"\", .envir = parent.frame(), .open = \"{\", .close = \"}\", .na = \"NA\", .null = character(), .comment = \"#\", .literal = FALSE, .transformer = identity_transformer, .trim = TRUE)"},{"p":"glue","o":"double_quote","f":"hp_double_quote","d":"These functions make it easy to quote each individual element and are useful\nin conjunction with glue_collapse(). These are thin wrappers around\nbase::encodeString().\n","ec":"double_quote(x)"},{"p":"glue","o":"identity_transformer","f":"hp_identity_transformer","d":"This is a simple wrapper around eval(parse()), used as the default\ntransformer.\n","ec":"identity_transformer(text, envir = parent.frame())"},{"p":"glue","o":"glue_data_col","f":"hp_glue_data_col","d":"The crayon package defines a number of functions used to\ncolor terminal output. glue_col() and glue_data_col() functions provide\nadditional syntax to make using these functions in glue strings easier.\n","ec":"glue_data_col(.x, ..., .envir = parent.frame(), .na = \"NA\", .literal = FALSE)"},{"p":"graphics","o":"polypath","f":"hp_polypath","d":"path draws a path whose vertices are\ngiven in x and y.\n","ec":"polypath(x, y = NULL, border = NULL, col = NA, lty = par(\"lty\"), rule = \"winding\", ...)"},{"p":"graphics","o":"sunflowerplot","f":"hp_sunflowerplot","d":"Multiple points are plotted as <U+2018>sunflowers<U+2019> with multiple leaves\n(<U+2018>petals<U+2019>) such that overplotting is visualized instead of\naccidental and invisible.\n","ec":"sunflowerplot(x, ...)"},{"p":"graphics","o":"plot.new","f":"hp_plot.new","d":"This function (frame is an alias for\nplot.new) causes the completion of plotting in the current plot\n(if there is one) and an advance to a new graphics frame.  This is\nused in all high-level plotting functions and also useful for skipping\nplots when a multi-figure region is in use.\n","ec":"plot.new()"},{"p":"graphics","o":"layout.show","f":"hp_layout.show","d":"layout divides the device up into as many rows and columns as\nthere are in matrix mat, with the column-widths and the\nrow-heights specified in the respective arguments.\n","ec":"layout.show(n = 1)"},{"p":"graphics","o":"matplot","f":"hp_matplot","d":"Plot the columns of one matrix against the columns of another (which\noften is just a vector treated as 1-column matrix).\n","ec":"matplot(x, y, type = \"p\", lty = 1:5, lwd = 1, lend = par(\"lend\"), pch = NULL, col = 1:6, cex = NULL, bg = NA, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, log = \"\", ..., add = FALSE, verbose = getOption(\"verbose\"))"},{"p":"graphics","o":"boxplot","f":"hp_boxplot","d":"Produce box-and-whisker plot(s) of the given (grouped) values.\n","ec":"boxplot(x, ...)"},{"p":"graphics","o":"panel.smooth","f":"hp_panel.smooth","d":"An example of a simple useful panel function to be used as\nargument in e.g., coplot or pairs.\n","ec":"panel.smooth(x, y, col = par(\"col\"), bg = NA, pch = par(\"pch\"), cex = 1, col.smooth = 2, span = 2/3, iter = 3, ...)"},{"p":"graphics","o":"box","f":"hp_box","d":"This function draws a box around the current plot in the given color\nand line type.  The bty parameter determines\nthe type of box drawn.  See par for details.\n","ec":"box(which = \"plot\", lty = \"solid\", ...)"},{"p":"graphics","o":"lcm","f":"hp_lcm","d":"layout divides the device up into as many rows and columns as\nthere are in matrix mat, with the column-widths and the\nrow-heights specified in the respective arguments.\n","ec":"lcm(x)"},{"p":"graphics","o":"locator","f":"hp_locator","d":"Reads the position of the graphics cursor when the (first) mouse\nbutton is pressed.\n","ec":"locator(n = 512, type = \"n\", ...)"},{"p":"graphics","o":"plot.design","f":"hp_plot.design","d":"Plot univariate effects of one or more factors,\ntypically for a designed experiment as analyzed by aov().\n","ec":"plot.design(x, y = NULL, fun = mean, data = NULL, ..., ylim = NULL, xlab = \"Factors\", ylab = NULL, main = NULL, ask = NULL, xaxt = par(\"xaxt\"), axes = TRUE, xtick = FALSE)"},{"p":"graphics","o":"barplot.default","f":"hp_barplot.default","d":"Creates a bar plot with vertical or horizontal bars.\n","ec":"barplot.default(height, width = 1, space = NULL, names.arg = NULL, legend.text = NULL, beside = FALSE, horiz = FALSE, density = NULL, angle = 45, col = NULL, border = par(\"fg\"), main = NULL, sub = NULL, xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, xpd = TRUE, log = \"\", axes = TRUE, axisnames = TRUE, cex.axis = par(\"cex.axis\"), cex.names = par(\"cex.axis\"), inside = TRUE, plot = TRUE, axis.lty = 0, offset = 0, add = FALSE, ann = !add && par(\"ann\"), args.legend = NULL, ...)"},{"p":"graphics","o":"axis.POSIXct","f":"hp_axis.POSIXct","d":"Add a date/time axis to the current plot of an object of class\n\"POSIXt\" or \"Date\", respectively.\n","ec":"axis.POSIXct(side, x, at, format, labels = TRUE, ...)"},{"p":"graphics","o":"curve","f":"hp_curve","d":"Draws a curve corresponding to a function over the interval\n[from, to]. curve can plot also an expression in the variable\nxname, default <U+2018><U+2060>x<U+2060><U+2019>.\n","ec":"curve(expr, from = NULL, to = NULL, n = 101, add = FALSE, type = \"l\", xname = \"x\", xlab = xname, ylab = NULL, log = NULL, xlim = NULL, ...)"},{"p":"graphics","o":"matpoints","f":"hp_matpoints","d":"Plot the columns of one matrix against the columns of another (which\noften is just a vector treated as 1-column matrix).\n","ec":"matpoints(x, y, type = \"p\", lty = 1:5, lwd = 1, pch = NULL, col = 1:6, ...)"},{"p":"graphics","o":"plot.default","f":"hp_plot.default","d":"Draw a scatter plot with decorations such as axes and titles\nin the active graphics window.\n","ec":"plot.default(x, y = NULL, type = \"p\", xlim = NULL, ylim = NULL, log = \"\", main = NULL, sub = NULL, xlab = NULL, ylab = NULL, ann = par(\"ann\"), axes = TRUE, frame.plot = axes, panel.first = NULL, panel.last = NULL, asp = NA, xgap.axis = NA, ygap.axis = NA, ...)"},{"p":"graphics","o":"pairs.default","f":"hp_pairs.default","d":"A matrix of scatterplots is produced.\n","ec":"pairs.default(x, labels, panel = points, ..., horInd = 1:nc, verInd = 1:nc, lower.panel = panel, upper.panel = panel, diag.panel = NULL, text.panel = textPanel, label.pos = 0.5 + has.diag/3, line.main = 3, cex.labels = NULL, font.labels = 1, row1attop = TRUE, gap = 1, log = \"\", horOdd = !row1attop, verOdd = !row1attop)"},{"p":"graphics","o":"coplot","f":"hp_coplot","d":"This function produces two variants of the conditioning plots\ndiscussed in the reference below.\n","ec":"coplot(formula, data, given.values, panel = points, rows, columns, show.given = TRUE, col = par(\"fg\"), pch = par(\"pch\"), bar.bg = c(num = gray(0.8), fac = gray(0.95)), xlab = c(x.name, paste(\"Given :\", a.name)), ylab = c(y.name, paste(\"Given :\", b.name)), subscripts = FALSE, axlabels = function(f) abbreviate(levels(f)), number = 6, overlap = 0.5, xlim, ylim, ...)"},{"p":"graphics","o":"par","f":"hp_par","d":"par can be used to set or query graphical parameters.\nParameters can be set by specifying them as arguments to par in\ntag = value form, or by passing them as a list of tagged\nvalues.\n","ec":"par(..., no.readonly = FALSE)"},{"p":"graphics","o":"co.intervals","f":"hp_co.intervals","d":"This function produces two variants of the conditioning plots\ndiscussed in the reference below.\n","ec":"co.intervals(x, number = 6, overlap = 0.5)"},{"p":"graphics","o":"hist.default","f":"hp_hist.default","d":"The generic function hist computes a histogram of the given\ndata values.  If plot = TRUE, the resulting object of\nclass \"histogram\" is plotted by\nplot.histogram, before it is returned.\n","ec":"hist.default(x, breaks = \"Sturges\", freq = NULL, probability = !freq, include.lowest = TRUE, right = TRUE, fuzz = 1e-07, density = NULL, angle = 45, col = \"lightgray\", border = NULL, main = paste(\"Histogram of\", xname), xlim = range(breaks), ylim = NULL, xlab = xname, ylab, axes = TRUE, plot = TRUE, labels = FALSE, nclass = NULL, warn.unused = TRUE, ...)"},{"p":"graphics","o":"xyinch","f":"hp_xyinch","d":"xinch and yinch convert the specified number of inches\ngiven as their arguments into the correct units for plotting with\ngraphics functions.  Usually, this only makes sense when normal\ncoordinates are used, i.e., no log scale (see the\nlog argument to par).\n","ec":"xyinch(xy = 1, warn.log = TRUE)"},{"p":"graphics","o":"mtext","f":"hp_mtext","d":"Text is written in one of the four margins of the current figure region\nor one of the outer margins of the device region.\n","ec":"mtext(text, side = 3, line = 0, outer = FALSE, at = NA, adj = NA, padj = NA, cex = NA, col = NA, font = NA, ...)"},{"p":"graphics","o":"frame","f":"hp_frame","d":"This function (frame is an alias for\nplot.new) causes the completion of plotting in the current plot\n(if there is one) and an advance to a new graphics frame.  This is\nused in all high-level plotting functions and also useful for skipping\nplots when a multi-figure region is in use.\n","ec":"frame()"},{"p":"graphics","o":"screen","f":"hp_screen","d":"split.screen defines a number of regions within the current\ndevice which can, to some extent, be treated as separate graphics\ndevices.  It is useful for generating multiple plots on a single\ndevice.  Screens can themselves be split, allowing for quite complex\narrangements of plots.\n","ec":"screen(n = cur.screen, new = TRUE)"},{"p":"graphics","o":"image.default","f":"hp_image.default","d":"Creates a grid of colored or gray-scale rectangles with colors\ncorresponding to the values in z.  This can be used to display\nthree-dimensional or spatial data aka images.\nThis is a generic function.\n","ec":"image.default(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out = ncol(z)), z, zlim = range(z[is.finite(z)]), xlim = range(x), ylim = range(y), col = hcl.colors(12, \"YlOrRd\", rev = TRUE), add = FALSE, xaxs = \"i\", yaxs = \"i\", xlab, ylab, breaks, oldstyle = FALSE, useRaster, ...)"},{"p":"graphics","o":"boxplot.default","f":"hp_boxplot.default","d":"Produce box-and-whisker plot(s) of the given (grouped) values.\n","ec":"boxplot.default(x, ..., range = 1.5, width = NULL, varwidth = FALSE, notch = FALSE, outline = TRUE, names, plot = TRUE, border = par(\"fg\"), col = \"lightgray\", log = \"\", pars = list(boxwex = 0.8, staplewex = 0.5, outwex = 0.5), ann = !add, horizontal = FALSE, add = FALSE, at = NULL)"},{"p":"graphics","o":"stem","f":"hp_stem","d":"stem produces a stem-and-leaf plot of the values in x.\nThe parameter scale can be used to expand the scale of the\nplot.  A value of scale = 2 will cause the plot to be roughly\ntwice as long as the default.\n","ec":"stem(x, scale = 1, width = 80, atom = 1e-08)"},{"p":"graphics","o":"polygon","f":"hp_polygon","d":"polygon draws the polygons whose vertices are\ngiven in x and y.\n","ec":"polygon(x, y = NULL, density = NULL, angle = 45, border = NULL, col = NA, lty = par(\"lty\"), ..., fillOddEven = FALSE)"},{"p":"graphics","o":"stars","f":"hp_stars","d":"Draw star plots or segment diagrams of a multivariate data set.\nWith one single location, also draws <U+2018>spider<U+2019>\n(or <U+2018>radar<U+2019>) plots.\n","ec":"stars(x, full = TRUE, scale = TRUE, radius = TRUE, labels = dimnames(x)[[1L]], locations = NULL, nrow = NULL, ncol = NULL, len = 1, key.loc = NULL, key.labels = dimnames(x)[[2L]], key.xpd = TRUE, xlim = NULL, ylim = NULL, flip.labels = NULL, draw.segments = FALSE, col.segments = 1L:n.seg, col.stars = NA, col.lines = NA, axes = FALSE, frame.plot = axes, main = NULL, sub = NULL, xlab = \"\", ylab = \"\", cex = 0.8, lwd = 0.25, lty = par(\"lty\"), xpd = FALSE, mar = pmin(par(\"mar\"), 1.1 + c(2 * axes + (xlab != \"\"), 2 * axes + (ylab != \"\"), 1, 0)), add = FALSE, plot = TRUE, ...)"},{"p":"graphics","o":"lines","f":"hp_lines","d":"A generic function taking coordinates given in various ways and\njoining the corresponding points with line segments.\n","ec":"lines(x, ...)"},{"p":"graphics","o":"symbols","f":"hp_symbols","d":"This function draws symbols on a plot.  One of six symbols;\ncircles, squares, rectangles, stars,\nthermometers, and boxplots, can be plotted at a\nspecified set of x and y coordinates.  Specific aspects of the\nsymbols, such as relative size, can be customized by additional\nparameters.\n","ec":"symbols(x, y = NULL, circles, squares, rectangles, stars, thermometers, boxplots, inches = TRUE, add = FALSE, fg = par(\"col\"), bg = NA, xlab = NULL, ylab = NULL, main = NULL, xlim = NULL, ylim = NULL, ...)"},{"p":"graphics","o":"pairs","f":"hp_pairs","d":"A matrix of scatterplots is produced.\n","ec":"pairs(x, ...)"},{"p":"graphics","o":"points","f":"hp_points","d":"points is a generic function to draw a sequence of points at\nthe specified coordinates.  The specified character(s) are plotted,\ncentered at the coordinates.\n","ec":"points(x, ...)"},{"p":"graphics","o":"grconvertX","f":"hp_grconvertX","d":"Convert between graphics coordinate systems.\n","ec":"grconvertX(x, from = \"user\", to = \"user\")"},{"p":"graphics","o":"assocplot","f":"hp_assocplot","d":"Produce a Cohen-Friendly association plot indicating deviations from\nindependence of rows and columns in a 2-dimensional contingency\ntable.\n","ec":"assocplot(x, col = c(\"black\", \"red\"), space = 0.3, main = NULL, xlab = NULL, ylab = NULL)"},{"p":"graphics","o":"spineplot","f":"hp_spineplot","d":"Spine plots are a special cases of mosaic plots, and can be seen as\na generalization of stacked (or highlighted) bar plots. Analogously,\nspinograms are an extension of histograms.\n","ec":"spineplot(x, ...)"},{"p":"graphics","o":"grconvertY","f":"hp_grconvertY","d":"Convert between graphics coordinate systems.\n","ec":"grconvertY(y, from = \"user\", to = \"user\")"},{"p":"graphics","o":"title","f":"hp_title","d":"This function can be used to add labels to a plot.  Its first four\nprincipal arguments can also be used as arguments in most high-level\nplotting functions.  They must be of type character or\nexpression. In the latter case, quite a bit of\nmathematical notation is available such as sub- and superscripts,\nGreek letters, fractions, etc: see plotmath\n","ec":"title(main = NULL, sub = NULL, xlab = NULL, ylab = NULL, line = NA, outer = FALSE, ...)"},{"p":"graphics","o":"barplot","f":"hp_barplot","d":"Creates a bar plot with vertical or horizontal bars.\n","ec":"barplot(height, ...)"},{"p":"graphics","o":"persp","f":"hp_persp","d":"This function draws perspective plots of a surface over the\nx<U+2013>y plane.  persp is a generic function.\n","ec":"persp(x, ...)"},{"p":"graphics","o":"legend","f":"hp_legend","d":"This function can be used to add legends to plots.  Note that a call\nto the function locator(1) can be used in place of the x\nand y arguments.\n","ec":"legend(x, y = NULL, legend, fill = NULL, col = par(\"col\"), border = \"black\", lty, lwd, pch, angle = 45, density = NULL, bty = \"o\", bg = par(\"bg\"), box.lwd = par(\"lwd\"), box.lty = par(\"lty\"), box.col = par(\"fg\"), pt.bg = NA, cex = 1, pt.cex = cex, pt.lwd = lwd, xjust = 0, yjust = 1, x.intersp = 1, y.intersp = 1, adj = c(0, 0.5), text.width = NULL, text.col = par(\"col\"), text.font = NULL, merge = do.lines && has.pch, trace = FALSE, plot = TRUE, ncol = 1, horiz = FALSE, title = NULL, inset = 0, xpd, title.col = text.col[1], title.adj = 0.5, title.cex = cex[1], title.font = text.font[1], seg.len = 2)"},{"p":"graphics","o":"identify","f":"hp_identify","d":"identify reads the position of the graphics pointer when the\n(first) mouse button is pressed.  It then searches the coordinates\ngiven in x and y for the point closest to the pointer.\nIf this point is close enough to the pointer, its index will be returned as\npart of the value of the call.\n","ec":"identify(x, ...)"},{"p":"graphics","o":"image","f":"hp_image","d":"Creates a grid of colored or gray-scale rectangles with colors\ncorresponding to the values in z.  This can be used to display\nthree-dimensional or spatial data aka images.\nThis is a generic function.\n","ec":"image(x, ...)"},{"p":"graphics","o":"filled.contour","f":"hp_filled.contour","d":"This function produces a contour plot with the areas between the\ncontours filled in solid color (Cleveland calls this a level plot).  A\nkey showing how the colors map to z values is shown to the right of\nthe plot.\n","ec":"filled.contour(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out = ncol(z)), z, xlim = range(x, finite = TRUE), ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), levels = pretty(zlim, nlevels), nlevels = 20, color.palette = function(n) hcl.colors(n, \"YlOrRd\", rev = TRUE), col = color.palette(length(levels) - 1), plot.title, plot.axes, key.title, key.axes, key.border = NULL, asp = NA, xaxs = \"i\", yaxs = \"i\", las = 1, axes = TRUE, frame.plot = axes, ...)"},{"p":"graphics","o":"lines.default","f":"hp_lines.default","d":"A generic function taking coordinates given in various ways and\njoining the corresponding points with line segments.\n","ec":"lines.default(x, y = NULL, type = \"l\", ...)"},{"p":"graphics","o":"hist","f":"hp_hist","d":"The generic function hist computes a histogram of the given\ndata values.  If plot = TRUE, the resulting object of\nclass \"histogram\" is plotted by\nplot.histogram, before it is returned.\n","ec":"hist(x, ...)"},{"p":"graphics","o":"stripchart","f":"hp_stripchart","d":"stripchart produces one dimensional scatter plots (or dot\nplots) of the given data.  These plots are a good alternative to\nboxplots when sample sizes are small.\n","ec":"stripchart(x, ...)"},{"p":"graphics","o":"contour","f":"hp_contour","d":"Create a contour plot, or add contour lines to an existing plot.\n","ec":"contour(x, ...)"},{"p":"graphics","o":"plot.function","f":"hp_plot.function","d":"Draws a curve corresponding to a function over the interval\n[from, to]. curve can plot also an expression in the variable\nxname, default <U+2018><U+2060>x<U+2060><U+2019>.\n","ec":"plot.function(x, y = 0, to = 1, from = y, xlim = NULL, ylab = NULL, ...)"},{"p":"graphics","o":"mosaicplot","f":"hp_mosaicplot","d":"Plots a mosaic on the current graphics device.","ec":"mosaicplot(x, ...)"},{"p":"graphics","o":"fourfoldplot","f":"hp_fourfoldplot","d":"Creates a fourfold display of a 2 by 2 by k contingency table on\nthe current graphics device, allowing for the visual inspection of the\nassociation between two dichotomous variables in one or several\npopulations (strata).\n","ec":"fourfoldplot(x, color = c(\"#99CCFF\", \"#6699CC\"), conf.level = 0.95, std = c(\"margins\", \"ind.max\", \"all.max\"), margin = c(1, 2), space = 0.2, main = NULL, mfrow = NULL, mfcol = NULL)"},{"p":"graphics","o":"split.screen","f":"hp_split.screen","d":"split.screen defines a number of regions within the current\ndevice which can, to some extent, be treated as separate graphics\ndevices.  It is useful for generating multiple plots on a single\ndevice.  Screens can themselves be split, allowing for quite complex\narrangements of plots.\n","ec":"split.screen(figs, screen, erase = TRUE)"},{"p":"graphics","o":"smoothScatter","f":"hp_smoothScatter","d":"smoothScatter produces a smoothed color density\nrepresentation of a scatterplot, obtained through a (2D) kernel\ndensity estimate.\n","ec":"smoothScatter(x, y = NULL, nbin = 128, bandwidth, colramp = colorRampPalette(c(\"white\", blues9)), nrpoints = 100, ret.selection = FALSE, pch = \".\", cex = 1, col = \"black\", transformation = function(x) x^0.25, postPlotHook = box, xlab = NULL, ylab = NULL, xlim, ylim, xaxs = par(\"xaxs\"), yaxs = par(\"yaxs\"), ...)"},{"p":"graphics","o":"matlines","f":"hp_matlines","d":"Plot the columns of one matrix against the columns of another (which\noften is just a vector treated as 1-column matrix).\n","ec":"matlines(x, y, type = \"l\", lty = 1:5, lwd = 1, pch = NULL, col = 1:6, ...)"},{"p":"graphics","o":"axTicks","f":"hp_axTicks","d":"Compute pretty tickmark locations, the same way as R does internally.\nThis is only non-trivial when log coordinates are active.\nBy default, gives the at values which\naxis(side) would use.\n","ec":"axTicks(side, axp = NULL, usr = NULL, log = NULL, nintLog = NULL)"},{"p":"graphics","o":"arrows","f":"hp_arrows","d":"Draw arrows between pairs of points.\n","ec":"arrows(x0, y0, x1 = x0, y1 = y0, length = 0.25, angle = 30, code = 2, col = par(\"fg\"), lty = par(\"lty\"), lwd = par(\"lwd\"), ...)"},{"p":"graphics","o":"text.default","f":"hp_text.default","d":"text draws the strings given in the vector labels at the\ncoordinates given by x and y.\ny may be missing since xy.coords(x, y) is used for\nconstruction of the coordinates.\n","ec":"text.default(x, y = NULL, labels = seq_along(x$x), adj = NULL, pos = NULL, offset = 0.5, vfont = NULL, cex = 1, col = NULL, font = NULL, ...)"},{"p":"graphics","o":"points.default","f":"hp_points.default","d":"points is a generic function to draw a sequence of points at\nthe specified coordinates.  The specified character(s) are plotted,\ncentered at the coordinates.\n","ec":"points.default(x, y = NULL, type = \"p\", ...)"},{"p":"graphics","o":"xinch","f":"hp_xinch","d":"xinch and yinch convert the specified number of inches\ngiven as their arguments into the correct units for plotting with\ngraphics functions.  Usually, this only makes sense when normal\ncoordinates are used, i.e., no log scale (see the\nlog argument to par).\n","ec":"xinch(x = 1, warn.log = TRUE)"},{"p":"graphics","o":"dotchart","f":"hp_dotchart","d":"Draw a Cleveland dot plot.\n","ec":"dotchart(x, labels = NULL, groups = NULL, gdata = NULL, offset = 1/8, ann = par(\"ann\"), xaxt = par(\"xaxt\"), frame.plot = TRUE, log = \"\", cex = par(\"cex\"), pt.cex = cex, pch = 21, gpch = 21, bg = par(\"bg\"), color = par(\"fg\"), gcolor = par(\"fg\"), lcolor = \"gray\", xlim = range(x[is.finite(x)]), main = NULL, xlab = NULL, ylab = NULL, ...)"},{"p":"graphics","o":"strheight","f":"hp_strheight","d":"These functions compute the width or height, respectively, of the\ngiven strings or mathematical expressions s[i] on\nthe current plotting device in user coordinates, inches\nor as fraction of the figure width par(\"fin\").\n","ec":"strheight(s, units = \"user\", cex = NULL, font = NULL, vfont = NULL, ...)"},{"p":"graphics","o":"rect","f":"hp_rect","d":"rect draws a rectangle (or sequence of rectangles) with the\ngiven coordinates, fill and border colors.\n","ec":"rect(xleft, ybottom, xright, ytop, density = NULL, angle = 45, col = NA, border = NULL, lty = par(\"lty\"), lwd = par(\"lwd\"), ...)"},{"p":"graphics","o":"grid","f":"hp_grid","d":"grid adds an nx by ny rectangular grid to an\nexisting plot.\n","ec":"grid(nx = NULL, ny = nx, col = \"lightgray\", lty = \"dotted\", lwd = par(\"lwd\"), equilogs = TRUE)"},{"p":"graphics","o":".filled.contour","f":"hp_.filled.contour","d":"This function produces a contour plot with the areas between the\ncontours filled in solid color (Cleveland calls this a level plot).  A\nkey showing how the colors map to z values is shown to the right of\nthe plot.\n","ec":".filled.contour(x, y, z, levels, col)"},{"p":"graphics","o":"close.screen","f":"hp_close.screen","d":"split.screen defines a number of regions within the current\ndevice which can, to some extent, be treated as separate graphics\ndevices.  It is useful for generating multiple plots on a single\ndevice.  Screens can themselves be split, allowing for quite complex\narrangements of plots.\n","ec":"close.screen(n, all.screens = FALSE)"},{"p":"graphics","o":"axis","f":"hp_axis","d":"Adds an axis to the current plot, allowing the\nspecification of the side, position, labels, and other options.\n","ec":"axis(side, at = NULL, labels = TRUE, tick = TRUE, line = NA, pos = NA, outer = FALSE, font = NA, lty = \"solid\", lwd = 1, lwd.ticks = lwd, col = NULL, col.ticks = NULL, hadj = NA, padj = NA, gap.axis = NA, ...)"},{"p":"graphics","o":"layout","f":"hp_layout","d":"layout divides the device up into as many rows and columns as\nthere are in matrix mat, with the column-widths and the\nrow-heights specified in the respective arguments.\n","ec":"layout(mat, widths = rep.int(1, ncol(mat)), heights = rep.int(1, nrow(mat)), respect = FALSE)"},{"p":"graphics","o":"contour.default","f":"hp_contour.default","d":"Create a contour plot, or add contour lines to an existing plot.\n","ec":"contour.default(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out = ncol(z)), z, nlevels = 10, levels = pretty(zlim, nlevels), labels = NULL, xlim = range(x, finite = TRUE), ylim = range(y, finite = TRUE), zlim = range(z, finite = TRUE), labcex = 0.6, drawlabels = TRUE, method = \"flattest\", vfont, axes = TRUE, frame.plot = axes, col = par(\"fg\"), lty = par(\"lty\"), lwd = par(\"lwd\"), add = FALSE, ...)"},{"p":"graphics","o":"cdplot","f":"hp_cdplot","d":"Computes and plots conditional densities describing how the\nconditional distribution of a categorical variable y changes over a\nnumerical variable x.\n","ec":"cdplot(x, ...)"},{"p":"graphics","o":"pie","f":"hp_pie","d":"Draw a pie chart.\n","ec":"pie(x, labels = names(x), edges = 200, radius = 0.8, clockwise = FALSE, init.angle = if (clockwise) 90 else 0, density = NULL, angle = 45, col = NULL, border = NULL, lty = NULL, main = NULL, ...)"},{"p":"graphics","o":"xspline","f":"hp_xspline","d":"Draw an X-spline, a curve drawn relative to control points.\n","ec":"xspline(x, y = NULL, shape = 0, open = TRUE, repEnds = TRUE, draw = TRUE, border = par(\"fg\"), col = NA, ...)"},{"p":"graphics","o":"text","f":"hp_text","d":"text draws the strings given in the vector labels at the\ncoordinates given by x and y.\ny may be missing since xy.coords(x, y) is used for\nconstruction of the coordinates.\n","ec":"text(x, ...)"},{"p":"graphics","o":"strwidth","f":"hp_strwidth","d":"These functions compute the width or height, respectively, of the\ngiven strings or mathematical expressions s[i] on\nthe current plotting device in user coordinates, inches\nor as fraction of the figure width par(\"fin\").\n","ec":"strwidth(s, units = \"user\", cex = NULL, font = NULL, vfont = NULL, ...)"},{"p":"graphics","o":"axis.Date","f":"hp_axis.Date","d":"Add a date/time axis to the current plot of an object of class\n\"POSIXt\" or \"Date\", respectively.\n","ec":"axis.Date(side, x, at, format, labels = TRUE, ...)"},{"p":"graphics","o":"boxplot.matrix","f":"hp_boxplot.matrix","d":"Interpreting the columns (or rows) of a matrix as different groups, draw a\nboxplot for each.\n","ec":"boxplot.matrix(x, use.cols = TRUE, ...)"},{"p":"graphics","o":"bxp","f":"hp_bxp","d":"bxp draws box plots based on the given summaries in z.\nIt is usually called from within boxplot, but can be\ninvoked directly.\n","ec":"bxp(z, notch = FALSE, width = NULL, varwidth = FALSE, outline = TRUE, notch.frac = 0.5, log = \"\", border = par(\"fg\"), pars = NULL, frame.plot = axes, horizontal = FALSE, ann = TRUE, add = FALSE, at = NULL, show.names = NULL, ...)"},{"p":"graphics","o":"abline","f":"hp_abline","d":"This function adds one or more straight lines through the current plot.\n","ec":"abline(a = NULL, b = NULL, h = NULL, v = NULL, reg = NULL, coef = NULL, untf = FALSE, ...)"},{"p":"graphics","o":"plot.xy","f":"hp_plot.xy","d":"This is the internal function that does the basic plotting of\npoints and lines.  Usually, one should rather use the higher level\nfunctions instead and refer to their help pages for explanation of the\narguments.\n","ec":"plot.xy(xy, type, pch = par(\"pch\"), lty = par(\"lty\"), col = par(\"col\"), bg = NA, cex = 1, lwd = par(\"lwd\"), ...)"},{"p":"graphics","o":"rasterImage","f":"hp_rasterImage","d":"rasterImage draws a raster image at the given locations and sizes.\n","ec":"rasterImage(image, xleft, ybottom, xright, ytop, angle = 0, interpolate = TRUE, ...)"},{"p":"graphics","o":"segments","f":"hp_segments","d":"Draw line segments between pairs of points.\n","ec":"segments(x0, y0, x1 = x0, y1 = y0, col = par(\"fg\"), lty = par(\"lty\"), lwd = par(\"lwd\"), ...)"},{"p":"graphics","o":"yinch","f":"hp_yinch","d":"xinch and yinch convert the specified number of inches\ngiven as their arguments into the correct units for plotting with\ngraphics functions.  Usually, this only makes sense when normal\ncoordinates are used, i.e., no log scale (see the\nlog argument to par).\n","ec":"yinch(y = 1, warn.log = TRUE)"},{"p":"graphics","o":"plot.window","f":"hp_plot.window","d":"This function sets up the world coordinate system for a graphics\nwindow.  It is called by higher level functions such as\nplot.default (after plot.new).\n","ec":"plot.window(xlim, ylim, log = \"\", asp = NA, ...)"},{"p":"graphics","o":"clip","f":"hp_clip","d":"Set clipping region in user coordinates\n","ec":"clip(x1, x2, y1, y2)"},{"p":"graphics","o":"erase.screen","f":"hp_erase.screen","d":"split.screen defines a number of regions within the current\ndevice which can, to some extent, be treated as separate graphics\ndevices.  It is useful for generating multiple plots on a single\ndevice.  Screens can themselves be split, allowing for quite complex\narrangements of plots.\n","ec":"erase.screen(n = cur.screen)"},{"p":"graphics","o":"rug","f":"hp_rug","d":"Adds a rug representation (1-d plot) of the data to the plot.\n","ec":"rug(x, ticksize = 0.03, side = 1, lwd = 0.5, col = par(\"fg\"), quiet = getOption(\"warn\") < 0, ...)"},{"p":"graphics","o":"Axis","f":"hp_Axis","d":"Generic function to add a suitable axis to the current plot.\n","ec":"Axis(x = NULL, at = NULL, ..., side, labels = NULL)"},{"p":"grDevices","o":".radialGradientPattern","f":"hp_.radialGradientPattern","d":"Internal grDevices functions\n","ec":".radialGradientPattern(colours = c(\"black\", \"white\"), stops = seq(0, 1, length.out = length(colours)), cx1 = 0, cy1 = 0, r1 = 0, cx2 = 1, cy2 = 1, r2 = 0.5, extend = \"pad\")"},{"p":"grDevices","o":"gray.colors","f":"hp_gray.colors","d":"Create a vector of n gamma-corrected gray colors.\n","ec":"gray.colors(n, start = 0.3, end = 0.9, gamma = 2.2, alpha, rev = FALSE)"},{"p":"grDevices","o":"rainbow","f":"hp_rainbow","d":"Create a vector of n contiguous colors.\n","ec":"rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1)/n, alpha, rev = FALSE)"},{"p":"grDevices","o":"check.options","f":"hp_check.options","d":"Utility function for setting options with some consistency checks.\nThe attributes of the new settings in new are\nchecked for consistency with the model (often default)\nlist in name.opt.\n","ec":"check.options(new, name.opt, reset = FALSE, assign.opt = FALSE, envir = .GlobalEnv, check.attributes = c(\"mode\", \"length\"), override.check = FALSE)"},{"p":"grDevices","o":"hcl.pals","f":"hp_hcl.pals","d":"Create a vector of n contiguous colors.\n","ec":"hcl.pals(type = NULL)"},{"p":"grDevices","o":"glyphFontList","f":"hp_glyphFontList","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphFontList(...)"},{"p":"grDevices","o":"embedFonts","f":"hp_embedFonts","d":"Runs Ghostscript to process a PDF or PostScript file and\nembed all fonts in the file.\n","ec":"embedFonts(file, format, outfile = file, fontpaths = character(), options = character())"},{"p":"grDevices","o":"cairo_ps","f":"hp_cairo_ps","d":"Graphics devices for SVG, PDF and PostScript graphics files using\nthe cairo graphics API.\n","ec":"cairo_ps(filename = if (onefile) \"Rplots.ps\" else \"Rplot%03d.ps\", width = 7, height = 7, pointsize = 12, onefile = TRUE, family = \"sans\", bg = \"white\", antialias = c(\"default\", \"none\", \"gray\", \"subpixel\"), fallback_resolution = 300, symbolfamily)"},{"p":"grDevices","o":"colorspaces","f":"hp_colorspaces","d":"Convert colours between their representations in standard\ncolour spaces.\n","ec":""},{"p":"grDevices","o":"cairo_pdf","f":"hp_cairo_pdf","d":"Graphics devices for SVG, PDF and PostScript graphics files using\nthe cairo graphics API.\n","ec":"cairo_pdf(filename = if (onefile) \"Rplots.pdf\" else \"Rplot%03d.pdf\", width = 7, height = 7, pointsize = 12, onefile = TRUE, family = \"sans\", bg = \"white\", antialias = c(\"default\", \"none\", \"gray\", \"subpixel\"), fallback_resolution = 300, symbolfamily)"},{"p":"grDevices","o":"getGraphicsEventEnv","f":"hp_getGraphicsEventEnv","d":"This function waits for input from a graphics window in the\nform of a mouse or keyboard event.\n","ec":"getGraphicsEventEnv(which = dev.cur())"},{"p":"grDevices","o":".axisPars","f":"hp_.axisPars","d":"Compute pretty axis scales and tick mark locations, the same way as\ntraditional R graphics do it.  This is interesting particularly for\nlog scale axes.\n","ec":".axisPars(usr, log = FALSE, nintLog = 5)"},{"p":"grDevices","o":"bmp","f":"hp_bmp","d":"Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files.\n","ec":"bmp(filename = \"Rplot%03d.bmp\", width = 480, height = 480, units = \"px\", pointsize = 12, bg = \"white\", res = NA, ..., type = c(\"cairo\", \"Xlib\", \"quartz\"), antialias)"},{"p":"grDevices","o":".devUp","f":"hp_.devUp","d":"Internal grDevices functions\n","ec":".devUp()"},{"p":"grDevices","o":".mask","f":"hp_.mask","d":"Internal grDevices functions\n","ec":".mask(fun, type)"},{"p":"grDevices","o":"graphics.off","f":"hp_graphics.off","d":"These functions provide control over multiple graphics devices.\n","ec":"graphics.off()"},{"p":"grDevices","o":"densCols","f":"hp_densCols","d":"densCols produces a vector containing colors which encode the\nlocal densities at each point in a scatterplot.\n","ec":"densCols(x, y = NULL, nbin = 128, bandwidth, colramp = colorRampPalette(blues9[-(1:3)]))"},{"p":"grDevices","o":"savePlot","f":"hp_savePlot","d":"Save the current page of a cairo X11() device to a file.\n","ec":"savePlot(filename = paste0(\"Rplot.\", type), type = c(\"png\", \"jpeg\", \"tiff\", \"bmp\"), device = dev.cur())"},{"p":"grDevices","o":"X11Font","f":"hp_X11Font","d":"These functions handle the translation of a device-independent R graphics\nfont family name to an X11 font description on Unix-alike platforms.\n","ec":"X11Font(font)"},{"p":"grDevices","o":"grey","f":"hp_grey","d":"Create a vector of colors from a vector of gray levels.\n","ec":"grey(level, alpha)"},{"p":"grDevices","o":".setMask","f":"hp_.setMask","d":"Internal grDevices functions\n","ec":".setMask(mask, ref)"},{"p":"grDevices","o":"deviceIsInteractive","f":"hp_deviceIsInteractive","d":"Test if the current graphics device (or that which would be opened) is\ninteractive.\n","ec":"deviceIsInteractive(name = NULL)"},{"p":"grDevices","o":".opIndex","f":"hp_.opIndex","d":"Internal grDevices functions\n","ec":".opIndex(x)"},{"p":"grDevices","o":"quartz.save","f":"hp_quartz.save","d":"quartz starts a graphics device driver for the macOS system.\nIt supports plotting both to the screen (the default) and to various\ngraphics file formats.\n","ec":"quartz.save(file, type = \"png\", device = dev.cur(), dpi = 100, ...)"},{"p":"grDevices","o":"quartz","f":"hp_quartz","d":"quartz starts a graphics device driver for the macOS system.\nIt supports plotting both to the screen (the default) and to various\ngraphics file formats.\n","ec":"quartz(title, width, height, pointsize, family, antialias, type, file = NULL, bg, canvas, dpi)"},{"p":"grDevices","o":"xfig","f":"hp_xfig","d":"xfig starts the graphics device driver for producing XFig\n(version 3.2) graphics.\n","ec":"xfig(file = if (onefile) \"Rplots.fig\" else \"Rplot%03d.fig\", onefile = FALSE, encoding = \"none\", paper = \"default\", horizontal = TRUE, width = 0, height = 0, family = \"Helvetica\", pointsize = 12, bg = \"transparent\", fg = \"black\", pagecentre = TRUE, defaultfont = FALSE, textspecial = FALSE)"},{"p":"grDevices","o":"dev.capabilities","f":"hp_dev.capabilities","d":"Query the capabilities of the current graphics device.\n","ec":"dev.capabilities(what = NULL)"},{"p":"grDevices","o":"extendrange","f":"hp_extendrange","d":"Extends a numerical range by a small percentage, i.e., fraction,\non both sides.\n","ec":"extendrange(x, r = range(x, na.rm = TRUE), f = 0.05)"},{"p":"grDevices","o":"nclass.Sturges","f":"hp_nclass.Sturges","d":"Compute the number of classes for a histogram, notably hist().\n","ec":"nclass.Sturges(x)"},{"p":"grDevices","o":".defineGroup","f":"hp_.defineGroup","d":"Internal grDevices functions\n","ec":".defineGroup(source, op, destination)"},{"p":"grDevices","o":".useGroup","f":"hp_.useGroup","d":"Internal grDevices functions\n","ec":".useGroup(ref, trans)"},{"p":"grDevices","o":"colors","f":"hp_colors","d":"Returns the built-in color names which R knows about.\n","ec":"colors(distinct = FALSE)"},{"p":"grDevices","o":"pictex","f":"hp_pictex","d":"This function produces simple graphics suitable for inclusion in TeX\nand LaTeX documents.  It dates from the very early days of R and is\nfor historical interest only.  It was deprecated in R 4.4.0.\nConsider the tikzDevice instead.\n","ec":"pictex(file = \"Rplots.tex\", width = 5, height = 4, debug = FALSE, bg = \"white\", fg = \"black\")"},{"p":"grDevices","o":".ruleIndex","f":"hp_.ruleIndex","d":"Internal grDevices functions\n","ec":".ruleIndex(x)"},{"p":"grDevices","o":"dev.set","f":"hp_dev.set","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.set(which = dev.next())"},{"p":"grDevices","o":"trans3d","f":"hp_trans3d","d":"Projection of 3-dimensional to 2-dimensional points using a 4x4\nviewing transformation matrix.  Mainly for adding to\nperspective plots such as persp.\n","ec":"trans3d(x, y, z, pmat, continuous = FALSE, verbose = TRUE)"},{"p":"grDevices","o":"recordPlot","f":"hp_recordPlot","d":"Functions to save the current plot in an R variable, and to replay it.\n","ec":"recordPlot(load = NULL, attach = NULL)"},{"p":"grDevices","o":"glyphWidthLeft","f":"hp_glyphWidthLeft","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphWidthLeft(w, label)"},{"p":"grDevices","o":"hsv","f":"hp_hsv","d":"Create a vector of colors from vectors specifying hue, saturation and\nvalue.\n","ec":"hsv(h = 1, s = 1, v = 1, alpha)"},{"p":"grDevices","o":"bitmap","f":"hp_bitmap","d":"bitmap generates a graphics file.\ndev2bitmap copies the current graphics device to a file in a\ngraphics format.\n","ec":"bitmap(file, type = \"png16m\", height = 7, width = 7, res = 72, units = \"in\", pointsize, taa = NA, gaa = NA, ...)"},{"p":"grDevices","o":"embedGlyphs","f":"hp_embedGlyphs","d":"Runs Ghostscript to process a PDF or PostScript file and\nembed all fonts in the file.\n","ec":"embedGlyphs(file, glyphInfo, outfile = file, options = character())"},{"p":"grDevices","o":"hcl","f":"hp_hcl","d":"Create a vector of colors from vectors specifying hue,\nchroma and luminance.\n","ec":"hcl(h = 0, c = 35, l = 85, alpha, fixup = TRUE)"},{"p":"grDevices","o":"postscriptFonts","f":"hp_postscriptFonts","d":"These functions handle the translation of a R graphics\nfont family name to a PostScript or PDF font description, used by the\npostscript or pdf graphics devices.\n","ec":"postscriptFonts(...)"},{"p":"grDevices","o":"tiff","f":"hp_tiff","d":"Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files.\n","ec":"tiff(filename = \"Rplot%03d.tiff\", width = 480, height = 480, units = \"px\", pointsize = 12, compression = c(\"none\", \"rle\", \"lzw\", \"jpeg\", \"zip\", \"lzw+p\", \"zip+p\", \"lerc\", \"lzma\", \"zstd\", \"webp\"), bg = \"white\", res = NA, ..., type = c(\"cairo\", \"Xlib\", \"quartz\"), antialias)"},{"p":"grDevices","o":"X11","f":"hp_X11","d":"The defaults for all of the arguments of X11 are set by\nX11.options: the <U+2018>Arguments<U+2019> section gives the\n<U+2018>factory-fresh<U+2019> defaults.\n","ec":"X11(display = \"\", width, height, pointsize, gamma, bg, canvas, fonts, family, xpos, ypos, title, type, antialias, symbolfamily)"},{"p":"grDevices","o":"Hershey","f":"hp_Hershey","d":"If the family graphical parameter (see par)\nhas been set to one of the Hershey fonts (see <U+2018>Details<U+2019>)\nHershey vector fonts are used to render text.\n","ec":""},{"p":"grDevices","o":"palette.colors","f":"hp_palette.colors","d":"View or manipulate the color palette which is used when col=\nhas a numeric index and supporting functions.\n","ec":"palette.colors(n = NULL, palette = \"Okabe-Ito\", alpha, recycle = FALSE, names = FALSE)"},{"p":"grDevices","o":"glyphHeight","f":"hp_glyphHeight","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphHeight(h, label = \"height\", bottom = \"bottom\")"},{"p":"grDevices","o":"is.raster","f":"hp_is.raster","d":"Functions to create a raster object (representing a bitmap\nimage) and coerce other objects to a raster object.\n","ec":"is.raster(x)"},{"p":"grDevices","o":"colorConverter","f":"hp_colorConverter","d":"These functions specify colour spaces for use in\nconvertColor.\n","ec":"colorConverter(toXYZ, fromXYZ, name, white = NULL, vectorized = FALSE)"},{"p":"grDevices","o":"glyphFont","f":"hp_glyphFont","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphFont(file, index, family, weight, style, PSname = NA)"},{"p":"grDevices","o":"dev2bitmap","f":"hp_dev2bitmap","d":"bitmap generates a graphics file.\ndev2bitmap copies the current graphics device to a file in a\ngraphics format.\n","ec":"dev2bitmap(file, type = \"png16m\", height = 7, width = 7, res = 72, units = \"in\", pointsize, ..., method = c(\"postscript\", \"pdf\"), taa = NA, gaa = NA)"},{"p":"grDevices","o":"dev.next","f":"hp_dev.next","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.next(which = dev.cur())"},{"p":"grDevices","o":"dev.interactive","f":"hp_dev.interactive","d":"Test if the current graphics device (or that which would be opened) is\ninteractive.\n","ec":"dev.interactive(orNone = FALSE)"},{"p":"grDevices","o":"grey.colors","f":"hp_grey.colors","d":"Create a vector of n gamma-corrected gray colors.\n","ec":"grey.colors(n, start = 0.3, end = 0.9, gamma = 2.2, alpha, rev = FALSE)"},{"p":"grDevices","o":"dev.copy2pdf","f":"hp_dev.copy2pdf","d":"dev.copy copies the graphics contents of the current device\nto the device specified by which or to a new device which has\nbeen created by the function specified by device (it is an\nerror to specify both which and device).  (If recording\nis off on the current device, there are no contents to copy: this will\nresult in no plot or an empty plot.)\nThe device copied to becomes the current device.\n","ec":"dev.copy2pdf(..., out.type = \"pdf\")"},{"p":"grDevices","o":"terrain.colors","f":"hp_terrain.colors","d":"Create a vector of n contiguous colors.\n","ec":"terrain.colors(n, alpha, rev = FALSE)"},{"p":"grDevices","o":"grSoftVersion","f":"hp_grSoftVersion","d":"Report versions of third-party graphics software available on the\ncurrent platform for R's graphics.\n","ec":"grSoftVersion()"},{"p":"grDevices","o":"quartz.options","f":"hp_quartz.options","d":"quartz starts a graphics device driver for the macOS system.\nIt supports plotting both to the screen (the default) and to various\ngraphics file formats.\n","ec":"quartz.options(..., reset = FALSE)"},{"p":"grDevices","o":".tilingPattern","f":"hp_.tilingPattern","d":"Internal grDevices functions\n","ec":".tilingPattern(fun, x, y, width, height, extend)"},{"p":"grDevices","o":"hcl.colors","f":"hp_hcl.colors","d":"Create a vector of n contiguous colors.\n","ec":"hcl.colors(n, palette = \"viridis\", alpha = NULL, rev = FALSE, fixup = TRUE)"},{"p":"grDevices","o":"glyphAnchor","f":"hp_glyphAnchor","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphAnchor(value, label)"},{"p":"grDevices","o":"nclass.scott","f":"hp_nclass.scott","d":"Compute the number of classes for a histogram, notably hist().\n","ec":"nclass.scott(x)"},{"p":"grDevices","o":"dev.hold","f":"hp_dev.hold","d":"This gives a way to hold/flush output on certain on-screen devices,\nand is ignored by other devices.\n","ec":"dev.hold(level = 1L)"},{"p":"grDevices","o":"glyphWidth","f":"hp_glyphWidth","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphWidth(w, label = \"width\", left = \"left\")"},{"p":"grDevices","o":"devAskNewPage","f":"hp_devAskNewPage","d":"This function can be used to control (for the current device)\nwhether the user is prompted before starting a new page of output.\n","ec":"devAskNewPage(ask = NULL)"},{"p":"grDevices","o":"x11","f":"hp_x11","d":"The defaults for all of the arguments of X11 are set by\nX11.options: the <U+2018>Arguments<U+2019> section gives the\n<U+2018>factory-fresh<U+2019> defaults.\n","ec":"x11(display = \"\", width, height, pointsize, gamma, bg, canvas, fonts, family, xpos, ypos, title, type, antialias, symbolfamily)"},{"p":"grDevices","o":"as.raster","f":"hp_as.raster","d":"Functions to create a raster object (representing a bitmap\nimage) and coerce other objects to a raster object.\n","ec":"as.raster(x, ...)"},{"p":"grDevices","o":".clipPath","f":"hp_.clipPath","d":"Internal grDevices functions\n","ec":".clipPath(fun, rule)"},{"p":"grDevices","o":"rgb2hsv","f":"hp_rgb2hsv","d":"rgb2hsv transforms colors\nfrom RGB space (red/green/blue)\ninto HSV space (hue/saturation/value).\n","ec":"rgb2hsv(r, g = NULL, b = NULL, maxColorValue = 255)"},{"p":"grDevices","o":"setGraphicsEventEnv","f":"hp_setGraphicsEventEnv","d":"This function waits for input from a graphics window in the\nform of a mouse or keyboard event.\n","ec":"setGraphicsEventEnv(which = dev.cur(), env)"},{"p":"grDevices","o":"heat.colors","f":"hp_heat.colors","d":"Create a vector of n contiguous colors.\n","ec":"heat.colors(n, alpha, rev = FALSE)"},{"p":"grDevices","o":"topo.colors","f":"hp_topo.colors","d":"Create a vector of n contiguous colors.\n","ec":"topo.colors(n, alpha, rev = FALSE)"},{"p":"grDevices","o":"blues9","f":"hp_blues9","d":"densCols produces a vector containing colors which encode the\nlocal densities at each point in a scatterplot.\n","ec":""},{"p":"grDevices","o":"recordGraphics","f":"hp_recordGraphics","d":"Records arbitrary code on the graphics engine display list.\nUseful for encapsulating calculations with graphical output\nthat depends on the calculations.\nIntended only for expert use.\n","ec":"recordGraphics(expr, list, env)"},{"p":"grDevices","o":"boxplot.stats","f":"hp_boxplot.stats","d":"This function is typically called by another function to\ngather the statistics necessary for producing box plots,\nbut may be invoked separately.\n","ec":"boxplot.stats(x, coef = 1.5, do.conf = TRUE, do.out = TRUE)"},{"p":"grDevices","o":"svg","f":"hp_svg","d":"Graphics devices for SVG, PDF and PostScript graphics files using\nthe cairo graphics API.\n","ec":"svg(filename = if (onefile) \"Rplots.svg\" else \"Rplot%03d.svg\", width = 7, height = 7, pointsize = 12, onefile = FALSE, family = \"sans\", bg = \"white\", antialias = c(\"default\", \"none\", \"gray\", \"subpixel\"), symbolfamily)"},{"p":"grDevices","o":"dev.list","f":"hp_dev.list","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.list()"},{"p":"grDevices","o":"colours","f":"hp_colours","d":"Returns the built-in color names which R knows about.\n","ec":"colours(distinct = FALSE)"},{"p":"grDevices","o":"convertColor","f":"hp_convertColor","d":"Convert colours between their representations in standard\ncolour spaces.\n","ec":"convertColor(color, from, to, from.ref.white = NULL, to.ref.white = NULL, scale.in = 1, scale.out = 1, clip = TRUE)"},{"p":"grDevices","o":"dev.copy","f":"hp_dev.copy","d":"dev.copy copies the graphics contents of the current device\nto the device specified by which or to a new device which has\nbeen created by the function specified by device (it is an\nerror to specify both which and device).  (If recording\nis off on the current device, there are no contents to copy: this will\nresult in no plot or an empty plot.)\nThe device copied to becomes the current device.\n","ec":"dev.copy(device, ..., which = dev.next())"},{"p":"grDevices","o":"chull","f":"hp_chull","d":"Computes the subset of points which lie on the convex hull of the\nset of points specified.\n","ec":"chull(x, y = NULL)"},{"p":"grDevices","o":"xy.coords","f":"hp_xy.coords","d":"xy.coords is used by many functions to obtain\nx and y coordinates for plotting.  The use of this common mechanism\nacross all relevant R functions produces a measure of consistency.\n","ec":"xy.coords(x, y = NULL, xlab = NULL, ylab = NULL, log = NULL, recycle = FALSE, setLab = TRUE)"},{"p":"grDevices","o":"dev.capture","f":"hp_dev.capture","d":"dev.capture captures the current contents of a graphics device\nas a raster (bitmap) image.\n","ec":"dev.capture(native = FALSE)"},{"p":"grDevices","o":"dev.cur","f":"hp_dev.cur","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.cur()"},{"p":"grDevices","o":"glyphJust","f":"hp_glyphJust","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphJust(just, ...)"},{"p":"grDevices","o":"setEPS","f":"hp_setEPS","d":"The auxiliary function ps.options can be used to set or view\n(if called without arguments) the default values for some of the\narguments to postscript.\n","ec":"setEPS(...)"},{"p":"grDevices","o":"cm","f":"hp_cm","d":"Translates from inches to cm (centimeters).\n","ec":"cm(x)"},{"p":"grDevices","o":"dev.flush","f":"hp_dev.flush","d":"This gives a way to hold/flush output on certain on-screen devices,\nand is ignored by other devices.\n","ec":"dev.flush(level = 1L)"},{"p":"grDevices","o":"glyphHeightBottom","f":"hp_glyphHeightBottom","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphHeightBottom(h, label)"},{"p":"grDevices","o":"dev.size","f":"hp_dev.size","d":"Find the dimensions of the device surface of the current device.\n","ec":"dev.size(units = c(\"in\", \"cm\", \"px\"))"},{"p":"grDevices","o":"setPS","f":"hp_setPS","d":"The auxiliary function ps.options can be used to set or view\n(if called without arguments) the default values for some of the\narguments to postscript.\n","ec":"setPS(...)"},{"p":"grDevices","o":"cm.colors","f":"hp_cm.colors","d":"Create a vector of n contiguous colors.\n","ec":"cm.colors(n, alpha, rev = FALSE)"},{"p":"grDevices","o":"dev.off","f":"hp_dev.off","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.off(which = dev.cur())"},{"p":"grDevices","o":"pdf","f":"hp_pdf","d":"pdf starts the graphics device driver for producing PDF\ngraphics.\n","ec":"pdf(file = if (onefile) \"Rplots.pdf\" else \"Rplot%03d.pdf\", width, height, onefile, family, title, fonts, version, paper, encoding, bg, fg, pointsize, pagecentre, colormodel, useDingbats, useKerning, fillOddEven, compress)"},{"p":"grDevices","o":"gray","f":"hp_gray","d":"Create a vector of colors from a vector of gray levels.\n","ec":"gray(level, alpha)"},{"p":"grDevices","o":"nclass.FD","f":"hp_nclass.FD","d":"Compute the number of classes for a histogram, notably hist().\n","ec":"nclass.FD(x, digits = 5)"},{"p":"grDevices","o":"ps.options","f":"hp_ps.options","d":"The auxiliary function ps.options can be used to set or view\n(if called without arguments) the default values for some of the\narguments to postscript.\n","ec":"ps.options(..., reset = FALSE, override.check = FALSE)"},{"p":"grDevices","o":"as.graphicsAnnot","f":"hp_as.graphicsAnnot","d":"Coerce an R object into a form suitable for graphics annotation.\n","ec":"as.graphicsAnnot(x)"},{"p":"grDevices","o":".setPattern","f":"hp_.setPattern","d":"Internal grDevices functions\n","ec":".setPattern(pattern)"},{"p":"grDevices","o":"X11.options","f":"hp_X11.options","d":"The defaults for all of the arguments of X11 are set by\nX11.options: the <U+2018>Arguments<U+2019> section gives the\n<U+2018>factory-fresh<U+2019> defaults.\n","ec":"X11.options(..., reset = FALSE)"},{"p":"grDevices","o":"palette","f":"hp_palette","d":"View or manipulate the color palette which is used when col=\nhas a numeric index and supporting functions.\n","ec":"palette(value)"},{"p":"grDevices","o":"replayPlot","f":"hp_replayPlot","d":"Functions to save the current plot in an R variable, and to replay it.\n","ec":"replayPlot(x, reloadPkgs = FALSE)"},{"p":"grDevices","o":"pdfFonts","f":"hp_pdfFonts","d":"These functions handle the translation of a R graphics\nfont family name to a PostScript or PDF font description, used by the\npostscript or pdf graphics devices.\n","ec":"pdfFonts(...)"},{"p":"grDevices","o":"cairoSymbolFont","f":"hp_cairoSymbolFont","d":"Specify a symbol font for a Cairo-based graphics device.\nThis function provides the opportunity to specify whether the font\nsupports Private Use Area code points.\n","ec":"cairoSymbolFont(family, usePUA = TRUE)"},{"p":"grDevices","o":"dev.new","f":"hp_dev.new","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.new(..., noRStudioGD = FALSE)"},{"p":"grDevices","o":"pdf.options","f":"hp_pdf.options","d":"The auxiliary function pdf.options can be used to set or view\n(if called without arguments) the default values for some of the\narguments to pdf.\n","ec":"pdf.options(..., reset = FALSE)"},{"p":"grDevices","o":"X11Fonts","f":"hp_X11Fonts","d":"These functions handle the translation of a device-independent R graphics\nfont family name to an X11 font description on Unix-alike platforms.\n","ec":"X11Fonts(...)"},{"p":"grDevices","o":"axisTicks","f":"hp_axisTicks","d":"Compute pretty axis scales and tick mark locations, the same way as\ntraditional R graphics do it.  This is interesting particularly for\nlog scale axes.\n","ec":"axisTicks(usr, log, axp = NULL, nint = 5)"},{"p":"grDevices","o":"make.rgb","f":"hp_make.rgb","d":"These functions specify colour spaces for use in\nconvertColor.\n","ec":"make.rgb(red, green, blue, name = NULL, white = \"D65\", gamma = 2.2)"},{"p":"grDevices","o":".setClipPath","f":"hp_.setClipPath","d":"Internal grDevices functions\n","ec":".setClipPath(path, index)"},{"p":"grDevices","o":"n2mfrow","f":"hp_n2mfrow","d":"Easy setup for plotting multiple figures (in a rectangular layout) on\none page.  This computes a sensible default for\npar(mfrow).\n","ec":"n2mfrow(nr.plots, asp = 1)"},{"p":"grDevices","o":"rgb","f":"hp_rgb","d":"This function creates colors corresponding to the given\nintensities (between 0 and max) of the red, green and blue\nprimaries.  The colour specification refers to the\nstandard sRGB colorspace (IEC standard 61966).\n","ec":"rgb(red, green, blue, alpha, names = NULL, maxColorValue = 1)"},{"p":"grDevices","o":"quartzFont","f":"hp_quartzFont","d":"These functions handle the translation of a device-independent R graphics\nfont family name to a quartz font description.\n","ec":"quartzFont(family)"},{"p":"grDevices","o":"getGraphicsEvent","f":"hp_getGraphicsEvent","d":"This function waits for input from a graphics window in the\nform of a mouse or keyboard event.\n","ec":"getGraphicsEvent(prompt = \"Waiting for input\", onMouseDown = NULL, onMouseMove = NULL, onMouseUp = NULL, onKeybd = NULL, onIdle = NULL, consolePrompt = prompt)"},{"p":"grDevices","o":"xyz.coords","f":"hp_xyz.coords","d":"Utility for obtaining consistent x, y and z coordinates and labels\nfor three dimensional (3D) plots.\n","ec":"xyz.coords(x, y = NULL, z = NULL, xlab = NULL, ylab = NULL, zlab = NULL, log = NULL, recycle = FALSE, setLab = TRUE)"},{"p":"grDevices","o":"xyTable","f":"hp_xyTable","d":"Given (x,y) points, determine their multiplicity <U+2013> checking for\nequality only up to some (crude kind of) noise.  Note that this is\nspecial kind of 2D binning.\n","ec":"xyTable(x, y = NULL, digits)"},{"p":"grDevices","o":"CIDFont","f":"hp_CIDFont","d":"These functions are used to define the translation of a R graphics\nfont family name to Type 1 or CID font descriptions, used by\nthe pdf and postscript graphics devices.\n","ec":"CIDFont(family, cmap, cmapEncoding, pdfresource = \"\")"},{"p":"grDevices","o":"adjustcolor","f":"hp_adjustcolor","d":"Adjust or modify a vector of colors by <U+201C>turning knobs<U+201D> on one or more\ncoordinates in (r,g,b,\\alpha) space, typically by up or down\nscaling them.\n","ec":"adjustcolor(col, alpha.f = 1, red.f = 1, green.f = 1, blue.f = 1, offset = c(0, 0, 0, 0), transform = diag(c(red.f, green.f, blue.f, alpha.f)))"},{"p":"grDevices","o":"col2rgb","f":"hp_col2rgb","d":"R color to RGB (red/green/blue) conversion.\n","ec":"col2rgb(col, alpha = FALSE)"},{"p":"grDevices","o":"dev.prev","f":"hp_dev.prev","d":"These functions provide control over multiple graphics devices.\n","ec":"dev.prev(which = dev.cur())"},{"p":"grDevices","o":"quartzFonts","f":"hp_quartzFonts","d":"These functions handle the translation of a device-independent R graphics\nfont family name to a quartz font description.\n","ec":"quartzFonts(...)"},{"p":"grDevices","o":"png","f":"hp_png","d":"Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files.\n","ec":"png(filename = \"Rplot%03d.png\", width = 480, height = 480, units = \"px\", pointsize = 12, bg = \"white\", res = NA, ..., type = c(\"cairo\", \"cairo-png\", \"Xlib\", \"quartz\"), antialias)"},{"p":"grDevices","o":"colorRampPalette","f":"hp_colorRampPalette","d":"These functions return functions that interpolate a set of given\ncolors to create new color palettes (like topo.colors) and\ncolor ramps, functions that map the interval [0, 1] to colors\n(like grey).\n","ec":"colorRampPalette(colors, ...)"},{"p":"grDevices","o":"palette.pals","f":"hp_palette.pals","d":"View or manipulate the color palette which is used when col=\nhas a numeric index and supporting functions.\n","ec":"palette.pals()"},{"p":"grDevices","o":"glyphInfo","f":"hp_glyphInfo","d":"Create an object that contains information about typeset glyphs.\nThis includes glyph identifiers, glyph locations, font and colour\ninformation, and metric information.\n","ec":"glyphInfo(id, x, y, font, size, fontList, width, height, hAnchor, vAnchor, col = NA)"},{"p":"grDevices","o":".linearGradientPattern","f":"hp_.linearGradientPattern","d":"Internal grDevices functions\n","ec":".linearGradientPattern(colours = c(\"black\", \"white\"), stops = seq(0, 1, length.out = length(colours)), x1 = 0, y1 = 0, x2 = 1, y2 = 1, extend = \"pad\")"},{"p":"grDevices","o":"jpeg","f":"hp_jpeg","d":"Graphics devices for BMP, JPEG, PNG and TIFF format bitmap files.\n","ec":"jpeg(filename = \"Rplot%03d.jpeg\", width = 480, height = 480, units = \"px\", pointsize = 12, quality = 75, bg = \"white\", res = NA, ..., type = c(\"cairo\", \"Xlib\", \"quartz\"), antialias)"},{"p":"grDevices","o":"colorRamp","f":"hp_colorRamp","d":"These functions return functions that interpolate a set of given\ncolors to create new color palettes (like topo.colors) and\ncolor ramps, functions that map the interval [0, 1] to colors\n(like grey).\n","ec":"colorRamp(colors, bias = 1, space = c(\"rgb\", \"Lab\"), interpolate = c(\"linear\", \"spline\"), alpha = FALSE)"},{"p":"grDevices","o":"setGraphicsEventHandlers","f":"hp_setGraphicsEventHandlers","d":"This function waits for input from a graphics window in the\nform of a mouse or keyboard event.\n","ec":"setGraphicsEventHandlers(which = dev.cur(), ...)"},{"p":"grDevices","o":"dev.control","f":"hp_dev.control","d":"dev.copy copies the graphics contents of the current device\nto the device specified by which or to a new device which has\nbeen created by the function specified by device (it is an\nerror to specify both which and device).  (If recording\nis off on the current device, there are no contents to copy: this will\nresult in no plot or an empty plot.)\nThe device copied to becomes the current device.\n","ec":"dev.control(displaylist = c(\"inhibit\", \"enable\"))"},{"p":"grDevices","o":"dev.print","f":"hp_dev.print","d":"dev.copy copies the graphics contents of the current device\nto the device specified by which or to a new device which has\nbeen created by the function specified by device (it is an\nerror to specify both which and device).  (If recording\nis off on the current device, there are no contents to copy: this will\nresult in no plot or an empty plot.)\nThe device copied to becomes the current device.\n","ec":"dev.print(device = postscript, ...)"},{"p":"grDevices","o":"dev.copy2eps","f":"hp_dev.copy2eps","d":"dev.copy copies the graphics contents of the current device\nto the device specified by which or to a new device which has\nbeen created by the function specified by device (it is an\nerror to specify both which and device).  (If recording\nis off on the current device, there are no contents to copy: this will\nresult in no plot or an empty plot.)\nThe device copied to becomes the current device.\n","ec":"dev.copy2eps(...)"},{"p":"grDevices","o":"Type1Font","f":"hp_Type1Font","d":"These functions are used to define the translation of a R graphics\nfont family name to Type 1 or CID font descriptions, used by\nthe pdf and postscript graphics devices.\n","ec":"Type1Font(family, metrics, encoding = \"default\")"},{"p":"grDevices","o":"contourLines","f":"hp_contourLines","d":"Calculate contour lines for a given set of data.\n","ec":"contourLines(x = seq(0, 1, length.out = nrow(z)), y = seq(0, 1, length.out = ncol(z)), z, nlevels = 10, levels = pretty(range(z, na.rm = TRUE), nlevels))"},{"p":"grDevices","o":"postscript","f":"hp_postscript","d":"postscript starts the graphics device driver for producing\nPostScript graphics.\n","ec":"postscript(file = if (onefile) \"Rplots.ps\" else \"Rplot%03d.ps\", onefile, family, title, fonts, encoding, bg, fg, width, height, horizontal, pointsize, paper, pagecentre, print.it, command, colormodel, useKerning, fillOddEven)"},{"p":"grid","o":"pathGrob","f":"hp_pathGrob","d":"These functions create and draw one or more paths.\nThe final point of a path will automatically\nbe connected to the initial point.\n","ec":"pathGrob(x, y, id = NULL, id.lengths = NULL, pathId = NULL, pathId.lengths = NULL, rule = \"winding\", default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"drawDetails","f":"hp_drawDetails","d":"These generic hook functions are called whenever a grid grob is drawn.\nThey provide an opportunity for customising the drawing of a\nnew class derived from grob (or gTree).\n","ec":"drawDetails(x, recording)"},{"p":"grid","o":"grid.multipanel","f":"hp_grid.multipanel","d":"Internal Grid functions\n","ec":"grid.multipanel(x = stats::runif(90), y = stats::runif(90), z = stats::runif(90), nplots = 9, nrow = 5, ncol = 2, newpage = TRUE, vp = NULL)"},{"p":"grid","o":"addGrob","f":"hp_addGrob","d":"Add a grob to a gTree or a descendant of a gTree.\n","ec":"addGrob(gTree, child, gPath = NULL, strict = FALSE, grep = FALSE, global = FALSE, warn = TRUE)"},{"p":"grid","o":"grobDescent","f":"hp_grobDescent","d":"These functions create a unit object describing the width or height of\na grob.  They are generic.\n","ec":"grobDescent(x)"},{"p":"grid","o":"grid.roundrect","f":"hp_grid.roundrect","d":"Draw a single rectangle with rounded corners.","ec":"grid.roundrect(...)"},{"p":"grid","o":"convertNative","f":"hp_convertNative","d":"The functions or variables listed here are no longer part of grid.\n","ec":"convertNative(unit, dimension = \"x\", type = \"location\")"},{"p":"grid","o":"vpPath","f":"hp_vpPath","d":"This function can be used to generate a viewport path for use\nin downViewport or seekViewport.\n","ec":"vpPath(...)"},{"p":"grid","o":"getGrob","f":"hp_getGrob","d":"Retrieve a grob or a descendant of a grob.\n","ec":"getGrob(gTree, gPath, strict = FALSE, grep = FALSE, global = FALSE)"},{"p":"grid","o":"xsplineGrob","f":"hp_xsplineGrob","d":"These functions create and draw an xspline, a curve drawn\nrelative to control points.\n","ec":"xsplineGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0), id = NULL, id.lengths = NULL, default.units = \"npc\", shape = 0, open = TRUE, arrow = NULL, repEnds = TRUE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"rectGrob","f":"hp_rectGrob","d":"These functions create and draw rectangles.\n","ec":"rectGrob(x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = unit(1, \"npc\"), height = unit(1, \"npc\"), just = \"centre\", hjust = NULL, vjust = NULL, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"pointsGrob","f":"hp_pointsGrob","d":"These functions create and draw data symbols.\n","ec":"pointsGrob(x = stats::runif(10), y = stats::runif(10), pch = 1, size = unit(1, \"char\"), default.units = \"native\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.grep","f":"hp_grid.grep","d":"Given a path, find all matching grobs and/or viewports on the display list\nor within a given grob.\n","ec":"grid.grep(path, x = NULL, grobs = TRUE, viewports = FALSE, strict = FALSE, grep = FALSE, global = FALSE, no.match = character(), vpPath = viewports)"},{"p":"grid","o":"applyEdits","f":"hp_applyEdits","d":"The functions gEdit and gEditList create\nobjects representing an edit operation (essentially a list\nof arguments to editGrob).\n","ec":"applyEdits(x, edits)"},{"p":"grid","o":"absolute.size","f":"hp_absolute.size","d":"This function converts a unit object into absolute units.\nAbsolute units are unaffected, but non-absolute units are\nconverted into \"null\" units.\n","ec":"absolute.size(unit)"},{"p":"grid","o":"explode","f":"hp_explode","d":"Explode a viewport path or grob path into its components.\n","ec":"explode(x)"},{"p":"grid","o":"gpar","f":"hp_gpar","d":"gpar() should be used to create a set of graphical\nparameter settings.  It returns an object of class \"gpar\".  This is\nbasically a list of name-value pairs.\n","ec":"gpar(...)"},{"p":"grid","o":"gPath","f":"hp_gPath","d":"This function can be used to generate a grob path for use\nin grid.edit and friends.\n","ec":"gPath(...)"},{"p":"grid","o":"widthDetails","f":"hp_widthDetails","d":"These generic functions are used to determine the size of grid grobs.\n","ec":"widthDetails(x)"},{"p":"grid","o":"current.transform","f":"hp_current.transform","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.transform()"},{"p":"grid","o":"descentDetails","f":"hp_descentDetails","d":"These generic functions are used to determine the size of grid grobs.\n","ec":"descentDetails(x)"},{"p":"grid","o":"grid.stroke","f":"hp_grid.stroke","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"grid.stroke(...)"},{"p":"grid","o":"bezierPoints","f":"hp_bezierPoints","d":"Rather than drawing an xspline (or Bezier curve), this function returns\nthe points that would be used to draw the series of line\nsegments for the xspline.  This may be useful to post-process\nthe xspline curve, for example, to clip the curve.\n","ec":"bezierPoints(x)"},{"p":"grid","o":"getNames","f":"hp_getNames","d":"Returns a character vector containing the names of all\ntop-level grobs on the display list.\n","ec":"getNames()"},{"p":"grid","o":"convertUnit","f":"hp_convertUnit","d":"These functions take a unit object and convert it to an\nequivalent\nunit object in a different coordinate system.\n","ec":"convertUnit(x, unitTo, axisFrom = \"x\", typeFrom = \"location\", axisTo = axisFrom, typeTo = typeFrom, valueOnly = FALSE)"},{"p":"grid","o":"grid.rect","f":"hp_grid.rect","d":"These functions create and draw rectangles.\n","ec":"grid.rect(x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = unit(1, \"npc\"), height = unit(1, \"npc\"), just = \"centre\", hjust = NULL, vjust = NULL, default.units = \"npc\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"grid.show.layout","f":"hp_grid.show.layout","d":"This function uses Grid graphics to draw a diagram of a\nGrid layout.\n","ec":"grid.show.layout(l, newpage = TRUE, vp.ex = 0.8, bg = \"light grey\", cell.border = \"blue\", cell.fill = \"light blue\", cell.label = TRUE, label.col = \"blue\", unit.col = \"red\", vp = NULL, ...)"},{"p":"grid","o":"is.grob","f":"hp_is.grob","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"is.grob(x)"},{"p":"grid","o":"grid.legend","f":"hp_grid.legend","d":"Constructing a legend grob (in progress)\n","ec":"grid.legend(..., draw = TRUE)"},{"p":"grid","o":"grid.place","f":"hp_grid.place","d":"These functions provide a simpler (and faster) alternative\nto the grid.pack() and packGrob\nfunctions.  They can be used to place objects within the existing\nrows and columns of a frame layout.  They do not provide the ability to\nadd new rows and columns nor do they affect the\nheights and widths of the rows and columns.\n","ec":"grid.place(gPath, grob, row = 1, col = 1, redraw = TRUE)"},{"p":"grid","o":"emptyCoords","f":"hp_emptyCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":""},{"p":"grid","o":"radialGradient","f":"hp_radialGradient","d":"Functions to define gradient fills and pattern fills.\n","ec":"radialGradient(colours = c(\"black\", \"white\"), stops = seq(0, 1, length.out = length(colours)), cx1 = unit(0.5, \"npc\"), cy1 = unit(0.5, \"npc\"), r1 = unit(0, \"npc\"), cx2 = unit(0.5, \"npc\"), cy2 = unit(0.5, \"npc\"), r2 = unit(0.5, \"npc\"), default.units = \"npc\", extend = c(\"pad\", \"repeat\", \"reflect\", \"none\"), group = TRUE)"},{"p":"grid","o":"groupShear","f":"hp_groupShear","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"groupShear(sx = 0, sy = 0)"},{"p":"grid","o":"stringDescent","f":"hp_stringDescent","d":"These functions create a unit object describing the width or height of\na string.\n","ec":"stringDescent(string)"},{"p":"grid","o":"removeGrob","f":"hp_removeGrob","d":"Remove a grob from a gTree or a descendant of a gTree.\n","ec":"removeGrob(gTree, gPath, strict = FALSE, grep = FALSE, global = FALSE, warn = TRUE)"},{"p":"grid","o":"grid.yaxis","f":"hp_grid.yaxis","d":"These functions create and draw a y-axis.\n","ec":"grid.yaxis(at = NULL, label = TRUE, main = TRUE, edits = NULL, name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"viewportScale","f":"hp_viewportScale","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"viewportScale(group, device = TRUE)"},{"p":"grid","o":"vpList","f":"hp_vpList","d":"These functions create viewports, which describe rectangular regions\non a graphics device and define a number of coordinate systems within\nthose regions.\n","ec":"vpList(...)"},{"p":"grid","o":"grid.revert","f":"hp_grid.revert","d":"Some grobs only generate their content to draw at\ndrawing time;  this function replaces such grobs with\ntheir at-drawing-time content.\n","ec":"grid.revert(x, ...)"},{"p":"grid","o":"grid.grob","f":"hp_grid.grob","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.grob(list.struct, cl = NULL, draw = TRUE)"},{"p":"grid","o":"arrow","f":"hp_arrow","d":"Produces a description of what arrows to add to a line.\nThe result can be passed to a function that draws a line,\ne.g., grid.lines.\n","ec":"arrow(angle = 30, length = unit(0.25, \"inches\"), ends = \"last\", type = \"open\")"},{"p":"grid","o":"strokeGrob","f":"hp_strokeGrob","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"strokeGrob(x, ...)"},{"p":"grid","o":"useRotate","f":"hp_useRotate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"useRotate(inverse = FALSE, device = TRUE)"},{"p":"grid","o":"fillGrob","f":"hp_fillGrob","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"fillGrob(x, ...)"},{"p":"grid","o":"gList","f":"hp_gList","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"gList(...)"},{"p":"grid","o":"grid.locator","f":"hp_grid.locator","d":"Allows the user to click the mouse once within the current\ngraphics\ndevice and returns the location of the mouse click within the\ncurrent viewport, in the specified coordinate system.\n","ec":"grid.locator(unit = \"native\")"},{"p":"grid","o":"emptyGTreeCoords","f":"hp_emptyGTreeCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"emptyGTreeCoords(name)"},{"p":"grid","o":"grid.pretty","f":"hp_grid.pretty","d":"Produces a pretty set of approximately n breakpoints within the\nrange given.\n","ec":"grid.pretty(range, n = 5L)"},{"p":"grid","o":"applyEdit","f":"hp_applyEdit","d":"The functions gEdit and gEditList create\nobjects representing an edit operation (essentially a list\nof arguments to editGrob).\n","ec":"applyEdit(x, edit)"},{"p":"grid","o":"fillStrokeGrob","f":"hp_fillStrokeGrob","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"fillStrokeGrob(x, ...)"},{"p":"grid","o":"deviceLoc","f":"hp_deviceLoc","d":"These functions take a pair of unit objects and convert\nthem to a pair of device locations (or dimensions) in inches\n(or native device coordinates).\n","ec":"deviceLoc(x, y, valueOnly = FALSE, device = FALSE)"},{"p":"grid","o":"arcCurvature","f":"hp_arcCurvature","d":"These functions create and draw a curve from one location\nto another.\n","ec":"arcCurvature(theta)"},{"p":"grid","o":"viewportTransform","f":"hp_viewportTransform","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"viewportTransform(group, shear = groupShear(), flip = groupFlip(), device = TRUE)"},{"p":"grid","o":"grid.curve","f":"hp_grid.curve","d":"These functions create and draw a curve from one location\nto another.\n","ec":"grid.curve(...)"},{"p":"grid","o":"useGrob","f":"hp_useGrob","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"useGrob(group, transform = viewportTransform, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grobWidth","f":"hp_grobWidth","d":"These functions create a unit object describing the width or height of\na grob.  They are generic.\n","ec":"grobWidth(x)"},{"p":"grid","o":"viewport.transform","f":"hp_viewport.transform","d":"The functions or variables listed here are no longer part of grid.\n","ec":"viewport.transform(vp)"},{"p":"grid","o":"glyphGrob","f":"hp_glyphGrob","d":"These functions create and draw a set of typeset glyphs.\n","ec":"glyphGrob(glyphInfo, x = 0.5, y = 0.5, default.units = \"npc\", hjust = \"centre\", vjust = \"centre\", gp = gpar(), vp = NULL, name = NULL)"},{"p":"grid","o":"grid.layout","f":"hp_grid.layout","d":"This function returns a Grid layout, which describes a subdivision\nof a rectangular region.\n","ec":"grid.layout(nrow = 1, ncol = 1, widths = unit(rep_len(1, ncol), \"null\"), heights = unit(rep_len(1, nrow), \"null\"), default.units = \"null\", respect = FALSE, just = \"centre\")"},{"p":"grid","o":"setChildren","f":"hp_setChildren","d":"Add a grob to a gTree or a descendant of a gTree.\n","ec":"setChildren(x, children)"},{"p":"grid","o":"grid.lines","f":"hp_grid.lines","d":"These functions create and draw a series of lines.\n","ec":"grid.lines(x = unit(c(0, 1), \"npc\"), y = unit(c(0, 1), \"npc\"), default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"grobAscent","f":"hp_grobAscent","d":"These functions create a unit object describing the width or height of\na grob.  They are generic.\n","ec":"grobAscent(x)"},{"p":"grid","o":"unit.pmin","f":"hp_unit.pmin","d":"Returns a unit object whose i-th value is the minimum (or maximum)\nof the i-th values of the arguments.\n","ec":"unit.pmin(...)"},{"p":"grid","o":"grid.ls","f":"hp_grid.ls","d":"Return a listing of the names of grobs or viewports.\n","ec":"grid.ls(x = NULL, grobs = TRUE, viewports = FALSE, fullNames = FALSE, recursive = TRUE, print = TRUE, flatten = TRUE, ...)"},{"p":"grid","o":"viewport.layout","f":"hp_viewport.layout","d":"Internal Grid functions\n","ec":"viewport.layout(vp)"},{"p":"grid","o":"current.viewport","f":"hp_current.viewport","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.viewport()"},{"p":"grid","o":"grid.reorder","f":"hp_grid.reorder","d":"Change the order in which the children of a gTree get drawn.\n","ec":"grid.reorder(gPath, order, back = TRUE, grep = FALSE, redraw = TRUE)"},{"p":"grid","o":"grobHeight","f":"hp_grobHeight","d":"These functions create a unit object describing the width or height of\na grob.  They are generic.\n","ec":"grobHeight(x)"},{"p":"grid","o":"plotViewport","f":"hp_plotViewport","d":"This is a convenience function for producing a viewport with\nthe common S-style plot layout <U+2013> i.e., a central\nplot region surrounded by margins given in terms of a\nnumber of lines of text.\n","ec":"plotViewport(margins = c(5.1, 4.1, 4.1, 2.1), ...)"},{"p":"grid","o":"moveToGrob","f":"hp_moveToGrob","d":"Grid has the notion of a current location.  These functions\nsets that location.\n","ec":"moveToGrob(x = 0, y = 0, default.units = \"npc\", name = NULL, vp = NULL)"},{"p":"grid","o":"preDrawDetails","f":"hp_preDrawDetails","d":"These generic hook functions are called whenever a grid grob is drawn.\nThey provide an opportunity for customising the drawing of a\nnew class derived from grob (or gTree).\n","ec":"preDrawDetails(x)"},{"p":"grid","o":"downViewport","f":"hp_downViewport","d":"Grid maintains a tree of viewports <U+2014> nested drawing\ncontexts.\n","ec":"downViewport(name, strict = FALSE, recording = TRUE)"},{"p":"grid","o":"grid.add","f":"hp_grid.add","d":"Add a grob to a gTree or a descendant of a gTree.\n","ec":"grid.add(gPath, child, strict = FALSE, grep = FALSE, global = FALSE, allDevices = FALSE, redraw = TRUE)"},{"p":"grid","o":"xsplinePoints","f":"hp_xsplinePoints","d":"Rather than drawing an xspline (or Bezier curve), this function returns\nthe points that would be used to draw the series of line\nsegments for the xspline.  This may be useful to post-process\nthe xspline curve, for example, to clip the curve.\n","ec":"xsplinePoints(x)"},{"p":"grid","o":"grid.segments","f":"hp_grid.segments","d":"These functions create and draw line segments.\n","ec":"grid.segments(x0 = unit(0, \"npc\"), y0 = unit(0, \"npc\"), x1 = unit(1, \"npc\"), y1 = unit(1, \"npc\"), default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"unitType","f":"hp_unitType","d":"This function returns the units of a unit object.\n","ec":"unitType(x, recurse = FALSE)"},{"p":"grid","o":"groupScale","f":"hp_groupScale","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"groupScale(sx = 1, sy = 1)"},{"p":"grid","o":"grid.xspline","f":"hp_grid.xspline","d":"These functions create and draw an xspline, a curve drawn\nrelative to control points.\n","ec":"grid.xspline(...)"},{"p":"grid","o":"viewportRotate","f":"hp_viewportRotate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"viewportRotate(group, device = TRUE)"},{"p":"grid","o":"grid.plot.and.legend","f":"hp_grid.plot.and.legend","d":"This function is just a wrapper for a simple demonstration of how\na basic plot and legend can be drawn from scratch using grid.\n","ec":"grid.plot.and.legend()"},{"p":"grid","o":"showGrob","f":"hp_showGrob","d":"Produces a graphical display of (by default) the current grid scene,\nwith labels showing the names of each grob in the scene.\nIt is also possible to label only specific grobs in the scene.\n","ec":"showGrob(x = NULL, gPath = NULL, strict = FALSE, grep = FALSE, recurse = TRUE, depth = NULL, labelfun = grobLabel, ...)"},{"p":"grid","o":"grid.get","f":"hp_grid.get","d":"Retrieve a grob or a descendant of a grob.\n","ec":"grid.get(gPath, strict = FALSE, grep = FALSE, global = FALSE, allDevices = FALSE)"},{"p":"grid","o":"layout.widths","f":"hp_layout.widths","d":"Internal Grid functions\n","ec":"layout.widths(lay)"},{"p":"grid","o":"frameGrob","f":"hp_frameGrob","d":"These functions, together with grid.pack,\ngrid.place, packGrob, and placeGrob are part of a\nGUI-builder-like interface to constructing graphical images.\nThe idea is that you create a frame with this function then\nuse grid.pack or whatever to pack/place objects into the frame.\n","ec":"frameGrob(layout = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.glyph","f":"hp_grid.glyph","d":"These functions create and draw a set of typeset glyphs.\n","ec":"grid.glyph(...)"},{"p":"grid","o":"grid.fillStroke","f":"hp_grid.fillStroke","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"grid.fillStroke(...)"},{"p":"grid","o":"isClosed","f":"hp_isClosed","d":"These functions calculate points along the perimeter (or length) of\na grob.\n","ec":"isClosed(x, ...)"},{"p":"grid","o":"grid.xaxis","f":"hp_grid.xaxis","d":"These functions create and draw an x-axis.\n","ec":"grid.xaxis(at = NULL, label = TRUE, main = TRUE, edits = NULL, name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"resolveRasterSize","f":"hp_resolveRasterSize","d":"Determine the width and height of a raster grob when one or both\nare not given explicitly.\n","ec":"resolveRasterSize(x)"},{"p":"grid","o":"yDetails","f":"hp_yDetails","d":"These generic functions are used to determine a location\non the boundary of a grid grob.\n","ec":"yDetails(x, theta)"},{"p":"grid","o":"grid.text","f":"hp_grid.text","d":"These functions create and draw text and plotmath expressions.\n","ec":"grid.text(label, x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), just = \"centre\", hjust = NULL, vjust = NULL, rot = 0, check.overlap = FALSE, default.units = \"npc\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"vpStack","f":"hp_vpStack","d":"These functions create viewports, which describe rectangular regions\non a graphics device and define a number of coordinate systems within\nthose regions.\n","ec":"vpStack(...)"},{"p":"grid","o":"convertHeight","f":"hp_convertHeight","d":"These functions take a unit object and convert it to an\nequivalent\nunit object in a different coordinate system.\n","ec":"convertHeight(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"defnRotate","f":"hp_defnRotate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"defnRotate(group, inverse = FALSE, device = TRUE)"},{"p":"grid","o":"grid.draw","f":"hp_grid.draw","d":"Produces graphical output from a graphical object.\n","ec":"grid.draw(x, recording = TRUE)"},{"p":"grid","o":"linesGrob","f":"hp_linesGrob","d":"These functions create and draw a series of lines.\n","ec":"linesGrob(x = unit(c(0, 1), \"npc\"), y = unit(c(0, 1), \"npc\"), default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.gedit","f":"hp_grid.gedit","d":"Changes the value of one of the slots of a grob\nand redraws the grob.\n","ec":"grid.gedit(..., grep = TRUE, global = TRUE)"},{"p":"grid","o":"valid.just","f":"hp_valid.just","d":"Utility functions for determining\nwhether a justification specification is valid\nand for resolving a single justification value from\na combination of character and numeric values.\n","ec":"valid.just(just)"},{"p":"grid","o":"postDrawDetails","f":"hp_postDrawDetails","d":"These generic hook functions are called whenever a grid grob is drawn.\nThey provide an opportunity for customising the drawing of a\nnew class derived from grob (or gTree).\n","ec":"postDrawDetails(x)"},{"p":"grid","o":"convertX","f":"hp_convertX","d":"These functions take a unit object and convert it to an\nequivalent\nunit object in a different coordinate system.\n","ec":"convertX(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"grid.record","f":"hp_grid.record","d":"Evaluates an expression that includes both calculations\nand drawing that depends on the calculations so that\nboth the calculations and the drawing will be rerun when\nthe scene is redrawn (e.g., device resize or editing).\n","ec":"grid.record(expr, list, name = NULL, gp = NULL, vp = NULL)"},{"p":"grid","o":"convertY","f":"hp_convertY","d":"These functions take a unit object and convert it to an\nequivalent\nunit object in a different coordinate system.\n","ec":"convertY(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"layoutRegion","f":"hp_layoutRegion","d":"Internal Grid functions\n","ec":"layoutRegion(layout.pos.row = 1, layout.pos.col = 1)"},{"p":"grid","o":"grid.frame","f":"hp_grid.frame","d":"These functions, together with grid.pack,\ngrid.place, packGrob, and placeGrob are part of a\nGUI-builder-like interface to constructing graphical images.\nThe idea is that you create a frame with this function then\nuse grid.pack or whatever to pack/place objects into the frame.\n","ec":"grid.frame(layout = NULL, name = NULL, gp = gpar(), vp = NULL, draw = TRUE)"},{"p":"grid","o":"grobPoints","f":"hp_grobPoints","d":"These functions calculate points along the perimeter (or length) of\na grob.\n","ec":"grobPoints(x, closed, ...)"},{"p":"grid","o":"polylineGrob","f":"hp_polylineGrob","d":"These functions create and draw a series of lines.\n","ec":"polylineGrob(x = unit(c(0, 1), \"npc\"), y = unit(c(0, 1), \"npc\"), id = NULL, id.lengths = NULL, default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"clipGrob","f":"hp_clipGrob","d":"These functions set the clipping region within the current viewport\nwithout altering the current coordinate system.\n","ec":"clipGrob(x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = unit(1, \"npc\"), height = unit(1, \"npc\"), just = \"centre\", hjust = NULL, vjust = NULL, default.units = \"npc\", name = NULL, vp = NULL)"},{"p":"grid","o":"rasterGrob","f":"hp_rasterGrob","d":"Render a raster object (bitmap image) at the given location, size,\nand orientation.\n","ec":"rasterGrob(image, x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = NULL, height = NULL, just = \"centre\", hjust = NULL, vjust = NULL, interpolate = TRUE, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"convertWidth","f":"hp_convertWidth","d":"These functions take a unit object and convert it to an\nequivalent\nunit object in a different coordinate system.\n","ec":"convertWidth(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"xDetails","f":"hp_xDetails","d":"These generic functions are used to determine a location\non the boundary of a grid grob.\n","ec":"xDetails(x, theta)"},{"p":"grid","o":"push.viewport","f":"hp_push.viewport","d":"The functions or variables listed here are no longer part of grid.\n","ec":"push.viewport(..., recording = TRUE)"},{"p":"grid","o":"pathListing","f":"hp_pathListing","d":"Return a listing of the names of grobs or viewports.\n","ec":"pathListing(x, gvpSep = \" | \", gAlign = TRUE)"},{"p":"grid","o":"as.mask","f":"hp_as.mask","d":"Define either an alpha mask or a luminance mask,\nbased on a grob.\n","ec":"as.mask(x, type = c(\"alpha\", \"luminance\"))"},{"p":"grid","o":"segmentsGrob","f":"hp_segmentsGrob","d":"These functions create and draw line segments.\n","ec":"segmentsGrob(x0 = unit(0, \"npc\"), y0 = unit(0, \"npc\"), x1 = unit(1, \"npc\"), y1 = unit(1, \"npc\"), default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"resolveVJust","f":"hp_resolveVJust","d":"Utility functions for determining\nwhether a justification specification is valid\nand for resolving a single justification value from\na combination of character and numeric values.\n","ec":"resolveVJust(just, vjust)"},{"p":"grid","o":"grid.polygon","f":"hp_grid.polygon","d":"These functions create and draw a polygon.\nThe final point will automatically\nbe connected to the initial point.\n","ec":"grid.polygon(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0), id = NULL, id.lengths = NULL, default.units = \"npc\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"get.gpar","f":"hp_get.gpar","d":"gpar() should be used to create a set of graphical\nparameter settings.  It returns an object of class \"gpar\".  This is\nbasically a list of name-value pairs.\n","ec":"get.gpar(names = NULL)"},{"p":"grid","o":"unit.pmax","f":"hp_unit.pmax","d":"Returns a unit object whose i-th value is the minimum (or maximum)\nof the i-th values of the arguments.\n","ec":"unit.pmax(...)"},{"p":"grid","o":"unit.psum","f":"hp_unit.psum","d":"Returns a unit object whose i-th value is the minimum (or maximum)\nof the i-th values of the arguments.\n","ec":"unit.psum(...)"},{"p":"grid","o":"dataViewport","f":"hp_dataViewport","d":"This is a convenience function for producing a viewport with\nx- and/or y-scales based on numeric values passed to the function.\n","ec":"dataViewport(xData = NULL, yData = NULL, xscale = NULL, yscale = NULL, extension = 0.05, ...)"},{"p":"grid","o":"current.vpPath","f":"hp_current.vpPath","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.vpPath()"},{"p":"grid","o":"ascentDetails","f":"hp_ascentDetails","d":"These generic functions are used to determine the size of grid grobs.\n","ec":"ascentDetails(x)"},{"p":"grid","o":"grid.abline","f":"hp_grid.abline","d":"Draw a curve representing a function.\n","ec":"grid.abline(intercept = 0, slope = 1, ...)"},{"p":"grid","o":"childNames","f":"hp_childNames","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"childNames(gTree)"},{"p":"grid","o":"grobPathListing","f":"hp_grobPathListing","d":"Return a listing of the names of grobs or viewports.\n","ec":"grobPathListing(x, ...)"},{"p":"grid","o":"delayGrob","f":"hp_delayGrob","d":"Evaluates an expression that includes both calculations\nand generating a grob that depends on the calculations so that\nboth the calculations and the grob generation will be rerun when\nthe scene is redrawn (e.g., device resize or editing).\n","ec":"delayGrob(expr, list, name = NULL, gp = NULL, vp = NULL)"},{"p":"grid","o":"grid.move.to","f":"hp_grid.move.to","d":"Grid has the notion of a current location.  These functions\nsets that location.\n","ec":"grid.move.to(x = 0, y = 0, default.units = \"npc\", name = NULL, draw = TRUE, vp = NULL)"},{"p":"grid","o":"grid.convertHeight","f":"hp_grid.convertHeight","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.convertHeight(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"pattern","f":"hp_pattern","d":"Functions to define gradient fills and pattern fills.\n","ec":"pattern(grob, x = 0.5, y = 0.5, width = 1, height = 1, default.units = \"npc\", just = \"centre\", hjust = NULL, vjust = NULL, extend = c(\"pad\", \"repeat\", \"reflect\", \"none\"), gp = gpar(fill = \"transparent\"), group = TRUE)"},{"p":"grid","o":"grid.gget","f":"hp_grid.gget","d":"Retrieve a grob or a descendant of a grob.\n","ec":"grid.gget(..., grep = TRUE, global = TRUE)"},{"p":"grid","o":"xaxisGrob","f":"hp_xaxisGrob","d":"These functions create and draw an x-axis.\n","ec":"xaxisGrob(at = NULL, label = TRUE, main = TRUE, edits = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"editDetails","f":"hp_editDetails","d":"This generic hook function is called whenever a grid grob is edited\nvia grid.edit or editGrob.\nThis provides an opportunity for customising the editing of a\nnew class derived from grob (or gTree).\n","ec":"editDetails(x, specs)"},{"p":"grid","o":"grid.define","f":"hp_grid.define","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"grid.define(src, op = \"over\", dst = NULL, coords = TRUE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"viewportTranslate","f":"hp_viewportTranslate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"viewportTranslate(group, device = TRUE)"},{"p":"grid","o":"grobTree","f":"hp_grobTree","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"grobTree(..., name = NULL, gp = NULL, vp = NULL, childrenvp = NULL, cl = NULL)"},{"p":"grid","o":"grid.DLapply","f":"hp_grid.DLapply","d":"Call a function on each element of the current display list.\n","ec":"grid.DLapply(FUN, ...)"},{"p":"grid","o":"grid.grill","f":"hp_grid.grill","d":"This function draws a grill within a Grid viewport.\n","ec":"grid.grill(h = unit(seq(0.25, 0.75, 0.25), \"npc\"), v = unit(seq(0.25, 0.75, 0.25), \"npc\"), default.units = \"npc\", gp = gpar(col = \"grey\"), vp = NULL)"},{"p":"grid","o":"nestedListing","f":"hp_nestedListing","d":"Return a listing of the names of grobs or viewports.\n","ec":"nestedListing(x, gindent = \"  \", vpindent = gindent)"},{"p":"grid","o":"as.path","f":"hp_as.path","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"as.path(x, gp = gpar(), rule = c(\"winding\", \"evenodd\"))"},{"p":"grid","o":"layout.heights","f":"hp_layout.heights","d":"Internal Grid functions\n","ec":"layout.heights(lay)"},{"p":"grid","o":"unit.c","f":"hp_unit.c","d":"This function produces a new unit object by combining the\nunit objects specified as arguments.\n","ec":"unit.c(..., check = TRUE)"},{"p":"grid","o":"grid.use","f":"hp_grid.use","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"grid.use(group, transform = viewportTransform, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.refresh","f":"hp_grid.refresh","d":"Replays the current grid display list.\n","ec":"grid.refresh()"},{"p":"grid","o":"resolveHJust","f":"hp_resolveHJust","d":"Utility functions for determining\nwhether a justification specification is valid\nand for resolving a single justification value from\na combination of character and numeric values.\n","ec":"resolveHJust(just, hjust)"},{"p":"grid","o":"emptyGrobCoords","f":"hp_emptyGrobCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"emptyGrobCoords(name)"},{"p":"grid","o":"grobName","f":"hp_grobName","d":"This function generates a unique (within-session) name for\na grob, based on the grob's class.\n","ec":"grobName(grob = NULL, prefix = \"GRID\")"},{"p":"grid","o":"editGrob","f":"hp_editGrob","d":"Changes the value of one of the slots of a grob\nand redraws the grob.\n","ec":"editGrob(grob, gPath = NULL, ..., strict = FALSE, grep = FALSE, global = FALSE, warn = TRUE)"},{"p":"grid","o":"grid.strip","f":"hp_grid.strip","d":"Internal Grid functions\n","ec":"grid.strip(label = \"whatever\", range.full = c(0, 1), range.thumb = c(0.3, 0.6), fill = \"#FFBF00\", thumb = \"#FF8000\", vp = NULL)"},{"p":"grid","o":"grid.clip","f":"hp_grid.clip","d":"These functions set the clipping region within the current viewport\nwithout altering the current coordinate system.\n","ec":"grid.clip(...)"},{"p":"grid","o":"arrowsGrob","f":"hp_arrowsGrob","d":"The functions or variables listed here are no longer part of grid.\n","ec":"arrowsGrob(x = c(0.25, 0.75), y = 0.5, default.units = \"npc\", grob = NULL, angle = 30, length = unit(0.25, \"inches\"), ends = \"last\", type = \"open\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.raster","f":"hp_grid.raster","d":"Render a raster object (bitmap image) at the given location, size,\nand orientation.\n","ec":"grid.raster(image, x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = NULL, height = NULL, just = \"centre\", hjust = NULL, vjust = NULL, interpolate = TRUE, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"unit.rep","f":"hp_unit.rep","d":"Replicates the units according to the values given in times and\nlength.out.\n","ec":"unit.rep(x, ...)"},{"p":"grid","o":"grid.circle","f":"hp_grid.circle","d":"Functions to create and draw a circle.\n","ec":"grid.circle(x = 0.5, y = 0.5, r = 0.5, default.units = \"npc\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"grid.copy","f":"hp_grid.copy","d":"This function is redundant and will disappear in future versions.\n","ec":"grid.copy(grob)"},{"p":"grid","o":"grid.fill","f":"hp_grid.fill","d":"These functions stroke (draw a line along the border) or\nfill (or both) a path, where the path is defined by\na grob.\n","ec":"grid.fill(...)"},{"p":"grid","o":"stringAscent","f":"hp_stringAscent","d":"These functions create a unit object describing the width or height of\na string.\n","ec":"stringAscent(string)"},{"p":"grid","o":"gridGTreeCoords","f":"hp_gridGTreeCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"gridGTreeCoords(x, name)"},{"p":"grid","o":"grid.points","f":"hp_grid.points","d":"These functions create and draw data symbols.\n","ec":"grid.points(x = stats::runif(10), y = stats::runif(10), pch = 1, size = unit(1, \"char\"), default.units = \"native\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"legendGrob","f":"hp_legendGrob","d":"Constructing a legend grob (in progress)\n","ec":"legendGrob(labels, nrow, ncol, byrow = FALSE, do.lines = has.lty || has.lwd, lines.first = TRUE, hgap = unit(1, \"lines\"), vgap = unit(1, \"lines\"), default.units = \"lines\", pch, gp = gpar(), vp = NULL)"},{"p":"grid","o":"popViewport","f":"hp_popViewport","d":"Grid maintains a tree of viewports <U+2014> nested drawing\ncontexts.\n","ec":"popViewport(n = 1, recording = TRUE)"},{"p":"grid","o":"grid.polyline","f":"hp_grid.polyline","d":"These functions create and draw a series of lines.\n","ec":"grid.polyline(...)"},{"p":"grid","o":"useScale","f":"hp_useScale","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"useScale(inverse = FALSE)"},{"p":"grid","o":"grid.group","f":"hp_grid.group","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"grid.group(src, op = \"over\", dst = NULL, coords = TRUE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"recordGrob","f":"hp_recordGrob","d":"Evaluates an expression that includes both calculations\nand drawing that depends on the calculations so that\nboth the calculations and the drawing will be rerun when\nthe scene is redrawn (e.g., device resize or editing).\n","ec":"recordGrob(expr, list, name = NULL, gp = NULL, vp = NULL)"},{"p":"grid","o":"circleGrob","f":"hp_circleGrob","d":"Functions to create and draw a circle.\n","ec":"circleGrob(x = 0.5, y = 0.5, r = 0.5, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"useTranslate","f":"hp_useTranslate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"useTranslate(inverse = FALSE, device = TRUE)"},{"p":"grid","o":"grid.newpage","f":"hp_grid.newpage","d":"This function erases the current device or moves to a new page.\n","ec":"grid.newpage(recording = TRUE, clearGroups = TRUE)"},{"p":"grid","o":"grid.edit","f":"hp_grid.edit","d":"Changes the value of one of the slots of a grob\nand redraws the grob.\n","ec":"grid.edit(gPath, ..., strict = FALSE, grep = FALSE, global = FALSE, allDevices = FALSE, redraw = TRUE)"},{"p":"grid","o":"forceGrob","f":"hp_forceGrob","d":"Some grobs only generate their content to draw at\ndrawing time;  this function replaces such grobs with\ntheir at-drawing-time content.\n","ec":"forceGrob(x)"},{"p":"grid","o":"grid.convertX","f":"hp_grid.convertX","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.convertX(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"isEmptyCoords","f":"hp_isEmptyCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"isEmptyCoords(coords)"},{"p":"grid","o":"grid.convertY","f":"hp_grid.convertY","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.convertY(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"grid.collection","f":"hp_grid.collection","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.collection(..., gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"polygonGrob","f":"hp_polygonGrob","d":"These functions create and draw a polygon.\nThe final point will automatically\nbe connected to the initial point.\n","ec":"polygonGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0), id = NULL, id.lengths = NULL, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"showViewport","f":"hp_showViewport","d":"Produces a graphical display of (by default) the current\ngrid viewport tree.  It is also possible to display only\nspecific viewports.  Each viewport is drawn as a rectangle\nand the leaf viewports are labelled with the viewport name.\n","ec":"showViewport(vp = NULL, recurse = TRUE, depth = NULL, newpage = FALSE, leaves = FALSE, col = rgb(0, 0, 1, 0.2), fill = rgb(0, 0, 1, 0.1), label = TRUE, nrow = 3, ncol = nrow)"},{"p":"grid","o":"grid.set","f":"hp_grid.set","d":"Replace a grob or a descendant of a grob.\n","ec":"grid.set(gPath, newGrob, strict = FALSE, grep = FALSE, redraw = TRUE)"},{"p":"grid","o":"vpTree","f":"hp_vpTree","d":"These functions create viewports, which describe rectangular regions\non a graphics device and define a number of coordinate systems within\nthose regions.\n","ec":"vpTree(parent, children)"},{"p":"grid","o":"makeContent","f":"hp_makeContent","d":"These generic hook functions are called whenever a grid grob is drawn.\nThey provide an opportunity for customising the drawing context\nand drawing content of a\nnew class derived from grob (or gTree).\n","ec":"makeContent(x)"},{"p":"grid","o":"unit","f":"hp_unit","d":"This function creates a unit object <U+2014> a vector of unit values.\nA unit value is typically just a single numeric value with an\nassociated unit.\n","ec":"unit(x, units, data = NULL)"},{"p":"grid","o":"grid.bezier","f":"hp_grid.bezier","d":"These functions create and draw Bezier Curves (a curve drawn\nrelative to 4 control points).\n","ec":"grid.bezier(...)"},{"p":"grid","o":"grid.display.list","f":"hp_grid.display.list","d":"Turn the Grid display list on or off.\n","ec":"grid.display.list(on = TRUE)"},{"p":"grid","o":"pushViewport","f":"hp_pushViewport","d":"Grid maintains a tree of viewports <U+2014> nested drawing\ncontexts.\n","ec":"pushViewport(..., recording = TRUE)"},{"p":"grid","o":"gTree","f":"hp_gTree","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"gTree(..., name = NULL, gp = NULL, vp = NULL, children = NULL, childrenvp = NULL, cl = NULL)"},{"p":"grid","o":"gridGrobCoords","f":"hp_gridGrobCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"gridGrobCoords(x, name, rule = NULL)"},{"p":"grid","o":"grid.pack","f":"hp_grid.pack","d":"these functions, together with grid.frame and frameGrob\nare part of a\nGUI-builder-like interface to constructing graphical images.\nThe idea is that you create a frame with grid.frame or\nframeGrob then\nuse these functions to pack objects into the frame.\n","ec":"grid.pack(gPath, grob, redraw = TRUE, side = NULL, row = NULL, row.before = NULL, row.after = NULL, col = NULL, col.before = NULL, col.after = NULL, width = NULL, height = NULL, force.width = FALSE, force.height = FALSE, border = NULL, dynamic = FALSE)"},{"p":"grid","o":"groupGrob","f":"hp_groupGrob","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"groupGrob(src, op = \"over\", dst = NULL, coords = TRUE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"viewport","f":"hp_viewport","d":"These functions create viewports, which describe rectangular regions\non a graphics device and define a number of coordinate systems within\nthose regions.\n","ec":"viewport(x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), width = unit(1, \"npc\"), height = unit(1, \"npc\"), default.units = \"npc\", just = \"centre\", gp = gpar(), clip = \"inherit\", mask = \"inherit\", xscale = c(0, 1), yscale = c(0, 1), angle = 0, layout = NULL, layout.pos.row = NULL, layout.pos.col = NULL, name = NULL)"},{"p":"grid","o":"defineGrob","f":"hp_defineGrob","d":"These functions define and draw one or more groups, where\na group is a grob that is drawn in isolation before being\ncombined with the main image.  The concept of groups\nallows for compositing operators, object reuse, and\naffine transformations (see the Details section).\n","ec":"defineGrob(src, op = \"over\", dst = NULL, coords = TRUE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"groupFlip","f":"hp_groupFlip","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"groupFlip(flipX = FALSE, flipY = FALSE)"},{"p":"grid","o":"nullGrob","f":"hp_nullGrob","d":"These functions create a NULL graphical object,\nwhich has zero width, zero height, and draw nothing.\nIt can be used as a place-holder or as an invisible\nreference point for other drawing.\n","ec":"nullGrob(x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), default.units = \"npc\", name = NULL, vp = NULL)"},{"p":"grid","o":"deviceDim","f":"hp_deviceDim","d":"These functions take a pair of unit objects and convert\nthem to a pair of device locations (or dimensions) in inches\n(or native device coordinates).\n","ec":"deviceDim(w, h, valueOnly = FALSE, device = FALSE)"},{"p":"grid","o":"current.rotation","f":"hp_current.rotation","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.rotation()"},{"p":"grid","o":"editViewport","f":"hp_editViewport","d":"This is a convenience function for producing a new viewport\nfrom a copy of an existing viewport (by default the current\nviewport), with specified modifications.\n","ec":"editViewport(vp = current.viewport(), ...)"},{"p":"grid","o":"upViewport","f":"hp_upViewport","d":"Grid maintains a tree of viewports <U+2014> nested drawing\ncontexts.\n","ec":"upViewport(n = 1, recording = TRUE)"},{"p":"grid","o":"grid.grabExpr","f":"hp_grid.grabExpr","d":"Creates a gTree object from the current grid display list\nor from a scene generated by user-specified code.\n","ec":"grid.grabExpr(expr, warn = 2, wrap = wrap.grobs, wrap.grobs = FALSE, width = 7, height = 7, device = offscreen, ...)"},{"p":"grid","o":"grob","f":"hp_grob","d":"Creating grid graphical objects, short (<U+201C>grob<U+201D>s).\n","ec":"grob(..., name = NULL, gp = NULL, vp = NULL, cl = NULL)"},{"p":"grid","o":"curveGrob","f":"hp_curveGrob","d":"These functions create and draw a curve from one location\nto another.\n","ec":"curveGrob(x1, y1, x2, y2, default.units = \"npc\", curvature = 1, angle = 90, ncp = 1, shape = 0.5, square = TRUE, squareShape = 1, inflect = FALSE, arrow = NULL, open = TRUE, debug = FALSE, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"gridCoords","f":"hp_gridCoords","d":"These functions support the development of grobPoints\nmethods for custom grobs.\n","ec":"gridCoords(x, y)"},{"p":"grid","o":"yaxisGrob","f":"hp_yaxisGrob","d":"These functions create and draw a y-axis.\n","ec":"yaxisGrob(at = NULL, label = TRUE, main = TRUE, edits = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"seekViewport","f":"hp_seekViewport","d":"Grid maintains a tree of viewports <U+2014> nested drawing\ncontexts.\n","ec":"seekViewport(name, recording = TRUE)"},{"p":"grid","o":"groupRotate","f":"hp_groupRotate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"groupRotate(r = 0, device = TRUE)"},{"p":"grid","o":"grid.line.to","f":"hp_grid.line.to","d":"Grid has the notion of a current location.  These functions\nsets that location.\n","ec":"grid.line.to(x = 1, y = 1, default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"placeGrob","f":"hp_placeGrob","d":"These functions provide a simpler (and faster) alternative\nto the grid.pack() and packGrob\nfunctions.  They can be used to place objects within the existing\nrows and columns of a frame layout.  They do not provide the ability to\nadd new rows and columns nor do they affect the\nheights and widths of the rows and columns.\n","ec":"placeGrob(frame, grob, row = NULL, col = NULL)"},{"p":"grid","o":"reorderGrob","f":"hp_reorderGrob","d":"Change the order in which the children of a gTree get drawn.\n","ec":"reorderGrob(x, order, back = TRUE)"},{"p":"grid","o":"depth","f":"hp_depth","d":"Determine the number of levels in a viewport stack or tree,\nin a viewport path, or in a grob path.\n","ec":"depth(x, ...)"},{"p":"grid","o":"defnScale","f":"hp_defnScale","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"defnScale(group, inverse = FALSE)"},{"p":"grid","o":"groupTranslate","f":"hp_groupTranslate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"groupTranslate(dx = 0, dy = 0)"},{"p":"grid","o":"heightDetails","f":"hp_heightDetails","d":"These generic functions are used to determine the size of grid grobs.\n","ec":"heightDetails(x)"},{"p":"grid","o":"bezierGrob","f":"hp_bezierGrob","d":"These functions create and draw Bezier Curves (a curve drawn\nrelative to 4 control points).\n","ec":"bezierGrob(x = c(0, 0.5, 1, 0.5), y = c(0.5, 1, 0.5, 0), id = NULL, id.lengths = NULL, default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"is.unit","f":"hp_is.unit","d":"This function creates a unit object <U+2014> a vector of unit values.\nA unit value is typically just a single numeric value with an\nassociated unit.\n","ec":"is.unit(x)"},{"p":"grid","o":"grobX","f":"hp_grobX","d":"These functions create a unit object describing a location somewhere\non the boundary of\na grob.  They are generic.\n","ec":"grobX(x, theta)"},{"p":"grid","o":"stringHeight","f":"hp_stringHeight","d":"These functions create a unit object describing the width or height of\na string.\n","ec":"stringHeight(string)"},{"p":"grid","o":"grid.convert","f":"hp_grid.convert","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.convert(x, unitTo, axisFrom = \"x\", typeFrom = \"location\", axisTo = axisFrom, typeTo = typeFrom, valueOnly = FALSE)"},{"p":"grid","o":"makeContext","f":"hp_makeContext","d":"These generic hook functions are called whenever a grid grob is drawn.\nThey provide an opportunity for customising the drawing context\nand drawing content of a\nnew class derived from grob (or gTree).\n","ec":"makeContext(x)"},{"p":"grid","o":"grobY","f":"hp_grobY","d":"These functions create a unit object describing a location somewhere\non the boundary of\na grob.  They are generic.\n","ec":"grobY(x, theta)"},{"p":"grid","o":"grid.path","f":"hp_grid.path","d":"These functions create and draw one or more paths.\nThe final point of a path will automatically\nbe connected to the initial point.\n","ec":"grid.path(...)"},{"p":"grid","o":"unit.length","f":"hp_unit.length","d":"The length of a unit object is defined as the number of unit\nvalues in the unit object.\n","ec":"unit.length(unit)"},{"p":"grid","o":"linearGradient","f":"hp_linearGradient","d":"Functions to define gradient fills and pattern fills.\n","ec":"linearGradient(colours = c(\"black\", \"white\"), stops = seq(0, 1, length.out = length(colours)), x1 = unit(0, \"npc\"), y1 = unit(0, \"npc\"), x2 = unit(1, \"npc\"), y2 = unit(1, \"npc\"), default.units = \"npc\", extend = c(\"pad\", \"repeat\", \"reflect\", \"none\"), group = TRUE)"},{"p":"grid","o":"grid.null","f":"hp_grid.null","d":"These functions create a NULL graphical object,\nwhich has zero width, zero height, and draw nothing.\nIt can be used as a place-holder or as an invisible\nreference point for other drawing.\n","ec":"grid.null(...)"},{"p":"grid","o":"grid.arrows","f":"hp_grid.arrows","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.arrows(x = c(0.25, 0.75), y = 0.5, default.units = \"npc\", grob = NULL, angle = 30, length = unit(0.25, \"inches\"), ends = \"last\", type = \"open\", name = NULL, gp = gpar(), draw = TRUE, vp = NULL)"},{"p":"grid","o":"defnTranslate","f":"hp_defnTranslate","d":"These functions define the transformation that will be applied\nwhen a grid.define()d group is grid.use()d.\n","ec":"defnTranslate(group, inverse = FALSE, device = TRUE)"},{"p":"grid","o":"grid.delay","f":"hp_grid.delay","d":"Evaluates an expression that includes both calculations\nand generating a grob that depends on the calculations so that\nboth the calculations and the grob generation will be rerun when\nthe scene is redrawn (e.g., device resize or editing).\n","ec":"grid.delay(expr, list, name = NULL, gp = NULL, vp = NULL)"},{"p":"grid","o":"textGrob","f":"hp_textGrob","d":"These functions create and draw text and plotmath expressions.\n","ec":"textGrob(label, x = unit(0.5, \"npc\"), y = unit(0.5, \"npc\"), just = \"centre\", hjust = NULL, vjust = NULL, rot = 0, check.overlap = FALSE, default.units = \"npc\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"roundrectGrob","f":"hp_roundrectGrob","d":"Draw a single rectangle with rounded corners.","ec":"roundrectGrob(x = 0.5, y = 0.5, width = 1, height = 1, default.units = \"npc\", r = unit(0.1, \"snpc\"), just = \"centre\", name = NULL, gp = NULL, vp = NULL)"},{"p":"grid","o":"grid.cap","f":"hp_grid.cap","d":"Capture the current contents of a graphics device as a raster\n(bitmap) image.\n","ec":"grid.cap()"},{"p":"grid","o":"validDetails","f":"hp_validDetails","d":"This generic hook function is called whenever a grid grob is created\nor\nedited\nvia grob, gTree, grid.edit or editGrob.\nThis provides an opportunity for customising the validation of a\nnew class derived from grob (or gTree).\n","ec":"validDetails(x)"},{"p":"grid","o":"grid.gremove","f":"hp_grid.gremove","d":"Remove a grob from a gTree or a descendant of a gTree.\n","ec":"grid.gremove(..., grep = TRUE, global = TRUE)"},{"p":"grid","o":"pop.viewport","f":"hp_pop.viewport","d":"The functions or variables listed here are no longer part of grid.\n","ec":"pop.viewport(n = 1, recording = TRUE)"},{"p":"grid","o":"layout.torture","f":"hp_layout.torture","d":"Internal Grid functions\n","ec":"layout.torture()"},{"p":"grid","o":"packGrob","f":"hp_packGrob","d":"these functions, together with grid.frame and frameGrob\nare part of a\nGUI-builder-like interface to constructing graphical images.\nThe idea is that you create a frame with grid.frame or\nframeGrob then\nuse these functions to pack objects into the frame.\n","ec":"packGrob(frame, grob, side = NULL, row = NULL, row.before = NULL, row.after = NULL, col = NULL, col.before = NULL, col.after = NULL, width = NULL, height = NULL, force.width = FALSE, force.height = FALSE, border = NULL, dynamic = FALSE)"},{"p":"grid","o":"grid.show.viewport","f":"hp_grid.show.viewport","d":"This function uses Grid graphics to draw a diagram of\na Grid viewport.\n","ec":"grid.show.viewport(v, parent.layout = NULL, newpage = TRUE, vp.ex = 0.8, border.fill = \"light grey\", vp.col = \"blue\", vp.fill = \"light blue\", scale.col = \"red\", vp = NULL)"},{"p":"grid","o":"gEdit","f":"hp_gEdit","d":"The functions gEdit and gEditList create\nobjects representing an edit operation (essentially a list\nof arguments to editGrob).\n","ec":"gEdit(...)"},{"p":"grid","o":"current.parent","f":"hp_current.parent","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.parent(n = 1)"},{"p":"grid","o":"grobCoords","f":"hp_grobCoords","d":"These functions calculate points along the perimeter (or length) of\na grob.\n","ec":"grobCoords(x, closed, ...)"},{"p":"grid","o":"engine.display.list","f":"hp_engine.display.list","d":"Turn the Grid display list on or off.\n","ec":"engine.display.list(on = TRUE)"},{"p":"grid","o":"grid.convertWidth","f":"hp_grid.convertWidth","d":"The functions or variables listed here are no longer part of grid.\n","ec":"grid.convertWidth(x, unitTo, valueOnly = FALSE)"},{"p":"grid","o":"grid.function","f":"hp_grid.function","d":"Draw a curve representing a function.\n","ec":"grid.function(...)"},{"p":"grid","o":"gEditList","f":"hp_gEditList","d":"The functions gEdit and gEditList create\nobjects representing an edit operation (essentially a list\nof arguments to editGrob).\n","ec":"gEditList(...)"},{"p":"grid","o":"calcStringMetric","f":"hp_calcStringMetric","d":"This function returns the ascent, descent, and width metric\ninformation for a character or expression vector.\n","ec":"calcStringMetric(text)"},{"p":"grid","o":"grid.remove","f":"hp_grid.remove","d":"Remove a grob from a gTree or a descendant of a gTree.\n","ec":"grid.remove(gPath, warn = TRUE, strict = FALSE, grep = FALSE, global = FALSE, allDevices = FALSE, redraw = TRUE)"},{"p":"grid","o":"grid.grab","f":"hp_grid.grab","d":"Creates a gTree object from the current grid display list\nor from a scene generated by user-specified code.\n","ec":"grid.grab(warn = 2, wrap = wrap.grobs, wrap.grobs = FALSE, ...)"},{"p":"grid","o":"functionGrob","f":"hp_functionGrob","d":"Draw a curve representing a function.\n","ec":"functionGrob(f, n = 101, range = \"x\", units = \"native\", name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"grid.force","f":"hp_grid.force","d":"Some grobs only generate their content to draw at\ndrawing time;  this function replaces such grobs with\ntheir at-drawing-time content.\n","ec":"grid.force(x, ...)"},{"p":"grid","o":"grid.panel","f":"hp_grid.panel","d":"Internal Grid functions\n","ec":"grid.panel(x = stats::runif(10), y = stats::runif(10), zrange = c(0, 1), zbin = stats::runif(2), xscale = extendrange(x), yscale = extendrange(y), axis.left = TRUE, axis.left.label = TRUE, axis.right = FALSE, axis.right.label = TRUE, axis.bottom = TRUE, axis.bottom.label = TRUE, axis.top = FALSE, axis.top.label = TRUE, vp = NULL)"},{"p":"grid","o":"setGrob","f":"hp_setGrob","d":"Replace a grob or a descendant of a grob.\n","ec":"setGrob(gTree, gPath, newGrob, strict = FALSE, grep = FALSE)"},{"p":"grid","o":"stringWidth","f":"hp_stringWidth","d":"These functions create a unit object describing the width or height of\na string.\n","ec":"stringWidth(string)"},{"p":"grid","o":"lineToGrob","f":"hp_lineToGrob","d":"Grid has the notion of a current location.  These functions\nsets that location.\n","ec":"lineToGrob(x = 1, y = 1, default.units = \"npc\", arrow = NULL, name = NULL, gp = gpar(), vp = NULL)"},{"p":"grid","o":"draw.details","f":"hp_draw.details","d":"The functions or variables listed here are no longer part of grid.\n","ec":"draw.details(x, recording)"},{"p":"grid","o":"current.vpTree","f":"hp_current.vpTree","d":"current.viewport()\nreturns the viewport that Grid is going to draw into.\n","ec":"current.vpTree(all = TRUE)"},{"p":"gtable","o":"gtable_trim","f":"hp_gtable_trim","d":"This function detects rows and columns that does not contain any grobs and\nremoves thewm from the gtable. If the rows and/or columns removed had a\nnon-zero height/width the relative layout of the gtable may change.\n","ec":"gtable_trim(x)"},{"p":"gtable","o":"gtable_add_rows","f":"hp_gtable_add_rows","d":"Insert new rows in a gtable and adjust the grob placement accordingly. If\nrows are added in the middle of a grob spanning multiple rows, the grob will\ncontinue to span them all. If a row is added above or below a grob, the grob\nwill not span the new row(s).\n","ec":"gtable_add_rows(x, heights, pos = -1)"},{"p":"gtable","o":"gtable_row","f":"hp_gtable_row","d":"This function puts grobs in a list side-by-side in a single-row gtable from\nleft to right witrh the given widths and height.\n","ec":"gtable_row(name, grobs, height = NULL, widths = NULL, z = NULL, vp = NULL)"},{"p":"gtable","o":"gtable_height","f":"hp_gtable_height","d":"Note that unlike heightDetails.gtable, this can return relative units.\n","ec":"gtable_height(x)"},{"p":"gtable","o":"gtable_add_cols","f":"hp_gtable_add_cols","d":"Insert new columns in a gtable and adjust the grob placement accordingly. If\ncolumns are added in the middle of a grob spanning multiple columns, the grob\nwill continue to span them all. If a column is added to the left or right of\na grob, the grob will not span the new column(s).\n","ec":"gtable_add_cols(x, widths, pos = -1)"},{"p":"gtable","o":"gtable_add_row_space","f":"hp_gtable_add_row_space","d":"Adds width space between the columns or height space between\nthe rows, effictvely pushing the existing cells apart.\n","ec":"gtable_add_row_space(x, height)"},{"p":"gtable","o":"gtable","f":"hp_gtable","d":"A grob table captures all the information needed to layout grobs in a table\nstructure. It supports row and column spanning, offers some tools to\nautomatically figure out the correct dimensions, and makes it easy to\nalign and combine multiple tables.\n","ec":"gtable(widths = list(), heights = list(), respect = FALSE, name = \"layout\", rownames = NULL, colnames = NULL, vp = NULL)"},{"p":"gtable","o":"is.gtable","f":"hp_is.gtable","d":"Is this a gtable?\n","ec":"is.gtable(x)"},{"p":"gtable","o":"gtable_show_layout","f":"hp_gtable_show_layout","d":"This function is a simple wrapper around grid::grid.show.layout() that\nallows you to inspect the layout of the gtable.\n","ec":"gtable_show_layout(x, ...)"},{"p":"gtable","o":"gtable_add_grob","f":"hp_gtable_add_grob","d":"This only adds grobs into the table - it doesn't affect the table layout in\nany way.  In the gtable model, grobs always fill up the complete table\ncell.  If you want custom justification you might need to define the grob\ndimension in absolute units, or put it into another gtable that can then be\nadded to the gtable instead of the grob.\n","ec":"gtable_add_grob(x, grobs, t, l, b = t, r = l, z = Inf, clip = \"on\", name = x$name)"},{"p":"gtable","o":"gtable_col_spacer","f":"hp_gtable_col_spacer","d":"Create a zero-column or zero-row gtable with the given heights or widths\nrespectively.\n","ec":"gtable_col_spacer(heights)"},{"p":"gtable","o":"gtable_matrix","f":"hp_gtable_matrix","d":"This function takes a matrix of grobs and create a gtable matching with the\ngrobs in the same position as they were in the matrix, with the given heights\nand widths.\n","ec":"gtable_matrix(name, grobs, widths = NULL, heights = NULL, z = NULL, respect = FALSE, clip = \"on\", vp = NULL)"},{"p":"gtable","o":"gtable_col","f":"hp_gtable_col","d":"This function stacks a list of grobs into a single column gtable of the given\nwidth and heights.\n","ec":"gtable_col(name, grobs, width = NULL, heights = NULL, z = NULL, vp = NULL)"},{"p":"gtable","o":"gtable_add_padding","f":"hp_gtable_add_padding","d":"This is a convenience function for adding an extra row and an extra column at\neach edge of the table.\n","ec":"gtable_add_padding(x, padding)"},{"p":"gtable","o":"gtable_row_spacer","f":"hp_gtable_row_spacer","d":"Create a zero-column or zero-row gtable with the given heights or widths\nrespectively.\n","ec":"gtable_row_spacer(widths)"},{"p":"gtable","o":"gtable_add_col_space","f":"hp_gtable_add_col_space","d":"Adds width space between the columns or height space between\nthe rows, effictvely pushing the existing cells apart.\n","ec":"gtable_add_col_space(x, width)"},{"p":"gtable","o":"gtable_width","f":"hp_gtable_width","d":"Note that unlike widthDetails.gtable, this can return relative units.\n","ec":"gtable_width(x)"},{"p":"gtable","o":"gtable_filter","f":"hp_gtable_filter","d":"Normally a gtable is considered a matrix when indexing so that indexing is\nworking on the cell layout and not on the grobs it contains. gtable_filter\nallows you to subset the grobs by name and optionally remove rows or columns\nif left empty after the subsetting\n","ec":"gtable_filter(x, pattern, fixed = FALSE, trim = TRUE, invert = FALSE)"},{"p":"haven","o":"print_tagged_na","f":"hp_print_tagged_na","d":"\"Tagged\" missing values work exactly like regular R missing values except\nthat they store one additional byte of information a tag, which is usually\na letter (\"a\" to \"z\"). When by loading a SAS and Stata file, the tagged\nmissing values always use lower case values.\n","ec":"print_tagged_na(x, digits = getOption(\"digits\"))"},{"p":"haven","o":"write_xpt","f":"hp_write_xpt","d":"The SAS transport format is a open format, as is required for submission\nof the data to the FDA.\n","ec":"write_xpt(data, path, version = 8, name = NULL, label = attr(data, \"label\"), adjust_tz = TRUE)"},{"p":"haven","o":"write_sav","f":"hp_write_sav","d":"read_sav() reads both .sav and .zsav files; write_sav() creates\n.zsav files when compress = TRUE. read_por() reads .por files.\nread_spss() uses either read_por() or read_sav() based on the\nfile extension.\n","ec":"write_sav(data, path, compress = c(\"byte\", \"none\", \"zsav\"), adjust_tz = TRUE)"},{"p":"haven","o":"zap_formats","f":"hp_zap_formats","d":"To provide some mild support for round-tripping variables between Stata/SPSS\nand R, haven stores variable formats in an attribute: format.stata,\nformat.spss, or format.sas. If this causes problems for your\ncode, you can get rid of them with zap_formats.\n","ec":"zap_formats(x)"},{"p":"haven","o":"labelled","f":"hp_labelled","d":"A labelled vector is a common data structure in other statistical\nenvironments, allowing you to assign text labels to specific values.\nThis class makes it possible to import such labelled vectors in to R\nwithout loss of fidelity. This class provides few methods, as I\nexpect you'll coerce to a standard R class (e.g. a factor())\nsoon after importing.\n","ec":"labelled(x = double(), labels = NULL, label = NULL)"},{"p":"haven","o":"read_stata","f":"hp_read_stata","d":"Currently haven can read and write logical, integer, numeric, character\nand factors. See labelled() for how labelled variables in\nStata are handled in R.\n","ec":"read_stata(file, encoding = NULL, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"is_tagged_na","f":"hp_is_tagged_na","d":"\"Tagged\" missing values work exactly like regular R missing values except\nthat they store one additional byte of information a tag, which is usually\na letter (\"a\" to \"z\"). When by loading a SAS and Stata file, the tagged\nmissing values always use lower case values.\n","ec":"is_tagged_na(x, tag = NULL)"},{"p":"haven","o":"write_dta","f":"hp_write_dta","d":"Currently haven can read and write logical, integer, numeric, character\nand factors. See labelled() for how labelled variables in\nStata are handled in R.\n","ec":"write_dta(data, path, version = 14, label = attr(data, \"label\"), strl_threshold = 2045, adjust_tz = TRUE)"},{"p":"haven","o":"print_labels","f":"hp_print_labels","d":"This is a convenience function, useful to explore the variables of\na newly imported dataset.\n","ec":"print_labels(x, name = NULL)"},{"p":"haven","o":"read_por","f":"hp_read_por","d":"read_sav() reads both .sav and .zsav files; write_sav() creates\n.zsav files when compress = TRUE. read_por() reads .por files.\nread_spss() uses either read_por() or read_sav() based on the\nfile extension.\n","ec":"read_por(file, user_na = FALSE, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"tagged_na","f":"hp_tagged_na","d":"\"Tagged\" missing values work exactly like regular R missing values except\nthat they store one additional byte of information a tag, which is usually\na letter (\"a\" to \"z\"). When by loading a SAS and Stata file, the tagged\nmissing values always use lower case values.\n","ec":"tagged_na(...)"},{"p":"haven","o":"na_tag","f":"hp_na_tag","d":"\"Tagged\" missing values work exactly like regular R missing values except\nthat they store one additional byte of information a tag, which is usually\na letter (\"a\" to \"z\"). When by loading a SAS and Stata file, the tagged\nmissing values always use lower case values.\n","ec":"na_tag(x)"},{"p":"haven","o":"zap_empty","f":"hp_zap_empty","d":"Convert empty strings into missing values\n","ec":"zap_empty(x)"},{"p":"haven","o":"vec_arith.haven_labelled","f":"hp_vec_arith.haven_labelled","d":"Internal vctrs methods\n","ec":"vec_arith.haven_labelled(op, x, y, ...)"},{"p":"haven","o":"zap_missing","f":"hp_zap_missing","d":"This is useful if you want to convert tagged missing values from SAS or\nStata, or user-defined missings from SPSS, to regular R NA.\n","ec":"zap_missing(x)"},{"p":"haven","o":"zap_labels","f":"hp_zap_labels","d":"Removes value labels, leaving unlabelled vectors as is. Use this if you\nwant to simply drop all labels from a data frame.\n","ec":"zap_labels(x, ...)"},{"p":"haven","o":"format_tagged_na","f":"hp_format_tagged_na","d":"\"Tagged\" missing values work exactly like regular R missing values except\nthat they store one additional byte of information a tag, which is usually\na letter (\"a\" to \"z\"). When by loading a SAS and Stata file, the tagged\nmissing values always use lower case values.\n","ec":"format_tagged_na(x, digits = getOption(\"digits\"))"},{"p":"haven","o":"zap_widths","f":"hp_zap_widths","d":"To provide some mild support for round-tripping variables between SPSS\nand R, haven stores display widths in an attribute: display_width. If this\ncauses problems for your code, you can get rid of them with zap_widths.\n","ec":"zap_widths(x)"},{"p":"haven","o":"zap_label","f":"hp_zap_label","d":"Removes variable label, leaving unlabelled vectors as is.\n","ec":"zap_label(x)"},{"p":"haven","o":"read_spss","f":"hp_read_spss","d":"read_sav() reads both .sav and .zsav files; write_sav() creates\n.zsav files when compress = TRUE. read_por() reads .por files.\nread_spss() uses either read_por() or read_sav() based on the\nfile extension.\n","ec":"read_spss(file, user_na = FALSE, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"read_sas","f":"hp_read_sas","d":"read_sas() supports both sas7bdat files and the accompanying sas7bcat files\nthat SAS uses to record value labels.\n","ec":"read_sas(data_file, catalog_file = NULL, encoding = NULL, catalog_encoding = encoding, col_select = NULL, skip = 0L, n_max = Inf, cols_only = deprecated(), .name_repair = \"unique\")"},{"p":"haven","o":"labelled_spss","f":"hp_labelled_spss","d":"This class is only used when user_na = TRUE in\nread_sav(). It is similar to the labelled() class\nbut it also models SPSS's user-defined missings, which can be up to\nthree distinct values, or for numeric vectors a range.\n","ec":"labelled_spss(x = double(), labels = NULL, na_values = NULL, na_range = NULL, label = NULL)"},{"p":"haven","o":"read_xpt","f":"hp_read_xpt","d":"The SAS transport format is a open format, as is required for submission\nof the data to the FDA.\n","ec":"read_xpt(file, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"read_sav","f":"hp_read_sav","d":"read_sav() reads both .sav and .zsav files; write_sav() creates\n.zsav files when compress = TRUE. read_por() reads .por files.\nread_spss() uses either read_por() or read_sav() based on the\nfile extension.\n","ec":"read_sav(file, encoding = NULL, user_na = FALSE, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"write_sas","f":"hp_write_sas","d":"\n","ec":"write_sas(data, path)"},{"p":"haven","o":"read_dta","f":"hp_read_dta","d":"Currently haven can read and write logical, integer, numeric, character\nand factors. See labelled() for how labelled variables in\nStata are handled in R.\n","ec":"read_dta(file, encoding = NULL, col_select = NULL, skip = 0, n_max = Inf, .name_repair = \"unique\")"},{"p":"haven","o":"is.labelled","f":"hp_is.labelled","d":"A labelled vector is a common data structure in other statistical\nenvironments, allowing you to assign text labels to specific values.\nThis class makes it possible to import such labelled vectors in to R\nwithout loss of fidelity. This class provides few methods, as I\nexpect you'll coerce to a standard R class (e.g. a factor())\nsoon after importing.\n","ec":"is.labelled(x)"},{"p":"hms","o":"hms","f":"hp_hms","d":"The values are stored as a difftime vector with a custom class,\nand always with \"seconds\" as unit for robust coercion to numeric.\nSupports construction from time values, coercion to and from\nvarious data types, and formatting.  Can be used as a regular column in a\ndata frame.\n","ec":"hms(seconds = NULL, minutes = NULL, hours = NULL, days = NULL)"},{"p":"hms","o":"as_hms","f":"hp_as_hms","d":"The values are stored as a difftime vector with a custom class,\nand always with \"seconds\" as unit for robust coercion to numeric.\nSupports construction from time values, coercion to and from\nvarious data types, and formatting.  Can be used as a regular column in a\ndata frame.\n","ec":"as_hms(x, ...)"},{"p":"hms","o":"as.hms","f":"hp_as.hms","d":"is.hms() has been replaced by is_hms().\n","ec":"as.hms(x, ...)"},{"p":"hms","o":"round_hms","f":"hp_round_hms","d":"Convenience functions to round or truncate to a multiple of seconds.\n","ec":"round_hms(x, secs = NULL, digits = NULL)"},{"p":"hms","o":"parse_hms","f":"hp_parse_hms","d":"These functions convert character vectors to objects of the hms class.\nNA values are supported.\n","ec":"parse_hms(x)"},{"p":"hms","o":"vec_cast.hms","f":"hp_vec_cast.hms","d":"Double dispatch methods to support vctrs::vec_cast().\n","ec":"vec_cast.hms(x, to, ...)"},{"p":"hms","o":"is_hms","f":"hp_is_hms","d":"The values are stored as a difftime vector with a custom class,\nand always with \"seconds\" as unit for robust coercion to numeric.\nSupports construction from time values, coercion to and from\nvarious data types, and formatting.  Can be used as a regular column in a\ndata frame.\n","ec":"is_hms(x)"},{"p":"hms","o":"parse_hm","f":"hp_parse_hm","d":"These functions convert character vectors to objects of the hms class.\nNA values are supported.\n","ec":"parse_hm(x)"},{"p":"hms","o":"is.hms","f":"hp_is.hms","d":"is.hms() has been replaced by is_hms().\n","ec":"is.hms(x)"},{"p":"hms","o":"new_hms","f":"hp_new_hms","d":"The values are stored as a difftime vector with a custom class,\nand always with \"seconds\" as unit for robust coercion to numeric.\nSupports construction from time values, coercion to and from\nvarious data types, and formatting.  Can be used as a regular column in a\ndata frame.\n","ec":"new_hms(x = numeric())"},{"p":"hms","o":"vec_ptype2.hms","f":"hp_vec_ptype2.hms","d":"Double dispatch methods to support vctrs::vec_ptype2().\n","ec":"vec_ptype2.hms(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"hms","o":"trunc_hms","f":"hp_trunc_hms","d":"Convenience functions to round or truncate to a multiple of seconds.\n","ec":"trunc_hms(x, secs = NULL, digits = NULL)"},{"p":"insight","o":"get_sigma","f":"hp_get_sigma","d":"Returns sigma, which corresponds the estimated standard\ndeviation of the residuals. This function extends the sigma() base R\ngeneric for models that don't have implemented it. It also computes the\nconfidence interval (CI), which is stored as an attribute.\n","ec":"get_sigma(x, ci = NULL, verbose = TRUE)"},{"p":"insight","o":"format_number","f":"hp_format_number","d":"Convert number to words\n","ec":"format_number(x, textual = TRUE, ...)"},{"p":"insight","o":"get_transformation","f":"hp_get_transformation","d":"This functions checks whether any transformation, such as log- or\nexp-transforming, was applied to the response variable (dependent variable)\nin a regression formula, and returns the related function that was used for\ntransformation.\n","ec":"get_transformation(x, verbose = TRUE)"},{"p":"insight","o":"find_response","f":"hp_find_response","d":"Returns the name(s) of the response variable(s) from a model object.\n","ec":"find_response(x, combine = TRUE, ...)"},{"p":"insight","o":"get_varcov","f":"hp_get_varcov","d":"Returns the variance-covariance, as retrieved by stats::vcov(), but works\nfor more model objects that probably don't provide a vcov()-method.\n","ec":"get_varcov(x, ...)"},{"p":"insight","o":"object_has_names","f":"hp_object_has_names","d":"object_has_names() checks if specified names are present in the given object.\nobject_has_rownames() checks if rownames are present in a dataframe.\n","ec":"object_has_names(x, names)"},{"p":"insight","o":"format_error","f":"hp_format_error","d":"Inserts line breaks into a longer message or warning string.\nLine length is adjusted to maximum length of the console, if the width\ncan be accessed. By default, new lines are indented by two spaces.\n","ec":"format_error(...)"},{"p":"insight","o":"colour_text","f":"hp_colour_text","d":"Convenient function that allows coloured output in the console.\nMainly implemented to reduce package dependencies.\n","ec":"colour_text(text, colour)"},{"p":"insight","o":"get_family","f":"hp_get_family","d":"A robust and resilient alternative to stats::family. To avoid issues\nwith models like gamm4.\n","ec":"get_family(x, ...)"},{"p":"insight","o":"standardize_names","f":"hp_standardize_names","d":"Standardize column names from data frames, in particular objects returned\nfrom parameters::model_parameters(), so column names are consistent and\nthe same for any model object.\n","ec":"standardize_names(data, ...)"},{"p":"insight","o":"format_string","f":"hp_format_string","d":"String Values Formatting\n","ec":"format_string(x, ...)"},{"p":"insight","o":"get_parameters","f":"hp_get_parameters","d":"Returns the coefficients (or posterior samples for Bayesian\nmodels) from a model. See the documentation for your object's class:\n","ec":"get_parameters(x, ...)"},{"p":"insight","o":"ellipsis_info","f":"hp_ellipsis_info","d":"Provides information regarding the models entered in an ellipsis.\nIt detects whether all are models, regressions, nested regressions etc.,\nassigning different classes to the list of objects.\n","ec":"ellipsis_info(objects, ...)"},{"p":"insight","o":"has_intercept","f":"hp_has_intercept","d":"Checks if model has an intercept.\n","ec":"has_intercept(x, verbose = TRUE)"},{"p":"insight","o":"format_message","f":"hp_format_message","d":"Inserts line breaks into a longer message or warning string.\nLine length is adjusted to maximum length of the console, if the width\ncan be accessed. By default, new lines are indented by two spaces.\n","ec":"format_message(string, ..., line_length = 0.9 * getOption(\"width\", 80), indent = \"  \")"},{"p":"insight","o":"link_function","f":"hp_link_function","d":"Returns the link-function from a model object.\n","ec":"link_function(x, ...)"},{"p":"insight","o":"find_parameters","f":"hp_find_parameters","d":"Returns the names of model parameters, like they typically\nappear in the summary() output. For Bayesian models, the parameter\nnames equal the column names of the posterior samples after coercion\nfrom as.data.frame(). See the documentation for your object's class:\n","ec":"find_parameters(x, ...)"},{"p":"insight","o":"format_ci","f":"hp_format_ci","d":"Confidence/Credible Interval (CI) Formatting\n","ec":"format_ci(CI_low, ...)"},{"p":"insight","o":"null_model","f":"hp_null_model","d":"This function computes the null-model (i.e. (y ~ 1)) of\na model. For mixed models, the null-model takes random effects into account.\n","ec":"null_model(model, verbose = TRUE, ...)"},{"p":"insight","o":"clean_names","f":"hp_clean_names","d":"This function \"cleans\" names of model terms (or a character\nvector with such names) by removing patterns like log() or\nas.factor() etc.\n","ec":"clean_names(x, ...)"},{"p":"insight","o":"display","f":"hp_display","d":"display() is a generic function to export data frames\ninto various table formats (like plain text, markdown, ...). print_md()\nusually is a convenient wrapper for display(format = \"markdown\").\nSimilar, print_html() is a shortcut for display(format = \"html\").\nSee the documentation for the specific objects' classes.\n","ec":"display(object, ...)"},{"p":"insight","o":"find_statistic","f":"hp_find_statistic","d":"Returns the statistic for a regression model (t-statistic,\nz-statistic, etc.).\n","ec":"find_statistic(x, ...)"},{"p":"insight","o":"format_p","f":"hp_format_p","d":"Format p-values.\n","ec":"format_p(p, stars = FALSE, stars_only = FALSE, whitespace = TRUE, name = \"p\", missing = \"\", decimal_separator = NULL, digits = 3, ...)"},{"p":"insight","o":"get_variance_residual","f":"hp_get_variance_residual","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_residual(x, verbose = TRUE, ...)"},{"p":"insight","o":"apply_table_theme","f":"hp_apply_table_theme","d":"Data frame and Tables Pretty Formatting\n","ec":"apply_table_theme(out, x, theme = \"default\", sub_header_positions = NULL)"},{"p":"insight","o":"get_deviance","f":"hp_get_deviance","d":"Returns model deviance (see stats::deviance()).\n","ec":"get_deviance(x, ...)"},{"p":"insight","o":"export_table","f":"hp_export_table","d":"Data frame and Tables Pretty Formatting\n","ec":"export_table(x, sep = \" | \", header = \"-\", cross = NULL, empty_line = NULL, digits = 2, protect_integers = TRUE, missing = \"\", width = NULL, format = NULL, title = NULL, caption = title, subtitle = NULL, footer = NULL, align = NULL, by = NULL, group_by = NULL, zap_small = FALSE, table_width = NULL, verbose = TRUE, ...)"},{"p":"insight","o":"get_correlation_slope_intercept","f":"hp_get_correlation_slope_intercept","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_correlation_slope_intercept(x, verbose = TRUE, ...)"},{"p":"insight","o":"format_rope","f":"hp_format_rope","d":"Percentage in ROPE formatting\n","ec":"format_rope(rope_percentage, name = \"in ROPE\", digits = 2)"},{"p":"insight","o":"object_has_rownames","f":"hp_object_has_rownames","d":"object_has_names() checks if specified names are present in the given object.\nobject_has_rownames() checks if rownames are present in a dataframe.\n","ec":"object_has_rownames(x)"},{"p":"insight","o":"get_intercept","f":"hp_get_intercept","d":"Returns the value at the intercept (i.e., the intercept\nparameter), and NA if there isn't one.\n","ec":"get_intercept(x, ...)"},{"p":"insight","o":"get_modelmatrix","f":"hp_get_modelmatrix","d":"Creates a design matrix from the description. Any character variables are coerced to factors.\n","ec":"get_modelmatrix(x, ...)"},{"p":"insight","o":"get_statistic","f":"hp_get_statistic","d":"Returns the statistic (t, z, ...) for model\nestimates. In most cases, this is the related column from\ncoef(summary()).\n","ec":"get_statistic(x, ...)"},{"p":"insight","o":"find_formula","f":"hp_find_formula","d":"Returns the formula(s) for the different parts of a model\n(like fixed or random effects, zero-inflated component, ...).\nformula_ok() checks if a model formula has valid syntax\nregarding writing TRUE instead of T inside poly()\nand that no data names are used (i.e. no data$variable, but rather\nvariable).\n","ec":"find_formula(x, ...)"},{"p":"insight","o":"model_info","f":"hp_model_info","d":"Retrieve information from model objects.\n","ec":"model_info(x, ...)"},{"p":"insight","o":"has_single_value","f":"hp_has_single_value","d":"Collection of small helper functions. trim_ws() is an\nefficient function to trim leading and trailing whitespaces from character\nvectors or strings. n_unique() returns the number of unique values in a\nvector. has_single_value() is equivalent to n_unique() == 1 but is faster.\nsafe_deparse() is comparable to deparse1(), i.e. it can safely\ndeparse very long expressions into a single string. safe_deparse_symbol()\nonly deparses a substituted expressions when possible, which can be much faster\nthan deparse(substitute()) for those cases where substitute() returns no\nvalid object name.\n","ec":"has_single_value(x, na.rm = FALSE)"},{"p":"insight","o":"compact_list","f":"hp_compact_list","d":"Remove empty elements from lists\n","ec":"compact_list(x, remove_na = FALSE)"},{"p":"insight","o":"get_variance_slope","f":"hp_get_variance_slope","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_slope(x, verbose = TRUE, ...)"},{"p":"insight","o":"n_obs","f":"hp_n_obs","d":"This method returns the number of observation that were used\nto fit the model, as numeric value.\n","ec":"n_obs(x, ...)"},{"p":"insight","o":"find_variables","f":"hp_find_variables","d":"Returns a list with the names of all variables, including\nresponse value and random effects.\n","ec":"find_variables(x, effects = \"all\", component = \"all\", flatten = FALSE, verbose = TRUE)"},{"p":"insight","o":"find_terms","f":"hp_find_terms","d":"Returns a list with the names of all terms, including response\nvalue and random effects, \"as is\". This means, on-the-fly tranformations\nor arithmetic expressions like log(), I(), as.factor() etc. are\npreserved.\n","ec":"find_terms(x, ...)"},{"p":"insight","o":"check_if_installed","f":"hp_check_if_installed","d":"Checking if needed package is installed\n","ec":"check_if_installed(package, reason = \"for this function to work\", stop = TRUE, minimum_version = NULL, quietly = FALSE, prompt = interactive(), ...)"},{"p":"insight","o":"supported_models","f":"hp_supported_models","d":"Small helper that checks if a model is a supported\n(regression) model object. supported_models() prints a list\nof currently supported model classes.\n","ec":"supported_models()"},{"p":"insight","o":"print_parameters","f":"hp_print_parameters","d":"This function takes a data frame, typically a data frame with information on\nsummaries of model parameters like bayestestR::describe_posterior(),\nbayestestR::hdi() or parameters::model_parameters(), as input and splits\nthis information into several parts, depending on the model. See details\nbelow.\n","ec":"print_parameters(x, ..., by = c(\"Effects\", \"Component\", \"Group\", \"Response\"), format = \"text\", parameter_column = \"Parameter\", keep_parameter_column = TRUE, remove_empty_column = FALSE, titles = NULL, subtitles = NULL, split_by = NULL)"},{"p":"insight","o":"standardize_column_order","f":"hp_standardize_column_order","d":"Standardizes order of columns for dataframes and other objects from\neasystats and broom ecosystem packages.\n","ec":"standardize_column_order(data, ...)"},{"p":"insight","o":"get_response","f":"hp_get_response","d":"Returns the values the response variable(s) from a model object.\nIf the model is a multivariate response model, a data frame with values\nfrom all response variables is returned.\n","ec":"get_response(x, ...)"},{"p":"insight","o":"find_random","f":"hp_find_random","d":"Return the name of the grouping factors from mixed effects models.\n","ec":"find_random(x, split_nested = FALSE, flatten = FALSE)"},{"p":"insight","o":"is_nullmodel","f":"hp_is_nullmodel","d":"Checks if model is a null-model (intercept-only), i.e. if\nthe conditional part of the model has no predictors.\n","ec":"is_nullmodel(x)"},{"p":"insight","o":"format_alert","f":"hp_format_alert","d":"Inserts line breaks into a longer message or warning string.\nLine length is adjusted to maximum length of the console, if the width\ncan be accessed. By default, new lines are indented by two spaces.\n","ec":"format_alert(string, ..., line_length = 0.9 * getOption(\"width\", 80), indent = \"  \", type = \"message\", call = FALSE, immediate = FALSE)"},{"p":"insight","o":"color_text","f":"hp_color_text","d":"Convenient function that allows coloured output in the console.\nMainly implemented to reduce package dependencies.\n","ec":"color_text(text, color)"},{"p":"insight","o":"get_variance_fixed","f":"hp_get_variance_fixed","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_fixed(x, verbose = TRUE, ...)"},{"p":"insight","o":"print_md","f":"hp_print_md","d":"display() is a generic function to export data frames\ninto various table formats (like plain text, markdown, ...). print_md()\nusually is a convenient wrapper for display(format = \"markdown\").\nSimilar, print_html() is a shortcut for display(format = \"html\").\nSee the documentation for the specific objects' classes.\n","ec":"print_md(x, ...)"},{"p":"insight","o":"find_predictors","f":"hp_find_predictors","d":"Returns the names of the predictor variables for the\ndifferent parts of a model (like fixed or random effects, zero-inflated\ncomponent, ...). Unlike find_parameters(), the names from\nfind_predictors() match the original variable names from the data\nthat was used to fit the model.\n","ec":"find_predictors(x, ...)"},{"p":"insight","o":"is_multivariate","f":"hp_is_multivariate","d":"Small helper that checks if a model is a multivariate response\nmodel, i.e. a model with multiple outcomes.\n","ec":"is_multivariate(x)"},{"p":"insight","o":"format_warning","f":"hp_format_warning","d":"Inserts line breaks into a longer message or warning string.\nLine length is adjusted to maximum length of the console, if the width\ncan be accessed. By default, new lines are indented by two spaces.\n","ec":"format_warning(..., immediate = FALSE)"},{"p":"insight","o":"is_model","f":"hp_is_model","d":"Small helper that checks if a model is a regression model or\na statistical object. is_regression_model() is stricter and only\nreturns TRUE for regression models, but not for, e.g., htest\nobjects.\n","ec":"is_model(x)"},{"p":"insight","o":"format_percent","f":"hp_format_percent","d":"format_value() converts numeric values into formatted string values, where\nformatting can be something like rounding digits, scientific notation etc.\nformat_percent() is a short-cut for format_value(as_percent = TRUE).\n","ec":"format_percent(x, ...)"},{"p":"insight","o":"find_offset","f":"hp_find_offset","d":"Returns a character vector with the name(s) of offset terms.\n","ec":"find_offset(x)"},{"p":"insight","o":"formula_ok","f":"hp_formula_ok","d":"Returns the formula(s) for the different parts of a model\n(like fixed or random effects, zero-inflated component, ...).\nformula_ok() checks if a model formula has valid syntax\nregarding writing TRUE instead of T inside poly()\nand that no data names are used (i.e. no data$variable, but rather\nvariable).\n","ec":"formula_ok(x, verbose = TRUE, ...)"},{"p":"insight","o":"get_call","f":"hp_get_call","d":"Returns the model's function call when available.\n","ec":"get_call(x)"},{"p":"insight","o":"color_theme","f":"hp_color_theme","d":"Convenient function that allows coloured output in the console.\nMainly implemented to reduce package dependencies.\n","ec":"color_theme()"},{"p":"insight","o":"print_color","f":"hp_print_color","d":"Convenient function that allows coloured output in the console.\nMainly implemented to reduce package dependencies.\n","ec":"print_color(text, color)"},{"p":"insight","o":"is_mixed_model","f":"hp_is_mixed_model","d":"Small helper that checks if a model is a mixed effects model,\ni.e. if it the model has random effects.\n","ec":"is_mixed_model(x)"},{"p":"insight","o":"is_empty_object","f":"hp_is_empty_object","d":"Check if object is empty\n","ec":"is_empty_object(x)"},{"p":"insight","o":"n_grouplevels","f":"hp_n_grouplevels","d":"Returns the number of group levels of random effects from mixed models.\n","ec":"n_grouplevels(x, ...)"},{"p":"insight","o":"get_predicted_ci","f":"hp_get_predicted_ci","d":"Confidence intervals around predicted values\n","ec":"get_predicted_ci(x, ...)"},{"p":"insight","o":"find_random_slopes","f":"hp_find_random_slopes","d":"Return the name of the random slopes from mixed effects models.\n","ec":"find_random_slopes(x)"},{"p":"insight","o":"is_regression_model","f":"hp_is_regression_model","d":"Small helper that checks if a model is a regression model or\na statistical object. is_regression_model() is stricter and only\nreturns TRUE for regression models, but not for, e.g., htest\nobjects.\n","ec":"is_regression_model(x)"},{"p":"insight","o":"trim_ws","f":"hp_trim_ws","d":"Collection of small helper functions. trim_ws() is an\nefficient function to trim leading and trailing whitespaces from character\nvectors or strings. n_unique() returns the number of unique values in a\nvector. has_single_value() is equivalent to n_unique() == 1 but is faster.\nsafe_deparse() is comparable to deparse1(), i.e. it can safely\ndeparse very long expressions into a single string. safe_deparse_symbol()\nonly deparses a substituted expressions when possible, which can be much faster\nthan deparse(substitute()) for those cases where substitute() returns no\nvalid object name.\n","ec":"trim_ws(x, ...)"},{"p":"insight","o":"find_weights","f":"hp_find_weights","d":"Returns the name of the variable that describes the weights of a\nmodel.\n","ec":"find_weights(x, ...)"},{"p":"insight","o":"get_weights","f":"hp_get_weights","d":"Returns weighting variable of a model.\n","ec":"get_weights(x, ...)"},{"p":"insight","o":"clean_parameters","f":"hp_clean_parameters","d":"This function \"cleans\" names of model parameters by removing\npatterns like \"r_\" or \"b[]\" (mostly applicable to Stan models)\nand adding columns with information to which group or component parameters\nbelong (i.e. fixed or random, count or zero-inflated...)\n","ec":"clean_parameters(x, ...)"},{"p":"insight","o":"print_colour","f":"hp_print_colour","d":"Convenient function that allows coloured output in the console.\nMainly implemented to reduce package dependencies.\n","ec":"print_colour(text, colour)"},{"p":"insight","o":"print_html","f":"hp_print_html","d":"display() is a generic function to export data frames\ninto various table formats (like plain text, markdown, ...). print_md()\nusually is a convenient wrapper for display(format = \"markdown\").\nSimilar, print_html() is a shortcut for display(format = \"html\").\nSee the documentation for the specific objects' classes.\n","ec":"print_html(x, ...)"},{"p":"insight","o":"loglikelihood","f":"hp_loglikelihood","d":"A robust function to compute the log-likelihood of a model, as well as\nindividual log-likelihoods (for each observation) whenever possible. Can be\nused as a replacement for stats::logLik() out of the box, as the\nreturned object is of the same class (and it gives the same results by\ndefault).\n","ec":"loglikelihood(x, ...)"},{"p":"insight","o":"is_gam_model","f":"hp_is_gam_model","d":"Small helper that checks if a model is a generalized additive\nmodel.\n","ec":"is_gam_model(x)"},{"p":"insight","o":"get_datagrid","f":"hp_get_datagrid","d":"Create a reference matrix, useful for visualisation, with evenly spread and\ncombined values. Usually used to make generate predictions using get_predicted().\nSee this vignette\nfor a tutorial on how to create a visualisation matrix using this function.\n","ec":"get_datagrid(x, ...)"},{"p":"insight","o":"is_converged","f":"hp_is_converged","d":"is_converged() provides an alternative convergence\ntest for merMod-objects.\n","ec":"is_converged(x, tolerance = 0.001, ...)"},{"p":"insight","o":"safe_deparse_symbol","f":"hp_safe_deparse_symbol","d":"Collection of small helper functions. trim_ws() is an\nefficient function to trim leading and trailing whitespaces from character\nvectors or strings. n_unique() returns the number of unique values in a\nvector. has_single_value() is equivalent to n_unique() == 1 but is faster.\nsafe_deparse() is comparable to deparse1(), i.e. it can safely\ndeparse very long expressions into a single string. safe_deparse_symbol()\nonly deparses a substituted expressions when possible, which can be much faster\nthan deparse(substitute()) for those cases where substitute() returns no\nvalid object name.\n","ec":"safe_deparse_symbol(x)"},{"p":"insight","o":"download_model","f":"hp_download_model","d":"Downloads pre-compiled models from the circus-repository.\nThe circus-repository contains a variety of fitted models to help\nthe systematic testing of other packages\n","ec":"download_model(name, url = \"https://raw.github.com/easystats/circus/master/data/\", extension = \".rda\", verbose = TRUE)"},{"p":"insight","o":"get_residuals","f":"hp_get_residuals","d":"Returns the residuals from regression models.\n","ec":"get_residuals(x, ...)"},{"p":"insight","o":"get_auxiliary","f":"hp_get_auxiliary","d":"Returns the requested auxiliary parameters from models, like\ndispersion, sigma, or beta...\n","ec":"get_auxiliary(x, type = \"sigma\", summary = TRUE, centrality = \"mean\", verbose = TRUE, ...)"},{"p":"insight","o":"get_variance","f":"hp_get_variance","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance(x, ...)"},{"p":"insight","o":"get_correlation_slopes","f":"hp_get_correlation_slopes","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_correlation_slopes(x, verbose = TRUE, ...)"},{"p":"insight","o":"text_remove_backticks","f":"hp_text_remove_backticks","d":"This function removes backticks from a string.\n","ec":"text_remove_backticks(x, ...)"},{"p":"insight","o":"get_loglikelihood","f":"hp_get_loglikelihood","d":"A robust function to compute the log-likelihood of a model, as well as\nindividual log-likelihoods (for each observation) whenever possible. Can be\nused as a replacement for stats::logLik() out of the box, as the\nreturned object is of the same class (and it gives the same results by\ndefault).\n","ec":"get_loglikelihood(x, ...)"},{"p":"insight","o":"find_transformation","f":"hp_find_transformation","d":"This functions checks whether any transformation, such as log-\nor exp-transforming, was applied to the response variable (dependent\nvariable) in a regression formula. Currently, following patterns are\ndetected: log, log1p, log2, log10, exp, expm1, sqrt,\n<U+2060>log(x+<number>)<U+2060>, log-log, power (to 2nd power, like I(x^2)), and\ninverse (like 1/y).\n","ec":"find_transformation(x, ...)"},{"p":"insight","o":"is_model_supported","f":"hp_is_model_supported","d":"Small helper that checks if a model is a supported\n(regression) model object. supported_models() prints a list\nof currently supported model classes.\n","ec":"is_model_supported(x)"},{"p":"insight","o":"safe_deparse","f":"hp_safe_deparse","d":"Collection of small helper functions. trim_ws() is an\nefficient function to trim leading and trailing whitespaces from character\nvectors or strings. n_unique() returns the number of unique values in a\nvector. has_single_value() is equivalent to n_unique() == 1 but is faster.\nsafe_deparse() is comparable to deparse1(), i.e. it can safely\ndeparse very long expressions into a single string. safe_deparse_symbol()\nonly deparses a substituted expressions when possible, which can be much faster\nthan deparse(substitute()) for those cases where substitute() returns no\nvalid object name.\n","ec":"safe_deparse(x, ...)"},{"p":"insight","o":"find_interactions","f":"hp_find_interactions","d":"Returns all lowest to highest order interaction terms from a model.\n","ec":"find_interactions(x, component = c(\"all\", \"conditional\", \"zi\", \"zero_inflated\", \"dispersion\", \"instruments\"), flatten = FALSE)"},{"p":"insight","o":"get_df","f":"hp_get_df","d":"Estimate or extract residual or model-based degrees of freedom\nfrom regression models.\n","ec":"get_df(x, ...)"},{"p":"insight","o":"get_variance_distribution","f":"hp_get_variance_distribution","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_distribution(x, verbose = TRUE, ...)"},{"p":"insight","o":"get_variance_random","f":"hp_get_variance_random","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_random(x, verbose = TRUE, tolerance = 1e-08, ...)"},{"p":"insight","o":"get_data","f":"hp_get_data","d":"This functions tries to get the data that was used to fit the\nmodel and returns it as data frame.\n","ec":"get_data(x, ...)"},{"p":"insight","o":"colour_if","f":"hp_colour_if","d":"Convenient function that formats columns in data frames with color codes,\nwhere the color is chosen based on certain conditions. Columns are then\nprinted in color in the console.\n","ec":"colour_if(x, columns, predicate = `>`, value = 0, colour_if = \"green\", colour_else = \"red\", digits = 2)"},{"p":"insight","o":"all_models_equal","f":"hp_all_models_equal","d":"Small helper that checks if all objects are supported\n(regression) model objects and of same class.\n","ec":"all_models_equal(..., verbose = FALSE)"},{"p":"insight","o":"is_nested_models","f":"hp_is_nested_models","d":"Checks whether a list of models are nested models, strictly\nfollowing the order they were passed to the function.\n","ec":"is_nested_models(...)"},{"p":"insight","o":"color_if","f":"hp_color_if","d":"Convenient function that formats columns in data frames with color codes,\nwhere the color is chosen based on certain conditions. Columns are then\nprinted in color in the console.\n","ec":"color_if(x, columns, predicate = `>`, value = 0, color_if = \"green\", color_else = \"red\", digits = 2)"},{"p":"insight","o":"format_table","f":"hp_format_table","d":"This functions takes a data frame with model parameters as input\nand formats certain columns into a more readable layout (like collapsing\nseparate columns for lower and upper confidence interval values). Furthermore,\ncolumn names are formatted as well. Note that format_table()\nconverts all columns into character vectors!\n","ec":"format_table(x, pretty_names = TRUE, stars = FALSE, digits = 2, ci_width = \"auto\", ci_brackets = TRUE, ci_digits = 2, p_digits = 3, rope_digits = 2, ic_digits = 1, zap_small = FALSE, preserve_attributes = FALSE, exact = TRUE, use_symbols = getOption(\"insight_use_symbols\", FALSE), verbose = TRUE, ...)"},{"p":"insight","o":"format_pd","f":"hp_format_pd","d":"Probability of direction (pd) formatting\n","ec":"format_pd(pd, stars = FALSE, stars_only = FALSE, name = \"pd\")"},{"p":"insight","o":"model_name","f":"hp_model_name","d":"Returns the \"name\" (class attribute) of a model, possibly including further information.\n","ec":"model_name(x, ...)"},{"p":"insight","o":"n_parameters","f":"hp_n_parameters","d":"Returns the number of parameters (coefficients) of a model.\n","ec":"n_parameters(x, ...)"},{"p":"insight","o":"format_capitalize","f":"hp_format_capitalize","d":"This function converts the first letter in a string into upper case.\n","ec":"format_capitalize(x, verbose = TRUE)"},{"p":"insight","o":"all_models_same_class","f":"hp_all_models_same_class","d":"Small helper that checks if all objects are supported\n(regression) model objects and of same class.\n","ec":"all_models_same_class(..., verbose = FALSE)"},{"p":"insight","o":"link_inverse","f":"hp_link_inverse","d":"Returns the link-inverse function from a model object.\n","ec":"link_inverse(x, ...)"},{"p":"insight","o":"get_predictors","f":"hp_get_predictors","d":"Returns the data from all predictor variables (fixed effects).\n","ec":"get_predictors(x, verbose = TRUE)"},{"p":"insight","o":"format_value","f":"hp_format_value","d":"format_value() converts numeric values into formatted string values, where\nformatting can be something like rounding digits, scientific notation etc.\nformat_percent() is a short-cut for format_value(as_percent = TRUE).\n","ec":"format_value(x, ...)"},{"p":"insight","o":"find_smooth","f":"hp_find_smooth","d":"Return the names of smooth terms from a model object.\n","ec":"find_smooth(x, flatten = FALSE)"},{"p":"insight","o":"get_predicted","f":"hp_get_predicted","d":"The get_predicted() function is a robust, flexible and user-friendly\nalternative to base R predict() function. Additional features and\nadvantages include availability of uncertainty intervals (CI), bootstrapping,\na more intuitive API and the support of more models than base R's predict()\nfunction. However, although the interface are simplified, it is still very\nimportant to read the documentation of the arguments. This is because making\n\"predictions\" (a lose term for a variety of things) is a non-trivial process,\nwith lots of caveats and complications. Read the 'Details' section for more\ninformation.\n","ec":"get_predicted(x, ...)"},{"p":"insight","o":"get_random","f":"hp_get_random","d":"Returns the data from all random effects terms.\n","ec":"get_random(x)"},{"p":"insight","o":"format_bf","f":"hp_format_bf","d":"Bayes Factor formatting\n","ec":"format_bf(bf, stars = FALSE, stars_only = FALSE, name = \"BF\", protect_ratio = FALSE, na_reference = NA, exact = FALSE)"},{"p":"insight","o":"compact_character","f":"hp_compact_character","d":"Remove empty strings from character\n","ec":"compact_character(x)"},{"p":"insight","o":"get_variance_intercept","f":"hp_get_variance_intercept","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_intercept(x, verbose = TRUE, ...)"},{"p":"insight","o":"find_algorithm","f":"hp_find_algorithm","d":"Returns information on the sampling or estimation algorithm\nas well as optimization functions, or for Bayesian model information on\nchains, iterations and warmup-samples.\n","ec":"find_algorithm(x, ...)"},{"p":"insight","o":"n_unique","f":"hp_n_unique","d":"Collection of small helper functions. trim_ws() is an\nefficient function to trim leading and trailing whitespaces from character\nvectors or strings. n_unique() returns the number of unique values in a\nvector. has_single_value() is equivalent to n_unique() == 1 but is faster.\nsafe_deparse() is comparable to deparse1(), i.e. it can safely\ndeparse very long expressions into a single string. safe_deparse_symbol()\nonly deparses a substituted expressions when possible, which can be much faster\nthan deparse(substitute()) for those cases where substitute() returns no\nvalid object name.\n","ec":"n_unique(x, ...)"},{"p":"insight","o":"get_priors","f":"hp_get_priors","d":"Provides a summary of the prior distributions used\nfor the parameters in a given model.\n","ec":"get_priors(x, ...)"},{"p":"insight","o":"get_variance_dispersion","f":"hp_get_variance_dispersion","d":"This function extracts the different variance components of a mixed model and\nreturns the result as list. Functions like get_variance_residual(x) or\nget_variance_fixed(x) are shortcuts for get_variance(x, component = \"residual\")\netc.\n","ec":"get_variance_dispersion(x, verbose = TRUE, ...)"},{"p":"jsonlite","o":"base64_enc","f":"hp_base64_enc","d":"Simple in-memory base64 encoder and decoder. Used internally for converting\nraw vectors to text. Interchangeable with encoder from base64enc or\nopenssl package.\n","ec":"base64_enc(input)"},{"p":"jsonlite","o":"stream_out","f":"hp_stream_out","d":"The stream_in and stream_out functions implement line-by-line processing\nof JSON data over a connection, such as a socket, url, file or pipe. JSON\nstreaming requires the ndjson format, which slightly differs\nfrom fromJSON() and toJSON(), see details.\n","ec":"stream_out(x, con = stdout(), pagesize = 500, verbose = TRUE, prefix = \"\", ...)"},{"p":"jsonlite","o":"base64url_enc","f":"hp_base64url_enc","d":"Simple in-memory base64 encoder and decoder. Used internally for converting\nraw vectors to text. Interchangeable with encoder from base64enc or\nopenssl package.\n","ec":"base64url_enc(input)"},{"p":"jsonlite","o":"serializeJSON","f":"hp_serializeJSON","d":"The serializeJSON() and unserializeJSON() functions convert between\nR objects to JSON data. Instead of using a class based mapping like\ntoJSON() and fromJSON(), the serialize functions base the encoding\nschema on the storage type, and capture all data and attributes from any object.\nThereby the object can be restored almost perfectly from its JSON representation, but\nthe resulting JSON output is very verbose. Apart from environments, all standard storage\ntypes are supported.\n","ec":"serializeJSON(x, digits = 8, pretty = FALSE)"},{"p":"jsonlite","o":"rbind_pages","f":"hp_rbind_pages","d":"The rbind_pages function is used to combine a list of data frames into a single\ndata frame. This is often needed when working with a JSON API that limits the amount\nof data per request. If we need more data than what fits in a single request, we need to\nperform multiple requests that each retrieve a fragment of data, not unlike pages in a\nbook. In practice this is often implemented using a page parameter in the API. The\nrbind_pages function can be used to combine these pages back into a single dataset.\n","ec":"rbind_pages(pages)"},{"p":"jsonlite","o":"parse_gzjson_b64","f":"hp_parse_gzjson_b64","d":"Wrapper to generate and parse gzipped JSON, in order to save some disk or\nnetwork space. This is mainly effective for larger json objects with many\nrepeated keys, as is common in serialized data frames.\n","ec":"parse_gzjson_b64(b64, ...)"},{"p":"jsonlite","o":"base64_dec","f":"hp_base64_dec","d":"Simple in-memory base64 encoder and decoder. Used internally for converting\nraw vectors to text. Interchangeable with encoder from base64enc or\nopenssl package.\n","ec":"base64_dec(input)"},{"p":"jsonlite","o":"as_gzjson_b64","f":"hp_as_gzjson_b64","d":"Wrapper to generate and parse gzipped JSON, in order to save some disk or\nnetwork space. This is mainly effective for larger json objects with many\nrepeated keys, as is common in serialized data frames.\n","ec":"as_gzjson_b64(x, ...)"},{"p":"jsonlite","o":"stream_in","f":"hp_stream_in","d":"The stream_in and stream_out functions implement line-by-line processing\nof JSON data over a connection, such as a socket, url, file or pipe. JSON\nstreaming requires the ndjson format, which slightly differs\nfrom fromJSON() and toJSON(), see details.\n","ec":"stream_in(con, handler = NULL, pagesize = 500, verbose = TRUE, ...)"},{"p":"jsonlite","o":"fromJSON","f":"hp_fromJSON","d":"These functions are used to convert between JSON data and R objects. The toJSON() and fromJSON()\nfunctions use a class based mapping, which follows conventions outlined in this paper:  https://arxiv.org/abs/1403.2805 (also available as vignette).\n","ec":"fromJSON(txt, simplifyVector = TRUE, simplifyDataFrame = simplifyVector, simplifyMatrix = simplifyVector, flatten = FALSE, ...)"},{"p":"jsonlite","o":"flatten","f":"hp_flatten","d":"In a nested data frame, one or more of the columns consist of another data\nframe. These structures frequently appear when parsing JSON data from the web.\nWe can flatten such data frames into a regular 2 dimensional tabular structure.\n","ec":"flatten(x, recursive = TRUE)"},{"p":"jsonlite","o":"as_gzjson_raw","f":"hp_as_gzjson_raw","d":"Wrapper to generate and parse gzipped JSON, in order to save some disk or\nnetwork space. This is mainly effective for larger json objects with many\nrepeated keys, as is common in serialized data frames.\n","ec":"as_gzjson_raw(x, ...)"},{"p":"jsonlite","o":"minify","f":"hp_minify","d":"Prettify adds indentation to a JSON string; minify removes all indentation/whitespace.\n","ec":"minify(txt)"},{"p":"jsonlite","o":"write_json","f":"hp_write_json","d":"These functions are similar to toJSON() and fromJSON() except they\nexplicitly distinguish between path and literal input, and do not simplify\nby default.\n","ec":"write_json(x, path, ...)"},{"p":"jsonlite","o":"unbox","f":"hp_unbox","d":"This function marks an atomic vector or data frame as a\nsingleton, i.e.\na set with exactly 1 element. Thereby, the value will not turn into an\narray when encoded into JSON. This can only be done for\natomic vectors of length 1, or data frames with exactly 1 row. To automatically\nunbox all vectors of length 1 within an object, use the auto_unbox argument\nin toJSON().\n","ec":"unbox(x)"},{"p":"jsonlite","o":"validate","f":"hp_validate","d":"Test if a string contains valid JSON. Characters vectors will be collapsed into a single string.\n","ec":"validate(txt)"},{"p":"jsonlite","o":"parse_gzjson_raw","f":"hp_parse_gzjson_raw","d":"Wrapper to generate and parse gzipped JSON, in order to save some disk or\nnetwork space. This is mainly effective for larger json objects with many\nrepeated keys, as is common in serialized data frames.\n","ec":"parse_gzjson_raw(buf, ...)"},{"p":"jsonlite","o":"prettify","f":"hp_prettify","d":"Prettify adds indentation to a JSON string; minify removes all indentation/whitespace.\n","ec":"prettify(txt, indent = 4)"},{"p":"jsonlite","o":"base64url_dec","f":"hp_base64url_dec","d":"Simple in-memory base64 encoder and decoder. Used internally for converting\nraw vectors to text. Interchangeable with encoder from base64enc or\nopenssl package.\n","ec":"base64url_dec(input)"},{"p":"jsonlite","o":"read_json","f":"hp_read_json","d":"These functions are similar to toJSON() and fromJSON() except they\nexplicitly distinguish between path and literal input, and do not simplify\nby default.\n","ec":"read_json(path, simplifyVector = FALSE, ...)"},{"p":"jsonlite","o":"toJSON","f":"hp_toJSON","d":"These functions are used to convert between JSON data and R objects. The toJSON() and fromJSON()\nfunctions use a class based mapping, which follows conventions outlined in this paper:  https://arxiv.org/abs/1403.2805 (also available as vignette).\n","ec":"toJSON(x, dataframe = c(\"rows\", \"columns\", \"values\"), matrix = c(\"rowmajor\", \"columnmajor\"), Date = c(\"ISO8601\", \"epoch\"), POSIXt = c(\"string\", \"ISO8601\", \"epoch\", \"mongo\"), factor = c(\"string\", \"integer\"), complex = c(\"string\", \"list\"), raw = c(\"base64\", \"hex\", \"mongo\", \"int\", \"js\"), null = c(\"list\", \"null\"), na = c(\"null\", \"string\"), auto_unbox = FALSE, digits = 4, pretty = FALSE, force = FALSE, ...)"},{"p":"jsonlite","o":"parse_json","f":"hp_parse_json","d":"These functions are similar to toJSON() and fromJSON() except they\nexplicitly distinguish between path and literal input, and do not simplify\nby default.\n","ec":"parse_json(json, simplifyVector = FALSE, ...)"},{"p":"jsonlite","o":"unserializeJSON","f":"hp_unserializeJSON","d":"The serializeJSON() and unserializeJSON() functions convert between\nR objects to JSON data. Instead of using a class based mapping like\ntoJSON() and fromJSON(), the serialize functions base the encoding\nschema on the storage type, and capture all data and attributes from any object.\nThereby the object can be restored almost perfectly from its JSON representation, but\nthe resulting JSON output is very verbose. Apart from environments, all standard storage\ntypes are supported.\n","ec":"unserializeJSON(txt)"},{"p":"labeling","o":"wilkinson","f":"hp_wilkinson","d":"Wilkinson's labeling algorithm\n","ec":"wilkinson(dmin, dmax, m, Q = c(1, 5, 2, 2.5, 3, 4, 1.5, 7, 6, 8, 9), mincoverage = 0.8, mrange = max(floor(m/2), 2):ceiling(6 * m))"},{"p":"labeling","o":"matplotlib","f":"hp_matplotlib","d":"Matplotlib's labeling algorithm\n","ec":"matplotlib(dmin, dmax, m)"},{"p":"labeling","o":"gnuplot","f":"hp_gnuplot","d":"gnuplot's labeling algorithm\n","ec":"gnuplot(dmin, dmax, m)"},{"p":"labeling","o":"sparks","f":"hp_sparks","d":"Sparks' labeling algorithm\n","ec":"sparks(dmin, dmax, m)"},{"p":"labeling","o":"extended","f":"hp_extended","d":"extended is an enhanced version of Wilkinson's\noptimization-based axis labeling approach. It is\ndescribed in detail in our paper. See the references.\n","ec":"extended(dmin, dmax, m, Q = c(1, 5, 2, 2.5, 4, 3), only.loose = FALSE, w = c(0.25, 0.2, 0.5, 0.05))"},{"p":"labeling","o":"rpretty","f":"hp_rpretty","d":"R's pretty algorithm implemented in R\n","ec":"rpretty(dmin, dmax, m = 6, n = floor(m) - 1, min.n = n%/%3, shrink.sml = 0.75, high.u.bias = 1.5, u5.bias = 0.5 + 1.5 * high.u.bias)"},{"p":"labeling","o":"heckbert","f":"hp_heckbert","d":"Heckbert's labeling algorithm\n","ec":"heckbert(dmin, dmax, m)"},{"p":"labeling","o":"nelder","f":"hp_nelder","d":"Nelder's labeling algorithm\n","ec":"nelder(dmin, dmax, m, Q = c(1, 1.2, 1.6, 2, 2.5, 3, 4, 5, 6, 8, 10))"},{"p":"labeling","o":"thayer","f":"hp_thayer","d":"Thayer and Storer's labeling algorithm\n","ec":"thayer(dmin, dmax, m)"},{"p":"labeling","o":"extended.figures","f":"hp_extended.figures","d":"Generates Figures 2 and 3 from our paper.\n","ec":"extended.figures(samples = 100)"},{"p":"lattice","o":"panel.text","f":"hp_panel.text","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.text(...)"},{"p":"lattice","o":"panel.3dscatter","f":"hp_panel.3dscatter","d":"Default panel functions controlling cloud and\nwireframe displays.\n","ec":"panel.3dscatter(x, y, z, rot.mat = diag(4), distance, groups = NULL, type = \"p\", xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, zero.scaled, col, col.point = if (is.null(groups)) plot.symbol$col else superpose.symbol$col, col.line = if (is.null(groups)) plot.line$col else superpose.line$col, lty = if (is.null(groups)) plot.line$lty else superpose.line$lty, lwd = if (is.null(groups)) plot.line$lwd else superpose.line$lwd, cex = if (is.null(groups)) plot.symbol$cex else superpose.symbol$cex, pch = if (is.null(groups)) \"+\" else superpose.symbol$pch, fill = if (is.null(groups)) plot.symbol$fill else superpose.symbol$fill, cross, ..., .scale = FALSE, subscripts = TRUE, identifier = \"3dscatter\")"},{"p":"lattice","o":"ltext","f":"hp_ltext","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"ltext(x, ...)"},{"p":"lattice","o":"lattice.options","f":"hp_lattice.options","d":"Functions to handle settings used by lattice.  Their main purpose is\nto make code maintainance easier, and users normally should not need\nto use these functions.  However, fine control at this level maybe\nuseful in certain cases.\n","ec":"lattice.options(...)"},{"p":"lattice","o":"as.shingle","f":"hp_as.shingle","d":"Functions to handle shingles\n","ec":"as.shingle(x)"},{"p":"lattice","o":"panel.curve","f":"hp_panel.curve","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.curve(expr, from, to, n = 101, curve.type = \"l\", col = add.line$col, lty = add.line$lty, lwd = add.line$lwd, type, ..., identifier = \"curve\")"},{"p":"lattice","o":"panel.lines","f":"hp_panel.lines","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.lines(...)"},{"p":"lattice","o":"panel.fill","f":"hp_panel.fill","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.fill(col = trellis.par.get(\"background\")$col, border = \"transparent\", ..., identifier = \"fill\")"},{"p":"lattice","o":"panel.levelplot.raster","f":"hp_panel.levelplot.raster","d":"These are the default panel functions for levelplot and\ncontourplot.  Also documented is an alternative raster-based\npanel function for use with levelplot.\n","ec":"panel.levelplot.raster(x, y, z, subscripts, at = pretty(z), ..., col.regions = regions$col, alpha.regions = regions$alpha, interpolate = FALSE, identifier = \"levelplot\")"},{"p":"lattice","o":"prepanel.default.cloud","f":"hp_prepanel.default.cloud","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.cloud(perspective = TRUE, distance = if (perspective) 0.2 else 0, xlim, ylim, zlim, screen = list(z = 40, x = -60), R.mat = diag(4), aspect = c(1, 1), panel.aspect = 1, ..., zoom = 0.8)"},{"p":"lattice","o":"current.panel.limits","f":"hp_current.panel.limits","d":"panel.axis is the function used by lattice to draw axes. It is\ntypically not used by users, except those wishing to create advanced\nannotation. Keep in mind issues of clipping when trying to use it as\npart of the panel function. current.panel.limits can be used to\nretrieve a panel's x and y limits.\n","ec":"current.panel.limits(unit = \"native\")"},{"p":"lattice","o":"lplot.xy","f":"hp_lplot.xy","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lplot.xy(xy, type = c(\"p\", \"l\", \"o\", \"b\", \"c\", \"s\", \"S\", \"h\", \"H\"), pch = 1, lty = 1, col = 1, cex = 1, lwd = 1, font = 1, fontfamily = NULL, fontface = NULL, col.line = col, col.symbol = col, alpha = 1, fill = NULL, origin = 0, ..., identifier = NULL, name.type = \"panel\")"},{"p":"lattice","o":"levelplot","f":"hp_levelplot","d":"Draws false color level plots and contour plots.\n","ec":"levelplot(x, data, ...)"},{"p":"lattice","o":"panel.tmd.qqmath","f":"hp_panel.tmd.qqmath","d":"tmd Creates Tukey Mean-Difference Plots from a trellis object\nreturned by xyplot, qq or qqmath.  The prepanel\nand panel functions are used as appropriate.  The formula and\ndata.frame methods for tmd are provided for convenience,\nand simply call tmd on the object created by the corresponding\nxyplot methods.\n","ec":"panel.tmd.qqmath(x, f.value = NULL, distribution = qnorm, qtype = 7, groups = NULL, subscripts, ..., identifier = \"tmd\")"},{"p":"lattice","o":"trellis.device","f":"hp_trellis.device","d":"Initialization of a display device with appropriate graphical\nparameters.\n","ec":"trellis.device(device = getOption(\"device\"), color = !(dev.name == \"postscript\"), theme = lattice.getOption(\"default.theme\"), new = TRUE, retain = FALSE, ...)"},{"p":"lattice","o":"larrows","f":"hp_larrows","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"larrows(...)"},{"p":"lattice","o":"panel.axis","f":"hp_panel.axis","d":"panel.axis is the function used by lattice to draw axes. It is\ntypically not used by users, except those wishing to create advanced\nannotation. Keep in mind issues of clipping when trying to use it as\npart of the panel function. current.panel.limits can be used to\nretrieve a panel's x and y limits.\n","ec":"panel.axis(side = c(\"bottom\", \"left\", \"top\", \"right\"), at = pretty(scale.range), labels = TRUE, draw.labels = TRUE, check.overlap = FALSE, outside = FALSE, ticks = TRUE, half = !outside, which.half = switch(side, bottom = \"lower\", left = \"upper\", top = \"upper\", right = \"lower\"), tck = as.numeric(ticks), rot = if (is.logical(labels)) 0 else c(90, 0), text.col = axis.text$col, text.alpha = axis.text$alpha, text.cex = axis.text$cex, text.font = axis.text$font, text.fontfamily = axis.text$fontfamily, text.fontface = axis.text$fontface, text.lineheight = axis.text$lineheight, line.col = axis.line$col, line.lty = axis.line$lty, line.lwd = axis.line$lwd, line.alpha = axis.line$alpha)"},{"p":"lattice","o":"qqmath","f":"hp_qqmath","d":"Draw quantile-Quantile plots of a sample against a theoretical\ndistribution, possibly conditioned on other variables.\n","ec":"qqmath(x, data, ...)"},{"p":"lattice","o":"panel.link.splom","f":"hp_panel.link.splom","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"panel.link.splom(threshold = 18, verbose = getOption(\"verbose\"), ...)"},{"p":"lattice","o":"lpoints","f":"hp_lpoints","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lpoints(x, ...)"},{"p":"lattice","o":"prepanel.tmd.qqmath","f":"hp_prepanel.tmd.qqmath","d":"tmd Creates Tukey Mean-Difference Plots from a trellis object\nreturned by xyplot, qq or qqmath.  The prepanel\nand panel functions are used as appropriate.  The formula and\ndata.frame methods for tmd are provided for convenience,\nand simply call tmd on the object created by the corresponding\nxyplot methods.\n","ec":"prepanel.tmd.qqmath(x, f.value = NULL, distribution = qnorm, qtype = 7, groups = NULL, subscripts, ...)"},{"p":"lattice","o":"which.packet","f":"hp_which.packet","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"which.packet(prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"prepanel.default.qqmath","f":"hp_prepanel.default.qqmath","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.qqmath(x, f.value = NULL, distribution = qnorm, qtype = 7, groups = NULL, subscripts, ..., tails.n = 0)"},{"p":"lattice","o":"prepanel.default.bwplot","f":"hp_prepanel.default.bwplot","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.bwplot(x, y, horizontal = TRUE, nlevels, origin = NULL, stack = FALSE, ...)"},{"p":"lattice","o":"strip.default","f":"hp_strip.default","d":"strip.default is the function that draws the strips by default\nin Trellis plots.  Users can write their own strip functions, but most\ncommonly this involves calling strip.default with a slightly\ndifferent arguments.  strip.custom provides a convenient way to\nobtain new strip functions that differ from strip.default only\nin the default values of certain arguments.\n","ec":"strip.default(which.given, which.panel, var.name, factor.levels, shingle.intervals = NULL, strip.names = c(FALSE, TRUE), strip.levels = c(TRUE, FALSE), sep = \" : \", style = 1, horizontal = TRUE, bg = trellis.par.get(\"strip.background\")$col[which.given], fg = trellis.par.get(\"strip.shingle\")$col[which.given], par.strip.text = trellis.par.get(\"add.text\"))"},{"p":"lattice","o":"xyplot.ts","f":"hp_xyplot.ts","d":"This function handles time series plotting, including cut-and-stack plots.\nExamples are given of superposing, juxtaposing and styling\ndifferent time series.\n","ec":"xyplot.ts(x, data = NULL, screens = if (superpose) 1 else colnames(x), ..., superpose = FALSE, cut = FALSE, type = \"l\", col = NULL, lty = NULL, lwd = NULL, pch = NULL, cex = NULL, fill = NULL, auto.key = superpose, panel = if (superpose) \"panel.superpose\" else \"panel.superpose.plain\", par.settings = list(), layout = NULL, as.table = TRUE, xlab = \"Time\", ylab = NULL, default.scales = list(y = list(relation = if (missing(cut)) \"free\" else \"same\")))"},{"p":"lattice","o":"trellis.currentLayout","f":"hp_trellis.currentLayout","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"trellis.currentLayout(which = c(\"packet\", \"panel\"), prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.grid","f":"hp_panel.grid","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.grid(h = 3, v = 3, col, col.line = reference.line$col, lty = reference.line$lty, lwd = reference.line$lwd, x = NULL, y = NULL, ..., identifier = \"grid\")"},{"p":"lattice","o":"panel.densityplot","f":"hp_panel.densityplot","d":"This is the default panel function for densityplot.\n","ec":"panel.densityplot(x, darg = list(n = 512), plot.points = \"jitter\", ref = FALSE, groups = NULL, weights = NULL, jitter.amount = 0.01 * diff(current.panel.limits()$ylim), type = \"p\", ..., grid = lattice.getOption(\"default.args\")$grid, identifier = \"density\")"},{"p":"lattice","o":"panel.violin","f":"hp_panel.violin","d":"This is a panel function that can create a violin plot.  It is\ntypically used in a high-level call to bwplot.\n","ec":"panel.violin(x, y, box.ratio = 1, box.width = box.ratio/(1 + box.ratio), horizontal = TRUE, alpha = plot.polygon$alpha, border = plot.polygon$border, lty = plot.polygon$lty, lwd = plot.polygon$lwd, col = plot.polygon$col, varwidth = FALSE, bw = NULL, adjust = NULL, kernel = NULL, window = NULL, width = NULL, n = 50, from = NULL, to = NULL, cut = NULL, na.rm = TRUE, ..., identifier = \"violin\")"},{"p":"lattice","o":"packet.panel.default","f":"hp_packet.panel.default","d":"When a \"trellis\" object is plotted, panels are always drawn in\nan order such that columns vary the fastest, then rows and then pages.\nAn optional function can be specified that determines, given the\ncolumn, row and page and other relevant information, the packet (if\nany) which should be used in that panel.  The function documented here\nimplements the default behaviour, which is to match panel order with\npacket order, determined by varying the first conditioning variable\nthe fastest, then the second, and so on.  This matching is performed\nafter any reordering and/or permutation of the conditioning variables.\n","ec":"packet.panel.default(layout, condlevels, page, row, column, skip, all.pages.skip = TRUE)"},{"p":"lattice","o":"banking","f":"hp_banking","d":"Calculates banking slope\n","ec":"banking(dx, dy = 1)"},{"p":"lattice","o":"lsegments","f":"hp_lsegments","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lsegments(...)"},{"p":"lattice","o":"axis.default","f":"hp_axis.default","d":"Lattice funtions provide control over how the plot axes are annotated\nthrough a common interface.  There are two levels of control.  The\nxscale.components and yscale.components arguments can be\nfunctions that determine tick mark locations and labels given a\npacket.  For more direct control, the axis argument can be a\nfunction that actually draws the axes.  The functions documented here\nare the defaults for these arguments.  They can additonally be used as\ncomponents of user written replacements.\n","ec":"axis.default(side = c(\"top\", \"bottom\", \"left\", \"right\"), scales, components, as.table, labels = c(\"default\", \"yes\", \"no\"), ticks = c(\"default\", \"yes\", \"no\"), ..., prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"parallelplot","f":"hp_parallelplot","d":"Draw Conditional Scatter Plot Matrices and Parallel Coordinate Plots\n","ec":"parallelplot(x, data, ...)"},{"p":"lattice","o":"panel.stripplot","f":"hp_panel.stripplot","d":"This is the default panel function for stripplot. Also see\npanel.superpose\n","ec":"panel.stripplot(x, y, jitter.data = FALSE, factor = 0.5, amount = NULL, horizontal = TRUE, groups = NULL, ..., grid = lattice.getOption(\"default.args\")$grid, identifier = \"stripplot\")"},{"p":"lattice","o":"trellis.unfocus","f":"hp_trellis.unfocus","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.unfocus()"},{"p":"lattice","o":"contourplot","f":"hp_contourplot","d":"Draws false color level plots and contour plots.\n","ec":"contourplot(x, data, ...)"},{"p":"lattice","o":"panel.superpose.plain","f":"hp_panel.superpose.plain","d":"These are panel functions for Trellis displays useful when a grouping\nvariable is specified for use within panels. The x (and\ny where appropriate) variables are plotted with different\ngraphical parameters for each distinct value of the grouping variable.\n","ec":"panel.superpose.plain(..., col = NA, col.line = plot.line$col, col.symbol = plot.symbol$col, pch = plot.symbol$pch, cex = plot.symbol$cex, fill = plot.symbol$fill, font = plot.symbol$font, fontface = plot.symbol$fontface, fontfamily = plot.symbol$fontfamily, lty = plot.line$lty, lwd = plot.line$lwd, alpha = plot.symbol$alpha)"},{"p":"lattice","o":"draw.key","f":"hp_draw.key","d":"Produces (and possibly draws) a Grid frame grob which is a legend (aka \nkey) that can be placed in other Grid plots.\n","ec":"draw.key(key, draw = FALSE, vp = NULL, ...)"},{"p":"lattice","o":"canonical.theme","f":"hp_canonical.theme","d":"Built-in graphical parameter settings. These mainly differ in their\nchoice of colors.\n","ec":"canonical.theme(...)"},{"p":"lattice","o":"panel.levelplot","f":"hp_panel.levelplot","d":"These are the default panel functions for levelplot and\ncontourplot.  Also documented is an alternative raster-based\npanel function for use with levelplot.\n","ec":"panel.levelplot(x, y, z, subscripts, at = pretty(z), shrink, labels = FALSE, label.style = c(\"mixed\", \"flat\", \"align\"), contour = FALSE, region = TRUE, col = add.line$col, lty = add.line$lty, lwd = add.line$lwd, border = \"transparent\", border.lty = 1, border.lwd = 0.1, ..., region.type = c(\"grid\", \"contour\"), col.regions = regions$col, alpha.regions = regions$alpha, identifier = \"levelplot\")"},{"p":"lattice","o":"xyplot","f":"hp_xyplot","d":"This help page documents several commonly used high-level Lattice\nfunctions.  xyplot produces bivariate scatterplots or\ntime-series plots, bwplot produces box-and-whisker plots,\ndotplot produces Cleveland dot plots, barchart produces\nbar plots, and stripplot produces one-dimensional scatterplots.\nAll these functions, along with other high-level Lattice functions,\nrespond to a common set of arguments that control conditioning,\nlayout, aspect ratio, legends, axis annotation, and many other details\nin a consistent manner.  These arguments are described extensively in\nthis help page, and should be used as the reference for other\nhigh-level functions as well.\n","ec":"xyplot(x, data, ...)"},{"p":"lattice","o":"panel.polygon","f":"hp_panel.polygon","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.polygon(...)"},{"p":"lattice","o":"latticeParseFormula","f":"hp_latticeParseFormula","d":"this function is used by high level Lattice functions like\nxyplot to parse the formula argument and evaluate various\ncomponents of the data.\n","ec":"latticeParseFormula(model, data, dimension = 2, subset = TRUE, groups = NULL, multiple = FALSE, outer = FALSE, subscripts = FALSE, drop = NULL)"},{"p":"lattice","o":"prepanel.default.qq","f":"hp_prepanel.default.qq","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.qq(x, y, ...)"},{"p":"lattice","o":"panel.linejoin","f":"hp_panel.linejoin","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.linejoin(x, y, fun = mean, horizontal = TRUE, lwd = reference.line$lwd, lty = reference.line$lty, col, col.line = reference.line$col, type = \"l\", ..., identifier = \"linejoin\")"},{"p":"lattice","o":"packet.number","f":"hp_packet.number","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"packet.number(prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.3dwire","f":"hp_panel.3dwire","d":"Default panel functions controlling cloud and\nwireframe displays.\n","ec":"panel.3dwire(x, y, z, rot.mat = diag(4), distance, shade = FALSE, shade.colors.palette = trellis.par.get(\"shade.colors\")$palette, light.source = c(0, 0, 1000), xlim, ylim, zlim, xlim.scaled, ylim.scaled, zlim.scaled, col = if (shade) \"transparent\" else \"black\", lty = 1, lwd = 1, alpha, col.groups = superpose.polygon$col, polynum = 100, ..., .scale = FALSE, drape = FALSE, at, col.regions = regions$col, alpha.regions = regions$alpha, identifier = \"3dwire\")"},{"p":"lattice","o":"qq","f":"hp_qq","d":"Quantile-Quantile plots for comparing two Distributions\n","ec":"qq(x, data, ...)"},{"p":"lattice","o":"ltransform3dto3d","f":"hp_ltransform3dto3d","d":"These are (related to) the default panel functions for cloud\nand wireframe.\n","ec":"ltransform3dto3d(x, R.mat, dist = 0)"},{"p":"lattice","o":"trellis.vpname","f":"hp_trellis.vpname","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.vpname(name = c(\"position\", \"split\", \"split.location\", \"toplevel\", \"figure\", \"panel\", \"strip\", \"strip.left\", \"legend\", \"legend.region\", \"main\", \"sub\", \"xlab\", \"ylab\", \"xlab.top\", \"ylab.right\", \"page\"), column = lattice.getStatus(\"current.focus.column\", prefix = prefix), row = lattice.getStatus(\"current.focus.row\", prefix = prefix), side = c(\"left\", \"top\", \"right\", \"bottom\", \"inside\"), clip.off = FALSE, prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.wireframe","f":"hp_panel.wireframe","d":"Default panel functions controlling cloud and\nwireframe displays.\n","ec":"panel.wireframe(...)"},{"p":"lattice","o":"lrect","f":"hp_lrect","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lrect(...)"},{"p":"lattice","o":"trellis.panelArgs","f":"hp_trellis.panelArgs","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.panelArgs(x, packet.number)"},{"p":"lattice","o":"strip.custom","f":"hp_strip.custom","d":"strip.default is the function that draws the strips by default\nin Trellis plots.  Users can write their own strip functions, but most\ncommonly this involves calling strip.default with a slightly\ndifferent arguments.  strip.custom provides a convenient way to\nobtain new strip functions that differ from strip.default only\nin the default values of certain arguments.\n","ec":"strip.custom(...)"},{"p":"lattice","o":"trellis.last.object","f":"hp_trellis.last.object","d":"Update method for objects of class \"trellis\", and a way to retrieve\nthe last printed trellis object (that was saved).\n","ec":"trellis.last.object(..., prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.number","f":"hp_panel.number","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"panel.number(prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"stripplot","f":"hp_stripplot","d":"This help page documents several commonly used high-level Lattice\nfunctions.  xyplot produces bivariate scatterplots or\ntime-series plots, bwplot produces box-and-whisker plots,\ndotplot produces Cleveland dot plots, barchart produces\nbar plots, and stripplot produces one-dimensional scatterplots.\nAll these functions, along with other high-level Lattice functions,\nrespond to a common set of arguments that control conditioning,\nlayout, aspect ratio, legends, axis annotation, and many other details\nin a consistent manner.  These arguments are described extensively in\nthis help page, and should be used as the reference for other\nhigh-level functions as well.\n","ec":"stripplot(x, data, ...)"},{"p":"lattice","o":"tmd","f":"hp_tmd","d":"tmd Creates Tukey Mean-Difference Plots from a trellis object\nreturned by xyplot, qq or qqmath.  The prepanel\nand panel functions are used as appropriate.  The formula and\ndata.frame methods for tmd are provided for convenience,\nand simply call tmd on the object created by the corresponding\nxyplot methods.\n","ec":"tmd(object, ...)"},{"p":"lattice","o":"is.shingle","f":"hp_is.shingle","d":"Functions to handle shingles\n","ec":"is.shingle(x)"},{"p":"lattice","o":"histogram","f":"hp_histogram","d":"Draw Histograms and Kernel Density Plots, possibly conditioned on\nother variables.\n","ec":"histogram(x, data, ...)"},{"p":"lattice","o":"prepanel.lmline","f":"hp_prepanel.lmline","d":"These are predefined prepanel functions available in Lattice.\n","ec":"prepanel.lmline(x, y, ...)"},{"p":"lattice","o":"panel.polypath","f":"hp_panel.polypath","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.polypath(...)"},{"p":"lattice","o":"panel.contourplot","f":"hp_panel.contourplot","d":"These are the default panel functions for levelplot and\ncontourplot.  Also documented is an alternative raster-based\npanel function for use with levelplot.\n","ec":"panel.contourplot(...)"},{"p":"lattice","o":"cloud","f":"hp_cloud","d":"Generic functions to draw 3d scatter plots and surfaces.  The\n\"formula\" methods do most of the actual work.\n","ec":"cloud(x, data, ...)"},{"p":"lattice","o":"panel.points","f":"hp_panel.points","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.points(...)"},{"p":"lattice","o":"panel.cloud","f":"hp_panel.cloud","d":"Default panel functions controlling cloud and\nwireframe displays.\n","ec":"panel.cloud(x, y, subscripts, z, groups = NULL, perspective = TRUE, distance = if (perspective) 0.2 else 0, xlim, ylim, zlim, panel.3d.cloud = \"panel.3dscatter\", panel.3d.wireframe = \"panel.3dwire\", screen = list(z = 40, x = -60), R.mat = diag(4), aspect = c(1, 1), par.box = NULL, xlab, ylab, zlab, xlab.default, ylab.default, zlab.default, scales.3d, proportion = 0.6, wireframe = FALSE, scpos, ..., at, identifier = \"cloud\")"},{"p":"lattice","o":"lattice.getOption","f":"hp_lattice.getOption","d":"Functions to handle settings used by lattice.  Their main purpose is\nto make code maintainance easier, and users normally should not need\nto use these functions.  However, fine control at this level maybe\nuseful in certain cases.\n","ec":"lattice.getOption(name)"},{"p":"lattice","o":"panel.qq","f":"hp_panel.qq","d":"This is the default panel function for xyplot. Also see\npanel.superpose.  The default panel functions for\nsplom and qq are essentially the same function.\n","ec":"panel.qq(..., identifier = \"qq\")"},{"p":"lattice","o":"trellis.par.get","f":"hp_trellis.par.get","d":"Functions used to query, display and modify graphical parameters for\nfine control of Trellis displays.  Modifications are made to the\nsettings for the currently active device only.\n","ec":"trellis.par.get(name = NULL)"},{"p":"lattice","o":"densityplot","f":"hp_densityplot","d":"Draw Histograms and Kernel Density Plots, possibly conditioned on\nother variables.\n","ec":"densityplot(x, data, ...)"},{"p":"lattice","o":"panel.arrows","f":"hp_panel.arrows","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.arrows(...)"},{"p":"lattice","o":"current.row","f":"hp_current.row","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"current.row(prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"lpolygon","f":"hp_lpolygon","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lpolygon(x, ...)"},{"p":"lattice","o":"level.colors","f":"hp_level.colors","d":"Calculates false colors from a numeric variable (including factors,\nusing their numeric codes) given a color scheme and breakpoints.\n","ec":"level.colors(x, at, col.regions, colors = TRUE, ...)"},{"p":"lattice","o":"panel.qqmath","f":"hp_panel.qqmath","d":"This is the default panel function for qqmath.\n","ec":"panel.qqmath(x, f.value = NULL, distribution = qnorm, qtype = 7, groups = NULL, ..., tails.n = 0, identifier = \"qqmath\")"},{"p":"lattice","o":"panel.refline","f":"hp_panel.refline","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.refline(...)"},{"p":"lattice","o":"shingle","f":"hp_shingle","d":"Functions to handle shingles\n","ec":"shingle(x, intervals = sort(unique(x)))"},{"p":"lattice","o":"splom","f":"hp_splom","d":"Draw Conditional Scatter Plot Matrices and Parallel Coordinate Plots\n","ec":"splom(x, data, ...)"},{"p":"lattice","o":"panel.splom","f":"hp_panel.splom","d":"This is the default panel function for xyplot. Also see\npanel.superpose.  The default panel functions for\nsplom and qq are essentially the same function.\n","ec":"panel.splom(..., identifier = \"splom\")"},{"p":"lattice","o":"panel.dotplot","f":"hp_panel.dotplot","d":"Default panel function for dotplot.\n","ec":"panel.dotplot(x, y, horizontal = TRUE, pch = if (is.null(groups)) dot.symbol$pch else sup.symbol$pch, col = if (is.null(groups)) dot.symbol$col else sup.symbol$col, lty = dot.line$lty, lwd = dot.line$lwd, col.line = dot.line$col, levels.fos = if (horizontal) unique(y) else unique(x), groups = NULL, ..., grid = lattice.getOption(\"default.args\")$grid, identifier = \"dotplot\")"},{"p":"lattice","o":"panel.loess","f":"hp_panel.loess","d":"A predefined panel function that can be used to add a LOESS smooth\nbased on the provided data.\n","ec":"panel.loess(x, y, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), evaluation = 50, lwd = plot.line$lwd, lty = plot.line$lty, col, col.line = plot.line$col, type, horizontal = FALSE, ..., identifier = \"loess\")"},{"p":"lattice","o":"trellis.par.set","f":"hp_trellis.par.set","d":"Functions used to query, display and modify graphical parameters for\nfine control of Trellis displays.  Modifications are made to the\nsettings for the currently active device only.\n","ec":"trellis.par.set(name, value, ..., theme, warn = TRUE, strict = FALSE)"},{"p":"lattice","o":"equal.count","f":"hp_equal.count","d":"Functions to handle shingles\n","ec":"equal.count(x, ...)"},{"p":"lattice","o":"show.settings","f":"hp_show.settings","d":"Functions used to query, display and modify graphical parameters for\nfine control of Trellis displays.  Modifications are made to the\nsettings for the currently active device only.\n","ec":"show.settings(x = NULL)"},{"p":"lattice","o":"panel.average","f":"hp_panel.average","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.average(x, y, fun = mean, horizontal = TRUE, lwd = reference.line$lwd, lty = reference.line$lty, col, col.line = reference.line$col, type = \"l\", ..., identifier = \"linejoin\")"},{"p":"lattice","o":"panel.superpose","f":"hp_panel.superpose","d":"These are panel functions for Trellis displays useful when a grouping\nvariable is specified for use within panels. The x (and\ny where appropriate) variables are plotted with different\ngraphical parameters for each distinct value of the grouping variable.\n","ec":"panel.superpose(x, y = NULL, subscripts, groups, panel.groups = \"panel.xyplot\", ..., col = \"black\", col.line = superpose.line$col, col.symbol = superpose.symbol$col, pch = superpose.symbol$pch, cex = superpose.symbol$cex, fill = superpose.symbol$fill, font = superpose.symbol$font, fontface = superpose.symbol$fontface, fontfamily = superpose.symbol$fontfamily, lty = superpose.line$lty, lwd = superpose.line$lwd, alpha = superpose.symbol$alpha, type = \"p\", grid = lattice.getOption(\"default.args\")$grid, distribute.type = FALSE)"},{"p":"lattice","o":"current.column","f":"hp_current.column","d":"Control over lattice plots are provided through a collection of user\nspecifiable functions that perform various tasks during the plotting.\nNot all information is available to all functions.  The functions\ndocumented here attempt to provide a consistent interface to access\nrelevant information from within these user specified functions,\nnamely those specified as the panel, strip and\naxis functions.  Note that this information is not available to\nthe prepanel function, which is executed prior to the actual\nplotting.\n","ec":"current.column(prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.segments","f":"hp_panel.segments","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.segments(...)"},{"p":"lattice","o":"yscale.components.default","f":"hp_yscale.components.default","d":"Lattice funtions provide control over how the plot axes are annotated\nthrough a common interface.  There are two levels of control.  The\nxscale.components and yscale.components arguments can be\nfunctions that determine tick mark locations and labels given a\npacket.  For more direct control, the axis argument can be a\nfunction that actually draws the axes.  The functions documented here\nare the defaults for these arguments.  They can additonally be used as\ncomponents of user written replacements.\n","ec":"yscale.components.default(lim, packet.number = 0, packet.list = NULL, right = TRUE, ...)"},{"p":"lattice","o":"panel.rect","f":"hp_panel.rect","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"panel.rect(...)"},{"p":"lattice","o":"panel.bwplot","f":"hp_panel.bwplot","d":"This is the default panel function for bwplot.\n","ec":"panel.bwplot(x, y, box.ratio = 1, box.width = box.ratio/(1 + box.ratio), horizontal = TRUE, pch = box.dot$pch, col = box.dot$col, alpha = box.dot$alpha, cex = box.dot$cex, font = box.dot$font, fontfamily = box.dot$fontfamily, fontface = box.dot$fontface, fill = box.rectangle$fill, varwidth = FALSE, notch = FALSE, notch.frac = 0.5, ..., levels.fos = if (horizontal) sort(unique(y)) else sort(unique(x)), stats = boxplot.stats, coef = 1.5, do.out = TRUE, identifier = \"bwplot\")"},{"p":"lattice","o":"panel.qqmathline","f":"hp_panel.qqmathline","d":"Useful panel function with qqmath. Draws a line passing through the\npoints (usually) determined by the .25 and .75 quantiles of the sample\nand the theoretical distribution.\n","ec":"panel.qqmathline(x, y = x, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, groups = NULL, ..., identifier = \"qqmathline\")"},{"p":"lattice","o":"draw.colorkey","f":"hp_draw.colorkey","d":"Creates (and optionally draws) a grid frame grob representing a color\nkey that can be placed in other grid-based plots. Primarily used by\nlevelplot when a color key is requested.\n","ec":"draw.colorkey(key, draw = FALSE, vp = NULL)"},{"p":"lattice","o":"panel.lmline","f":"hp_panel.lmline","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.lmline(x, y, ..., identifier = \"lmline\")"},{"p":"lattice","o":"lpolypath","f":"hp_lpolypath","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"lpolypath(x, ...)"},{"p":"lattice","o":"col.whitebg","f":"hp_col.whitebg","d":"Built-in graphical parameter settings. These mainly differ in their\nchoice of colors.\n","ec":"col.whitebg()"},{"p":"lattice","o":"prepanel.default.xyplot","f":"hp_prepanel.default.xyplot","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.xyplot(x, y, type, subscripts, groups = NULL, ...)"},{"p":"lattice","o":"prepanel.tmd.default","f":"hp_prepanel.tmd.default","d":"tmd Creates Tukey Mean-Difference Plots from a trellis object\nreturned by xyplot, qq or qqmath.  The prepanel\nand panel functions are used as appropriate.  The formula and\ndata.frame methods for tmd are provided for convenience,\nand simply call tmd on the object created by the corresponding\nxyplot methods.\n","ec":"prepanel.tmd.default(x, y, ...)"},{"p":"lattice","o":"xscale.components.default","f":"hp_xscale.components.default","d":"Lattice funtions provide control over how the plot axes are annotated\nthrough a common interface.  There are two levels of control.  The\nxscale.components and yscale.components arguments can be\nfunctions that determine tick mark locations and labels given a\npacket.  For more direct control, the axis argument can be a\nfunction that actually draws the axes.  The functions documented here\nare the defaults for these arguments.  They can additonally be used as\ncomponents of user written replacements.\n","ec":"xscale.components.default(lim, packet.number = 0, packet.list = NULL, top = TRUE, ...)"},{"p":"lattice","o":"prepanel.loess","f":"hp_prepanel.loess","d":"These are predefined prepanel functions available in Lattice.\n","ec":"prepanel.loess(x, y, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), evaluation = 50, horizontal = FALSE, ...)"},{"p":"lattice","o":"classic.theme","f":"hp_classic.theme","d":"Built-in graphical parameter settings. These mainly differ in their\nchoice of colors.\n","ec":"classic.theme(name = .Device, color = name != \"postscript\")"},{"p":"lattice","o":"llines","f":"hp_llines","d":"These functions are intended to replace common low level traditional\ngraphics functions, primarily for use in panel functions.  The\noriginals can not be used (at least not easily) because lattice panel\nfunctions need to use grid graphics.  Low level drawing functions in\ngrid can be used directly as well, and is often more flexible.  These\nfunctions are provided for convenience and portability.\n","ec":"llines(x, ...)"},{"p":"lattice","o":"Rows","f":"hp_Rows","d":"Convenience function to extract subset of a list. Usually used in\ncreating keys.\n","ec":"Rows(x, which)"},{"p":"lattice","o":"panel.parallel","f":"hp_panel.parallel","d":"This is the default panel function for parallel.\n","ec":"panel.parallel(x, y, z, subscripts, groups = NULL, col = superpose.line$col, lwd = superpose.line$lwd, lty = superpose.line$lty, alpha = superpose.line$alpha, common.scale = FALSE, lower = sapply(z, function(x) min(as.numeric(x), na.rm = TRUE)), upper = sapply(z, function(x) max(as.numeric(x), na.rm = TRUE)), ..., horizontal.axis = TRUE, identifier = \"parallel\")"},{"p":"lattice","o":"trellis.switchFocus","f":"hp_trellis.switchFocus","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.switchFocus(name, side = NULL, clip.off = FALSE, highlight, ..., prefix)"},{"p":"lattice","o":"panel.brush.splom","f":"hp_panel.brush.splom","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"panel.brush.splom(threshold = 18, verbose = getOption(\"verbose\"), ...)"},{"p":"lattice","o":"make.groups","f":"hp_make.groups","d":"Combines two or more vectors, possibly of different lengths, producing\na data frame with a second column indicating which of these vectors\nthat row came from.  This is mostly useful for getting data into a\nform suitable for use in high level Lattice functions.\n","ec":"make.groups(...)"},{"p":"lattice","o":"diag.panel.splom","f":"hp_diag.panel.splom","d":"This is the default superpanel function for splom.\n","ec":"diag.panel.splom(x = NULL, varname = NULL, limits, at = NULL, labels = NULL, draw = TRUE, tick.number = 5, varname.col = add.text$col, varname.cex = add.text$cex, varname.lineheight = add.text$lineheight, varname.font = add.text$font, varname.fontfamily = add.text$fontfamily, varname.fontface = add.text$fontface, axis.text.col = axis.text$col, axis.text.alpha = axis.text$alpha, axis.text.cex = axis.text$cex, axis.text.font = axis.text$font, axis.text.fontfamily = axis.text$fontfamily, axis.text.fontface = axis.text$fontface, axis.text.lineheight = axis.text$lineheight, axis.line.col = axis.line$col, axis.line.alpha = axis.line$alpha, axis.line.lty = axis.line$lty, axis.line.lwd = axis.line$lwd, axis.line.tck = 1, ...)"},{"p":"lattice","o":"panel.xyplot","f":"hp_panel.xyplot","d":"This is the default panel function for xyplot. Also see\npanel.superpose.  The default panel functions for\nsplom and qq are essentially the same function.\n","ec":"panel.xyplot(x, y, type = \"p\", groups = NULL, pch = if (is.null(groups)) plot.symbol$pch else superpose.symbol$pch, col, col.line = if (is.null(groups)) plot.line$col else superpose.line$col, col.symbol = if (is.null(groups)) plot.symbol$col else superpose.symbol$col, font = if (is.null(groups)) plot.symbol$font else superpose.symbol$font, fontfamily = if (is.null(groups)) plot.symbol$fontfamily else superpose.symbol$fontfamily, fontface = if (is.null(groups)) plot.symbol$fontface else superpose.symbol$fontface, lty = if (is.null(groups)) plot.line$lty else superpose.line$lty, cex = if (is.null(groups)) plot.symbol$cex else superpose.symbol$cex, fill = if (is.null(groups)) plot.symbol$fill else superpose.symbol$fill, lwd = if (is.null(groups)) plot.line$lwd else superpose.line$lwd, horizontal = FALSE, ..., smooth = NULL, grid = lattice.getOption(\"default.args\")$grid, abline = NULL, jitter.x = FALSE, jitter.y = FALSE, factor = 0.5, amount = NULL, identifier = \"xyplot\")"},{"p":"lattice","o":"panel.identify","f":"hp_panel.identify","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"panel.identify(x, y = NULL, subscripts = seq_along(x), labels = subscripts, n = length(x), offset = 0.5, threshold = 18, panel.args = trellis.panelArgs(), ...)"},{"p":"lattice","o":"prepanel.default.levelplot","f":"hp_prepanel.default.levelplot","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.levelplot(x, y, subscripts, ...)"},{"p":"lattice","o":"panel.tmd.default","f":"hp_panel.tmd.default","d":"tmd Creates Tukey Mean-Difference Plots from a trellis object\nreturned by xyplot, qq or qqmath.  The prepanel\nand panel functions are used as appropriate.  The formula and\ndata.frame methods for tmd are provided for convenience,\nand simply call tmd on the object created by the corresponding\nxyplot methods.\n","ec":"panel.tmd.default(x, y, groups = NULL, ..., identifier = \"tmd\")"},{"p":"lattice","o":"prepanel.default.splom","f":"hp_prepanel.default.splom","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.splom(z, ...)"},{"p":"lattice","o":"prepanel.default.densityplot","f":"hp_prepanel.default.densityplot","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.densityplot(x, darg, groups = NULL, weights = NULL, subscripts = TRUE, ...)"},{"p":"lattice","o":"simpleTheme","f":"hp_simpleTheme","d":"Simple interface to generate a list appropriate as a theme, typically\nused as the par.settings argument in a high level call\n","ec":"simpleTheme(col, alpha, cex, pch, lty, lwd, font, fill, border, col.points, col.line, alpha.points, alpha.line)"},{"p":"lattice","o":"panel.identify.qqmath","f":"hp_panel.identify.qqmath","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"panel.identify.qqmath(x = panel.args$x, distribution = panel.args$distribution, groups = panel.args$groups, subscripts = panel.args$subscripts, labels = subscripts, panel.args = trellis.panelArgs(), ...)"},{"p":"lattice","o":"panel.histogram","f":"hp_panel.histogram","d":"This is the default panel function for histogram.\n","ec":"panel.histogram(x, breaks, equal.widths = TRUE, type = \"density\", nint = round(log2(length(x)) + 1), alpha = plot.polygon$alpha, col = plot.polygon$col, border = plot.polygon$border, lty = plot.polygon$lty, lwd = plot.polygon$lwd, ..., identifier = \"histogram\")"},{"p":"lattice","o":"as.factorOrShingle","f":"hp_as.factorOrShingle","d":"Functions to handle shingles\n","ec":"as.factorOrShingle(x, subset = TRUE, drop = FALSE)"},{"p":"lattice","o":"panel.identify.cloud","f":"hp_panel.identify.cloud","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"panel.identify.cloud(x = panel.args$x, y = panel.args$y, z = panel.args$z, subscripts = panel.args$subscripts, perspective = TRUE, distance = if (perspective) 0.2 else 0, xlim = panel.args$xlim, ylim = panel.args$ylim, zlim = panel.args$zlim, screen = list(z = 40, x = -60), R.mat = diag(4), aspect = c(1, 1), scales.3d = panel.args$scales.3d, ..., panel.3d.identify = panel.3didentify, n = length(subscripts), offset = 0.5, threshold = 18, labels = subscripts, panel.args = trellis.panelArgs())"},{"p":"lattice","o":"panel.mathdensity","f":"hp_panel.mathdensity","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.mathdensity(dmath = dnorm, args = list(mean = 0, sd = 1), n = 50, col, col.line = reference.line$col, lwd = reference.line$lwd, lty = reference.line$lty, type, ..., identifier = \"mathdensity\")"},{"p":"lattice","o":"rfs","f":"hp_rfs","d":"Plots fitted values and residuals (via qqmath) on a common scale for\nany object that has methods for fitted values and residuals. \n","ec":"rfs(model, layout = c(2, 1), xlab = \"f-value\", ylab = NULL, distribution = qunif, panel = function(...) { panel.grid(h = -1, v = -1) panel.qqmath(...) }, prepanel = NULL, strip = TRUE, ...)"},{"p":"lattice","o":"prepanel.default.histogram","f":"hp_prepanel.default.histogram","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.histogram(x, breaks, equal.widths = TRUE, type = \"density\", nint = round(log2(length(x)) + 1), ...)"},{"p":"lattice","o":"prepanel.default.parallel","f":"hp_prepanel.default.parallel","d":"These prepanel functions are used as fallback defaults in various\nhigh level plot functions in Lattice.  These are rarely useful to\nnormal users but may be helpful in developing new displays.\n","ec":"prepanel.default.parallel(x, y, z, ..., horizontal.axis = TRUE)"},{"p":"lattice","o":"oneway","f":"hp_oneway","d":"Fits a One-way model to univariate data grouped by a factor, the\nresult often being displayed using rfs \n","ec":"oneway(formula, data, location = mean, spread = function(x) sqrt(var(x)))"},{"p":"lattice","o":"ltransform3dMatrix","f":"hp_ltransform3dMatrix","d":"These are (related to) the default panel functions for cloud\nand wireframe.\n","ec":"ltransform3dMatrix(screen, R.mat = diag(4))"},{"p":"lattice","o":"dotplot","f":"hp_dotplot","d":"This help page documents several commonly used high-level Lattice\nfunctions.  xyplot produces bivariate scatterplots or\ntime-series plots, bwplot produces box-and-whisker plots,\ndotplot produces Cleveland dot plots, barchart produces\nbar plots, and stripplot produces one-dimensional scatterplots.\nAll these functions, along with other high-level Lattice functions,\nrespond to a common set of arguments that control conditioning,\nlayout, aspect ratio, legends, axis annotation, and many other details\nin a consistent manner.  These arguments are described extensively in\nthis help page, and should be used as the reference for other\nhigh-level functions as well.\n","ec":"dotplot(x, data, ...)"},{"p":"lattice","o":"panel.error","f":"hp_panel.error","d":"The print and plot methods produce a graph from a\n\"trellis\" object.  The print method is necessary for\nautomatic plotting.  plot method is essentially\nan alias, provided for convenience.  The summary method\ngives a textual summary of the object.  dim and dimnames\ndescribe the cross-tabulation induced by conditioning.\npanel.error is the default handler used when an error occurs\nwhile executing the panel function.\n","ec":"panel.error(e)"},{"p":"lattice","o":"bwplot","f":"hp_bwplot","d":"This help page documents several commonly used high-level Lattice\nfunctions.  xyplot produces bivariate scatterplots or\ntime-series plots, bwplot produces box-and-whisker plots,\ndotplot produces Cleveland dot plots, barchart produces\nbar plots, and stripplot produces one-dimensional scatterplots.\nAll these functions, along with other high-level Lattice functions,\nrespond to a common set of arguments that control conditioning,\nlayout, aspect ratio, legends, axis annotation, and many other details\nin a consistent manner.  These arguments are described extensively in\nthis help page, and should be used as the reference for other\nhigh-level functions as well.\n","ec":"bwplot(x, data, ...)"},{"p":"lattice","o":"panel.rug","f":"hp_panel.rug","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.rug(x = NULL, y = NULL, regular = TRUE, start = if (regular) 0 else 0.97, end = if (regular) 0.03 else 1, x.units = rep(\"npc\", 2), y.units = rep(\"npc\", 2), col = plot.line$col, col.line = col, lty = plot.line$lty, lwd = plot.line$lwd, alpha = plot.line$alpha, ..., identifier = \"rug\")"},{"p":"lattice","o":"makeShadePalette","f":"hp_makeShadePalette","d":"Default panel functions controlling cloud and\nwireframe displays.\n","ec":"makeShadePalette(col.regions, ..., min = 0.05, pref = 0.75)"},{"p":"lattice","o":"parallel","f":"hp_parallel","d":"Draw Conditional Scatter Plot Matrices and Parallel Coordinate Plots\n","ec":"parallel(x, data, ...)"},{"p":"lattice","o":"panel.abline","f":"hp_panel.abline","d":"These are predefined panel functions available in lattice for use in\nconstructing new panel functions (often on-the-fly).\n","ec":"panel.abline(a = NULL, b = 0, h = NULL, v = NULL, reg = NULL, coef = NULL, col, col.line = add.line$col, lty = add.line$lty, lwd = add.line$lwd, alpha = add.line$alpha, type, ..., reference = FALSE, identifier = \"abline\")"},{"p":"lattice","o":"barchart","f":"hp_barchart","d":"This help page documents several commonly used high-level Lattice\nfunctions.  xyplot produces bivariate scatterplots or\ntime-series plots, bwplot produces box-and-whisker plots,\ndotplot produces Cleveland dot plots, barchart produces\nbar plots, and stripplot produces one-dimensional scatterplots.\nAll these functions, along with other high-level Lattice functions,\nrespond to a common set of arguments that control conditioning,\nlayout, aspect ratio, legends, axis annotation, and many other details\nin a consistent manner.  These arguments are described extensively in\nthis help page, and should be used as the reference for other\nhigh-level functions as well.\n","ec":"barchart(x, data, ...)"},{"p":"lattice","o":"trellis.focus","f":"hp_trellis.focus","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.focus(name, column = stop(\"column must be specified\"), row = stop(\"row must be specified\"), side = NULL, clip.off = FALSE, highlight = interactive(), ..., prefix, guess = TRUE, verbose = getOption(\"verbose\"))"},{"p":"lattice","o":"standard.theme","f":"hp_standard.theme","d":"Built-in graphical parameter settings. These mainly differ in their\nchoice of colors.\n","ec":"standard.theme(name, color = TRUE, symbol = palette.colors(palette = \"Okabe-Ito\")[c(6, 2, 4, 7, 3, 5, 8)], fill = NULL, region = hcl.colors(14, palette = \"YlGnBu\", rev = TRUE), reference = \"gray90\", bg = \"transparent\", fg = \"black\", ...)"},{"p":"lattice","o":"panel.superpose.2","f":"hp_panel.superpose.2","d":"These are panel functions for Trellis displays useful when a grouping\nvariable is specified for use within panels. The x (and\ny where appropriate) variables are plotted with different\ngraphical parameters for each distinct value of the grouping variable.\n","ec":"panel.superpose.2(..., distribute.type = TRUE)"},{"p":"lattice","o":"panel.barchart","f":"hp_panel.barchart","d":"Default panel function for barchart.\n","ec":"panel.barchart(x, y, box.ratio = 1, box.width = box.ratio/(1 + box.ratio), horizontal = TRUE, origin = NULL, reference = TRUE, stack = FALSE, groups = NULL, col = if (is.null(groups)) plot.polygon$col else superpose.polygon$col, border = if (is.null(groups)) plot.polygon$border else superpose.polygon$border, lty = if (is.null(groups)) plot.polygon$lty else superpose.polygon$lty, lwd = if (is.null(groups)) plot.polygon$lwd else superpose.polygon$lwd, ..., identifier = \"barchart\")"},{"p":"lattice","o":"trellis.grobname","f":"hp_trellis.grobname","d":"The classic Trellis paradigm is to plot the whole object at once,\nwithout the possibility of interacting with it afterwards.  However,\nby keeping track of the grid viewports where the panels and strips are\ndrawn, it is possible to go back to them afterwards and enhance them\none panel at a time.  These functions provide convenient interfaces to\nhelp in this.  Note that these are still experimental and the exact\ndetails may change in future.\n","ec":"trellis.grobname(name, type = c(\"\", \"panel\", \"strip\", \"strip.left\", \"key\", \"colorkey\"), group = 0, which.given = lattice.getStatus(\"current.which.given\", prefix = prefix), which.panel = lattice.getStatus(\"current.which.panel\", prefix = prefix), column = lattice.getStatus(\"current.focus.column\", prefix = prefix), row = lattice.getStatus(\"current.focus.row\", prefix = prefix), prefix = lattice.getStatus(\"current.prefix\"))"},{"p":"lattice","o":"panel.pairs","f":"hp_panel.pairs","d":"This is the default superpanel function for splom.\n","ec":"panel.pairs(z, panel = lattice.getOption(\"panel.splom\"), lower.panel = panel, upper.panel = panel, diag.panel = \"diag.panel.splom\", as.matrix = FALSE, groups = NULL, panel.subscripts, subscripts, pscales = 5, prepanel.limits = scale_limits, varnames = colnames(z), varname.col = add.text$col, varname.cex = add.text$cex, varname.font = add.text$font, varname.fontfamily = add.text$fontfamily, varname.fontface = add.text$fontface, axis.text.col = axis.text$col, axis.text.cex = axis.text$cex, axis.text.font = axis.text$font, axis.text.fontfamily = axis.text$fontfamily, axis.text.fontface = axis.text$fontface, axis.text.lineheight = axis.text$lineheight, axis.line.col = axis.line$col, axis.line.lty = axis.line$lty, axis.line.lwd = axis.line$lwd, axis.line.alpha = axis.line$alpha, axis.line.tck = 1, ...)"},{"p":"lattice","o":"simpleKey","f":"hp_simpleKey","d":"Simple interface to generate a list appropriate for draw.key\n","ec":"simpleKey(text, points = TRUE, rectangles = FALSE, lines = FALSE, col = add.text$col, cex = add.text$cex, alpha = add.text$alpha, font = add.text$font, fontface = add.text$fontface, fontfamily = add.text$fontfamily, lineheight = add.text$lineheight, ...)"},{"p":"lattice","o":"wireframe","f":"hp_wireframe","d":"Generic functions to draw 3d scatter plots and surfaces.  The\n\"formula\" methods do most of the actual work.\n","ec":"wireframe(x, data, ...)"},{"p":"lattice","o":"panel.spline","f":"hp_panel.spline","d":"A predefined panel function that can be used to add a spline smooth\nbased on the provided data.\n","ec":"panel.spline(x, y, npoints = 101, lwd = plot.line$lwd, lty = plot.line$lty, col, col.line = plot.line$col, type, horizontal = FALSE, ..., keep.data = FALSE, identifier = \"spline\")"},{"p":"lattice","o":"panel.smoothScatter","f":"hp_panel.smoothScatter","d":"This function allows the user to place smoothScatter plots in\nlattice graphics.\n","ec":"panel.smoothScatter(x, y = NULL, nbin = 64, cuts = 255, bandwidth, col.regions, colramp, nrpoints = 100, transformation = function(x) x^0.25, pch = \".\", cex = 1, col = \"black\", range.x, ..., raster = FALSE, subscripts, identifier = \"smoothScatter\")"},{"p":"lattice","o":"prepanel.spline","f":"hp_prepanel.spline","d":"These are predefined prepanel functions available in Lattice.\n","ec":"prepanel.spline(x, y, npoints = 101, horizontal = FALSE, ..., keep.data = FALSE)"},{"p":"lattice","o":"prepanel.qqmathline","f":"hp_prepanel.qqmathline","d":"These are predefined prepanel functions available in Lattice.\n","ec":"prepanel.qqmathline(x, y = x, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, groups = NULL, subscripts = TRUE, ...)"},{"p":"lattice","o":"do.breaks","f":"hp_do.breaks","d":"Draw Histograms and Kernel Density Plots, possibly conditioned on\nother variables.\n","ec":"do.breaks(endpoints, nint)"},{"p":"magrittr","o":"add","f":"hp_add","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"add(e1, e2)"},{"p":"magrittr","o":"set_class","f":"hp_set_class","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_class(x, value)"},{"p":"magrittr","o":"multiply_by","f":"hp_multiply_by","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"multiply_by(e1, e2)"},{"p":"magrittr","o":"multiply_by_matrix","f":"hp_multiply_by_matrix","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"multiply_by_matrix(x, y)"},{"p":"magrittr","o":"equals","f":"hp_equals","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"equals(e1, e2)"},{"p":"magrittr","o":"pipe_eager_lexical","f":"hp_pipe_eager_lexical","d":"Assign these pipe variants to an infix symbol like <U+2060>%>%<U+2060>.\n","ec":"pipe_eager_lexical(lhs, rhs)"},{"p":"magrittr","o":"is_weakly_greater_than","f":"hp_is_weakly_greater_than","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"is_weakly_greater_than(e1, e2)"},{"p":"magrittr","o":"debug_fseq","f":"hp_debug_fseq","d":"This is a utility function for marking functions in a functional\nsequence for debbuging.\n","ec":"debug_fseq(fseq, ...)"},{"p":"magrittr","o":"%>%","f":"hp_X...","d":"Pipe an object forward into a function or call expression.\n","ec":"%>%(lhs, rhs)"},{"p":"magrittr","o":"divide_by","f":"hp_divide_by","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"divide_by(e1, e2)"},{"p":"magrittr","o":"set_rownames","f":"hp_set_rownames","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_rownames(x, value)"},{"p":"magrittr","o":"set_names","f":"hp_set_names","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_names(x, value)"},{"p":"magrittr","o":"is_less_than","f":"hp_is_less_than","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"is_less_than(e1, e2)"},{"p":"magrittr","o":"set_attr","f":"hp_set_attr","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_attr(x, which, value)"},{"p":"magrittr","o":"raise_to_power","f":"hp_raise_to_power","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"raise_to_power(e1, e2)"},{"p":"magrittr","o":"is_in","f":"hp_is_in","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"is_in(x, table)"},{"p":"magrittr","o":"extract","f":"hp_extract","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":""},{"p":"magrittr","o":"divide_by_int","f":"hp_divide_by_int","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"divide_by_int(e1, e2)"},{"p":"magrittr","o":"pipe_nested","f":"hp_pipe_nested","d":"Assign these pipe variants to an infix symbol like <U+2060>%>%<U+2060>.\n","ec":"pipe_nested(lhs, rhs)"},{"p":"magrittr","o":"%T>%","f":"hp_X.T..","d":"Pipe a value forward into a function- or call expression and return the\noriginal value instead of the result. This is useful when an expression\nis used for its side-effect, say plotting or printing.\n","ec":"%T>%(lhs, rhs)"},{"p":"magrittr","o":"subtract","f":"hp_subtract","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"subtract(e1, e2)"},{"p":"magrittr","o":"freduce","f":"hp_freduce","d":"This function applies the first function to value, then the\nnext function to the result of the previous function call, etc.\n","ec":"freduce(value, function_list)"},{"p":"magrittr","o":"%$%","f":"hp_X...","d":"Expose the names in lhs to the rhs expression. This is useful when functions\ndo not have a built-in data argument.\n","ec":"%$%(lhs, rhs)"},{"p":"magrittr","o":"mod","f":"hp_mod","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"mod(e1, e2)"},{"p":"magrittr","o":"inset2","f":"hp_inset2","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":""},{"p":"magrittr","o":"is_greater_than","f":"hp_is_greater_than","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"is_greater_than(e1, e2)"},{"p":"magrittr","o":"%<>%","f":"hp_X....","d":"Pipe an object forward into a function or call expression and update the\nlhs object with the resulting value.\n","ec":"%<>%(lhs, rhs)"},{"p":"magrittr","o":"functions","f":"hp_functions","d":"This can be used to extract the list of functions inside a functional\nsequence created with a chain like . %>% foo %>% bar.\n","ec":"functions(fseq)"},{"p":"magrittr","o":"set_colnames","f":"hp_set_colnames","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_colnames(x, value)"},{"p":"magrittr","o":"extract2","f":"hp_extract2","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":""},{"p":"magrittr","o":"use_series","f":"hp_use_series","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":""},{"p":"magrittr","o":"and","f":"hp_and","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"and(e1, e2)"},{"p":"magrittr","o":"pipe_lazy_masking","f":"hp_pipe_lazy_masking","d":"Assign these pipe variants to an infix symbol like <U+2060>%>%<U+2060>.\n","ec":"pipe_lazy_masking(lhs, rhs)"},{"p":"magrittr","o":"debug_pipe","f":"hp_debug_pipe","d":"This function is a wrapper around browser, which makes it\neasier to debug at certain places in a magrittr pipe chain.\n","ec":"debug_pipe(x)"},{"p":"magrittr","o":"inset","f":"hp_inset","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":""},{"p":"magrittr","o":"set_attributes","f":"hp_set_attributes","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"set_attributes(x, value)"},{"p":"magrittr","o":"%!>%","f":"hp_X....","d":"Whereas <U+2060>%>%<U+2060> is lazy and only evaluates the piped expressions when\nneeded, <U+2060>%!>%<U+2060> is eager and evaluates the piped input at each step.\nThis produces more intuitive behaviour when functions are called\nfor their side effects, such as displaying a message.\n","ec":"%!>%(lhs, rhs)"},{"p":"magrittr","o":"n'est pas","f":"hp_n.est.pas","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"n'est pas(x)"},{"p":"magrittr","o":"is_weakly_less_than","f":"hp_is_weakly_less_than","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"is_weakly_less_than(e1, e2)"},{"p":"magrittr","o":"not","f":"hp_not","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"not(x)"},{"p":"magrittr","o":"undebug_fseq","f":"hp_undebug_fseq","d":"This is a utility function for marking functions in a functional\nsequence for debbuging.\n","ec":"undebug_fseq(fseq)"},{"p":"magrittr","o":"or","f":"hp_or","d":"magrittr provides a series of aliases which can be more pleasant to use\nwhen composing chains using the %>% operator.\n","ec":"or(e1, e2)"},{"p":"MASS","o":"boxcox","f":"hp_boxcox","d":"Computes and optionally plots profile log-likelihoods for the\nparameter of the Box-Cox power transformation.\n","ec":"boxcox(object, ...)"},{"p":"MASS","o":"lm.ridge","f":"hp_lm.ridge","d":"Fit a linear model by ridge regression.\n","ec":"lm.ridge(formula, data, subset, na.action, lambda = 0, model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...)"},{"p":"MASS","o":"con2tr","f":"hp_con2tr","d":"Convert lists to data frames for use by lattice.\n","ec":"con2tr(obj)"},{"p":"MASS","o":"rms.curv","f":"hp_rms.curv","d":"Calculates the root mean square parameter effects and intrinsic relative\ncurvatures, c^\\theta and c^\\iota, for a\nfitted nonlinear regression, as defined in Bates & Watts, section 7.3,\np. 253ff\n","ec":"rms.curv(obj)"},{"p":"MASS","o":"cov.rob","f":"hp_cov.rob","d":"Compute a multivariate location and scale estimate with a high\nbreakdown point <U+2013> this can be thought of as estimating the mean and\ncovariance of the good part of the data. cov.mve and\ncov.mcd are compatibility wrappers.\n","ec":"cov.rob(x, cor = FALSE, quantile.used = floor((n + p + 1)/2), method = c(\"mve\", \"mcd\", \"classical\"), nsamp = \"best\", seed)"},{"p":"MASS","o":"parcoord","f":"hp_parcoord","d":"Parallel coordinates plot\n","ec":"parcoord(x, col = 1, lty = 1, var.label = FALSE, ...)"},{"p":"MASS","o":"Null","f":"hp_Null","d":"Given a matrix, M, find a matrix N giving a basis for the\n(left) null space.  That is crossprod(N, M) = t(N) %*% M\nis an all-zero matrix and N has the maximum number of linearly\nindependent columns.\n","ec":"Null(M)"},{"p":"MASS","o":"lqs","f":"hp_lqs","d":"Fit a regression to the good points in the dataset, thereby\nachieving a regression estimator with a high breakdown point.\nlmsreg and ltsreg are compatibility wrappers.\n","ec":"lqs(x, ...)"},{"p":"MASS","o":"enlist","f":"hp_enlist","d":"Internal MASS functions.\n","ec":"enlist(vec)"},{"p":"MASS","o":"write.matrix","f":"hp_write.matrix","d":"Writes a matrix or data frame to a file or the console, using column\nlabels and a layout respecting columns.\n","ec":"write.matrix(x, file = \"\", sep = \" \", blocksize)"},{"p":"MASS","o":"rational","f":"hp_rational","d":"Find rational approximations to the components of a real numeric\nobject using a standard continued fraction method.\n","ec":"rational(x, cycles = 10, max.denominator = 2000, ...)"},{"p":"MASS","o":"lda","f":"hp_lda","d":"Linear discriminant analysis.\n","ec":"lda(x, ...)"},{"p":"MASS","o":"is.fractions","f":"hp_is.fractions","d":"Find rational approximations to the components of a real numeric\nobject using a standard continued fraction method.\n","ec":"is.fractions(f)"},{"p":"MASS","o":"select","f":"hp_select","d":"Fit a linear model by ridge regression.\n","ec":"select(obj)"},{"p":"MASS","o":"rlm","f":"hp_rlm","d":"Fit a linear model by robust regression using an M estimator.\n","ec":"rlm(x, ...)"},{"p":"MASS","o":"sammon","f":"hp_sammon","d":"One form of non-metric multidimensional scaling.\n","ec":"sammon(d, y = cmdscale(d, k), k = 2, niter = 100, trace = TRUE, magic = 0.2, tol = 1e-04)"},{"p":"MASS","o":"negative.binomial","f":"hp_negative.binomial","d":"Specifies the information required to fit a Negative Binomial generalized\nlinear model, with known theta parameter, using glm().\n","ec":"negative.binomial(theta = stop(\"'theta' must be specified\"), link = \"log\")"},{"p":"MASS","o":"Shepard","f":"hp_Shepard","d":"One form of non-metric multidimensional scaling\n","ec":"Shepard(d, x, p = 2)"},{"p":"MASS","o":"logtrans","f":"hp_logtrans","d":"Find and optionally plot the marginal (profile) likelihood for alpha\nfor a transformation model of the form log(y + alpha) ~ x1 + x2 + ....\n","ec":"logtrans(object, ...)"},{"p":"MASS","o":"psi.hampel","f":"hp_psi.hampel","d":"Fit a linear model by robust regression using an M estimator.\n","ec":"psi.hampel(u, a = 2, b = 4, c = 8, deriv = 0)"},{"p":"MASS","o":"mca","f":"hp_mca","d":"Computes a multiple correspondence analysis of a set of factors.\n","ec":"mca(df, nf = 2, abbrev = FALSE)"},{"p":"MASS","o":"loglm1","f":"hp_loglm1","d":"loglm1 is an internal function used by loglm.\nIt is a generic function dispatching on the data argument.\n","ec":"loglm1(formula, data, ...)"},{"p":"MASS","o":"frequency.polygon","f":"hp_frequency.polygon","d":"Internal MASS functions.\n","ec":"frequency.polygon(x, nclass = nclass.freq(x), xlab = \"\", ylab = \"\", ...)"},{"p":"MASS","o":"stepAIC","f":"hp_stepAIC","d":"Performs stepwise model selection by AIC.\n","ec":"stepAIC(object, scope, scale = 0, direction = c(\"both\", \"backward\", \"forward\"), trace = 1, keep = NULL, steps = 1000, use.start = FALSE, k = 2, ...)"},{"p":"MASS","o":"kde2d","f":"hp_kde2d","d":"Two-dimensional kernel density estimation with an axis-aligned\nbivariate normal kernel, evaluated on a square grid.\n","ec":"kde2d(x, y, h, n = 25, lims = c(range(x), range(y)))"},{"p":"MASS","o":"area","f":"hp_area","d":"Integrate a function of one variable over a finite range using a\nrecursive adaptive method.  This function is mainly for\ndemonstration purposes.\n","ec":"area(f, a, b, ..., fa = f(a, ...), fb = f(b, ...), limit = 10, eps = 1e-05)"},{"p":"MASS","o":"polr","f":"hp_polr","d":"Fits a logistic or probit regression model to an ordered factor\nresponse.  The default logistic case is proportional odds\nlogistic regression, after which the function is named.\n","ec":"polr(formula, data, weights, start, ..., subset, na.action, contrasts = NULL, Hess = FALSE, model = TRUE, method = c(\"logistic\", \"probit\", \"loglog\", \"cloglog\", \"cauchit\"))"},{"p":"MASS","o":"cov.mcd","f":"hp_cov.mcd","d":"Compute a multivariate location and scale estimate with a high\nbreakdown point <U+2013> this can be thought of as estimating the mean and\ncovariance of the good part of the data. cov.mve and\ncov.mcd are compatibility wrappers.\n","ec":"cov.mcd(...)"},{"p":"MASS","o":"hist.FD","f":"hp_hist.FD","d":"Plot a histogram with automatic bin width selection, using the Scott\nor Freedman<U+2013>Diaconis formulae.\n","ec":"hist.FD(x, prob = TRUE, xlab = deparse(substitute(x)), ...)"},{"p":"MASS","o":"addterm","f":"hp_addterm","d":"Try fitting all models that differ from the current model by adding a\nsingle term from those supplied, maintaining marginality.\n","ec":"addterm(object, ...)"},{"p":"MASS","o":"nclass.freq","f":"hp_nclass.freq","d":"Internal MASS functions.\n","ec":"nclass.freq(x)"},{"p":"MASS","o":"huber","f":"hp_huber","d":"Finds the Huber M-estimator of location with MAD scale.\n","ec":"huber(y, k = 1.5, tol = 1e-06)"},{"p":"MASS","o":"psi.huber","f":"hp_psi.huber","d":"Fit a linear model by robust regression using an M estimator.\n","ec":"psi.huber(u, k = 1.345, deriv = 0)"},{"p":"MASS","o":"renumerate","f":"hp_renumerate","d":"denumerate converts a formula written using the conventions of\nloglm into one that terms is able to process.  renumerate\nconverts it back again to a form like the original.\n","ec":"renumerate(x)"},{"p":"MASS","o":"gamma.dispersion","f":"hp_gamma.dispersion","d":"A front end to gamma.shape for convenience.  Finds the\nreciprocal of the estimate of the shape parameter only.\n","ec":"gamma.dispersion(object, ...)"},{"p":"MASS","o":"glm.nb","f":"hp_glm.nb","d":"A modification of the system function glm() to include\nestimation of the additional parameter, theta, for a\nNegative Binomial generalized linear model.\n","ec":"glm.nb(formula, data, weights, subset, na.action, start = NULL, etastart, mustart, control = glm.control(...), method = \"glm.fit\", model = TRUE, x = FALSE, y = TRUE, contrasts = NULL, ..., init.theta, link = log)"},{"p":"MASS","o":"lm.gls","f":"hp_lm.gls","d":"Fit linear models by Generalized Least Squares\n","ec":"lm.gls(formula, data, W, subset, na.action, inverse = FALSE, method = \"qr\", model = FALSE, x = FALSE, y = FALSE, contrasts = NULL, ...)"},{"p":"MASS","o":"ucv","f":"hp_ucv","d":"Uses unbiased cross-validation to select the bandwidth of a Gaussian\nkernel density estimator.\n","ec":"ucv(x, nb = 1000, lower = 0.1 * hmax, upper = hmax)"},{"p":"MASS","o":"bcv","f":"hp_bcv","d":"Uses biased cross-validation to select the bandwidth of a  Gaussian\nkernel density estimator.\n","ec":"bcv(x, nb = 1000, lower = 0.1 * hmax, upper = hmax)"},{"p":"MASS","o":"neg.bin","f":"hp_neg.bin","d":"Internal MASS functions.\n","ec":"neg.bin(theta = stop(\"'theta' must be given\"))"},{"p":"MASS","o":"loglm","f":"hp_loglm","d":"This function provides a front-end to the standard function,\nloglin, to allow log-linear models to be specified and fitted\nin a manner similar to that of other fitting functions, such as\nglm.\n","ec":"loglm(formula, data, subset, na.action, ...)"},{"p":"MASS","o":"dropterm","f":"hp_dropterm","d":"Try fitting all models that differ from the current model by dropping a\nsingle term, maintaining marginality.\n","ec":"dropterm(object, ...)"},{"p":"MASS","o":"ginv","f":"hp_ginv","d":"Calculates the Moore-Penrose generalized inverse of a matrix\nX.\n","ec":"ginv(X, tol = sqrt(.Machine$double.eps))"},{"p":"MASS","o":"as.fractions","f":"hp_as.fractions","d":"Find rational approximations to the components of a real numeric\nobject using a standard continued fraction method.\n","ec":"as.fractions(x)"},{"p":"MASS","o":"dose.p","f":"hp_dose.p","d":"Calibrate binomial assays, generalizing the calculation of LD50.\n","ec":"dose.p(obj, cf = 1:2, p = 0.5)"},{"p":"MASS","o":"theta.md","f":"hp_theta.md","d":"Given the estimated mean vector, estimate theta of the\nNegative Binomial Distribution.\n","ec":"theta.md(y, mu, dfr, weights, limit = 20, eps = .Machine$double.eps^0.25)"},{"p":"MASS","o":"lmsreg","f":"hp_lmsreg","d":"Fit a regression to the good points in the dataset, thereby\nachieving a regression estimator with a high breakdown point.\nlmsreg and ltsreg are compatibility wrappers.\n","ec":"lmsreg(...)"},{"p":"MASS","o":"fractions","f":"hp_fractions","d":"Find rational approximations to the components of a real numeric\nobject using a standard continued fraction method.\n","ec":"fractions(x, cycles = 10, max.denominator = 2000, ...)"},{"p":"MASS","o":"studres","f":"hp_studres","d":"The Studentized residuals.  Like standardized residuals, these are\nnormalized to unit variance, but the Studentized version is fitted\nignoring the current data point. (They are sometimes called jackknifed\nresiduals).\n","ec":"studres(object)"},{"p":"MASS","o":"glmmPQL","f":"hp_glmmPQL","d":"Fit a GLMM model with multivariate normal random effects, using\nPenalized Quasi-Likelihood.\n","ec":"glmmPQL(fixed, random, family, data, correlation, weights, control, niter = 10, verbose = TRUE, ...)"},{"p":"MASS","o":"eqscplot","f":"hp_eqscplot","d":"Version of a scatterplot with scales chosen to be equal on both axes, that\nis 1cm represents the same units on each\n","ec":"eqscplot(x, y, ratio = 1, tol = 0.04, uin, ...)"},{"p":"MASS","o":"ldahist","f":"hp_ldahist","d":"Plot histograms or density plots of data on a single Fisher linear\ndiscriminant.\n","ec":"ldahist(data, g, nbins = 25, h, x0 = -h/1000, breaks, xlim = range(breaks), ymax = 0, width, type = c(\"histogram\", \"density\", \"both\"), sep = (type != \"density\"), col = 5L, xlab = deparse(substitute(data)), bty = \"n\", ...)"},{"p":"MASS","o":"hist.scott","f":"hp_hist.scott","d":"Plot a histogram with automatic bin width selection, using the Scott\nor Freedman<U+2013>Diaconis formulae.\n","ec":"hist.scott(x, prob = TRUE, xlab = deparse(substitute(x)), ...)"},{"p":"MASS","o":"cov.trob","f":"hp_cov.trob","d":"Estimates a covariance or correlation matrix assuming the data came\nfrom a multivariate t distribution: this provides some degree of\nrobustness to outlier without giving a high breakdown point.\n","ec":"cov.trob(x, wt = rep(1, n), cor = FALSE, center = TRUE, nu = 5, maxit = 25, tol = 0.01)"},{"p":"MASS","o":"corresp","f":"hp_corresp","d":"Find the principal canonical correlation and corresponding row- and\ncolumn-scores from a correspondence analysis of a two-way contingency\ntable.\n","ec":"corresp(x, ...)"},{"p":"MASS","o":"theta.ml","f":"hp_theta.ml","d":"Given the estimated mean vector, estimate theta of the\nNegative Binomial Distribution.\n","ec":"theta.ml(y, mu, n = sum(weights), weights, limit = 10, eps = .Machine$double.eps^0.25, trace = FALSE)"},{"p":"MASS","o":"cov.mve","f":"hp_cov.mve","d":"Compute a multivariate location and scale estimate with a high\nbreakdown point <U+2013> this can be thought of as estimating the mean and\ncovariance of the good part of the data. cov.mve and\ncov.mcd are compatibility wrappers.\n","ec":"cov.mve(...)"},{"p":"MASS","o":"gamma.shape","f":"hp_gamma.shape","d":"Find the maximum likelihood estimate of the shape parameter of\nthe gamma distribution after fitting a Gamma generalized\nlinear model.\n","ec":"gamma.shape(object, ...)"},{"p":"MASS","o":"theta.mm","f":"hp_theta.mm","d":"Given the estimated mean vector, estimate theta of the\nNegative Binomial Distribution.\n","ec":"theta.mm(y, mu, dfr, weights, limit = 10, eps = .Machine$double.eps^0.25)"},{"p":"MASS","o":"fitdistr","f":"hp_fitdistr","d":"Maximum-likelihood fitting of univariate distributions, allowing\nparameters to be held fixed if desired.\n","ec":"fitdistr(x, densfun, start, ...)"},{"p":"MASS","o":"rnegbin","f":"hp_rnegbin","d":"Function to generate random outcomes from a Negative Binomial distribution,\nwith mean mu and variance mu + mu^2/theta.\n","ec":"rnegbin(n, mu = n, theta = stop(\"'theta' must be specified\"))"},{"p":"MASS","o":"glm.convert","f":"hp_glm.convert","d":"This function modifies an output object from glm.nb() to one\nthat looks like the output from glm() with a negative binomial\nfamily.  This allows it to be updated keeping the theta parameter\nfixed.\n","ec":"glm.convert(object)"},{"p":"MASS","o":"contr.sdif","f":"hp_contr.sdif","d":"A coding for factors based on successive differences.\n","ec":"contr.sdif(n, contrasts = TRUE, sparse = FALSE)"},{"p":"MASS","o":"fbeta","f":"hp_fbeta","d":"Internal MASS functions.\n","ec":"fbeta(x, alpha, beta)"},{"p":"MASS","o":"ltsreg","f":"hp_ltsreg","d":"Fit a regression to the good points in the dataset, thereby\nachieving a regression estimator with a high breakdown point.\nlmsreg and ltsreg are compatibility wrappers.\n","ec":"ltsreg(...)"},{"p":"MASS","o":"hubers","f":"hp_hubers","d":"Finds the Huber M-estimator for location with scale specified, scale\nwith location specified, or both if neither is specified.\n","ec":"hubers(y, k = 1.5, mu, s, initmu = median(y), tol = 1e-06)"},{"p":"MASS","o":"negexp.SSival","f":"hp_negexp.SSival","d":"Internal MASS functions.\n","ec":"negexp.SSival(mCall, data, LHS)"},{"p":"MASS","o":"psi.bisquare","f":"hp_psi.bisquare","d":"Fit a linear model by robust regression using an M estimator.\n","ec":"psi.bisquare(u, c = 4.685, deriv = 0)"},{"p":"MASS","o":"truehist","f":"hp_truehist","d":"Creates a histogram on the current graphics device.\n","ec":"truehist(data, nbins = \"Scott\", h, x0 = -h/1000, breaks, prob = TRUE, xlim = range(breaks), ymax = max(est), col = \"cyan\", xlab = deparse(substitute(data)), bty = \"n\", ...)"},{"p":"MASS","o":"bandwidth.nrd","f":"hp_bandwidth.nrd","d":"A well-supported rule-of-thumb for choosing the bandwidth of a Gaussian\nkernel density estimator.\n","ec":"bandwidth.nrd(x)"},{"p":"MASS","o":"mvrnorm","f":"hp_mvrnorm","d":"Produces one or more samples from the specified\nmultivariate normal distribution.\n","ec":"mvrnorm(n = 1, mu, Sigma, tol = 1e-06, empirical = FALSE, EISPACK = FALSE)"},{"p":"MASS","o":"denumerate","f":"hp_denumerate","d":"loglm allows dimension numbers to be used in place of names in\nthe formula.  denumerate modifies such a formula into one that\nterms can process.\n","ec":"denumerate(x)"},{"p":"MASS","o":"width.SJ","f":"hp_width.SJ","d":"Uses the method of Sheather & Jones (1991) to select the bandwidth of\na Gaussian kernel density estimator.\n","ec":"width.SJ(x, nb = 1000, lower = 0.1 * hmax, upper = hmax, method = c(\"ste\", \"dpi\"))"},{"p":"MASS","o":"isoMDS","f":"hp_isoMDS","d":"One form of non-metric multidimensional scaling\n","ec":"isoMDS(d, y = cmdscale(d, k), k = 2, maxit = 50, trace = TRUE, tol = 0.001, p = 2)"},{"p":"MASS","o":"stdres","f":"hp_stdres","d":"The standardized residuals.  These are normalized to unit\nvariance, fitted including the current data point.\n","ec":"stdres(object)"},{"p":"MASS","o":"lqs.formula","f":"hp_lqs.formula","d":"Fit a regression to the good points in the dataset, thereby\nachieving a regression estimator with a high breakdown point.\nlmsreg and ltsreg are compatibility wrappers.\n","ec":"lqs.formula(formula, data, ..., method = c(\"lts\", \"lqs\", \"lms\", \"S\", \"model.frame\"), subset, na.action, model = TRUE, x.ret = FALSE, y.ret = FALSE, contrasts = NULL)"},{"p":"MASS","o":"qda","f":"hp_qda","d":"Quadratic discriminant analysis.\n","ec":"qda(x, ...)"},{"p":"Matrix","o":".__T__Logic:base","f":"hp_.__T__Logic.base","d":"-NA-","ec":""},{"p":"Matrix","o":".asmatrix","f":"hp_.asmatrix","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".asmatrix(x)"},{"p":"Matrix","o":".__C__index","f":"hp_.__C__index","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__tail:utils","f":"hp_.__T__tail.utils","d":"-NA-","ec":""},{"p":"Matrix","o":"Diagonal","f":"hp_Diagonal","d":"Construct a formally diagonal Matrix,\ni.e., an object inheriting from virtual class\ndiagonalMatrix\n(or, if desired, a mathematically diagonal\nCsparseMatrix).\n","ec":"Diagonal(n, x = NULL, names = FALSE)"},{"p":"Matrix","o":".__C__rleDiff","f":"hp_.__C__rleDiff","d":"-NA-","ec":""},{"p":"Matrix","o":"diagU2N","f":"hp_diagU2N","d":"Transform a triangular matrix x, i.e., of class\ntriangularMatrix,\nfrom (internally!) unit triangular (<U+201C>unitriangular<U+201D>) to\n<U+201C>general<U+201D> triangular (diagU2N(x)) or back (diagN2U(x)).\nNote that the latter, diagN2U(x), also sets the diagonal to one\nin cases where diag(x) was not all one.\n","ec":"diagU2N(x, cl = getClassDef(class(x)), checkDense = FALSE)"},{"p":"Matrix","o":".__T__qr.qy:base","f":"hp_.__T__qr.qy.base","d":"-NA-","ec":""},{"p":"Matrix","o":".m2lgC","f":"hp_.m2lgC","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".m2lgC(from)"},{"p":"Matrix","o":".__T__facmul:Matrix","f":"hp_.__T__facmul.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"rankMatrix","f":"hp_rankMatrix","d":"Compute <U+2018>the<U+2019> matrix rank, a well-defined functional in theory(*),\nsomewhat ambiguous in practice.  We provide several methods, the\ndefault corresponding to Matlab's definition.\n","ec":"rankMatrix(x, tol = NULL, method = c(\"tolNorm2\", \"qr.R\", \"qrLINPACK\", \"qr\", \"useGrad\", \"maybeGrad\"), sval = svd(x, 0, 0)$d, warn.t = TRUE, warn.qr = TRUE)"},{"p":"Matrix","o":".__C__lgeMatrix","f":"hp_.__C__lgeMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"%&%","f":"hp_X...","d":"For boolean or <U+201C>pattern<U+201D> matrices, i.e., R objects of\nclass nMatrix, it is natural to allow matrix\nproducts using boolean instead of numerical arithmetic.\n","ec":"%&%(x, y)"},{"p":"Matrix","o":".__C__dtrMatrix","f":"hp_.__C__dtrMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"nnzero","f":"hp_nnzero","d":"Returns the number of non-zero values of a numeric-like R object, and\nin particular an object x inheriting from class\nMatrix.\n","ec":"nnzero(x, na.counted = NA)"},{"p":"Matrix","o":".__C__dgRMatrix","f":"hp_.__C__dgRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__is.nan:base","f":"hp_.__T__is.nan.base","d":"-NA-","ec":""},{"p":"Matrix","o":"norm","f":"hp_norm","d":"Computes a matrix norm of x, using Lapack for dense matrices.\nThe norm can be the one  (\"O\", or \"1\") norm, the\ninfinity (\"I\") norm, the Frobenius  (\"F\") norm,\nthe maximum modulus (\"M\") among elements of a matrix, or the\nspectral norm or 2-norm (\"2\"), as determined by the value of\ntype.\n","ec":"norm(x, type, ...)"},{"p":"Matrix","o":".__T__isDiagonal:Matrix","f":"hp_.__T__isDiagonal.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__toeplitz:stats","f":"hp_.__T__toeplitz.stats","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__QR","f":"hp_.__C__QR","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__[<-:base","f":"hp_.__T__....base","d":"-NA-","ec":""},{"p":"Matrix","o":"uniqTsparse","f":"hp_uniqTsparse","d":"Detect or standardize a TsparseMatrix with\nunsorted or duplicated (i,j) pairs.\n","ec":"uniqTsparse(x, class.x = class(x))"},{"p":"Matrix","o":".__C__dCHMsimpl","f":"hp_.__C__dCHMsimpl","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__lspMatrix","f":"hp_.__C__lspMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__lsTMatrix","f":"hp_.__C__lsTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__sparseLU","f":"hp_.__C__sparseLU","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__format:base","f":"hp_.__T__format.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__as.array:base","f":"hp_.__T__as.array.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__rep:base","f":"hp_.__T__rep.base","d":"-NA-","ec":""},{"p":"Matrix","o":"bdiag","f":"hp_bdiag","d":"Build a block diagonal matrix given several building block matrices.\n","ec":"bdiag(...)"},{"p":"Matrix","o":"mat2triplet","f":"hp_mat2triplet","d":"From an R object coercible to \"TsparseMatrix\",\ntypically a (sparse) matrix, produce its triplet representation which may\ncollapse to a <U+201C>Duplet<U+201D> in the case of binary aka pattern, such as\n\"nMatrix\" objects.\n","ec":"mat2triplet(x, uniqT = FALSE)"},{"p":"Matrix","o":"qr2rankMatrix","f":"hp_qr2rankMatrix","d":"Compute <U+2018>the<U+2019> matrix rank, a well-defined functional in theory(*),\nsomewhat ambiguous in practice.  We provide several methods, the\ndefault corresponding to Matlab's definition.\n","ec":"qr2rankMatrix(qr, tol = NULL, isBqr = is.qr(qr), do.warn = TRUE)"},{"p":"Matrix","o":".dxC2mat","f":"hp_.dxC2mat","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".dxC2mat(from, chkUdiag)"},{"p":"Matrix","o":"rowScale","f":"hp_rowScale","d":"dimScale, rowScale, and colScale implement\nD1 %*% x %*% D2, D %*% x, and x %*% D\nfor diagonal matrices D1, D2, and D with\ndiagonal entries d1, d2, and d, respectively.\nUnlike the explicit products, these functions preserve dimnames(x)\nand symmetry where appropriate.\n","ec":"rowScale(x, d)"},{"p":"Matrix","o":"readHB","f":"hp_readHB","d":"Read matrices stored in the Harwell-Boeing or MatrixMarket formats\nor write sparseMatrix objects to one of these\nformats.\n","ec":"readHB(file)"},{"p":"Matrix","o":".trDiagonal","f":"hp_.trDiagonal","d":"Construct a formally diagonal Matrix,\ni.e., an object inheriting from virtual class\ndiagonalMatrix\n(or, if desired, a mathematically diagonal\nCsparseMatrix).\n","ec":".trDiagonal(n, x = NULL, uplo = \"U\", unitri = TRUE, kind)"},{"p":"Matrix","o":".__T__qr.coef:base","f":"hp_.__T__qr.coef.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dtTMatrix","f":"hp_.__C__dtTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dtpMatrix","f":"hp_.__C__dtpMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__zapsmall:base","f":"hp_.__T__zapsmall.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__skewpart:Matrix","f":"hp_.__T__skewpart.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"skewpart","f":"hp_skewpart","d":"symmpart(x) computes the symmetric part (x + t(x))/2 and\nskewpart(x) the\nskew symmetric part (x - t(x))/2 of a square matrix x,\nmore efficiently for specific Matrix classes.\n","ec":"skewpart(x)"},{"p":"Matrix","o":".__T__all.equal:base","f":"hp_.__T__all.equal.base","d":"-NA-","ec":""},{"p":"Matrix","o":"nearPD","f":"hp_nearPD","d":"Compute the nearest positive definite matrix to an approximate\none, typically a correlation or variance-covariance matrix.\n","ec":"nearPD(x, corr = FALSE, keepDiag = FALSE, base.matrix = FALSE, do2eigen = TRUE, doSym = FALSE, doDykstra = TRUE, only.values = FALSE, ensureSymmetry = !isSymmetric(x), eig.tol = 1e-06, conv.tol = 1e-07, posd.tol = 1e-08, maxit = 100L, conv.norm.type = \"I\", trace = FALSE)"},{"p":"Matrix","o":".__T__coerce:methods","f":"hp_.__T__coerce.methods","d":"-NA-","ec":""},{"p":"Matrix","o":"Schur","f":"hp_Schur","d":"Computes the Schur factorization of an n \\times n\nreal matrix A, which has the general form \n","ec":"Schur(x, vectors = TRUE, ...)"},{"p":"Matrix","o":".__T__as.complex:base","f":"hp_.__T__as.complex.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__anyNA:base","f":"hp_.__T__anyNA.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__lgTMatrix","f":"hp_.__C__lgTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__qr.X:base","f":"hp_.__T__qr.X.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__CsparseMatrix","f":"hp_.__C__CsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dgeMatrix","f":"hp_.__C__dgeMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__triangularMatrix","f":"hp_.__C__triangularMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__sparseVector","f":"hp_.__C__sparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__qr.resid:base","f":"hp_.__T__qr.resid.base","d":"-NA-","ec":""},{"p":"Matrix","o":"diag","f":"hp_diag","d":"-NA-","ec":"diag(x = 1, nrow, ncol, names = TRUE)"},{"p":"Matrix","o":"det","f":"hp_det","d":"The Matrix class is a class contained by all actual\nclasses in the Matrix package.  It is a <U+201C>virtual<U+201D> class.\n","ec":"det(x, ...)"},{"p":"Matrix","o":"update","f":"hp_update","d":"-NA-","ec":"update(object, ...)"},{"p":"Matrix","o":".nC2d","f":"hp_.nC2d","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".nC2d(from)"},{"p":"Matrix","o":".dense2sparse","f":"hp_.dense2sparse","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".dense2sparse(from, repr = \"C\")"},{"p":"Matrix","o":".__T__qr.R:base","f":"hp_.__T__qr.R.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dsTMatrix","f":"hp_.__C__dsTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".bdiag","f":"hp_.bdiag","d":"Build a block diagonal matrix given several building block matrices.\n","ec":".bdiag(lst)"},{"p":"Matrix","o":".__C__dspMatrix","f":"hp_.__C__dspMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__forceSymmetric:Matrix","f":"hp_.__T__forceSymmetric.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__generalMatrix","f":"hp_.__C__generalMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__show:methods","f":"hp_.__T__show.methods","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__as.vector:base","f":"hp_.__T__as.vector.base","d":"-NA-","ec":""},{"p":"Matrix","o":".nC2l","f":"hp_.nC2l","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".nC2l(from)"},{"p":"Matrix","o":".__T__rcond:base","f":"hp_.__T__rcond.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__cov2cor:stats","f":"hp_.__T__cov2cor.stats","d":"-NA-","ec":""},{"p":"Matrix","o":"zapsmall","f":"hp_zapsmall","d":"-NA-","ec":"zapsmall(x, digits = getOption(\"digits\"), mFUN = function(x, ina) max(abs(x[!ina])), min.d = 0L, ...)"},{"p":"Matrix","o":"formatSpMatrix","f":"hp_formatSpMatrix","d":"Format and print sparse matrices flexibly.  These are the <U+201C>workhorses<U+201D> used by\nthe format, show and print\nmethods for sparse matrices.  If x is large,\nprintSpMatrix2(x) calls printSpMatrix() twice, namely,\nfor the first and the last few rows, suppressing those in between, and\nalso suppresses columns when x is too wide.\n","ec":"formatSpMatrix(x, digits = NULL, maxp = 1e+09, cld = getClassDef(class(x)), zero.print = \".\", col.names, note.dropping.colnames = TRUE, uniDiag = TRUE, align = c(\"fancy\", \"right\"), ...)"},{"p":"Matrix","o":".__T__pack:Matrix","f":"hp_.__T__pack.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__tcrossprod:base","f":"hp_.__T__tcrossprod.base","d":"-NA-","ec":""},{"p":"Matrix","o":".ind2dense","f":"hp_.ind2dense","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".ind2dense(from, kind = \"n\")"},{"p":"Matrix","o":"signPerm","f":"hp_signPerm","d":"invertPerm and signPerm compute the inverse and sign\nof a length-n permutation vector.  isPerm tests\nif a length-n integer vector is a valid permutation vector.\nasPerm coerces a length-m transposition vector to a\nlength-n permutation vector, where m <= n.\n","ec":"signPerm(p, off = 1L)"},{"p":"Matrix","o":".__T__is.infinite:base","f":"hp_.__T__is.infinite.base","d":"-NA-","ec":""},{"p":"Matrix","o":"isLDL","f":"hp_isLDL","d":"CHMfactor is the virtual class of sparse Cholesky\nfactorizations of n \\times n real, symmetric\nmatrices A, having the general form\n","ec":"isLDL(x)"},{"p":"Matrix","o":".__C__CHMfactor","f":"hp_.__C__CHMfactor","d":"-NA-","ec":""},{"p":"Matrix","o":"fac2Sparse","f":"hp_fac2Sparse","d":"Construct a sparse model or <U+201C>design<U+201D> matrix,\nfrom a formula and data frame (sparse.model.matrix) or a single\nfactor (fac2sparse).\n","ec":"fac2Sparse(from, to = c(\"d\", \"l\", \"n\"), drop.unused.levels = TRUE, repr = c(\"C\", \"R\", \"T\"), giveCsparse, factorPatt12, contrasts.arg = NULL)"},{"p":"Matrix","o":".M2C","f":"hp_.M2C","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2C(from)"},{"p":"Matrix","o":".__C__lgCMatrix","f":"hp_.__C__lgCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__expand1:Matrix","f":"hp_.__T__expand1.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"colScale","f":"hp_colScale","d":"dimScale, rowScale, and colScale implement\nD1 %*% x %*% D2, D %*% x, and x %*% D\nfor diagonal matrices D1, D2, and D with\ndiagonal entries d1, d2, and d, respectively.\nUnlike the explicit products, these functions preserve dimnames(x)\nand symmetry where appropriate.\n","ec":"colScale(x, d)"},{"p":"Matrix","o":".__C__dgTMatrix","f":"hp_.__C__dgTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__BunchKaufman:Matrix","f":"hp_.__T__BunchKaufman.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"printSpMatrix","f":"hp_printSpMatrix","d":"Format and print sparse matrices flexibly.  These are the <U+201C>workhorses<U+201D> used by\nthe format, show and print\nmethods for sparse matrices.  If x is large,\nprintSpMatrix2(x) calls printSpMatrix() twice, namely,\nfor the first and the last few rows, suppressing those in between, and\nalso suppresses columns when x is too wide.\n","ec":"printSpMatrix(x, digits = NULL, maxp = max(100L, getOption(\"max.print\")), cld = getClassDef(class(x)), zero.print = \".\", col.names, note.dropping.colnames = TRUE, uniDiag = TRUE, col.trailer = \"\", align = c(\"fancy\", \"right\"), ...)"},{"p":"Matrix","o":".SuiteSparse_version","f":"hp_.SuiteSparse_version","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".SuiteSparse_version()"},{"p":"Matrix","o":"isSymmetric","f":"hp_isSymmetric","d":"isSymmetric tests whether its argument is a symmetric square\nmatrix, by default tolerating some numerical fuzz and requiring\nsymmetric [dD]imnames in addition to symmetry in the\nmathematical sense.  isSymmetric is a generic function in\nbase, which has a method for traditional\nmatrices of implicit class \"matrix\".\nMethods are defined here for various proper and virtual classes\nin Matrix, so that isSymmetric works for all objects\ninheriting from virtual class \"Matrix\".\n","ec":"isSymmetric(object, ...)"},{"p":"Matrix","o":".__C__BunchKaufman","f":"hp_.__C__BunchKaufman","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__%&%:Matrix","f":"hp_.__T__....Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"fac2sparse","f":"hp_fac2sparse","d":"Construct a sparse model or <U+201C>design<U+201D> matrix,\nfrom a formula and data frame (sparse.model.matrix) or a single\nfactor (fac2sparse).\n","ec":"fac2sparse(from, to = c(\"d\", \"l\", \"n\"), drop.unused.levels = TRUE, repr = c(\"C\", \"R\", \"T\"), giveCsparse)"},{"p":"Matrix","o":"qr.resid","f":"hp_qr.resid","d":"-NA-","ec":"qr.resid(qr, y)"},{"p":"Matrix","o":".M2R","f":"hp_.M2R","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2R(from)"},{"p":"Matrix","o":".__C__lsyMatrix","f":"hp_.__C__lsyMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".CR2RC","f":"hp_.CR2RC","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".CR2RC(from)"},{"p":"Matrix","o":".__T__expand2:Matrix","f":"hp_.__T__expand2.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".M2T","f":"hp_.M2T","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2T(from)"},{"p":"Matrix","o":".__C__SchurFactorization","f":"hp_.__C__SchurFactorization","d":"-NA-","ec":""},{"p":"Matrix","o":".tCR2RC","f":"hp_.tCR2RC","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".tCR2RC(from)"},{"p":"Matrix","o":".__C__sparseQR","f":"hp_.__C__sparseQR","d":"-NA-","ec":""},{"p":"Matrix","o":".M2V","f":"hp_.M2V","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2V(from)"},{"p":"Matrix","o":".__T__cbind2:methods","f":"hp_.__T__cbind2.methods","d":"-NA-","ec":""},{"p":"Matrix","o":"T2graph","f":"hp_T2graph","d":"Since 2005, package Matrix has supported coercions to and\nfrom class graph from package\ngraph.\nSince 2013, this functionality has been exposed via functions\nT2graph and graph2T, which, unlike methods for\nas(from, \"<Class>\"), support optional arguments.\n","ec":"T2graph(from, need.uniq = !isUniqueT(from), edgemode = NULL)"},{"p":"Matrix","o":"toeplitz","f":"hp_toeplitz","d":"-NA-","ec":"toeplitz(x, ...)"},{"p":"Matrix","o":".__C__CholeskyFactorization","f":"hp_.__C__CholeskyFactorization","d":"-NA-","ec":""},{"p":"Matrix","o":"unpack","f":"hp_unpack","d":"pack() coerces dense symmetric and dense triangular matrices\nfrom unpacked format (storing the full matrix) to packed format\n(storing only one of the upper and lower triangles).  unpack()\nperforms the reverse coercion. The two formats are formalized\nby the virtual classes \"packedMatrix\" and\n\"unpackedMatrix\".\n","ec":"unpack(x, ...)"},{"p":"Matrix","o":".__T__drop:base","f":"hp_.__T__drop.base","d":"-NA-","ec":""},{"p":"Matrix","o":"qr.qy","f":"hp_qr.qy","d":"-NA-","ec":"qr.qy(qr, y)"},{"p":"Matrix","o":"rep2abI","f":"hp_rep2abI","d":"rep2abI(x, times) conceptually computes\nrep.int(x, times) but with an\nabIndex class result.\n","ec":"rep2abI(x, times)"},{"p":"Matrix","o":".__C__dgCMatrix","f":"hp_.__C__dgCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".M2gen","f":"hp_.M2gen","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2gen(from, kind = \".\")"},{"p":"Matrix","o":".M2packed","f":"hp_.M2packed","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2packed(from)"},{"p":"Matrix","o":"drop0","f":"hp_drop0","d":"Deletes <U+201C>non-structural<U+201D> zeros (i.e., zeros stored explicitly,\nin memory) from a sparse matrix and returns the result.\n","ec":"drop0(x, tol = 0, is.Csparse = NA, give.Csparse = TRUE)"},{"p":"Matrix","o":".__T__updown:Matrix","f":"hp_.__T__updown.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__nnzero:Matrix","f":"hp_.__T__nnzero.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__RsparseMatrix","f":"hp_.__C__RsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"formatSparseM","f":"hp_formatSparseM","d":"Utilities for formatting sparse numeric matrices in a flexible way.\nThese functions are used by the format and print\nmethods for sparse matrices and can be applied as well to standard R\nmatrices.  Note that all arguments but the first are optional.\n","ec":"formatSparseM(x, zero.print = \".\", align = c(\"fancy\", \"right\"), m = as(x, \"matrix\"), asLogical = NULL, uniDiag = NULL, digits = NULL, cx, iN0, dn = dimnames(m))"},{"p":"Matrix","o":".__C__diagonalMatrix","f":"hp_.__C__diagonalMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__indMatrix","f":"hp_.__C__indMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"Matrix.Version","f":"hp_Matrix.Version","d":"The Matrix class is a class contained by all actual\nclasses in the Matrix package.  It is a <U+201C>virtual<U+201D> class.\n","ec":"Matrix.Version()"},{"p":"Matrix","o":"Hilbert","f":"hp_Hilbert","d":"Generate the n by n symmetric Hilbert matrix.  Because\nthese matrices are ill-conditioned for moderate to large n,\nthey are often used for testing numerical linear algebra code.\n","ec":"Hilbert(n)"},{"p":"Matrix","o":"abIseq1","f":"hp_abIseq1","d":"Generation of abstract index vectors, i.e., objects of class\n\"abIndex\".\n","ec":"abIseq1(from = 1, to = 1)"},{"p":"Matrix","o":".__C__dsyMatrix","f":"hp_.__C__dsyMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".M2m","f":"hp_.M2m","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2m(from)"},{"p":"Matrix","o":".__T__log:base","f":"hp_.__T__log.base","d":"-NA-","ec":""},{"p":"Matrix","o":".validateCsparse","f":"hp_.validateCsparse","d":"The \"CsparseMatrix\" class is the virtual class of\nall sparse matrices coded in sorted compressed column-oriented form.\nSince it is a virtual class, no objects may be created from it.  See\nshowClass(\"CsparseMatrix\") for its subclasses.\n","ec":".validateCsparse(x, sort.if.needed = FALSE)"},{"p":"Matrix","o":".__C__ntRMatrix","f":"hp_.__C__ntRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".m2sparse","f":"hp_.m2sparse","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".m2sparse(from, class = \".gC\", uplo = \"U\", diag = \"N\", trans = FALSE)"},{"p":"Matrix","o":"cov2cor","f":"hp_cov2cor","d":"-NA-","ec":"cov2cor(V)"},{"p":"Matrix","o":".C2nC","f":"hp_.C2nC","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".C2nC(from, isTri)"},{"p":"Matrix","o":"writeMM","f":"hp_writeMM","d":"Read matrices stored in the Harwell-Boeing or MatrixMarket formats\nor write sparseMatrix objects to one of these\nformats.\n","ec":"writeMM(obj, file, ...)"},{"p":"Matrix","o":".__C__TsparseMatrix","f":"hp_.__C__TsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"symmpart","f":"hp_symmpart","d":"symmpart(x) computes the symmetric part (x + t(x))/2 and\nskewpart(x) the\nskew symmetric part (x - t(x))/2 of a square matrix x,\nmore efficiently for specific Matrix classes.\n","ec":"symmpart(x)"},{"p":"Matrix","o":".M2sym","f":"hp_.M2sym","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2sym(from, ...)"},{"p":"Matrix","o":"chol2inv","f":"hp_chol2inv","d":"Given formally upper and lower triangular matrices\nU and L, compute (U' U)^{-1}\nand (L L')^{-1}, respectively.\n","ec":"chol2inv(x, ...)"},{"p":"Matrix","o":".M2v","f":"hp_.M2v","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2v(from)"},{"p":"Matrix","o":".__C__ntCMatrix","f":"hp_.__C__ntCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"band","f":"hp_band","d":"Return the matrix obtained by setting to zero elements below a diagonal\n(triu), above a diagonal (tril), or outside of a general\nband (band).\n","ec":"band(x, k1, k2, ...)"},{"p":"Matrix","o":".__C__nCHMsimpl","f":"hp_.__C__nCHMsimpl","d":"-NA-","ec":""},{"p":"Matrix","o":"anyDuplicatedT","f":"hp_anyDuplicatedT","d":"Detect or standardize a TsparseMatrix with\nunsorted or duplicated (i,j) pairs.\n","ec":"anyDuplicatedT(x, ...)"},{"p":"Matrix","o":".__T__Arith:base","f":"hp_.__T__Arith.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__pBunchKaufman","f":"hp_.__C__pBunchKaufman","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__atomicVector","f":"hp_.__C__atomicVector","d":"-NA-","ec":""},{"p":"Matrix","o":".solve.dgC.lu","f":"hp_.solve.dgC.lu","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".solve.dgC.lu(a, b, tol = .Machine$double.eps, check = TRUE)"},{"p":"Matrix","o":"asUniqueT","f":"hp_asUniqueT","d":"Detect or standardize a TsparseMatrix with\nunsorted or duplicated (i,j) pairs.\n","ec":"asUniqueT(x, byrow = FALSE, isT = is(x, \"TsparseMatrix\"))"},{"p":"Matrix","o":"readMM","f":"hp_readMM","d":"Read matrices stored in the Harwell-Boeing or MatrixMarket formats\nor write sparseMatrix objects to one of these\nformats.\n","ec":"readMM(file)"},{"p":"Matrix","o":"diff","f":"hp_diff","d":"-NA-","ec":"diff(x, ...)"},{"p":"Matrix","o":"Cholesky","f":"hp_Cholesky","d":"Computes the pivoted Cholesky factorization of an\nn \\times n real, symmetric matrix A,\nwhich has the general form\n","ec":"Cholesky(A, ...)"},{"p":"Matrix","o":".__T__triu:Matrix","f":"hp_.__T__triu.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__replValue","f":"hp_.__C__replValue","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nsRMatrix","f":"hp_.__C__nsRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__writeMM:Matrix","f":"hp_.__T__writeMM.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"abIseq","f":"hp_abIseq","d":"Generation of abstract index vectors, i.e., objects of class\n\"abIndex\".\n","ec":"abIseq(from = 1, to = 1, by = ((to - from)/(length.out - 1)), length.out = NULL, along.with = NULL)"},{"p":"Matrix","o":"t","f":"hp_t","d":"-NA-","ec":"t(x)"},{"p":"Matrix","o":".formatSparseSimple","f":"hp_.formatSparseSimple","d":"Utilities for formatting sparse numeric matrices in a flexible way.\nThese functions are used by the format and print\nmethods for sparse matrices and can be applied as well to standard R\nmatrices.  Note that all arguments but the first are optional.\n","ec":".formatSparseSimple(m, asLogical = FALSE, digits = NULL, col.names, note.dropping.colnames = TRUE, dn = dimnames(m))"},{"p":"Matrix","o":"invertPerm","f":"hp_invertPerm","d":"invertPerm and signPerm compute the inverse and sign\nof a length-n permutation vector.  isPerm tests\nif a length-n integer vector is a valid permutation vector.\nasPerm coerces a length-m transposition vector to a\nlength-n permutation vector, where m <= n.\n","ec":"invertPerm(p, off = 1L, ioff = 1L)"},{"p":"Matrix","o":".__C__lsCMatrix","f":"hp_.__C__lsCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dsparseMatrix","f":"hp_.__C__dsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nsparseMatrix","f":"hp_.__C__nsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__*:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":"condest","f":"hp_condest","d":"<U+201C>Estimate<U+201D>, i.e. compute approximately the CONDition number of\na (potentially large, often sparse) matrix A.\nIt works by apply a fast randomized approximation of the 1-norm,\nnorm(A,\"1\"), through onenormest(.).\n","ec":"condest(A, t = min(n, 5), normA = norm(A, \"1\"), silent = FALSE, quiet = TRUE)"},{"p":"Matrix","o":"summary","f":"hp_summary","d":"-NA-","ec":"summary(object, ...)"},{"p":"Matrix","o":"asPerm","f":"hp_asPerm","d":"invertPerm and signPerm compute the inverse and sign\nof a length-n permutation vector.  isPerm tests\nif a length-n integer vector is a valid permutation vector.\nasPerm coerces a length-m transposition vector to a\nlength-n permutation vector, where m <= n.\n","ec":"asPerm(pivot, off = 1L, ioff = 1L, n = length(pivot))"},{"p":"Matrix","o":".__T__&:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":"isPerm","f":"hp_isPerm","d":"invertPerm and signPerm compute the inverse and sign\nof a length-n permutation vector.  isPerm tests\nif a length-n integer vector is a valid permutation vector.\nasPerm coerces a length-m transposition vector to a\nlength-n permutation vector, where m <= n.\n","ec":"isPerm(p, off = 1L)"},{"p":"Matrix","o":".__T__band:Matrix","f":"hp_.__T__band.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"unname","f":"hp_unname","d":"-NA-","ec":"unname(obj, force = FALSE)"},{"p":"Matrix","o":"expm","f":"hp_expm","d":"Compute the exponential of a matrix.\n","ec":"expm(x)"},{"p":"Matrix","o":".diagU2N","f":"hp_.diagU2N","d":"Transform a triangular matrix x, i.e., of class\ntriangularMatrix,\nfrom (internally!) unit triangular (<U+201C>unitriangular<U+201D>) to\n<U+201C>general<U+201D> triangular (diagU2N(x)) or back (diagN2U(x)).\nNote that the latter, diagN2U(x), also sets the diagonal to one\nin cases where diag(x) was not all one.\n","ec":".diagU2N(x, cl = getClassDef(class(x)), checkDense = FALSE)"},{"p":"Matrix","o":".__C__ntrMatrix","f":"hp_.__C__ntrMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Compare:methods","f":"hp_.__T__Compare.methods","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ngRMatrix","f":"hp_.__C__ngRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__pMatrix","f":"hp_.__C__pMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"expand","f":"hp_expand","d":"expand1 and expand2 construct matrix factors from\nobjects specifying matrix factorizations.  Such objects typically\ndo not store the factors explicitly, employing instead a compact\nrepresentation to save memory.\n","ec":"expand(x, ...)"},{"p":"Matrix","o":"BunchKaufman","f":"hp_BunchKaufman","d":"Computes the Bunch-Kaufman factorization of an n \\times n\nreal, symmetric matrix A, which has the general form\n","ec":"BunchKaufman(x, ...)"},{"p":"Matrix","o":".__C__dCHMsuper","f":"hp_.__C__dCHMsuper","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__colSums:base","f":"hp_.__T__colSums.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Math2:methods","f":"hp_.__T__Math2.methods","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__sparseMatrix","f":"hp_.__C__sparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__diff:base","f":"hp_.__T__diff.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__t:base","f":"hp_.__T__t.base","d":"-NA-","ec":""},{"p":"Matrix","o":"print","f":"hp_print","d":"-NA-","ec":"print(x, ...)"},{"p":"Matrix","o":".__C__dsCMatrix","f":"hp_.__C__dsCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__qr:base","f":"hp_.__T__qr.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dpoMatrix","f":"hp_.__C__dpoMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ntTMatrix","f":"hp_.__C__ntTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"graph2T","f":"hp_graph2T","d":"Since 2005, package Matrix has supported coercions to and\nfrom class graph from package\ngraph.\nSince 2013, this functionality has been exposed via functions\nT2graph and graph2T, which, unlike methods for\nas(from, \"<Class>\"), support optional arguments.\n","ec":"graph2T(from, use.weights = graph.has.weights(from) && graph.non.1.weights(from))"},{"p":"Matrix","o":".__C__ntpMatrix","f":"hp_.__C__ntpMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__dim:base","f":"hp_.__T__dim.base","d":"-NA-","ec":""},{"p":"Matrix","o":"as.matrix","f":"hp_as.matrix","d":"-NA-","ec":"as.matrix(x, ...)"},{"p":"Matrix","o":".__C__ldiMatrix","f":"hp_.__C__ldiMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__isSymmetric:base","f":"hp_.__T__isSymmetric.base","d":"-NA-","ec":""},{"p":"Matrix","o":"invPerm","f":"hp_invPerm","d":"invertPerm and signPerm compute the inverse and sign\nof a length-n permutation vector.  isPerm tests\nif a length-n integer vector is a valid permutation vector.\nasPerm coerces a length-m transposition vector to a\nlength-n permutation vector, where m <= n.\n","ec":"invPerm(p, zero.p = FALSE, zero.res = FALSE)"},{"p":"Matrix","o":".n2dgT","f":"hp_.n2dgT","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".n2dgT(from)"},{"p":"Matrix","o":"qr.Q","f":"hp_qr.Q","d":"-NA-","ec":"qr.Q(qr, complete = FALSE, Dvec)"},{"p":"Matrix","o":"KhatriRao","f":"hp_KhatriRao","d":"Computes Khatri-Rao products for any kind of matrices.\n","ec":"KhatriRao(X, Y = X, FUN = \"*\", sparseY = TRUE, make.dimnames = FALSE)"},{"p":"Matrix","o":"qr.R","f":"hp_qr.R","d":"-NA-","ec":"qr.R(qr, complete = FALSE, ...)"},{"p":"Matrix","o":".__C__ngeMatrix","f":"hp_.__C__ngeMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".M2unpacked","f":"hp_.M2unpacked","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2unpacked(from)"},{"p":"Matrix","o":".__T__diag<-:base","f":"hp_.__T__diag...base","d":"-NA-","ec":""},{"p":"Matrix","o":"mean","f":"hp_mean","d":"-NA-","ec":"mean(x, ...)"},{"p":"Matrix","o":"lu","f":"hp_lu","d":"Computes the pivoted LU factorization of an m \\times n\nreal matrix A, which has the general form\n","ec":"lu(x, ...)"},{"p":"Matrix","o":".__T__update:stats","f":"hp_.__T__update.stats","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__as.numeric:base","f":"hp_.__T__as.numeric.base","d":"-NA-","ec":""},{"p":"Matrix","o":"colSums","f":"hp_colSums","d":"Form row and column sums and means for\nobjects, for sparseMatrix the result may\noptionally be sparse (sparseVector), too.\nRow or column names are kept respectively as for base matrices\nand colSums methods, when the result is\nnumeric vector.\n","ec":"colSums(x, na.rm = FALSE, dims = 1, ...)"},{"p":"Matrix","o":"sparseVector","f":"hp_sparseVector","d":"User friendly construction of sparse vectors,\ni.e., objects inheriting from class\nsparseVector, from indices and values of its\nnon-zero entries.\n","ec":"sparseVector(x, i, length)"},{"p":"Matrix","o":".__T__length:base","f":"hp_.__T__length.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__which:base","f":"hp_.__T__which.base","d":"-NA-","ec":""},{"p":"Matrix","o":"qr.X","f":"hp_qr.X","d":"-NA-","ec":"qr.X(qr, complete = FALSE, ncol, ...)"},{"p":"Matrix","o":".__C__nsTMatrix","f":"hp_.__C__nsTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nspMatrix","f":"hp_.__C__nspMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"is.null.DN","f":"hp_is.null.DN","d":"Are the dimnames dn NULL-like?\n","ec":"is.null.DN(dn)"},{"p":"Matrix","o":"qrR","f":"hp_qrR","d":"sparseQR is the class of sparse, row- and column-pivoted\nQR factorizations of m \\times n (m \\ge n)\nreal matrices, having the general form\n","ec":"qrR(qr, complete = FALSE, backPermute = TRUE, row.names = TRUE)"},{"p":"Matrix","o":".__T__^:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__lsparseMatrix","f":"hp_.__C__lsparseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dppMatrix","f":"hp_.__C__dppMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"qr.coef","f":"hp_qr.coef","d":"-NA-","ec":"qr.coef(qr, y)"},{"p":"Matrix","o":"..2dge","f":"hp_..2dge","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":"..2dge(from)"},{"p":"Matrix","o":".tCRT","f":"hp_.tCRT","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".tCRT(x, lazy = TRUE)"},{"p":"Matrix","o":"sparse.model.matrix","f":"hp_sparse.model.matrix","d":"Construct a sparse model or <U+201C>design<U+201D> matrix,\nfrom a formula and data frame (sparse.model.matrix) or a single\nfactor (fac2sparse).\n","ec":"sparse.model.matrix(object, data = environment(object), contrasts.arg = NULL, xlev = NULL, transpose = FALSE, drop.unused.levels = FALSE, row.names = TRUE, sep = \"\", verbose = FALSE, ...)"},{"p":"Matrix","o":".__C__MatrixFactorization","f":"hp_.__C__MatrixFactorization","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__mean:base","f":"hp_.__T__mean.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__%*%:base","f":"hp_.__T__....base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__symmpart:Matrix","f":"hp_.__T__symmpart.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__lu:Matrix","f":"hp_.__T__lu.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ddiMatrix","f":"hp_.__C__ddiMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__symmetricMatrix","f":"hp_.__C__symmetricMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".m2V","f":"hp_.m2V","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".m2V(from, kind = \".\")"},{"p":"Matrix","o":"format","f":"hp_format","d":"-NA-","ec":"format(x, ...)"},{"p":"Matrix","o":".__C__ngTMatrix","f":"hp_.__C__ngTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__as.logical:base","f":"hp_.__T__as.logical.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__%/%:base","f":"hp_.__T__....base","d":"-NA-","ec":""},{"p":"Matrix","o":".m2ngC","f":"hp_.m2ngC","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".m2ngC(from)"},{"p":"Matrix","o":".m2ngTn","f":"hp_.m2ngTn","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".m2ngTn(from, na.is.not.0 = FALSE)"},{"p":"Matrix","o":".__T__image:graphics","f":"hp_.__T__image.graphics","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__kronecker:base","f":"hp_.__T__kronecker.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__rbind2:methods","f":"hp_.__T__rbind2.methods","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Cholesky:Matrix","f":"hp_.__T__Cholesky.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ddenseMatrix","f":"hp_.__C__ddenseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Schur:Matrix","f":"hp_.__T__Schur.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__head:utils","f":"hp_.__T__head.utils","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__as.integer:base","f":"hp_.__T__as.integer.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__expm:Matrix","f":"hp_.__T__expm.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"rcond","f":"hp_rcond","d":"Estimate the reciprocal of the condition number of a matrix.\n","ec":"rcond(x, norm, ...)"},{"p":"Matrix","o":".diagN2U","f":"hp_.diagN2U","d":"Transform a triangular matrix x, i.e., of class\ntriangularMatrix,\nfrom (internally!) unit triangular (<U+201C>unitriangular<U+201D>) to\n<U+201C>general<U+201D> triangular (diagU2N(x)) or back (diagN2U(x)).\nNote that the latter, diagN2U(x), also sets the diagonal to one\nin cases where diag(x) was not all one.\n","ec":".diagN2U(x, cl = getClassDef(class(x)), checkDense = FALSE)"},{"p":"Matrix","o":".__C__abIndex","f":"hp_.__C__abIndex","d":"-NA-","ec":""},{"p":"Matrix","o":"isUniqueT","f":"hp_isUniqueT","d":"Detect or standardize a TsparseMatrix with\nunsorted or duplicated (i,j) pairs.\n","ec":"isUniqueT(x, byrow = FALSE, isT = is(x, \"TsparseMatrix\"))"},{"p":"Matrix","o":"diag<-","f":"hp_diag..","d":"-NA-","ec":"diag<-(x, value)"},{"p":"Matrix","o":"dimScale","f":"hp_dimScale","d":"dimScale, rowScale, and colScale implement\nD1 %*% x %*% D2, D %*% x, and x %*% D\nfor diagonal matrices D1, D2, and D with\ndiagonal entries d1, d2, and d, respectively.\nUnlike the explicit products, these functions preserve dimnames(x)\nand symmetry where appropriate.\n","ec":"dimScale(x, d1 = sqrt(1/diag(x, names = FALSE)), d2 = d1)"},{"p":"Matrix","o":"facmul","f":"hp_facmul","d":"Multiplies a matrix or vector on the left or right by a factor\nfrom a matrix factorization or its transpose.\n","ec":"facmul(x, factor, y, trans = FALSE, left = TRUE, ...)"},{"p":"Matrix","o":".__C__lMatrix","f":"hp_.__C__lMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__chol:base","f":"hp_.__T__chol.base","d":"-NA-","ec":""},{"p":"Matrix","o":"rowMeans","f":"hp_rowMeans","d":"Form row and column sums and means for\nobjects, for sparseMatrix the result may\noptionally be sparse (sparseVector), too.\nRow or column names are kept respectively as for base matrices\nand colSums methods, when the result is\nnumeric vector.\n","ec":"rowMeans(x, na.rm = FALSE, dims = 1, ...)"},{"p":"Matrix","o":".__C__ngCMatrix","f":"hp_.__C__ngCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".dense2sy","f":"hp_.dense2sy","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".dense2sy(from, ...)"},{"p":"Matrix","o":"which","f":"hp_which","d":"-NA-","ec":"which(x, arr.ind = FALSE, useNames = TRUE)"},{"p":"Matrix","o":".__T__qr.Q:base","f":"hp_.__T__qr.Q.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Ops:base","f":"hp_.__T__Ops.base","d":"-NA-","ec":""},{"p":"Matrix","o":"bandSparse","f":"hp_bandSparse","d":"Construct a sparse banded matrix by specifying its non-zero sup- and\nsuper-diagonals.\n","ec":"bandSparse(n, m = n, k, diagonals, symmetric = FALSE, repr = \"C\", giveCsparse = (repr == \"C\"))"},{"p":"Matrix","o":".dense2kind","f":"hp_.dense2kind","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".dense2kind(from, kind)"},{"p":"Matrix","o":".__C__LU","f":"hp_.__C__LU","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__compMatrix","f":"hp_.__C__compMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__chol2inv:base","f":"hp_.__T__chol2inv.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__unname:base","f":"hp_.__T__unname.base","d":"-NA-","ec":""},{"p":"Matrix","o":"drop","f":"hp_drop","d":"-NA-","ec":"drop(x)"},{"p":"Matrix","o":".__C__zMatrix","f":"hp_.__C__zMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nMatrix","f":"hp_.__C__nMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dsparseVector","f":"hp_.__C__dsparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__Matrix","f":"hp_.__C__Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"MatrixClass","f":"hp_MatrixClass","d":"Return the (maybe super-)class of class cl from\npackage Matrix, returning character(0) if there is none.\n","ec":"MatrixClass(cl, cld = getClassDef(cl), ...Matrix = TRUE, dropVirtual = TRUE, ...)"},{"p":"Matrix","o":".__C__nsyMatrix","f":"hp_.__C__nsyMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__iMatrix","f":"hp_.__C__iMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".diag.dsC","f":"hp_.diag.dsC","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".diag.dsC(x, Chx = Cholesky(x, LDL = TRUE), res.kind = \"diag\")"},{"p":"Matrix","o":".solve.dgC.qr","f":"hp_.solve.dgC.qr","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".solve.dgC.qr(a, b, order = 3L, check = TRUE)"},{"p":"Matrix","o":"rowSums","f":"hp_rowSums","d":"Form row and column sums and means for\nobjects, for sparseMatrix the result may\noptionally be sparse (sparseVector), too.\nRow or column names are kept respectively as for base matrices\nand colSums methods, when the result is\nnumeric vector.\n","ec":"rowSums(x, na.rm = FALSE, dims = 1, ...)"},{"p":"Matrix","o":"qr.fitted","f":"hp_qr.fitted","d":"-NA-","ec":"qr.fitted(qr, y, k = qr$rank)"},{"p":"Matrix","o":".__C__unpackedMatrix","f":"hp_.__C__unpackedMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__denseMatrix","f":"hp_.__C__denseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__Math:base","f":"hp_.__T__Math.base","d":"-NA-","ec":""},{"p":"Matrix","o":"head","f":"hp_head","d":"-NA-","ec":"head(x, ...)"},{"p":"Matrix","o":".__T__unpack:Matrix","f":"hp_.__T__unpack.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__Cholesky","f":"hp_.__C__Cholesky","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__dimnames:base","f":"hp_.__T__dimnames.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__%%:base","f":"hp_.__T__...base","d":"-NA-","ec":""},{"p":"Matrix","o":".m2dense","f":"hp_.m2dense","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".m2dense(from, class = \".ge\", uplo = \"U\", diag = \"N\", trans = FALSE)"},{"p":"Matrix","o":"aggregateT","f":"hp_aggregateT","d":"Detect or standardize a TsparseMatrix with\nunsorted or duplicated (i,j) pairs.\n","ec":"aggregateT(x)"},{"p":"Matrix","o":"all.equal","f":"hp_all.equal","d":"Methods for function all.equal() (from R package\nbase) are defined for all Matrix classes.\n","ec":"all.equal(target, current, ...)"},{"p":"Matrix","o":".__T__is.na:base","f":"hp_.__T__is.na.base","d":"-NA-","ec":""},{"p":"Matrix","o":"qr","f":"hp_qr","d":"Computes the pivoted QR factorization of an m \\times n\nreal matrix A, which has the general form\n","ec":"qr(x, ...)"},{"p":"Matrix","o":"diagN2U","f":"hp_diagN2U","d":"Transform a triangular matrix x, i.e., of class\ntriangularMatrix,\nfrom (internally!) unit triangular (<U+201C>unitriangular<U+201D>) to\n<U+201C>general<U+201D> triangular (diagU2N(x)) or back (diagN2U(x)).\nNote that the latter, diagN2U(x), also sets the diagonal to one\nin cases where diag(x) was not all one.\n","ec":"diagN2U(x, cl = getClassDef(class(x)), checkDense = FALSE)"},{"p":"Matrix","o":"printSpMatrix2","f":"hp_printSpMatrix2","d":"Format and print sparse matrices flexibly.  These are the <U+201C>workhorses<U+201D> used by\nthe format, show and print\nmethods for sparse matrices.  If x is large,\nprintSpMatrix2(x) calls printSpMatrix() twice, namely,\nfor the first and the last few rows, suppressing those in between, and\nalso suppresses columns when x is too wide.\n","ec":"printSpMatrix2(x, digits = NULL, maxp = max(100L, getOption(\"max.print\")), zero.print = \".\", col.names, note.dropping.colnames = TRUE, uniDiag = TRUE, suppRows = NULL, suppCols = NULL, col.trailer = if (suppCols) \"......\" else \"\", align = c(\"fancy\", \"right\"), width = getOption(\"width\"), fitWidth = TRUE, ...)"},{"p":"Matrix","o":".__T__isTriangular:Matrix","f":"hp_.__T__isTriangular.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":"spMatrix","f":"hp_spMatrix","d":"User friendly construction of a sparse matrix (inheriting from class\nTsparseMatrix) from the triplet representation.\n","ec":"spMatrix(nrow, ncol, i = integer(0L), j = integer(0L), x = double(0L))"},{"p":"Matrix","o":".M2tri","f":"hp_.M2tri","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2tri(from, ...)"},{"p":"Matrix","o":".__C__dMatrix","f":"hp_.__C__dMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nsparseVector","f":"hp_.__C__nsparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__corMatrix","f":"hp_.__C__corMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".T2Cmat","f":"hp_.T2Cmat","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".T2Cmat(from, isTri)"},{"p":"Matrix","o":".__C__CHMsimpl","f":"hp_.__C__CHMsimpl","d":"-NA-","ec":""},{"p":"Matrix","o":".diag2sparse","f":"hp_.diag2sparse","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".diag2sparse(from, kind = \".\", shape = \"t\", repr = \"C\", uplo = \"U\")"},{"p":"Matrix","o":"c.sparseVector","f":"hp_c.sparseVector","d":"Sparse Vector Classes: The virtual mother class\n\"sparseVector\" has the five actual daughter classes\n\"dsparseVector\", \"isparseVector\",\n\"lsparseVector\", \"nsparseVector\", and\n\"zsparseVector\", where we've mainly implemented methods for\nthe d*, l* and n* ones.\n","ec":"c.sparseVector(...)"},{"p":"Matrix","o":".diag2sT","f":"hp_.diag2sT","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".diag2sT(from, uplo = \"U\", kind = \".\", drop0 = TRUE)"},{"p":"Matrix","o":"onenormest","f":"hp_onenormest","d":"<U+201C>Estimate<U+201D>, i.e. compute approximately the CONDition number of\na (potentially large, often sparse) matrix A.\nIt works by apply a fast randomized approximation of the 1-norm,\nnorm(A,\"1\"), through onenormest(.).\n","ec":"onenormest(A, t = min(n, 5), A.x, At.x, n, silent = FALSE, quiet = silent, iter.max = 10, eps = 4 * .Machine$double.eps)"},{"p":"Matrix","o":"forceSymmetric","f":"hp_forceSymmetric","d":"Force a square matrix x to a symmetricMatrix,\nwithout a symmetry check as it would be applied for as(x,\n    \"symmetricMatrix\").\n","ec":"forceSymmetric(x, uplo)"},{"p":"Matrix","o":".__C__lsparseVector","f":"hp_.__C__lsparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__dim<-:base","f":"hp_.__T__dim...base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__summary:base","f":"hp_.__T__summary.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__copMatrix","f":"hp_.__C__copMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__diag:base","f":"hp_.__T__diag.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nsCMatrix","f":"hp_.__C__nsCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__qr.fitted:base","f":"hp_.__T__qr.fitted.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__is.finite:base","f":"hp_.__T__is.finite.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__tril:Matrix","f":"hp_.__T__tril.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__isparseVector","f":"hp_.__C__isparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":"tril","f":"hp_tril","d":"Return the matrix obtained by setting to zero elements below a diagonal\n(triu), above a diagonal (tril), or outside of a general\nband (band).\n","ec":"tril(x, k = 0L, ...)"},{"p":"Matrix","o":".__T__expand:Matrix","f":"hp_.__T__expand.Matrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__norm:base","f":"hp_.__T__norm.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__pCholesky","f":"hp_.__C__pCholesky","d":"-NA-","ec":""},{"p":"Matrix","o":".diag2tT","f":"hp_.diag2tT","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".diag2tT(from, uplo = \"U\", kind = \".\", drop0 = TRUE)"},{"p":"Matrix","o":".CR2T","f":"hp_.CR2T","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".CR2T(from)"},{"p":"Matrix","o":".__C__CHMsuper","f":"hp_.__C__CHMsuper","d":"-NA-","ec":""},{"p":"Matrix","o":"rsparsematrix","f":"hp_rsparsematrix","d":"Generate a random sparse matrix efficiently.  The default has rounded\ngaussian non-zero entries, and rand.x = NULL generates random\npattern matrices, i.e. inheriting from nsparseMatrix.\n","ec":"rsparsematrix(nrow, ncol, density, nnz = round(density * maxE), symmetric = FALSE, rand.x = function(n) signif(rnorm(n), 2L), ...)"},{"p":"Matrix","o":".__T__rowSums:base","f":"hp_.__T__rowSums.base","d":"-NA-","ec":""},{"p":"Matrix","o":".m2ngCn","f":"hp_.m2ngCn","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".m2ngCn(from, na.is.not.0 = FALSE)"},{"p":"Matrix","o":".sparse2dense","f":"hp_.sparse2dense","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".sparse2dense(from, packed = FALSE)"},{"p":"Matrix","o":"triu","f":"hp_triu","d":"Return the matrix obtained by setting to zero elements below a diagonal\n(triu), above a diagonal (tril), or outside of a general\nband (band).\n","ec":"triu(x, k = 0L, ...)"},{"p":"Matrix","o":".diag2mat","f":"hp_.diag2mat","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".diag2mat(from)"},{"p":"Matrix","o":".__T__Summary:base","f":"hp_.__T__Summary.base","d":"-NA-","ec":""},{"p":"Matrix","o":"determinant","f":"hp_determinant","d":"-NA-","ec":"determinant(x, logarithm = TRUE, ...)"},{"p":"Matrix","o":".__C__ndenseMatrix","f":"hp_.__C__ndenseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ldenseMatrix","f":"hp_.__C__ldenseMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__!:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":".solve.dgC.chol","f":"hp_.solve.dgC.chol","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".solve.dgC.chol(a, b, check = TRUE)"},{"p":"Matrix","o":".__C__BunchKaufmanFactorization","f":"hp_.__C__BunchKaufmanFactorization","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__ltRMatrix","f":"hp_.__C__ltRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".updateCHMfactor","f":"hp_.updateCHMfactor","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".updateCHMfactor(object, parent, mult = 0)"},{"p":"Matrix","o":".__T__+:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__crossprod:base","f":"hp_.__T__crossprod.base","d":"-NA-","ec":""},{"p":"Matrix","o":"sparseMatrix","f":"hp_sparseMatrix","d":"User-friendly construction of sparse matrices (inheriting from\nvirtual class CsparseMatrix,\nRsparseMatrix, or\nTsparseMatrix)\nfrom the positions and values of their nonzero entries.\n","ec":"sparseMatrix(i, j, p, x, dims, dimnames, symmetric = FALSE, triangular = FALSE, index1 = TRUE, repr = c(\"C\", \"R\", \"T\"), giveCsparse, check = TRUE, use.last.ij = FALSE)"},{"p":"Matrix","o":".__T__colMeans:base","f":"hp_.__T__colMeans.base","d":"-NA-","ec":""},{"p":"Matrix","o":"chol","f":"hp_chol","d":"Computes the upper triangular Cholesky factor of an\nn \\times n real, symmetric, positive semidefinite\nmatrix A, optionally after pivoting.\nThat is the factor L' in\n","ec":"chol(x, ...)"},{"p":"Matrix","o":".__C__zsparseVector","f":"hp_.__C__zsparseVector","d":"-NA-","ec":""},{"p":"Matrix","o":".dsy2mat","f":"hp_.dsy2mat","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".dsy2mat(from, keep.dimnames = TRUE)"},{"p":"Matrix","o":".__C__ltCMatrix","f":"hp_.__C__ltCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__-:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":".dsy2dsp","f":"hp_.dsy2dsp","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".dsy2dsp(from)"},{"p":"Matrix","o":".__T__/:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":"cBind","f":"hp_cBind","d":"The functions or variables listed here are no longer part of\nMatrix as they are no longer needed.\n","ec":"cBind(..., deparse.level = 1)"},{"p":"Matrix","o":"isDiagonal","f":"hp_isDiagonal","d":"isTriangular and isDiagonal test whether their argument\nis a triangular or diagonal matrix, respectively.  Unlike the analogous\nisSymmetric, these two functions are generically\nfrom Matrix rather than base.  Hence Matrix\ndefines methods for traditional matrices of implicit class\n\"matrix\" in addition to matrices inheriting from\nvirtual class \"Matrix\".\n","ec":"isDiagonal(object)"},{"p":"Matrix","o":".__T__qr.qty:base","f":"hp_.__T__qr.qty.base","d":"-NA-","ec":""},{"p":"Matrix","o":"tail","f":"hp_tail","d":"-NA-","ec":"tail(x, ...)"},{"p":"Matrix","o":".__C__ndiMatrix","f":"hp_.__C__ndiMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__denseLU","f":"hp_.__C__denseLU","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__number","f":"hp_.__C__number","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__rowMeans:base","f":"hp_.__T__rowMeans.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__lsRMatrix","f":"hp_.__C__lsRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__dimnames<-:base","f":"hp_.__T__dimnames...base","d":"-NA-","ec":""},{"p":"Matrix","o":".diag2dense","f":"hp_.diag2dense","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".diag2dense(from, kind = \".\", shape = \"t\", packed = FALSE, uplo = \"U\")"},{"p":"Matrix","o":".sparse2g","f":"hp_.sparse2g","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".sparse2g(from, kind = \".\")"},{"p":"Matrix","o":"updown","f":"hp_updown","d":"Computes a rank-k update or downdate of a sparse Cholesky\nfactorization\n","ec":"updown(update, C, L)"},{"p":"Matrix","o":"rBind","f":"hp_rBind","d":"The functions or variables listed here are no longer part of\nMatrix as they are no longer needed.\n","ec":"rBind(..., deparse.level = 1)"},{"p":"Matrix","o":".__T__as.matrix:base","f":"hp_.__T__as.matrix.base","d":"-NA-","ec":""},{"p":"Matrix","o":"qr.qty","f":"hp_qr.qty","d":"-NA-","ec":"qr.qty(qr, y)"},{"p":"Matrix","o":".ind2sparse","f":"hp_.ind2sparse","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".ind2sparse(from, kind = \"n\", repr = \".\")"},{"p":"Matrix","o":"image","f":"hp_image","d":"Methods for function image in package\nMatrix.  An image of a matrix simply color codes all matrix\nentries and draws the n\\times m matrix using an\nn\\times m grid of (colored) rectangles.\n","ec":"image(x, ...)"},{"p":"Matrix","o":".sparse2m","f":"hp_.sparse2m","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".sparse2m(from)"},{"p":"Matrix","o":".__C__dtRMatrix","f":"hp_.__C__dtRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__determinant:base","f":"hp_.__T__determinant.base","d":"-NA-","ec":""},{"p":"Matrix","o":"isTriangular","f":"hp_isTriangular","d":"isTriangular and isDiagonal test whether their argument\nis a triangular or diagonal matrix, respectively.  Unlike the analogous\nisSymmetric, these two functions are generically\nfrom Matrix rather than base.  Hence Matrix\ndefines methods for traditional matrices of implicit class\n\"matrix\" in addition to matrices inheriting from\nvirtual class \"Matrix\".\n","ec":"isTriangular(object, upper = NA, ...)"},{"p":"Matrix","o":"Matrix","f":"hp_Matrix","d":"Construct a Matrix of a class that inherits from Matrix.\n","ec":"Matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL, sparse = NULL, doDiag = TRUE, forceCheck = FALSE)"},{"p":"Matrix","o":".dense2g","f":"hp_.dense2g","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".dense2g(from, kind = \".\")"},{"p":"Matrix","o":".T2CR","f":"hp_.T2CR","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".T2CR(from, Csparse = TRUE)"},{"p":"Matrix","o":".__C__Schur","f":"hp_.__C__Schur","d":"-NA-","ec":""},{"p":"Matrix","o":".m2dgC","f":"hp_.m2dgC","d":"These functions are provided for compatibility with older versions\nof Matrix only and may be defunct as soon as the next release.\n","ec":".m2dgC(from)"},{"p":"Matrix","o":"expand1","f":"hp_expand1","d":"expand1 and expand2 construct matrix factors from\nobjects specifying matrix factorizations.  Such objects typically\ndo not store the factors explicitly, employing instead a compact\nrepresentation to save memory.\n","ec":"expand1(x, which, ...)"},{"p":"Matrix","o":".M2kind","f":"hp_.M2kind","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2kind(from, kind = \".\", sparse = NA)"},{"p":"Matrix","o":".symDiagonal","f":"hp_.symDiagonal","d":"Construct a formally diagonal Matrix,\ni.e., an object inheriting from virtual class\ndiagonalMatrix\n(or, if desired, a mathematically diagonal\nCsparseMatrix).\n","ec":".symDiagonal(n, x = NULL, uplo = \"U\", kind)"},{"p":"Matrix","o":".__C__ltrMatrix","f":"hp_.__C__ltrMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"expand2","f":"hp_expand2","d":"expand1 and expand2 construct matrix factors from\nobjects specifying matrix factorizations.  Such objects typically\ndo not store the factors explicitly, employing instead a compact\nrepresentation to save memory.\n","ec":"expand2(x, ...)"},{"p":"Matrix","o":".__T__solve:base","f":"hp_.__T__solve.base","d":"-NA-","ec":""},{"p":"Matrix","o":".sparse2kind","f":"hp_.sparse2kind","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".sparse2kind(from, kind, drop0 = FALSE)"},{"p":"Matrix","o":".__C__lgRMatrix","f":"hp_.__C__lgRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"as.array","f":"hp_as.array","d":"-NA-","ec":"as.array(x, ...)"},{"p":"Matrix","o":".dense2m","f":"hp_.dense2m","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".dense2m(from)"},{"p":"Matrix","o":".sparse2v","f":"hp_.sparse2v","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".sparse2v(from)"},{"p":"Matrix","o":".__C__dtCMatrix","f":"hp_.__C__dtCMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__T__print:base","f":"hp_.__T__print.base","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__nCHMsuper","f":"hp_.__C__nCHMsuper","d":"-NA-","ec":""},{"p":"Matrix","o":".M2diag","f":"hp_.M2diag","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".M2diag(from)"},{"p":"Matrix","o":".__C__packedMatrix","f":"hp_.__C__packedMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".__C__dsRMatrix","f":"hp_.__C__dsRMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".dense2v","f":"hp_.dense2v","d":"<U+201C>Semi-API<U+201D> functions used internally by Matrix,\noften to bypass S4 dispatch and avoid the associated overhead.\nThese are exported to provide this capability to expert users.\nTypical users should continue to rely on S4 generic functions\nto dispatch suitable methods, by calling,\ne.g., as(., <class>) for coercions.\n","ec":".dense2v(from)"},{"p":"Matrix","o":".__T__[:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Matrix","o":"pack","f":"hp_pack","d":"pack() coerces dense symmetric and dense triangular matrices\nfrom unpacked format (storing the full matrix) to packed format\n(storing only one of the upper and lower triangles).  unpack()\nperforms the reverse coercion. The two formats are formalized\nby the virtual classes \"packedMatrix\" and\n\"unpackedMatrix\".\n","ec":"pack(x, ...)"},{"p":"Matrix","o":"colMeans","f":"hp_colMeans","d":"Form row and column sums and means for\nobjects, for sparseMatrix the result may\noptionally be sparse (sparseVector), too.\nRow or column names are kept respectively as for base matrices\nand colSums methods, when the result is\nnumeric vector.\n","ec":"colMeans(x, na.rm = FALSE, dims = 1, ...)"},{"p":"Matrix","o":"solve","f":"hp_solve","d":"Methods for generic function solve for solving\nlinear systems of equations,\ni.e., for X in A X = B,\nwhere A is a square matrix and X and B are matrices\nwith dimensions consistent with A.\n","ec":"solve(a, b, ...)"},{"p":"Matrix","o":".__C__ltpMatrix","f":"hp_.__C__ltpMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":".sparseDiagonal","f":"hp_.sparseDiagonal","d":"Construct a formally diagonal Matrix,\ni.e., an object inheriting from virtual class\ndiagonalMatrix\n(or, if desired, a mathematically diagonal\nCsparseMatrix).\n","ec":".sparseDiagonal(n, x = NULL, uplo = \"U\", shape = \"t\", unitri = TRUE, kind, cols)"},{"p":"Matrix","o":".__C__ltTMatrix","f":"hp_.__C__ltTMatrix","d":"-NA-","ec":""},{"p":"Matrix","o":"dmperm","f":"hp_dmperm","d":"For any n \\times m (typically) sparse matrix x\ncompute the Dulmage-Mendelsohn row and columns permutations which at\nfirst splits the n rows and m columns into coarse partitions\neach; and then a finer one, reordering rows and columns such that the\npermutated matrix is <U+201C>as upper triangular<U+201D> as possible.\n","ec":"dmperm(x, nAns = 6L, seed = 0L)"},{"p":"matrixStats","o":"rowWeightedVars","f":"hp_rowWeightedVars","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"rowWeightedVars(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowWeightedMedians","f":"hp_rowWeightedMedians","d":"Calculates the weighted medians for each row (column) in a matrix.\n","ec":"rowWeightedMedians(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowWeightedMads","f":"hp_rowWeightedMads","d":"Computes a weighted MAD of a numeric vector.\n","ec":"rowWeightedMads(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, constant = 1.4826, center = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowVarDiffs","f":"hp_rowVarDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"rowVarDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colSds","f":"hp_colSds","d":"Standard deviation estimates for each row (column) in a matrix.\n","ec":"colSds(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, center = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCumsums","f":"hp_rowCumsums","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"rowCumsums(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowQuantiles","f":"hp_rowQuantiles","d":"Estimates quantiles for each row (column) in a matrix.\n","ec":"rowQuantiles(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE)"},{"p":"matrixStats","o":"rowLogSumExps","f":"hp_rowLogSumExps","d":"Accurately computes the logarithm of the sum of exponentials across rows or\ncolumns.\n","ec":"rowLogSumExps(lx, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(lx), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowMaxs","f":"hp_rowMaxs","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"rowMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"x_OP_y","f":"hp_x_OP_y","d":"Fast calculation of 'z <- x OP y' and 'z <- t(t(x) OP y)', where OP can be\n+, -, *, and /.  For + and *, na.rm = TRUE will drop missing values first.\n","ec":"x_OP_y(x, y, OP, xrows = NULL, xcols = NULL, yidxs = NULL, commute = FALSE, na.rm = FALSE)"},{"p":"matrixStats","o":"allValue","f":"hp_allValue","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"allValue(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"rowMeans2","f":"hp_rowMeans2","d":"Calculates the mean for each row (column) in a matrix.\n","ec":"rowMeans2(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"indexByRow","f":"hp_indexByRow","d":"Translates matrix indices by rows into indices by columns.\n","ec":"indexByRow(dim, idxs = NULL, ...)"},{"p":"matrixStats","o":"colMads","f":"hp_colMads","d":"Standard deviation estimates for each row (column) in a matrix.\n","ec":"colMads(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowIQRs","f":"hp_rowIQRs","d":"Estimates of the interquartile range for each row (column) in a matrix.\n","ec":"rowIQRs(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colAlls","f":"hp_colAlls","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"colAlls(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowWeightedSds","f":"hp_rowWeightedSds","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"rowWeightedSds(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowTabulates","f":"hp_rowTabulates","d":"Tabulates the values in a matrix by row (column).\n","ec":"rowTabulates(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowProds","f":"hp_rowProds","d":"Calculates the product for each row (column) in a matrix.\n","ec":"rowProds(x, rows = NULL, cols = NULL, na.rm = FALSE, method = c(\"direct\", \"expSumLog\"), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowAnyNAs","f":"hp_rowAnyNAs","d":"Checks if there are any missing values in an object or not.\nPlease use base::anyNA() instead of anyMissing(),\ncolAnyNAs() instead of colAnyMissings(), and\nrowAnyNAs() instead of rowAnyMissings().\n","ec":"rowAnyNAs(x, rows = NULL, cols = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowDiffs","f":"hp_rowDiffs","d":"Calculates difference for each row (column) in a matrix.\n","ec":"rowDiffs(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"weightedVar","f":"hp_weightedVar","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"weightedVar(x, w = NULL, idxs = NULL, na.rm = FALSE, center = NULL, ...)"},{"p":"matrixStats","o":"iqrDiff","f":"hp_iqrDiff","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"iqrDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)"},{"p":"matrixStats","o":"colIQRDiffs","f":"hp_colIQRDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"colIQRDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowOrderStats","f":"hp_rowOrderStats","d":"Gets an order statistic for each row (column) in a matrix.\n","ec":"rowOrderStats(x, rows = NULL, cols = NULL, which, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowRanks","f":"hp_rowRanks","d":"Gets the rank of the elements in each row (column) of a matrix.\n","ec":"rowRanks(x, rows = NULL, cols = NULL, ties.method = c(\"max\", \"average\", \"first\", \"last\", \"random\", \"max\", \"min\", \"dense\"), dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colAvgsPerRowSet","f":"hp_colAvgsPerRowSet","d":"Applies a row-by-row (column-by-column) averaging function to equally-sized\nsubsets of matrix columns (rows).  Each subset is averaged independently of\nthe others.\n","ec":"colAvgsPerRowSet(X, W = NULL, cols = NULL, S, FUN = colMeans, ..., na.rm = NA, tFUN = FALSE)"},{"p":"matrixStats","o":"diff2","f":"hp_diff2","d":"Computes the lagged and iterated differences.\n","ec":"diff2(x, idxs = NULL, lag = 1L, differences = 1L, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colCounts","f":"hp_colCounts","d":"The row- and column-wise functions take either a matrix or a vector as\ninput. If a vector, then argument dim. must be specified and fulfill\nprod(dim.) == length(x).  The result will be identical to the results\nobtained when passing matrix(x, nrow = dim.[1L], ncol = dim.[2L]),\nbut avoids having to temporarily create/allocate a matrix, if only such is\nneeded only for these calculations.\n","ec":"colCounts(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowAnys","f":"hp_rowAnys","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"rowAnys(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowMedians","f":"hp_rowMedians","d":"Calculates the median for each row (column) in a matrix.\n","ec":"rowMedians(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCummins","f":"hp_rowCummins","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"rowCummins(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"binMeans","f":"hp_binMeans","d":"Computes the sample means in non-overlapping bins\n","ec":"binMeans(y, x, idxs = NULL, bx, na.rm = TRUE, count = TRUE, right = FALSE, ...)"},{"p":"matrixStats","o":"colWeightedMads","f":"hp_colWeightedMads","d":"Computes a weighted MAD of a numeric vector.\n","ec":"colWeightedMads(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, constant = 1.4826, center = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colWeightedVars","f":"hp_colWeightedVars","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"colWeightedVars(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"weightedSd","f":"hp_weightedSd","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"weightedSd(...)"},{"p":"matrixStats","o":"varDiff","f":"hp_varDiff","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"varDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)"},{"p":"matrixStats","o":"madDiff","f":"hp_madDiff","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"madDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, constant = 1.4826, ...)"},{"p":"matrixStats","o":"colSums2","f":"hp_colSums2","d":"Calculates the sum for each row (column) in a matrix.\n","ec":"colSums2(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colMins","f":"hp_colMins","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"colMins(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colRanges","f":"hp_colRanges","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"colRanges(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"anyMissing","f":"hp_anyMissing","d":"Checks if there are any missing values in an object or not.\nPlease use base::anyNA() instead of anyMissing(),\ncolAnyNAs() instead of colAnyMissings(), and\nrowAnyNAs() instead of rowAnyMissings().\n","ec":"anyMissing(x, idxs = NULL, ...)"},{"p":"matrixStats","o":"weightedMean","f":"hp_weightedMean","d":"Computes the weighted sample mean of a numeric vector.\n","ec":"weightedMean(x, w = NULL, idxs = NULL, na.rm = FALSE, refine = FALSE, ...)"},{"p":"matrixStats","o":"mean2","f":"hp_mean2","d":"Computes the sample mean of all or a subset of values.\n","ec":"mean2(x, idxs = NULL, na.rm = FALSE, refine = TRUE, ...)"},{"p":"matrixStats","o":"rowWeightedMeans","f":"hp_rowWeightedMeans","d":"Calculates the weighted means for each row (column) in a matrix.\n","ec":"rowWeightedMeans(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowVars","f":"hp_rowVars","d":"Variance estimates for each row (column) in a matrix.\n","ec":"rowVars(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, center = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowRanges","f":"hp_rowRanges","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"rowRanges(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colCummaxs","f":"hp_colCummaxs","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"colCummaxs(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowIQRDiffs","f":"hp_rowIQRDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"rowIQRDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"weightedMad","f":"hp_weightedMad","d":"Computes a weighted MAD of a numeric vector.\n","ec":"weightedMad(x, w = NULL, idxs = NULL, na.rm = FALSE, constant = 1.4826, center = NULL, ...)"},{"p":"matrixStats","o":"count","f":"hp_count","d":"The row- and column-wise functions take either a matrix or a vector as\ninput. If a vector, then argument dim. must be specified and fulfill\nprod(dim.) == length(x).  The result will be identical to the results\nobtained when passing matrix(x, nrow = dim.[1L], ncol = dim.[2L]),\nbut avoids having to temporarily create/allocate a matrix, if only such is\nneeded only for these calculations.\n","ec":"count(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"allocArray","f":"hp_allocArray","d":"Allocates an empty vector, matrix or array faster than the corresponding\nfunction in R.\n","ec":"allocArray(dim, value = 0, ...)"},{"p":"matrixStats","o":"rowSdDiffs","f":"hp_rowSdDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"rowSdDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colAnys","f":"hp_colAnys","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"colAnys(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colWeightedSds","f":"hp_colWeightedSds","d":"Computes a weighted variance / standard deviation of a numeric vector or\nacross rows or columns of a matrix.\n","ec":"colWeightedSds(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colTabulates","f":"hp_colTabulates","d":"Tabulates the values in a matrix by row (column).\n","ec":"colTabulates(x, rows = NULL, cols = NULL, values = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"binCounts","f":"hp_binCounts","d":"Counts the number of elements in non-overlapping bins\n","ec":"binCounts(x, idxs = NULL, bx, right = FALSE, ...)"},{"p":"matrixStats","o":"logSumExp","f":"hp_logSumExp","d":"Accurately computes the logarithm of the sum of exponentials, that is,\nlog(sum(exp(lx))).  If lx = log(x), then this is equivalently to\ncalculating log(sum(x)).\n","ec":"logSumExp(lx, idxs = NULL, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"signTabulate","f":"hp_signTabulate","d":"Calculates the number of negative, zero, positive and missing values in a\nnumeric vector.  For double vectors,\nthe number of negative and positive infinite values are also counted.\n","ec":"signTabulate(x, idxs = NULL, ...)"},{"p":"matrixStats","o":"anyValue","f":"hp_anyValue","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"anyValue(x, idxs = NULL, value = TRUE, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"colMadDiffs","f":"hp_colMadDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"colMadDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCollapse","f":"hp_rowCollapse","d":"Extracts one cell per row (column) from a matrix.  The implementation is\noptimized for memory and speed.\n","ec":"rowCollapse(x, idxs, rows = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"weightedMedian","f":"hp_weightedMedian","d":"Computes a weighted median of a numeric vector.\n","ec":"weightedMedian(x, w = NULL, idxs = NULL, na.rm = FALSE, interpolate = is.null(ties), ties = NULL, ...)"},{"p":"matrixStats","o":"rowAlls","f":"hp_rowAlls","d":"Checks if a value exists / does not exist in each row (column) of a matrix.\n","ec":"rowAlls(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCounts","f":"hp_rowCounts","d":"The row- and column-wise functions take either a matrix or a vector as\ninput. If a vector, then argument dim. must be specified and fulfill\nprod(dim.) == length(x).  The result will be identical to the results\nobtained when passing matrix(x, nrow = dim.[1L], ncol = dim.[2L]),\nbut avoids having to temporarily create/allocate a matrix, if only such is\nneeded only for these calculations.\n","ec":"rowCounts(x, rows = NULL, cols = NULL, value = TRUE, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colSdDiffs","f":"hp_colSdDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"colSdDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCumprods","f":"hp_rowCumprods","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"rowCumprods(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowMads","f":"hp_rowMads","d":"Standard deviation estimates for each row (column) in a matrix.\n","ec":"rowMads(x, rows = NULL, cols = NULL, center = NULL, constant = 1.4826, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colAnyMissings","f":"hp_colAnyMissings","d":"Checks if there are any missing values in an object or not.\nPlease use base::anyNA() instead of anyMissing(),\ncolAnyNAs() instead of colAnyMissings(), and\nrowAnyNAs() instead of rowAnyMissings().\n","ec":"colAnyMissings(x, rows = NULL, cols = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colWeightedMedians","f":"hp_colWeightedMedians","d":"Calculates the weighted medians for each row (column) in a matrix.\n","ec":"colWeightedMedians(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"sum2","f":"hp_sum2","d":"Computes the sum of all or a subset of values.\n","ec":"sum2(x, idxs = NULL, na.rm = FALSE, mode = typeof(x), ...)"},{"p":"matrixStats","o":"allocVector","f":"hp_allocVector","d":"Allocates an empty vector, matrix or array faster than the corresponding\nfunction in R.\n","ec":"allocVector(length, value = 0, ...)"},{"p":"matrixStats","o":"colMaxs","f":"hp_colMaxs","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"colMaxs(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colRanks","f":"hp_colRanks","d":"Gets the rank of the elements in each row (column) of a matrix.\n","ec":"colRanks(x, rows = NULL, cols = NULL, ties.method = c(\"max\", \"average\", \"first\", \"last\", \"random\", \"max\", \"min\", \"dense\"), dim. = dim(x), preserveShape = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowCummaxs","f":"hp_rowCummaxs","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"rowCummaxs(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colLogSumExps","f":"hp_colLogSumExps","d":"Accurately computes the logarithm of the sum of exponentials across rows or\ncolumns.\n","ec":"colLogSumExps(lx, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(lx), ..., useNames = TRUE)"},{"p":"matrixStats","o":"product","f":"hp_product","d":"Calculates the product for each row (column) in a matrix.\n","ec":"product(x, idxs = NULL, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"colCollapse","f":"hp_colCollapse","d":"Extracts one cell per row (column) from a matrix.  The implementation is\noptimized for memory and speed.\n","ec":"colCollapse(x, idxs, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowSds","f":"hp_rowSds","d":"Standard deviation estimates for each row (column) in a matrix.\n","ec":"rowSds(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, center = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colWeightedMeans","f":"hp_colWeightedMeans","d":"Calculates the weighted means for each row (column) in a matrix.\n","ec":"colWeightedMeans(x, w = NULL, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowMadDiffs","f":"hp_rowMadDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"rowMadDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colAnyNAs","f":"hp_colAnyNAs","d":"Checks if there are any missing values in an object or not.\nPlease use base::anyNA() instead of anyMissing(),\ncolAnyNAs() instead of colAnyMissings(), and\nrowAnyNAs() instead of rowAnyMissings().\n","ec":"colAnyNAs(x, rows = NULL, cols = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colIQRs","f":"hp_colIQRs","d":"Estimates of the interquartile range for each row (column) in a matrix.\n","ec":"colIQRs(x, rows = NULL, cols = NULL, na.rm = FALSE, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colProds","f":"hp_colProds","d":"Calculates the product for each row (column) in a matrix.\n","ec":"colProds(x, rows = NULL, cols = NULL, na.rm = FALSE, method = c(\"direct\", \"expSumLog\"), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colCumsums","f":"hp_colCumsums","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"colCumsums(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowMins","f":"hp_rowMins","d":"Gets the range of values in each row (column) of a matrix.\n","ec":"rowMins(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"allocMatrix","f":"hp_allocMatrix","d":"Allocates an empty vector, matrix or array faster than the corresponding\nfunction in R.\n","ec":"allocMatrix(nrow, ncol, value = 0, ...)"},{"p":"matrixStats","o":"colCummins","f":"hp_colCummins","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"colCummins(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colMeans2","f":"hp_colMeans2","d":"Calculates the mean for each row (column) in a matrix.\n","ec":"colMeans2(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colOrderStats","f":"hp_colOrderStats","d":"Gets an order statistic for each row (column) in a matrix.\n","ec":"colOrderStats(x, rows = NULL, cols = NULL, which, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colCumprods","f":"hp_colCumprods","d":"Cumulative sums, products, minima and maxima for each row (column) in a\nmatrix.\n","ec":"colCumprods(x, rows = NULL, cols = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"colVarDiffs","f":"hp_colVarDiffs","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"colVarDiffs(x, rows = NULL, cols = NULL, na.rm = FALSE, diff = 1L, trim = 0, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colDiffs","f":"hp_colDiffs","d":"Calculates difference for each row (column) in a matrix.\n","ec":"colDiffs(x, rows = NULL, cols = NULL, lag = 1L, differences = 1L, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowSums2","f":"hp_rowSums2","d":"Calculates the sum for each row (column) in a matrix.\n","ec":"rowSums2(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"rowAnyMissings","f":"hp_rowAnyMissings","d":"Checks if there are any missing values in an object or not.\nPlease use base::anyNA() instead of anyMissing(),\ncolAnyNAs() instead of colAnyMissings(), and\nrowAnyNAs() instead of rowAnyMissings().\n","ec":"rowAnyMissings(x, rows = NULL, cols = NULL, ..., useNames = TRUE)"},{"p":"matrixStats","o":"colQuantiles","f":"hp_colQuantiles","d":"Estimates quantiles for each row (column) in a matrix.\n","ec":"colQuantiles(x, rows = NULL, cols = NULL, probs = seq(from = 0, to = 1, by = 0.25), na.rm = FALSE, type = 7L, digits = 7L, ..., useNames = TRUE, drop = TRUE)"},{"p":"matrixStats","o":"rowAvgsPerColSet","f":"hp_rowAvgsPerColSet","d":"Applies a row-by-row (column-by-column) averaging function to equally-sized\nsubsets of matrix columns (rows).  Each subset is averaged independently of\nthe others.\n","ec":"rowAvgsPerColSet(X, W = NULL, rows = NULL, S, FUN = rowMeans, ..., na.rm = NA, tFUN = FALSE)"},{"p":"matrixStats","o":"colVars","f":"hp_colVars","d":"Variance estimates for each row (column) in a matrix.\n","ec":"colVars(x, rows = NULL, cols = NULL, na.rm = FALSE, refine = TRUE, center = NULL, dim. = dim(x), ..., useNames = TRUE)"},{"p":"matrixStats","o":"t_tx_OP_y","f":"hp_t_tx_OP_y","d":"Fast calculation of 'z <- x OP y' and 'z <- t(t(x) OP y)', where OP can be\n+, -, *, and /.  For + and *, na.rm = TRUE will drop missing values first.\n","ec":"t_tx_OP_y(x, y, OP, xrows = NULL, xcols = NULL, yidxs = NULL, commute = FALSE, na.rm = FALSE)"},{"p":"matrixStats","o":"sdDiff","f":"hp_sdDiff","d":"Estimation of scale based on sequential-order differences, corresponding to\nthe scale estimates provided by var,\nsd, mad and\nIQR.\n","ec":"sdDiff(x, idxs = NULL, na.rm = FALSE, diff = 1L, trim = 0, ...)"},{"p":"matrixStats","o":"iqr","f":"hp_iqr","d":"Estimates of the interquartile range for each row (column) in a matrix.\n","ec":"iqr(x, idxs = NULL, na.rm = FALSE, ...)"},{"p":"matrixStats","o":"colMedians","f":"hp_colMedians","d":"Calculates the median for each row (column) in a matrix.\n","ec":"colMedians(x, rows = NULL, cols = NULL, na.rm = FALSE, dim. = dim(x), ..., useNames = TRUE)"},{"p":"methods","o":".__C__signature","f":"hp_.__C__signature","d":"-NA-","ec":""},{"p":"methods","o":".__T__Logic:base","f":"hp_.__T__Logic.base","d":"-NA-","ec":""},{"p":"methods","o":".__T__loadMethod:methods","f":"hp_.__T__loadMethod.methods","d":"-NA-","ec":""},{"p":"methods","o":".ShortPrimitiveSkeletons","f":"hp_.ShortPrimitiveSkeletons","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":""},{"p":"methods","o":"showExtends","f":"hp_showExtends","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"showExtends(ext, printTo = stdout())"},{"p":"methods","o":".__C__packageInfo","f":"hp_.__C__packageInfo","d":"-NA-","ec":""},{"p":"methods","o":".__C__MethodSelectionReport","f":"hp_.__C__MethodSelectionReport","d":"-NA-","ec":""},{"p":"methods","o":".__C__uninitializedField","f":"hp_.__C__uninitializedField","d":"-NA-","ec":""},{"p":"methods","o":"extends","f":"hp_extends","d":"Functions to test inheritance relationships between an object and a\nclass or between two classes (extends).\n","ec":"extends(class1, class2, maybe = TRUE, fullInfo = FALSE)"},{"p":"methods","o":".__C__ordered","f":"hp_.__C__ordered","d":"-NA-","ec":""},{"p":"methods","o":".__C__oldClass","f":"hp_.__C__oldClass","d":"-NA-","ec":""},{"p":"methods","o":"addNextMethod","f":"hp_addNextMethod","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"addNextMethod(method, f = \"<unknown>\", mlist, optional = FALSE, envir)"},{"p":"methods","o":".__C__groupGenericFunction","f":"hp_.__C__groupGenericFunction","d":"-NA-","ec":""},{"p":"methods","o":"getGenerics","f":"hp_getGenerics","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"getGenerics(where, searchForm = FALSE)"},{"p":"methods","o":".__C__standardGeneric","f":"hp_.__C__standardGeneric","d":"-NA-","ec":""},{"p":"methods","o":".__C__nonstandardGroupGenericFunction","f":"hp_.__C__nonstandardGroupGenericFunction","d":"-NA-","ec":""},{"p":"methods","o":"makeExtends","f":"hp_makeExtends","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"makeExtends(Class, coerce = NULL, test = NULL, replace = NULL, by = character(), package, slots = getSlots(classDef1), classDef1 = getClass(Class), classDef2)"},{"p":"methods","o":".__C__S3","f":"hp_.__C__S3","d":"-NA-","ec":""},{"p":"methods","o":".__C__array","f":"hp_.__C__array","d":"-NA-","ec":""},{"p":"methods","o":".__T__[<-:base","f":"hp_.__T__....base","d":"-NA-","ec":""},{"p":"methods","o":".__C__S4","f":"hp_.__C__S4","d":"-NA-","ec":""},{"p":"methods","o":".EmptyPrimitiveSkeletons","f":"hp_.EmptyPrimitiveSkeletons","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":""},{"p":"methods","o":".__C__SuperClassMethod","f":"hp_.__C__SuperClassMethod","d":"-NA-","ec":""},{"p":"methods","o":"showMlist","f":"hp_showMlist","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"showMlist(mlist, includeDefs = TRUE, inherited = TRUE, classes = NULL, useArgNames = TRUE, printTo = stdout())"},{"p":"methods","o":"setAs","f":"hp_setAs","d":"A call to setAs defines a method for coercing an object of\nclass from to class to.  The methods will then be used\nby calls to as for objects with class from,\nincluding calls that replace part of the object.\n","ec":"setAs(from, to, def, replace = NULL, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__aov","f":"hp_.__C__aov","d":"-NA-","ec":""},{"p":"methods","o":"resetClass","f":"hp_resetClass","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"resetClass(Class, classDef, where)"},{"p":"methods","o":"assignMethodsMetaData","f":"hp_assignMethodsMetaData","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"assignMethodsMetaData(f, value, fdef, where)"},{"p":"methods","o":".__C__integrate","f":"hp_.__C__integrate","d":"-NA-","ec":""},{"p":"methods","o":"getDataPart","f":"hp_getDataPart","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"getDataPart(object, NULL.for.none = FALSE)"},{"p":"methods","o":".__C__listOfMethods","f":"hp_.__C__listOfMethods","d":"-NA-","ec":""},{"p":"methods","o":".__C__ClassUnionRepresentation","f":"hp_.__C__ClassUnionRepresentation","d":"-NA-","ec":""},{"p":"methods","o":"findMethodSignatures","f":"hp_findMethodSignatures","d":"The function findMethods converts the methods defined in a table for a generic\nfunction (as used for selection of methods) into a list, for study or\ndisplay.  The list is actually from the class listOfMethods\n(see the section describing the class, below).\n","ec":"findMethodSignatures(..., target = TRUE, methods = findMethods(...))"},{"p":"methods","o":"getGroupMembers","f":"hp_getGroupMembers","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"getGroupMembers(group, recursive = FALSE, character = TRUE)"},{"p":"methods","o":"signature","f":"hp_signature","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"signature(...)"},{"p":"methods","o":".__T__coerce:methods","f":"hp_.__T__coerce.methods","d":"-NA-","ec":""},{"p":"methods","o":"setReplaceMethod","f":"hp_setReplaceMethod","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"setReplaceMethod(f, ..., where = topenv(parent.frame()))"},{"p":"methods","o":"removeClass","f":"hp_removeClass","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"removeClass(Class, where = topenv(parent.frame()))"},{"p":"methods","o":"implicitGeneric","f":"hp_implicitGeneric","d":"The implicit generic mechanism stores generic versions of\nfunctions\nin a table in a package. The package does not want the current\nversion of the function to be a generic, however, and retains the\nnon-generic version.\n","ec":"implicitGeneric(name, where = topenv(parent.frame()), generic = getGeneric(name, where = where))"},{"p":"methods","o":".OldClassesList","f":"hp_.OldClassesList","d":"Register an old-style (a.k.a. <U+2018>S3<U+2019>) class as a formally defined\nclass. Simple usage will be of the form:\n","ec":""},{"p":"methods","o":".__C__refObject","f":"hp_.__C__refObject","d":"-NA-","ec":""},{"p":"methods","o":"cacheMetaData","f":"hp_cacheMetaData","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"cacheMetaData(where, attach = TRUE, searchWhere = as.environment(where), doCheck = TRUE)"},{"p":"methods","o":"el","f":"hp_el","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"el(object, where)"},{"p":"methods","o":"callGeneric","f":"hp_callGeneric","d":"A call to callGeneric can only appear inside a method\ndefinition.  It then results in a call to the current generic\nfunction.  The value of that call is the value of callGeneric.\nWhile it can be called from any method, it is useful and typically\nused in methods for group generic functions.\n","ec":"callGeneric(...)"},{"p":"methods","o":"showClass","f":"hp_showClass","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"showClass(Class, complete = TRUE, propertiesAreCalled = \"Slots\")"},{"p":"methods","o":"Complex","f":"hp_Complex","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Complex(z)"},{"p":"methods","o":".__T__show:methods","f":"hp_.__T__show.methods","d":"-NA-","ec":""},{"p":"methods","o":".__C__.Other","f":"hp_.__C__.Other","d":"-NA-","ec":""},{"p":"methods","o":".__C__classPrototypeDef","f":"hp_.__C__classPrototypeDef","d":"-NA-","ec":""},{"p":"methods","o":".__C__ts","f":"hp_.__C__ts","d":"-NA-","ec":""},{"p":"methods","o":"evalSource","f":"hp_evalSource","d":"Definitions of functions and/or methods from a source file are\ninserted into a package, using the trace mechanism.\nTypically, this allows testing or debugging modified versions of a few\nfunctions without reinstalling a large package.\n","ec":"evalSource(source, package = \"\", lock = TRUE, cache = FALSE)"},{"p":"methods","o":"coerce<-","f":"hp_coerce..","d":"A call to setAs defines a method for coercing an object of\nclass from to class to.  The methods will then be used\nby calls to as for objects with class from,\nincluding calls that replace part of the object.\n","ec":"coerce<-(from, to, value)"},{"p":"methods","o":"kronecker","f":"hp_kronecker","d":"-NA-","ec":"kronecker(X, Y, FUN = \"*\", make.dimnames = FALSE, ...)"},{"p":"methods","o":"resetGeneric","f":"hp_resetGeneric","d":"These are internal support routines for computations on formal methods.\n","ec":"resetGeneric(f, fdef = getGeneric(f, where = where), mlist = getMethodsForDispatch(fdef), where = topenv(parent.frame()), deflt = finalDefaultMethod(mlist))"},{"p":"methods","o":"possibleExtends","f":"hp_possibleExtends","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"possibleExtends(class1, class2, ClassDef1 = getClassDef(class1), ClassDef2 = getClassDef(class2, where = .classEnv(ClassDef1)))"},{"p":"methods","o":".__C__table","f":"hp_.__C__table","d":"-NA-","ec":""},{"p":"methods","o":"missingArg","f":"hp_missingArg","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"missingArg(symbol, envir = parent.frame(), eval = FALSE)"},{"p":"methods","o":"Quote","f":"hp_Quote","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"Quote(expr)"},{"p":"methods","o":"registerImplicitGenerics","f":"hp_registerImplicitGenerics","d":"The implicit generic mechanism stores generic versions of\nfunctions\nin a table in a package. The package does not want the current\nversion of the function to be a generic, however, and retains the\nnon-generic version.\n","ec":"registerImplicitGenerics(what = .ImplicitGenericsTable(where), where = topenv(parent.frame()))"},{"p":"methods","o":".__T__body<-:base","f":"hp_.__T__body...base","d":"-NA-","ec":""},{"p":"methods","o":".__C__double","f":"hp_.__C__double","d":"-NA-","ec":""},{"p":"methods","o":"isClassDef","f":"hp_isClassDef","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"isClassDef(object)"},{"p":"methods","o":"initRefFields","f":"hp_initRefFields","d":"The software described here allows packages to define reference\nclasses that behave in the style of <U+201C>OOP<U+201D> languages such as Java and\nC++.\nThis model for OOP differs from the functional model implemented by S4\n(and S3) classes and methods, in which methods are defined for generic\nfunctions.\nMethods for reference classes are <U+201C>encapsulated<U+201D> in the class definition.\n","ec":"initRefFields(.Object, classDef, selfEnv, args)"},{"p":"methods","o":".__C__environment","f":"hp_.__C__environment","d":"-NA-","ec":""},{"p":"methods","o":"insertMethod","f":"hp_insertMethod","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"insertMethod(mlist, signature, args, def, cacheOnly = FALSE)"},{"p":"methods","o":"findFunction","f":"hp_findFunction","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"findFunction(f, generic = TRUE, where = topenv(parent.frame()))"},{"p":"methods","o":"externalRefMethod","f":"hp_externalRefMethod","d":"The software described here allows packages to define reference\nclasses that behave in the style of <U+201C>OOP<U+201D> languages such as Java and\nC++.\nThis model for OOP differs from the functional model implemented by S4\n(and S3) classes and methods, in which methods are defined for generic\nfunctions.\nMethods for reference classes are <U+201C>encapsulated<U+201D> in the class definition.\n","ec":"externalRefMethod(...)"},{"p":"methods","o":"fixPre1.8","f":"hp_fixPre1.8","d":"Beginning with R version 1.8.0, the class of an object contains the\nidentification of the package in which the class is defined.  The\nfunction fixPre1.8 fixes and re-assigns objects missing that information\n(typically because they were loaded from a file saved with a previous\nversion of R.)\n","ec":"fixPre1.8(names, where = topenv(parent.frame()))"},{"p":"methods","o":"checkAtAssignment","f":"hp_checkAtAssignment","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"checkAtAssignment(cl, name, valueClass)"},{"p":"methods","o":".__C__Date","f":"hp_.__C__Date","d":"-NA-","ec":""},{"p":"methods","o":"finalDefaultMethod","f":"hp_finalDefaultMethod","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"finalDefaultMethod(method)"},{"p":"methods","o":".__C__character","f":"hp_.__C__character","d":"-NA-","ec":""},{"p":"methods","o":"isClass","f":"hp_isClass","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"isClass(Class, formal = TRUE, where = topenv(parent.frame()))"},{"p":"methods","o":"completeClassDefinition","f":"hp_completeClassDefinition","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"completeClassDefinition(Class, ClassDef = getClassDef(Class), where, doExtends = TRUE)"},{"p":"methods","o":".__T__cbind2:methods","f":"hp_.__T__cbind2.methods","d":"-NA-","ec":""},{"p":"methods","o":"callNextMethod","f":"hp_callNextMethod","d":"A call to callNextMethod can only appear inside a method\ndefinition.  It then results in a call to the first inherited method\nafter the current method, with the arguments to the current method\npassed down to the next method.  The value of that method call is the\nvalue of callNextMethod.\n","ec":"callNextMethod(...)"},{"p":"methods","o":"isVirtualClass","f":"hp_isVirtualClass","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"isVirtualClass(Class, where = topenv(parent.frame()))"},{"p":"methods","o":"slotNames","f":"hp_slotNames","d":"These functions return or set information about the individual slots\nin an object.\n","ec":"slotNames(x)"},{"p":"methods","o":"getSlots","f":"hp_getSlots","d":"These functions return or set information about the individual slots\nin an object.\n","ec":"getSlots(x)"},{"p":"methods","o":".__C__LinearMethodsList","f":"hp_.__C__LinearMethodsList","d":"-NA-","ec":""},{"p":"methods","o":"selectSuperClasses","f":"hp_selectSuperClasses","d":"Return superclasses of ClassDef, possibly only non-virtual or\ndirect or simple ones.\n","ec":"selectSuperClasses(Class, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly, where = topenv(parent.frame()))"},{"p":"methods","o":"removeMethods","f":"hp_removeMethods","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"removeMethods(f, where = topenv(parent.frame()), all = missing(where))"},{"p":"methods","o":".classEnv","f":"hp_.classEnv","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":".classEnv(Class, default = .requirePackage(\"methods\"), mustFind = TRUE)"},{"p":"methods","o":".__C__structure","f":"hp_.__C__structure","d":"-NA-","ec":""},{"p":"methods","o":"evalOnLoad","f":"hp_evalOnLoad","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"evalOnLoad(expr, where = topenv(parent.frame()), aname = \"\")"},{"p":"methods","o":"cbind2","f":"hp_cbind2","d":"Combine two matrix-like R objects by columns (cbind2)\nor rows (rbind2).  These are (S4) generic functions with default\nmethods.\n","ec":"cbind2(x, y, ...)"},{"p":"methods","o":".__C__lm","f":"hp_.__C__lm","d":"-NA-","ec":""},{"p":"methods","o":".__C__dump.frames","f":"hp_.__C__dump.frames","d":"-NA-","ec":""},{"p":"methods","o":"setClassUnion","f":"hp_setClassUnion","d":"A class may be defined as the union of other classes; that\nis, as a virtual class defined as a superclass of several other\nclasses. Class unions are useful in method signatures or as slots in\nother classes, when we want to allow one of several classes to be supplied.\n","ec":"setClassUnion(name, members = character(), where = topenv(parent.frame()))"},{"p":"methods","o":".__C__density","f":"hp_.__C__density","d":"-NA-","ec":""},{"p":"methods","o":".hasSlot","f":"hp_.hasSlot","d":"These functions return or set information about the individual slots\nin an object.\n","ec":".hasSlot(object, name)"},{"p":"methods","o":"initialize","f":"hp_initialize","d":"A call to  new returns a newly allocated object from the\nclass identified by the first argument.  This call in turn calls the\nmethod for the generic function initialize corresponding to\nthe specified class, passing the ... arguments to this\nmethod.\nIn the default method for initialize(), named arguments provide\nvalues for the corresponding slots and unnamed arguments must be\nobjects from superclasses of this class.\n","ec":"initialize(.Object, ...)"},{"p":"methods","o":"Summary","f":"hp_Summary","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Summary(x, ..., na.rm = FALSE)"},{"p":"methods","o":"representation","f":"hp_representation","d":"These are old utility functions  to construct, respectively\na list designed to represent the slots and superclasses and\na list of prototype specifications.  The representation()\nfunction is no longer useful, since the arguments slots and\ncontains to setClass are now recommended.\n","ec":"representation(...)"},{"p":"methods","o":"getClass","f":"hp_getClass","d":"Get the definition of a class.\n","ec":"getClass(Class, .Force = FALSE, where = .classEnv(Class, topenv(parent.frame()), FALSE))"},{"p":"methods","o":"method.skeleton","f":"hp_method.skeleton","d":"This function writes a source file containing a call to\nsetMethod to define a method for the generic function\nand signature supplied.  By default the method definition is in line\nin the call, but can be made an external (previously assigned) function.\n","ec":"method.skeleton(generic, signature, file, external = FALSE, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__vector","f":"hp_.__C__vector","d":"-NA-","ec":""},{"p":"methods","o":"setRefClass","f":"hp_setRefClass","d":"The software described here allows packages to define reference\nclasses that behave in the style of <U+201C>OOP<U+201D> languages such as Java and\nC++.\nThis model for OOP differs from the functional model implemented by S4\n(and S3) classes and methods, in which methods are defined for generic\nfunctions.\nMethods for reference classes are <U+201C>encapsulated<U+201D> in the class definition.\n","ec":"setRefClass(Class, fields = character(), contains = character(), methods = list(), where = topenv(parent.frame()), inheritPackage = FALSE, ...)"},{"p":"methods","o":"Math2","f":"hp_Math2","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Math2(x, digits)"},{"p":"methods","o":"getMethods","f":"hp_getMethods","d":"The function findMethods converts the methods defined in a table for a generic\nfunction (as used for selection of methods) into a list, for study or\ndisplay.  The list is actually from the class listOfMethods\n(see the section describing the class, below).\n","ec":"getMethods(f, where = topenv(parent.frame()), table = FALSE)"},{"p":"methods","o":"S3Part<-","f":"hp_S3Part..","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"S3Part<-(object, strictS3 = FALSE, needClass = .S3Class(object), value)"},{"p":"methods","o":".__C__repeat","f":"hp_.__C__repeat","d":"-NA-","ec":""},{"p":"methods","o":".__C__MethodsList","f":"hp_.__C__MethodsList","d":"-NA-","ec":""},{"p":"methods","o":"Logic","f":"hp_Logic","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Logic(e1, e2)"},{"p":"methods","o":"matchSignature","f":"hp_matchSignature","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"matchSignature(signature, fun, where = baseenv())"},{"p":"methods","o":".__C__className","f":"hp_.__C__className","d":"-NA-","ec":""},{"p":"methods","o":"methodsPackageMetaName","f":"hp_methodsPackageMetaName","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"methodsPackageMetaName(prefix, name, package = \"\")"},{"p":"methods","o":"defaultDumpName","f":"hp_defaultDumpName","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"defaultDumpName(generic, signature)"},{"p":"methods","o":".__C__name","f":"hp_.__C__name","d":"-NA-","ec":""},{"p":"methods","o":"getGroup","f":"hp_getGroup","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"getGroup(fdef, recursive = FALSE, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__ObjectsWithPackage","f":"hp_.__C__ObjectsWithPackage","d":"-NA-","ec":""},{"p":"methods","o":".__C__glm.null","f":"hp_.__C__glm.null","d":"-NA-","ec":""},{"p":"methods","o":"substituteDirect","f":"hp_substituteDirect","d":"Substitute for the variables named in the second argument the\ncorresponding objects, substituting into object.  The argument\nframe is a named list; if omitted, the environment of the\ncaller is used.\n","ec":"substituteDirect(object, frame = parent.frame(), cleanFunction = TRUE)"},{"p":"methods","o":"packageSlot","f":"hp_packageSlot","d":"The functions below produce the package associated with a particular\nenvironment or position on the search list, or of the package\ncontaining a particular function.  They are primarily used to support\ncomputations that need to differentiate objects on multiple packages.\n","ec":"packageSlot(object)"},{"p":"methods","o":".__C__defaultBindingFunction","f":"hp_.__C__defaultBindingFunction","d":"-NA-","ec":""},{"p":"methods","o":"as<-","f":"hp_as..","d":"Coerce an object to a given class.\n","ec":"as<-(object, Class, value)"},{"p":"methods","o":"removeMethod","f":"hp_removeMethod","d":"Remove the method for a given function and signature.  Obsolete for\nordinary applications: Method definitions in a package should never\nneed to remove methods and it's very bad practice to remove methods\nthat were defined in other packages.\n","ec":"removeMethod(f, signature = character(), where = topenv(parent.frame()))"},{"p":"methods","o":".__C__(","f":"hp_.__C__.","d":"-NA-","ec":""},{"p":"methods","o":".__C__special","f":"hp_.__C__special","d":"-NA-","ec":""},{"p":"methods","o":".__C__SealedMethodDefinition","f":"hp_.__C__SealedMethodDefinition","d":"-NA-","ec":""},{"p":"methods","o":"MethodsListSelect","f":"hp_MethodsListSelect","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"MethodsListSelect(f, env, mlist = NULL, fEnv = if (is(fdef, \"genericFunction\")) environment(fdef) else baseenv(), finalDefault = finalDefaultMethod(mlist), evalArgs = TRUE, useInherited = TRUE, fdef = getGeneric(f, where = env), resetAllowed = TRUE)"},{"p":"methods","o":"S3Part","f":"hp_S3Part","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"S3Part(object, strictS3 = FALSE, S3Class)"},{"p":"methods","o":".__C__list","f":"hp_.__C__list","d":"-NA-","ec":""},{"p":"methods","o":".__C__NULL","f":"hp_.__C__NULL","d":"-NA-","ec":""},{"p":"methods","o":"is","f":"hp_is","d":"Functions to test inheritance relationships between an object and a\nclass or between two classes (extends).\n","ec":"is(object, class2)"},{"p":"methods","o":"checkSlotAssignment","f":"hp_checkSlotAssignment","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"checkSlotAssignment(obj, name, value)"},{"p":"methods","o":".__T__Arith:base","f":"hp_.__T__Arith.base","d":"-NA-","ec":""},{"p":"methods","o":"classMetaName","f":"hp_classMetaName","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"classMetaName(name)"},{"p":"methods","o":"slotsFromS3","f":"hp_slotsFromS3","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"slotsFromS3(object)"},{"p":"methods","o":"promptMethods","f":"hp_promptMethods","d":"Generates a shell of documentation for the methods of a generic\nfunction.\n","ec":"promptMethods(f, filename = NULL, methods)"},{"p":"methods","o":"insertClassMethods","f":"hp_insertClassMethods","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"insertClassMethods(methods, Class, value, fieldNames, returnAll)"},{"p":"methods","o":"isXS3Class","f":"hp_isXS3Class","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"isXS3Class(classDef)"},{"p":"methods","o":"packageSlot<-","f":"hp_packageSlot..","d":"The functions below produce the package associated with a particular\nenvironment or position on the search list, or of the package\ncontaining a particular function.  They are primarily used to support\ncomputations that need to differentiate objects on multiple packages.\n","ec":"packageSlot<-(object, value)"},{"p":"methods","o":"isRematched","f":"hp_isRematched","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"isRematched(definition)"},{"p":"methods","o":".__C__.environment","f":"hp_.__C__.environment","d":"-NA-","ec":""},{"p":"methods","o":".selectSuperClasses","f":"hp_.selectSuperClasses","d":"Return superclasses of ClassDef, possibly only non-virtual or\ndirect or simple ones.\n","ec":".selectSuperClasses(ext, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly)"},{"p":"methods","o":"languageEl<-","f":"hp_languageEl..","d":"Internal routines to support some operations on language objects.\n","ec":"languageEl<-(object, which, value)"},{"p":"methods","o":".__C__genericFunctionWithTrace","f":"hp_.__C__genericFunctionWithTrace","d":"-NA-","ec":""},{"p":"methods","o":".__T__[[<-:base","f":"hp_.__T__.....base","d":"-NA-","ec":""},{"p":"methods","o":".__C__anova","f":"hp_.__C__anova","d":"-NA-","ec":""},{"p":"methods","o":".__C__socket","f":"hp_.__C__socket","d":"-NA-","ec":""},{"p":"methods","o":".__T__$:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"methods","o":"emptyMethodsList","f":"hp_emptyMethodsList","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"emptyMethodsList(mlist, thisClass = \"ANY\", sublist = list())"},{"p":"methods","o":"listFromMethods","f":"hp_listFromMethods","d":"These are internal support routines for computations on formal methods.\n","ec":"listFromMethods(generic, where, table)"},{"p":"methods","o":"isGeneric","f":"hp_isGeneric","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"isGeneric(f, where = topenv(parent.frame()), fdef = NULL, getName = FALSE)"},{"p":"methods","o":".__C__refGeneratorSlot","f":"hp_.__C__refGeneratorSlot","d":"-NA-","ec":""},{"p":"methods","o":".__C__integer","f":"hp_.__C__integer","d":"-NA-","ec":""},{"p":"methods","o":"show","f":"hp_show","d":"Display the object, by printing, plotting or whatever suits its\nclass.  This function exists to be specialized by methods.  The\ndefault method calls showDefault.\n","ec":"show(object)"},{"p":"methods","o":"metaNameUndo","f":"hp_metaNameUndo","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"metaNameUndo(strings, prefix, searchForm = FALSE)"},{"p":"methods","o":".untracedFunction","f":"hp_.untracedFunction","d":" The classes described  here are used by the R function\ntrace to create versions of functions and methods\nincluding browser calls, etc., and also to untrace the\nsame objects.","ec":".untracedFunction(f)"},{"p":"methods","o":"getMethodsForDispatch","f":"hp_getMethodsForDispatch","d":"These are internal support routines for computations on formal methods.\n","ec":"getMethodsForDispatch(fdef, inherited = FALSE)"},{"p":"methods","o":".__C__packageIQR","f":"hp_.__C__packageIQR","d":"-NA-","ec":""},{"p":"methods","o":".__C__envRefClass","f":"hp_.__C__envRefClass","d":"-NA-","ec":""},{"p":"methods","o":"Math","f":"hp_Math","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Math(x)"},{"p":"methods","o":"makePrototypeFromClassDef","f":"hp_makePrototypeFromClassDef","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"makePrototypeFromClassDef(slots, ClassDef, extends, where)"},{"p":"methods","o":".__T__Compare:methods","f":"hp_.__T__Compare.methods","d":"-NA-","ec":""},{"p":"methods","o":"slot","f":"hp_slot","d":"These functions return or set information about the individual slots\nin an object.\n","ec":"slot(object, name)"},{"p":"methods","o":".__C__complex","f":"hp_.__C__complex","d":"-NA-","ec":""},{"p":"methods","o":"reconcilePropertiesAndPrototype","f":"hp_reconcilePropertiesAndPrototype","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"reconcilePropertiesAndPrototype(name, properties, prototype, superClasses, where)"},{"p":"methods","o":"doPrimitiveMethod","f":"hp_doPrimitiveMethod","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"doPrimitiveMethod(name, def, call = sys.call(sys.parent()), ev = sys.frame(sys.parent(2)))"},{"p":"methods","o":"getValidity","f":"hp_getValidity","d":"validObject() tests the validity of object related to\nits class definition; specifically, it checks that all slots\nspecified in the class definition are present and that the object in\nthe slot is from the required class or a subclass of that class.\n","ec":"getValidity(ClassDef)"},{"p":"methods","o":".__C__classRepresentation","f":"hp_.__C__classRepresentation","d":"-NA-","ec":""},{"p":"methods","o":".__T__Math2:methods","f":"hp_.__T__Math2.methods","d":"-NA-","ec":""},{"p":"methods","o":"SignatureMethod","f":"hp_SignatureMethod","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"SignatureMethod(names, signature, definition)"},{"p":"methods","o":".__C__libraryIQR","f":"hp_.__C__libraryIQR","d":"-NA-","ec":""},{"p":"methods","o":"isSealedMethod","f":"hp_isSealedMethod","d":"These functions check for either a method or a class that has been\nsealed when it was defined, and which therefore cannot be\nre-defined.\n","ec":"isSealedMethod(f, signature, fdef = getGeneric(f, FALSE, where = where), where = topenv(parent.frame()))"},{"p":"methods","o":"getPackageName","f":"hp_getPackageName","d":"The functions below produce the package associated with a particular\nenvironment or position on the search list, or of the package\ncontaining a particular function.  They are primarily used to support\ncomputations that need to differentiate objects on multiple packages.\n","ec":"getPackageName(where = topenv(parent.frame()), create = TRUE)"},{"p":"methods","o":".__C__OptionalFunction","f":"hp_.__C__OptionalFunction","d":"-NA-","ec":""},{"p":"methods","o":"setIs","f":"hp_setIs","d":"setIs is an explicit alternative\nto the contains= argument to setClass.  It is\nonly needed to create relations with explicit test or coercion.\nThese have not proved to be of much practical value, so this\nfunction should not likely be needed in applications.\n","ec":"setIs(class1, class2, test = NULL, coerce = NULL, replace = NULL, by = character(), where = topenv(parent.frame()), classDef = getClass(class1, TRUE, where = where), extensionObject = NULL, doComplete = TRUE)"},{"p":"methods","o":"balanceMethodsList","f":"hp_balanceMethodsList","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"balanceMethodsList(mlist, args, check = TRUE)"},{"p":"methods","o":".__T__slotsFromS3:methods","f":"hp_.__T__slotsFromS3.methods","d":"-NA-","ec":""},{"p":"methods","o":".__C__missing","f":"hp_.__C__missing","d":"-NA-","ec":""},{"p":"methods","o":"setLoadActions","f":"hp_setLoadActions","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"setLoadActions(..., .where = topenv(parent.frame()))"},{"p":"methods","o":"setDataPart","f":"hp_setDataPart","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"setDataPart(object, value, check = TRUE)"},{"p":"methods","o":".__C__refMethodDef","f":"hp_.__C__refMethodDef","d":"-NA-","ec":""},{"p":"methods","o":"setGroupGeneric","f":"hp_setGroupGeneric","d":"The setGroupGeneric function behaves like setGeneric\nexcept that it constructs a group generic function, differing in two\nways from an ordinary generic function.  First, this function cannot\nbe called directly, and the body of the function created will contain\na stop call with this information.  Second, the group generic function\ncontains information about the known members of the group, used to\nkeep the members up to date when the group definition changes, through\nchanges in the search list or direct specification of methods, etc.\n","ec":"setGroupGeneric(name, def = NULL, group = list(), valueClass = character(), knownMembers = list(), package = getPackageName(where), where = topenv(parent.frame()))"},{"p":"methods","o":".__C__genericFunction","f":"hp_.__C__genericFunction","d":"-NA-","ec":""},{"p":"methods","o":"S3Class","f":"hp_S3Class","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"S3Class(object)"},{"p":"methods","o":"findUnique","f":"hp_findUnique","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"findUnique(what, message, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__classGeneratorFunction","f":"hp_.__C__classGeneratorFunction","d":"-NA-","ec":""},{"p":"methods","o":"dumpMethods","f":"hp_dumpMethods","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"dumpMethods(f, file = \"\", signature = NULL, methods = findMethods(f, where = where), where = topenv(parent.frame()))"},{"p":"methods","o":".__C__raw","f":"hp_.__C__raw","d":"-NA-","ec":""},{"p":"methods","o":".__C__mlm","f":"hp_.__C__mlm","d":"-NA-","ec":""},{"p":"methods","o":"sigToEnv","f":"hp_sigToEnv","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"sigToEnv(signature, generic)"},{"p":"methods","o":"setGenericImplicit","f":"hp_setGenericImplicit","d":"The implicit generic mechanism stores generic versions of\nfunctions\nin a table in a package. The package does not want the current\nversion of the function to be a generic, however, and retains the\nnon-generic version.\n","ec":"setGenericImplicit(name, where = topenv(parent.frame()), restore = TRUE)"},{"p":"methods","o":".__C__POSIXct","f":"hp_.__C__POSIXct","d":"-NA-","ec":""},{"p":"methods","o":".__C__{","f":"hp_.__C__.","d":"-NA-","ec":""},{"p":"methods","o":"sealClass","f":"hp_sealClass","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"sealClass(Class, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__groupGenericFunctionWithTrace","f":"hp_.__C__groupGenericFunctionWithTrace","d":"-NA-","ec":""},{"p":"methods","o":"hasArg","f":"hp_hasArg","d":"Returns TRUE if name corresponds to an argument in the\ncall, either a formal argument to the function, or a component of\n..., and FALSE otherwise.\n","ec":"hasArg(name)"},{"p":"methods","o":"makeStandardGeneric","f":"hp_makeStandardGeneric","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"makeStandardGeneric(f, fdef)"},{"p":"methods","o":".__T__Complex:base","f":"hp_.__T__Complex.base","d":"-NA-","ec":""},{"p":"methods","o":"selectMethod","f":"hp_selectMethod","d":"The function selectMethod() returns the method that\nwould be selected for a call to function f if the arguments had\nclasses as specified by signature.  Failing to find a method\nis an error, unless argument optional = TRUE, in which case\nNULL is returned.\n","ec":"selectMethod(f, signature, optional = FALSE, useInherited = TRUE, mlist = if (!is.null(fdef)) getMethodsForDispatch(fdef), fdef = getGeneric(f, !optional), verbose = FALSE, doCache = FALSE)"},{"p":"methods","o":"loadMethod","f":"hp_loadMethod","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"loadMethod(method, fname, envir)"},{"p":"methods","o":"getLoadActions","f":"hp_getLoadActions","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"getLoadActions(where = topenv(parent.frame()))"},{"p":"methods","o":"prohibitGeneric","f":"hp_prohibitGeneric","d":"The implicit generic mechanism stores generic versions of\nfunctions\nin a table in a package. The package does not want the current\nversion of the function to be a generic, however, and retains the\nnon-generic version.\n","ec":"prohibitGeneric(name, where = topenv(parent.frame()))"},{"p":"methods","o":"substituteFunctionArgs","f":"hp_substituteFunctionArgs","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"substituteFunctionArgs(def, newArgs, args = formalArgs(def), silent = FALSE, functionName = \"a function\")"},{"p":"methods","o":"completeExtends","f":"hp_completeExtends","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"completeExtends(ClassDef, class2, extensionDef, where)"},{"p":"methods","o":"assignClassDef","f":"hp_assignClassDef","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"assignClassDef(Class, def, where = .GlobalEnv, force = FALSE, doSubclasses = is(def, \"ClassUnionRepresentation\"))"},{"p":"methods","o":"methodSignatureMatrix","f":"hp_methodSignatureMatrix","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"methodSignatureMatrix(object, sigSlots = c(\"target\", \"defined\"))"},{"p":"methods","o":".__T__coerce<-:methods","f":"hp_.__T__coerce...methods","d":"-NA-","ec":""},{"p":"methods","o":"body<-","f":"hp_body..","d":"-NA-","ec":"body<-(fun, envir = environment(fun), value)"},{"p":"methods","o":"isGrammarSymbol","f":"hp_isGrammarSymbol","d":"Internal routines to support some operations on language objects.\n","ec":"isGrammarSymbol(symbol)"},{"p":"methods","o":"prototype","f":"hp_prototype","d":"These are old utility functions  to construct, respectively\na list designed to represent the slots and superclasses and\na list of prototype specifications.  The representation()\nfunction is no longer useful, since the arguments slots and\ncontains to setClass are now recommended.\n","ec":"prototype(...)"},{"p":"methods","o":"requireMethods","f":"hp_requireMethods","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"requireMethods(functions, signature, message = \"\", where = topenv(parent.frame()))"},{"p":"methods","o":".__C__data.frameRowLabels","f":"hp_.__C__data.frameRowLabels","d":"-NA-","ec":""},{"p":"methods","o":".__C__activeBindingFunction","f":"hp_.__C__activeBindingFunction","d":"-NA-","ec":""},{"p":"methods","o":".__C__externalptr","f":"hp_.__C__externalptr","d":"-NA-","ec":""},{"p":"methods","o":".__C__.name","f":"hp_.__C__.name","d":"-NA-","ec":""},{"p":"methods","o":"slot<-","f":"hp_slot..","d":"These functions return or set information about the individual slots\nin an object.\n","ec":"slot<-(object, name, check = TRUE, value)"},{"p":"methods","o":"setOldClass","f":"hp_setOldClass","d":"Register an old-style (a.k.a. <U+2018>S3<U+2019>) class as a formally defined\nclass. Simple usage will be of the form:\n","ec":"setOldClass(Classes, prototype = NULL, where = topenv(parent.frame()), test = FALSE, S4Class)"},{"p":"methods","o":"setPrimitiveMethods","f":"hp_setPrimitiveMethods","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"setPrimitiveMethods(f, fdef, code, generic, mlist = get(\".Methods\", envir = environment(generic)))"},{"p":"methods","o":".__C__recordedplot","f":"hp_.__C__recordedplot","d":"-NA-","ec":""},{"p":"methods","o":"isGroup","f":"hp_isGroup","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"isGroup(f, where = topenv(parent.frame()), fdef = getGeneric(f, where = where))"},{"p":"methods","o":"getAllSuperClasses","f":"hp_getAllSuperClasses","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"getAllSuperClasses(ClassDef, simpleOnly = TRUE)"},{"p":"methods","o":".__C__localRefClass","f":"hp_.__C__localRefClass","d":"-NA-","ec":""},{"p":"methods","o":"findMethods","f":"hp_findMethods","d":"The function findMethods converts the methods defined in a table for a generic\nfunction (as used for selection of methods) into a list, for study or\ndisplay.  The list is actually from the class listOfMethods\n(see the section describing the class, below).\n","ec":"findMethods(f, where, classes = character(), inherited = FALSE, package = \"\")"},{"p":"methods","o":".__T__kronecker:base","f":"hp_.__T__kronecker.base","d":"-NA-","ec":""},{"p":"methods","o":".__T__rbind2:methods","f":"hp_.__T__rbind2.methods","d":"-NA-","ec":""},{"p":"methods","o":"rematchDefinition","f":"hp_rematchDefinition","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"rematchDefinition(definition, generic, mnames, fnames, signature)"},{"p":"methods","o":"MethodAddCoerce","f":"hp_MethodAddCoerce","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"MethodAddCoerce(method, argName, thisClass, methodClass)"},{"p":"methods","o":".__C__POSIXt","f":"hp_.__C__POSIXt","d":"-NA-","ec":""},{"p":"methods","o":".__C__summary.table","f":"hp_.__C__summary.table","d":"-NA-","ec":""},{"p":"methods","o":"hasMethod","f":"hp_hasMethod","d":"The function selectMethod() returns the method that\nwould be selected for a call to function f if the arguments had\nclasses as specified by signature.  Failing to find a method\nis an error, unless argument optional = TRUE, in which case\nNULL is returned.\n","ec":"hasMethod(f, signature = character(), where = .genEnv(f, topenv(parent.frame())))"},{"p":"methods","o":".__C__language","f":"hp_.__C__language","d":"-NA-","ec":""},{"p":"methods","o":".__C__refClass","f":"hp_.__C__refClass","d":"-NA-","ec":""},{"p":"methods","o":".__T__initialize:methods","f":"hp_.__T__initialize.methods","d":"-NA-","ec":""},{"p":"methods","o":"evalqOnLoad","f":"hp_evalqOnLoad","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"evalqOnLoad(expr, where = topenv(parent.frame()), aname = \"\")"},{"p":"methods","o":".__T__$<-:base","f":"hp_.__T__....base","d":"-NA-","ec":""},{"p":"methods","o":"insertSource","f":"hp_insertSource","d":"Definitions of functions and/or methods from a source file are\ninserted into a package, using the trace mechanism.\nTypically, this allows testing or debugging modified versions of a few\nfunctions without reinstalling a large package.\n","ec":"insertSource(source, package = \"\", functions = allPlainObjects(), methods = (if (missing(functions)) allMethodTables() else NULL), force = missing(functions) & missing(methods))"},{"p":"methods","o":"hasLoadAction","f":"hp_hasLoadAction","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"hasLoadAction(aname, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__numeric","f":"hp_.__C__numeric","d":"-NA-","ec":""},{"p":"methods","o":".__C__derivedDefaultMethodWithTrace","f":"hp_.__C__derivedDefaultMethodWithTrace","d":"-NA-","ec":""},{"p":"methods","o":".__C__externalRefMethod","f":"hp_.__C__externalRefMethod","d":"-NA-","ec":""},{"p":"methods","o":"validSlotNames","f":"hp_validSlotNames","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"validSlotNames(names)"},{"p":"methods","o":"multipleClasses","f":"hp_multipleClasses","d":"The function className() generates a\nvalid references to a class, including the name of the package\ncontaining the class definition.  The object returned, from class \"className\", is the\nunambiguous way to refer to a class, for example when calling\nsetMethod, just in case multiple definitions of the\nclass exist.\n","ec":"multipleClasses(details = FALSE)"},{"p":"methods","o":".__T__addNextMethod:methods","f":"hp_.__T__addNextMethod.methods","d":"-NA-","ec":""},{"p":"methods","o":"empty.dump","f":"hp_empty.dump","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"empty.dump()"},{"p":"methods","o":"setPackageName","f":"hp_setPackageName","d":"The functions below produce the package associated with a particular\nenvironment or position on the search list, or of the package\ncontaining a particular function.  They are primarily used to support\ncomputations that need to differentiate objects on multiple packages.\n","ec":"setPackageName(pkg, env)"},{"p":"methods","o":"el<-","f":"hp_el..","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":""},{"p":"methods","o":".__C__MethodDefinitionWithTrace","f":"hp_.__C__MethodDefinitionWithTrace","d":"-NA-","ec":""},{"p":"methods","o":".__C__maov","f":"hp_.__C__maov","d":"-NA-","ec":""},{"p":"methods","o":".__T__Ops:base","f":"hp_.__T__Ops.base","d":"-NA-","ec":""},{"p":"methods","o":"elNamed<-","f":"hp_elNamed..","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"elNamed<-(x, name, value)"},{"p":"methods","o":".__C__standardGenericWithTrace","f":"hp_.__C__standardGenericWithTrace","d":"-NA-","ec":""},{"p":"methods","o":"getClassDef","f":"hp_getClassDef","d":"Get the definition of a class.\n","ec":"getClassDef(Class, where = topenv(parent.frame()), package = packageSlot(Class), inherits = TRUE)"},{"p":"methods","o":"newEmptyObject","f":"hp_newEmptyObject","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"newEmptyObject()"},{"p":"methods","o":"formalArgs","f":"hp_formalArgs","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"formalArgs(def)"},{"p":"methods","o":"Arith","f":"hp_Arith","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Arith(e1, e2)"},{"p":"methods","o":"mergeMethods","f":"hp_mergeMethods","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"mergeMethods(m1, m2, genericLabel = character())"},{"p":"methods","o":"MethodsList","f":"hp_MethodsList","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"MethodsList(.ArgName, ...)"},{"p":"methods","o":"getRefClass","f":"hp_getRefClass","d":"The software described here allows packages to define reference\nclasses that behave in the style of <U+201C>OOP<U+201D> languages such as Java and\nC++.\nThis model for OOP differs from the functional model implemented by S4\n(and S3) classes and methods, in which methods are defined for generic\nfunctions.\nMethods for reference classes are <U+201C>encapsulated<U+201D> in the class definition.\n","ec":"getRefClass(Class, where = topenv(parent.frame()))"},{"p":"methods","o":"inheritedSlotNames","f":"hp_inheritedSlotNames","d":"For a class (or class definition, see getClass and\nthe description of class classRepresentation),\ngive the names which are inherited from <U+201C>above<U+201D>, i.e., super\nclasses, rather than by this class' definition itself.\n","ec":"inheritedSlotNames(Class, where = topenv(parent.frame()))"},{"p":"methods","o":".__C__.NULL","f":"hp_.__C__.NULL","d":"-NA-","ec":""},{"p":"methods","o":".__C__PossibleMethod","f":"hp_.__C__PossibleMethod","d":"-NA-","ec":""},{"p":"methods","o":"classesToAM","f":"hp_classesToAM","d":"Given a vector of class names or a list of class definitions, the\nfunction returns an adjacency matrix of the superclasses of these\nclasses; that is, a matrix with class names as the row and column\nnames and with element [i, j] being 1 if the class in column j is a\ndirect superclass of the class in row i, and 0 otherwise.\n","ec":"classesToAM(classes, includeSubclasses = FALSE, abbreviate = 2)"},{"p":"methods","o":".__C__functionWithTrace","f":"hp_.__C__functionWithTrace","d":"-NA-","ec":""},{"p":"methods","o":"asMethodDefinition","f":"hp_asMethodDefinition","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"asMethodDefinition(def, signature = list(.anyClassName), sealed = FALSE, fdef = def)"},{"p":"methods","o":".__C__factor","f":"hp_.__C__factor","d":"-NA-","ec":""},{"p":"methods","o":".__T__Math:base","f":"hp_.__T__Math.base","d":"-NA-","ec":""},{"p":"methods","o":".__C__sourceEnvironment","f":"hp_.__C__sourceEnvironment","d":"-NA-","ec":""},{"p":"methods","o":"languageEl","f":"hp_languageEl","d":"Internal routines to support some operations on language objects.\n","ec":"languageEl(object, which)"},{"p":"methods","o":"Ops","f":"hp_Ops","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Ops(e1, e2)"},{"p":"methods","o":"getMethod","f":"hp_getMethod","d":"The function selectMethod() returns the method that\nwould be selected for a call to function f if the arguments had\nclasses as specified by signature.  Failing to find a method\nis an error, unless argument optional = TRUE, in which case\nNULL is returned.\n","ec":"getMethod(f, signature = character(), where = topenv(parent.frame()), optional = FALSE, mlist, fdef)"},{"p":"methods","o":".__C__MethodDefinition","f":"hp_.__C__MethodDefinition","d":"-NA-","ec":""},{"p":"methods","o":"listFromMlist","f":"hp_listFromMlist","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"listFromMlist(mlist, prefix = list(), sigs. = TRUE, methods. = TRUE)"},{"p":"methods","o":"allNames","f":"hp_allNames","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"allNames(x)"},{"p":"methods","o":".__C__mts","f":"hp_.__C__mts","d":"-NA-","ec":""},{"p":"methods","o":".__C__mtable","f":"hp_.__C__mtable","d":"-NA-","ec":""},{"p":"methods","o":"completeSubclasses","f":"hp_completeSubclasses","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"completeSubclasses(classDef, class2, extensionDef, where, classDef2 = getClassDef(class2, where))"},{"p":"methods","o":"cacheGenericsMetaData","f":"hp_cacheGenericsMetaData","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"cacheGenericsMetaData(f, fdef, attach = TRUE, where = topenv(parent.frame()), package, methods)"},{"p":"methods","o":".__C__data.frame","f":"hp_.__C__data.frame","d":"-NA-","ec":""},{"p":"methods","o":"tryNew","f":"hp_tryNew","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"tryNew(Class, where)"},{"p":"methods","o":"findClass","f":"hp_findClass","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"findClass(Class, where = topenv(parent.frame()), unique = \"\")"},{"p":"methods","o":"cacheMethod","f":"hp_cacheMethod","d":"These are internal support routines for computations on formal methods.\n","ec":"cacheMethod(f, sig, def, args = names(sig), fdef, inherited = FALSE)"},{"p":"methods","o":"showDefault","f":"hp_showDefault","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"showDefault(object, oldMethods = TRUE)"},{"p":"methods","o":"Compare","f":"hp_Compare","d":"Methods can be defined for group generic functions.  Each group\ngeneric function has a number of member generic functions\nassociated with it.\n","ec":"Compare(e1, e2)"},{"p":"methods","o":"new","f":"hp_new","d":"A call to  new returns a newly allocated object from the\nclass identified by the first argument.  This call in turn calls the\nmethod for the generic function initialize corresponding to\nthe specified class, passing the ... arguments to this\nmethod.\nIn the default method for initialize(), named arguments provide\nvalues for the corresponding slots and unnamed arguments must be\nobjects from superclasses of this class.\n","ec":"new(Class, ...)"},{"p":"methods","o":".__C__if","f":"hp_.__C__if","d":"-NA-","ec":""},{"p":"methods","o":".__C__EmptyMethodsList","f":"hp_.__C__EmptyMethodsList","d":"-NA-","ec":""},{"p":"methods","o":"makeClassRepresentation","f":"hp_makeClassRepresentation","d":"Constructs an object of class classRepresentation\nto describe a particular class.  Mostly a utility function, but you can\ncall it to create a class definition without assigning it, as\nsetClass would do.\n","ec":"makeClassRepresentation(name, slots = list(), superClasses = character(), prototype = NULL, package, validity = NULL, access = list(), version = .newExternalptr(), sealed = FALSE, virtual = NA, where)"},{"p":"methods","o":"promptClass","f":"hp_promptClass","d":"Assembles all relevant slot and method information for a class, with\nminimal markup for Rd processing; no QC facilities at present.\n","ec":"promptClass(clName, filename = NULL, type = \"class\", keywords = \"classes\", where = topenv(parent.frame()), generatorName = clName)"},{"p":"methods","o":".__C__optionalMethod","f":"hp_.__C__optionalMethod","d":"-NA-","ec":""},{"p":"methods","o":"newClassRepresentation","f":"hp_newClassRepresentation","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"newClassRepresentation(...)"},{"p":"methods","o":".S4methods","f":"hp_.S4methods","d":"Show a summary of the methods for one or more generic functions,\npossibly restricted to those involving specified classes.\n","ec":".S4methods(generic.function, class)"},{"p":"methods","o":".__C__ANY","f":"hp_.__C__ANY","d":"-NA-","ec":""},{"p":"methods","o":"testVirtual","f":"hp_testVirtual","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"testVirtual(properties, extends, prototype, where)"},{"p":"methods","o":".__C__refClassRepresentation","f":"hp_.__C__refClassRepresentation","d":"-NA-","ec":""},{"p":"methods","o":".__C__conditionalExtension","f":"hp_.__C__conditionalExtension","d":"-NA-","ec":""},{"p":"methods","o":"linearizeMlist","f":"hp_linearizeMlist","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"linearizeMlist(mlist, inherited = TRUE)"},{"p":"methods","o":"removeGeneric","f":"hp_removeGeneric","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"removeGeneric(f, where = topenv(parent.frame()))"},{"p":"methods","o":"canCoerce","f":"hp_canCoerce","d":"Test if an object can be coerced to a given S4 class.\nMaybe useful inside if() to ensure that calling\nas(object, Class) will find a method.\n","ec":"canCoerce(object, Class)"},{"p":"methods","o":".__C__traceable","f":"hp_.__C__traceable","d":"-NA-","ec":""},{"p":"methods","o":"S3Class<-","f":"hp_S3Class..","d":"A regular (S4) class may contain an S3 class, if that class has been registered (by calling\nsetOldClass).  The functions described here provide\ninformation about contained S3 classes.  See the section <U+2018>Functions<U+2019>.\n","ec":"S3Class<-(object, value)"},{"p":"methods","o":".__C__MethodWithNextWithTrace","f":"hp_.__C__MethodWithNextWithTrace","d":"-NA-","ec":""},{"p":"methods","o":"rbind2","f":"hp_rbind2","d":"Combine two matrix-like R objects by columns (cbind2)\nor rows (rbind2).  These are (S4) generic functions with default\nmethods.\n","ec":"rbind2(x, y, ...)"},{"p":"methods","o":".__C__anova.glm.null","f":"hp_.__C__anova.glm.null","d":"-NA-","ec":""},{"p":"methods","o":".__C__.externalptr","f":"hp_.__C__.externalptr","d":"-NA-","ec":""},{"p":"methods","o":".__C__matrix","f":"hp_.__C__matrix","d":"-NA-","ec":""},{"p":"methods","o":"setValidity","f":"hp_setValidity","d":"validObject() tests the validity of object related to\nits class definition; specifically, it checks that all slots\nspecified in the class definition are present and that the object in\nthe slot is from the required class or a subclass of that class.\n","ec":"setValidity(Class, method, where = topenv(parent.frame()))"},{"p":"methods","o":"functionBody","f":"hp_functionBody","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"functionBody(fun = sys.function(sys.parent()))"},{"p":"methods","o":".__C__hsearch","f":"hp_.__C__hsearch","d":"-NA-","ec":""},{"p":"methods","o":".__C__function","f":"hp_.__C__function","d":"-NA-","ec":""},{"p":"methods","o":"getGeneric","f":"hp_getGeneric","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"getGeneric(f, mustFind = FALSE, where, package = \"\")"},{"p":"methods","o":".__C__POSIXlt","f":"hp_.__C__POSIXlt","d":"-NA-","ec":""},{"p":"methods","o":"dumpMethod","f":"hp_dumpMethod","d":"The functions documented here manage collections of methods associated\nwith a generic function, as well as providing information about the\ngeneric functions themselves.\n","ec":"dumpMethod(f, signature = character(), file = defaultDumpName(f, signature), where = topenv(parent.frame()), def = getMethod(f, signature, where = where, optional = TRUE))"},{"p":"methods","o":"elNamed","f":"hp_elNamed","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"elNamed(x, name, mustFind = FALSE)"},{"p":"methods","o":".__C__logical","f":"hp_.__C__logical","d":"-NA-","ec":""},{"p":"methods","o":".__C__nonstandardGenericWithTrace","f":"hp_.__C__nonstandardGenericWithTrace","d":"-NA-","ec":""},{"p":"methods","o":".__C__summaryDefault","f":"hp_.__C__summaryDefault","d":"-NA-","ec":""},{"p":"methods","o":".__C__derivedDefaultMethod","f":"hp_.__C__derivedDefaultMethod","d":"-NA-","ec":""},{"p":"methods","o":".__C__nonstandardGeneric","f":"hp_.__C__nonstandardGeneric","d":"-NA-","ec":""},{"p":"methods","o":".doTracePrint","f":"hp_.doTracePrint","d":" The classes described  here are used by the R function\ntrace to create versions of functions and methods\nincluding browser calls, etc., and also to untrace the\nsame objects.","ec":".doTracePrint(msg = \"\")"},{"p":"methods","o":".__C__glm","f":"hp_.__C__glm","d":"-NA-","ec":""},{"p":"methods","o":".__C__nonstandardGenericFunction","f":"hp_.__C__nonstandardGenericFunction","d":"-NA-","ec":""},{"p":"methods","o":".__C__refObjectGenerator","f":"hp_.__C__refObjectGenerator","d":"-NA-","ec":""},{"p":"methods","o":".__C__builtin","f":"hp_.__C__builtin","d":"-NA-","ec":""},{"p":"methods","o":".__T__Summary:base","f":"hp_.__T__Summary.base","d":"-NA-","ec":""},{"p":"methods","o":"setClass","f":"hp_setClass","d":"Create  a class definition and return a generator function to create\nobjects from the class.  Typical usage will be\nof the style:\n","ec":"setClass(Class, representation = list(), prototype = NULL, contains = character(), validity = NULL, access = list(), where = topenv(parent.frame()), version = .newExternalptr(), sealed = FALSE, package = getPackageName(where), S3methods = FALSE, slots)"},{"p":"methods","o":".__C__for","f":"hp_.__C__for","d":"-NA-","ec":""},{"p":"methods","o":"isSealedClass","f":"hp_isSealedClass","d":"These functions check for either a method or a class that has been\nsealed when it was defined, and which therefore cannot be\nre-defined.\n","ec":"isSealedClass(Class, where = topenv(parent.frame()))"},{"p":"methods","o":"generic.skeleton","f":"hp_generic.skeleton","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"generic.skeleton(name, fdef, fdefault)"},{"p":"methods","o":".__C__internalDispatchMethod","f":"hp_.__C__internalDispatchMethod","d":"-NA-","ec":""},{"p":"methods","o":".__C__anova.glm","f":"hp_.__C__anova.glm","d":"-NA-","ec":""},{"p":"methods","o":"makeGeneric","f":"hp_makeGeneric","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"makeGeneric(f, fdef, fdefault = fdef, group = list(), valueClass = character(), package = getPackageName(environment(fdef)), signature = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL)"},{"p":"methods","o":"setMethod","f":"hp_setMethod","d":"Create a method for a generic function, corresponding to a signature of classes for the arguments. Standard usage will be of the form:\n","ec":"setMethod(f, signature = character(), definition, where = topenv(parent.frame()), valueClass = NULL, sealed = FALSE)"},{"p":"methods","o":"isClassUnion","f":"hp_isClassUnion","d":"A class may be defined as the union of other classes; that\nis, as a virtual class defined as a superclass of several other\nclasses. Class unions are useful in method signatures or as slots in\nother classes, when we want to allow one of several classes to be supplied.\n","ec":"isClassUnion(Class)"},{"p":"methods","o":"coerce","f":"hp_coerce","d":"A call to setAs defines a method for coercing an object of\nclass from to class to.  The methods will then be used\nby calls to as for objects with class from,\nincluding calls that replace part of the object.\n","ec":"coerce(from, to, strict = TRUE)"},{"p":"methods","o":"initFieldArgs","f":"hp_initFieldArgs","d":"The software described here allows packages to define reference\nclasses that behave in the style of <U+201C>OOP<U+201D> languages such as Java and\nC++.\nThis model for OOP differs from the functional model implemented by S4\n(and S3) classes and methods, in which methods are defined for generic\nfunctions.\nMethods for reference classes are <U+201C>encapsulated<U+201D> in the class definition.\n","ec":"initFieldArgs(.Object, classDef, selfEnv, ...)"},{"p":"methods","o":".valueClassTest","f":"hp_.valueClassTest","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":".valueClassTest(object, classes, fname)"},{"p":"methods","o":"validObject","f":"hp_validObject","d":"validObject() tests the validity of object related to\nits class definition; specifically, it checks that all slots\nspecified in the class definition are present and that the object in\nthe slot is from the required class or a subclass of that class.\n","ec":"validObject(object, test = FALSE, complete = FALSE)"},{"p":"methods","o":"getClasses","f":"hp_getClasses","d":"Functions to find classes:  isClass tests for a class;\nfindClass returns the name(s) of packages containing the\nclass; getClasses returns the names of all the classes in an\nenvironment, typically a namespace.  To examine the definition of a class, use getClass.\n","ec":"getClasses(where = .externalCallerEnv(), inherits = missing(where))"},{"p":"methods","o":"setGeneric","f":"hp_setGeneric","d":"Create a generic version of the named function so that methods may\nbe defined for it.  A call to setMethod will call\nsetGeneric automatically if applied to a non-generic\nfunction.\n","ec":"setGeneric(name, def = NULL, group = list(), valueClass = character(), where = topenv(parent.frame()), package = NULL, signature = NULL, useAsDefault = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL)"},{"p":"methods","o":".__C__<-","f":"hp_.__C__..","d":"-NA-","ec":""},{"p":"methods","o":"unRematchDefinition","f":"hp_unRematchDefinition","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"unRematchDefinition(definition)"},{"p":"methods","o":".__C__nonStructure","f":"hp_.__C__nonStructure","d":"-NA-","ec":""},{"p":"methods","o":"hasMethods","f":"hp_hasMethods","d":"The function findMethods converts the methods defined in a table for a generic\nfunction (as used for selection of methods) into a list, for study or\ndisplay.  The list is actually from the class listOfMethods\n(see the section describing the class, below).\n","ec":"hasMethods(f, where, package = \"\")"},{"p":"methods","o":".__C__call","f":"hp_.__C__call","d":"-NA-","ec":""},{"p":"methods","o":"existsFunction","f":"hp_existsFunction","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"existsFunction(f, generic = TRUE, where = topenv(parent.frame()))"},{"p":"methods","o":"classLabel","f":"hp_classLabel","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"classLabel(Class)"},{"p":"methods","o":"defaultPrototype","f":"hp_defaultPrototype","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"defaultPrototype()"},{"p":"methods","o":".__C__MethodWithNext","f":"hp_.__C__MethodWithNext","d":"-NA-","ec":""},{"p":"methods","o":".__C__rle","f":"hp_.__C__rle","d":"-NA-","ec":""},{"p":"methods","o":"showMethods","f":"hp_showMethods","d":"Show a summary of the methods for one or more generic functions,\npossibly restricted to those involving specified classes.\n","ec":"showMethods(f = character(), where = topenv(parent.frame()), classes = NULL, includeDefs = FALSE, inherited = !includeDefs, showEmpty, printTo = stdout(), fdef = getGeneric(f, where = where))"},{"p":"methods","o":".__C__logLik","f":"hp_.__C__logLik","d":"-NA-","ec":""},{"p":"methods","o":".__C__namedList","f":"hp_.__C__namedList","d":"-NA-","ec":""},{"p":"methods","o":".__C__formula","f":"hp_.__C__formula","d":"-NA-","ec":""},{"p":"methods","o":"findMethod","f":"hp_findMethod","d":"The function selectMethod() returns the method that\nwould be selected for a call to function f if the arguments had\nclasses as specified by signature.  Failing to find a method\nis an error, unless argument optional = TRUE, in which case\nNULL is returned.\n","ec":"findMethod(f, signature, where = topenv(parent.frame()))"},{"p":"methods","o":"testInheritedMethods","f":"hp_testInheritedMethods","d":"A set of distinct inherited signatures is generated to test\ninheritance for all the methods of a specified generic function.  If\nmethod selection is ambiguous for some of these, a summary of the\nambiguities is attached to the returned object.  This test should be\nperformed by package authors before releasing a package.\n","ec":"testInheritedMethods(f, signatures, test = TRUE, virtual = FALSE, groupMethods = TRUE, where = .GlobalEnv)"},{"p":"methods","o":"as","f":"hp_as","d":"Coerce an object to a given class.\n","ec":"as(object, Class, strict = TRUE, ext = possibleExtends(thisClass, Class))"},{"p":"methods","o":"conformMethod","f":"hp_conformMethod","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"conformMethod(signature, mnames, fnames, f = \"<unspecified>\", fdef, method)"},{"p":"methods","o":"makeMethodsList","f":"hp_makeMethodsList","d":"These functions create and manipulate MethodsList objects, the\nobjects formerly used in R to store methods for dispatch.  Use of\nthese objects is deprecated since R 3.2.0, as it will rarely be a\ngood idea.  Where methods dispatch is\nto be studied, see selectMethod.  For computations\nthat iterate over methods or over method signatures, see\nfindMethods, which returns a linearized methods list\nto hold method definitions, usually more convenient for iteration\nthan the recursive MethodsList objects.\n","ec":"makeMethodsList(object, level = 1)"},{"p":"methods","o":"newBasic","f":"hp_newBasic","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"newBasic(Class, ...)"},{"p":"methods","o":".__C__while","f":"hp_.__C__while","d":"-NA-","ec":""},{"p":"methods","o":".slotNames","f":"hp_.slotNames","d":"These functions return or set information about the individual slots\nin an object.\n","ec":".slotNames(x)"},{"p":"methods","o":"className","f":"hp_className","d":"The function className() generates a\nvalid references to a class, including the name of the package\ncontaining the class definition.  The object returned, from class \"className\", is the\nunambiguous way to refer to a class, for example when calling\nsetMethod, just in case multiple definitions of the\nclass exist.\n","ec":"className(class, package)"},{"p":"methods","o":".__C__expression","f":"hp_.__C__expression","d":"-NA-","ec":""},{"p":"methods","o":".__C__refMethodDefWithTrace","f":"hp_.__C__refMethodDefWithTrace","d":"-NA-","ec":""},{"p":"methods","o":"functionBody<-","f":"hp_functionBody..","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"functionBody<-(fun, envir = environment(fun), value)"},{"p":"methods","o":"setLoadAction","f":"hp_setLoadAction","d":"These functions provide a mechanism for packages to specify\ncomputations to be done during the loading of a package namespace.\nSuch actions are a flexible way to provide information only available at\nload time (such as locations in a dynamically linked library).\n","ec":"setLoadAction(action, aname = \"\", where = topenv(parent.frame()))"},{"p":"methods","o":".__C__VIRTUAL","f":"hp_.__C__VIRTUAL","d":"-NA-","ec":""},{"p":"methods","o":"superClassDepth","f":"hp_superClassDepth","d":"These are various functions to support the definition and use of\nformal classes.  Most of them are rarely suitable to be called\ndirectly.\n","ec":"superClassDepth(ClassDef, soFar = ClassDef@className, simpleOnly = TRUE)"},{"p":"methods","o":".__T__[:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"methods","o":".__C__SClassExtension","f":"hp_.__C__SClassExtension","d":"-NA-","ec":""},{"p":"methods","o":"existsMethod","f":"hp_existsMethod","d":"The function selectMethod() returns the method that\nwould be selected for a call to function f if the arguments had\nclasses as specified by signature.  Failing to find a method\nis an error, unless argument optional = TRUE, in which case\nNULL is returned.\n","ec":"existsMethod(f, signature = character(), where = topenv(parent.frame()))"},{"p":"methods","o":"getFunction","f":"hp_getFunction","d":"These are internal utilities, currently in the methods\npackage, that either provide some functionality needed by the package\n(e.g., element matching by name), or add compatibility with S-Plus, or both.\n","ec":"getFunction(name, generic = TRUE, mustFind = TRUE, where = topenv(parent.frame()))"},{"p":"methods","o":"getMethodsMetaData","f":"hp_getMethodsMetaData","d":"Utility functions to support the definition and use of formal\nmethods.  Most of these functions will not normally be called directly\nby the user.\n","ec":"getMethodsMetaData(f, where = topenv(parent.frame()))"},{"p":"mgcv","o":"rmvn","f":"hp_rmvn","d":" Generates multivariate normal or t random deviates, and evaluates the corresponding log densities.\n","ec":"rmvn(n, mu, V)"},{"p":"mgcv","o":"notLog2","f":"hp_notLog2","d":"notLog2 and notExp2 are alternatives to log\nand exp or notLog and notExp for\nre-parameterization of variance parameters. They are used by the\npdTens and pdIdnot classes which in turn implement\nsmooths for gamm.\n","ec":"notLog2(x, d = .Options$mgcv.vc.logrange, b = 1/d)"},{"p":"mgcv","o":"rTweedie","f":"hp_rTweedie","d":" Generates Tweedie random deviates, for powers between 1 and 2.\n","ec":"rTweedie(mu, p = 1.5, phi = 1)"},{"p":"mgcv","o":"gumbls","f":"hp_gumbls","d":"The gumbls family implements Gumbel location scale additive models in which the location and scale parameters (see details) can depend on additive smooth predictors. Useable only with gam, the linear predictors are specified via a list of formulae.\n","ec":"gumbls(link = list(\"identity\", \"log\"), b = -7)"},{"p":"mgcv","o":"fix.family.qf","f":"hp_fix.family.qf","d":" Generalized Additive Model fitting by <U+2018>outer<U+2019> iteration,\nrequires extra derivatives of the variance and link functions to be \nadded to family objects. The first 3 functions add what is needed. Model checking can\nbe aided by adding quantile and random deviate generating functions to the family. \nThe final two functions do this.\n","ec":"fix.family.qf(fam)"},{"p":"mgcv","o":"gaulss","f":"hp_gaulss","d":"The gaulss family implements Gaussian location scale additive models in which \nthe mean and the logb of the standard deviation (see details) can depend on additive smooth predictors. Useable \nonly with gam, the linear predictors are specified via a list of formulae.\n","ec":"gaulss(link = list(\"identity\", \"logb\"), b = 0.01)"},{"p":"mgcv","o":"Predict.matrix.sos.smooth","f":"hp_Predict.matrix.sos.smooth","d":"gam can use isotropic smooths on the sphere, via terms like \ns(la,lo,bs=\"sos\",m=2,k=100). There must be exactly 2 arguments to such a smooth. \nThe first is taken to be latitude (in degrees) and the second longitude (in degrees). \nm (default 0) is an integer in the range -1 to 4 determining the order of the penalty used. \nFor m>0, (m+2)/2 is the penalty order, with m=2 equivalent to the usual second \nderivative penalty. m=0 signals to use the 2nd order spline on the sphere, computed by \nWendelberger's (1981) method. m = -1 results in a Duchon.spline being \nused (with m=2 and s=1/2), following an unpublished suggestion of Jean Duchon.\n","ec":"Predict.matrix.sos.smooth(object, data)"},{"p":"mgcv","o":"mini.roots","f":"hp_mini.roots","d":"INTERNAL function to obtain square roots, B[[i]], of the penalty matrices S[[i]]'s having as few\ncolumns as possible.\n","ec":"mini.roots(S, off, np, rank = NULL)"},{"p":"mgcv","o":"exclude.too.far","f":"hp_exclude.too.far","d":" Takes two arrays defining the nodes of a grid over a 2D covariate space and two arrays \ndefining the location of data in that space, and returns a logical vector with elements TRUE if \nthe corresponding node is too far from data and FALSE otherwise. Basically a service routine for \nvis.gam and plot.gam.\n","ec":"exclude.too.far(g1, g2, d1, d2, dist)"},{"p":"mgcv","o":"smooth.construct.tp.smooth.spec","f":"hp_smooth.construct.tp.smooth.spec","d":"gam can use isotropic smooths of any number of variables, specified via terms like\ns(x,z,bs=\"tp\",m=3) (or just s(x,z) as this is the default basis). These terms are based on thin plate \nregression splines. m specifies the order of the derivatives in the thin plate spline penalty.\n","ec":"smooth.construct.tp.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"new.name","f":"hp_new.name","d":"gamm works by transforming a GAMM into something \nthat can be estimated by lme, but this involves creating new \nvariables, the names of which should not clash with the names of other \nvariables on which the model depends. This simple service routine checks a \nsuggested name against a list of those in use, and if neccesary modifies it \nso that there is no clash.","ec":"new.name(proposed, old.names)"},{"p":"mgcv","o":"Predict.matrix","f":"hp_Predict.matrix","d":" Takes smooth objects produced by smooth.construct methods and obtains the matrix mapping \nthe parameters associated with such a smooth to the predicted values of the smooth at a set of new covariate values.\n","ec":"Predict.matrix(object, data)"},{"p":"mgcv","o":"smooth.construct.so.smooth.spec","f":"hp_smooth.construct.so.smooth.spec","d":" Sets up basis functions and wiggliness penalties for\nsoap film smoothers (Wood, Bravington and Hedley, 2008). Soap film smoothers are based on the idea of\nconstructing a 2-D smooth as a film of soap connecting a smoothly varying\nclosed boundary. Unless smoothing very heavily, the film is distorted towards\nthe data. The smooths are designed not to smooth across boundary features (peninsulas,\nfor example).\n","ec":"smooth.construct.so.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"gam.reparam","f":"hp_gam.reparam","d":"INTERNAL function for finding an orthogonal re-parameterization which avoids \"dominant machine zero leakage\" between\ncomponents of the square root penalty.\n","ec":"gam.reparam(rS, lsp, deriv)"},{"p":"mgcv","o":"pdTens","f":"hp_pdTens","d":"This set of functions implements an nlme library pdMat class to allow\ntensor product smooths to be estimated by lme as called by gamm. Tensor product smooths\nhave a penalty matrix made up of a weighted sum of penalty matrices, where the weights are the smoothing \nparameters. In the mixed model formulation the penalty matrix is the inverse of the covariance matrix for \nthe random effects of a term, and the smoothing parameters (times a half) are variance parameters to be estimated. \nIt's not possible to transform the problem to make the required random effects covariance matrix look like one of the standard \npdMat classes: hence the need for the pdTens class. A notLog2 parameterization ensures that \nthe parameters are positive. \n","ec":"pdTens(value = numeric(0), form = NULL, nam = NULL, data = sys.frame(sys.parent()))"},{"p":"mgcv","o":"gamlss.etamu","f":"hp_gamlss.etamu","d":"Mainly intended for internal use in specifying location scale models.\nLet g(mu) = lp, where lp is the linear predictor, and g is the link\nfunction. Assume that we have calculated the derivatives of the log-likelihood wrt mu.\nThis function uses the chain rule to calculate the derivatives of the log-likelihood wrt\nlp. See trind.generator for array packing conventions. \n","ec":"gamlss.etamu(l1, l2, l3 = NULL, l4 = NULL, ig1, g2, g3 = NULL, g4 = NULL, i2, i3 = NULL, i4 = NULL, deriv = 0)"},{"p":"mgcv","o":"notExp","f":"hp_notExp","d":" It is common practice in statistical optimization to use log-parameterizations when a \nparameter ought to be positive. i.e. if an optimization parameter a should be non-negative then \nwe use a=exp(b) and optimize with respect to the unconstrained parameter b. This often works \nwell, but it does imply a rather limited working range for b: using 8 byte doubles, for example, \nif b's magnitude gets much above 700 then a overflows or underflows. This can cause \nproblems for numerical optimization methods. \n","ec":"notExp(x)"},{"p":"mgcv","o":"Predict.matrix.gp.smooth","f":"hp_Predict.matrix.gp.smooth","d":"Gaussian process/kriging models based on simple covariance functions can be written in a very similar form to thin plate and Duchon spline models (e.g. Handcock, Meier, Nychka, 1994), and low rank versions produced by the eigen approximation method of Wood (2003). Kammann and Wand (2003) suggest a particularly simple form of the Matern covariance function with only a single smoothing parameter to estimate, and this class implements this and other similar models.  \n","ec":"Predict.matrix.gp.smooth(object, data)"},{"p":"mgcv","o":"gam","f":"hp_gam","d":" Fits a generalized additive model (GAM) to\ndata, the term <U+2018>GAM<U+2019> being taken to include any quadratically penalized GLM and a variety of \nother models estimated by a quadratically penalised likelihood type approach (see family.mgcv).  \nThe degree of smoothness of model terms is estimated as part of\nfitting. gam can also fit any GLM subject to multiple quadratic penalties (including \nestimation of degree of penalization). Confidence/credible intervals are readily\navailable for any quantity predicted using a fitted model.\n","ec":"gam(formula, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action, offset = NULL, method = \"GCV.Cp\", optimizer = c(\"outer\", \"newton\"), control = list(), scale = 0, select = FALSE, knots = NULL, sp = NULL, min.sp = NULL, H = NULL, gamma = 1, fit = TRUE, paraPen = NULL, G = NULL, in.out = NULL, drop.unused.levels = TRUE, drop.intercept = NULL, nei = NULL, discrete = FALSE, ...)"},{"p":"mgcv","o":"full.score","f":"hp_full.score","d":" Evaluates GCV/UBRE score for a GAM, given smoothing\nparameters. The routine calls gam.fit to fit the model, and is\nusually called by nlm to optimize the smoothing parameters. \n","ec":"full.score(sp, G, family, control, gamma, ...)"},{"p":"mgcv","o":"smooth.construct.ts.smooth.spec","f":"hp_smooth.construct.ts.smooth.spec","d":"gam can use isotropic smooths of any number of variables, specified via terms like\ns(x,z,bs=\"tp\",m=3) (or just s(x,z) as this is the default basis). These terms are based on thin plate \nregression splines. m specifies the order of the derivatives in the thin plate spline penalty.\n","ec":"smooth.construct.ts.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"Predict.matrix.ts.smooth","f":"hp_Predict.matrix.ts.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.ts.smooth(object, data)"},{"p":"mgcv","o":"smooth.construct.sf.smooth.spec","f":"hp_smooth.construct.sf.smooth.spec","d":" Sets up basis functions and wiggliness penalties for\nsoap film smoothers (Wood, Bravington and Hedley, 2008). Soap film smoothers are based on the idea of\nconstructing a 2-D smooth as a film of soap connecting a smoothly varying\nclosed boundary. Unless smoothing very heavily, the film is distorted towards\nthe data. The smooths are designed not to smooth across boundary features (peninsulas,\nfor example).\n","ec":"smooth.construct.sf.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"Predict.matrix.cyclic.smooth","f":"hp_Predict.matrix.cyclic.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.cyclic.smooth(object, data)"},{"p":"mgcv","o":"initial.sp","f":"hp_initial.sp","d":" Finds initial smoothing parameter guesses for multiple smoothing\nparameter estimation. The idea is to find values such that the estimated\ndegrees of freedom per penalized parameter should be well away from 0 and 1\nfor each penalized parameter, thus ensuring that the values are in a region of\nparameter space where the smoothing parameter estimation criterion is varying\nsubstantially with smoothing parameter value. \n","ec":"initial.sp(X, S, off, expensive = FALSE, XX = FALSE)"},{"p":"mgcv","o":"smooth.construct.bs.smooth.spec","f":"hp_smooth.construct.bs.smooth.spec","d":"gam can use smoothing splines based on univariate B-spline bases\nwith derivative based penalties, specified via terms like s(x,bs=\"bs\",m=c(3,2)). m[1] controls the spline order, with m[1]=3 being a cubic spline, m[1]=2 being quadratic, and so on. The integrated square of the m[2]th derivative is used as the penalty. So m=c(3,2) is a conventional cubic spline. Any further elements of m, after the first 2, define the order of derivative in further penalties. If m is supplied as a single number, then it is taken to be m[1] and m[2]=m[1]-1, which is only a conventional smoothing spline in the m=3, cubic spline case. Notice that the definition of the spline order in terms of m[1] is intuitive, but differs to that used with the tprs and p.spline bases. See details for options for controlling the interval over which the penalty is evaluated (which can matter if it is necessary to extrapolate).\n","ec":"smooth.construct.bs.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"smooth.construct.cc.smooth.spec","f":"hp_smooth.construct.cc.smooth.spec","d":"gam can use univariate penalized cubic regression spline smooths, specified via terms like\ns(x,bs=\"cr\"). s(x,bs=\"cs\") specifies a penalized cubic regression spline which has had its penalty modified \nto shrink towards zero at high enough smoothing parameters (as the smoothing parameter goes to infinity a normal cubic spline tends to a \nstraight line.) s(x,bs=\"cc\") specifies a cyclic penalized cubic regression spline smooth.\n","ec":"smooth.construct.cc.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"blas.thread.test","f":"hp_blas.thread.test","d":"Most BLAS implementations are thread safe, but some versions of OpenBLAS, for example, are not. This routine is a diagnostic helper function, which you will never need if you don't set nthreads>1, and even then are unlikely to need.   \n","ec":"blas.thread.test(n = 1000, nt = 4)"},{"p":"mgcv","o":"bam","f":"hp_bam","d":" Fits a generalized additive model (GAM) to a very large\ndata set, the term <U+2018>GAM<U+2019> being taken to include any quadratically penalized GLM (the extended families\nlisted in family.mgcv can also be used).  \nThe degree of smoothness of model terms is estimated as part of\nfitting. In use the function is much like gam, except that the numerical methods\nare designed for datasets containing upwards of several tens of thousands of data (see Wood, Goude and Shaw, 2015). The advantage \nof bam is much lower memory footprint than gam, but it can also be much faster, \nfor large datasets. bam can also compute on a cluster set up by the parallel package.\n","ec":"bam(formula, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action = na.omit, offset = NULL, method = \"fREML\", control = list(), select = FALSE, scale = 0, gamma = 1, knots = NULL, sp = NULL, min.sp = NULL, paraPen = NULL, chunk.size = 10000, rho = 0, AR.start = NULL, discrete = FALSE, cluster = NULL, nthreads = 1, gc.level = 0, use.chol = FALSE, samfrac = 1, coef = NULL, drop.unused.levels = TRUE, G = NULL, fit = TRUE, drop.intercept = NULL, in.out = NULL, ...)"},{"p":"mgcv","o":"te","f":"hp_te","d":" Functions used for the definition of tensor product smooths and interactions within\ngam model formulae. te produces a full tensor product smooth, while ti \nproduces a tensor product interaction, appropriate when the main effects (and any lower \ninteractions) are also present.\n","ec":"te(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, fx = FALSE, np = TRUE, xt = NULL, id = NULL, sp = NULL, pc = NULL)"},{"p":"mgcv","o":"sim2jam","f":"hp_sim2jam","d":"Facilities to auto-generate model specification code and associated data to simulate with GAMs in JAGS (or BUGS). This is useful for inference about models with complex random effects structure best coded in JAGS. It is a very innefficient approach to making inferences about standard GAMs. The idea is that jagam generates template JAGS code, and associated data, for the smooth part of the model. This template is then directly edited to include other stochastic components. After simulation with the resulting model, facilities are provided for plotting and prediction with the model smooth components. \n","ec":"sim2jam(sam, pregam, edf.type = 2, burnin = 0)"},{"p":"mgcv","o":"smooth.construct.cp.smooth.spec","f":"hp_smooth.construct.cp.smooth.spec","d":"gam can use univariate P-splines as proposed by Eilers and Marx (1996), \nspecified via terms like s(x,bs=\"ps\"). These terms use B-spline bases \npenalized by discrete penalties applied directly to \nthe basis coefficients. Cyclic P-splines are specified by model terms like s(x,bs=\"cp\",...). \nThese bases can be used in tensor product smooths (see te).\n","ec":"smooth.construct.cp.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"gamm","f":"hp_gamm","d":" Fits the specified  generalized additive mixed model (GAMM) to\ndata, by a call to lme in the normal errors identity link case, or by \na call to gammPQL (a modification of glmmPQL from the MASS library) otherwise. \nIn the latter case estimates are only approximately MLEs. The routine is typically \nslower than gam, and not quite as numerically robust. \n","ec":"gamm(formula, random = NULL, correlation = NULL, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action, knots = NULL, control = list(niterEM = 0, optimMethod = \"L-BFGS-B\", returnObject = TRUE), niterPQL = 20, verbosePQL = TRUE, method = \"ML\", drop.unused.levels = TRUE, mustart = NULL, etastart = NULL, ...)"},{"p":"mgcv","o":"ti","f":"hp_ti","d":" Functions used for the definition of tensor product smooths and interactions within\ngam model formulae. te produces a full tensor product smooth, while ti \nproduces a tensor product interaction, appropriate when the main effects (and any lower \ninteractions) are also present.\n","ec":"ti(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, fx = FALSE, np = TRUE, xt = NULL, id = NULL, sp = NULL, mc = NULL, pc = NULL)"},{"p":"mgcv","o":"inSide","f":"hp_inSide","d":"Assesses whether points are inside a boundary. The boundary must enclose the\ndomain, but may include islands. \n","ec":"inSide(bnd, x, y)"},{"p":"mgcv","o":"smoothCon","f":"hp_smoothCon","d":" Wrapper functions for construction of and prediction from smooth\nterms in a GAM. The purpose of the wrappers is to allow user-transparant\nre-parameterization of smooth terms, in order to allow identifiability\nconstraints to be absorbed into the parameterization of each term, if required.\nThe routine also handles <U+2018>by<U+2019> variables and construction of identifiability constraints automatically, \nalthough this behaviour can be over-ridden.\n","ec":"smoothCon(object, data, knots = NULL, absorb.cons = FALSE, scale.penalty = TRUE, n = nrow(data), dataX = NULL, null.space.penalty = FALSE, sparse.cons = 0, diagonal.penalty = FALSE, apply.by = TRUE, modCon = 0)"},{"p":"mgcv","o":"influence.gam","f":"hp_influence.gam","d":" Extracts the leading diagonal of the influence matrix (hat\nmatrix) of a fitted gam object.\n","ec":"influence.gam(model, ...)"},{"p":"mgcv","o":"in.out","f":"hp_in.out","d":"Tests whether each of a set of points lie within a region defined by one or more \n(possibly nested) polygons. Points count as <U+2018>inside<U+2019> if they are interior to an odd number of polygons.\n","ec":"in.out(bnd, x)"},{"p":"mgcv","o":"bam.update","f":"hp_bam.update","d":" Gaussian with identity link models fitted by bam can be efficiently updated as new data becomes available,\nby simply updating the QR decomposition on which estimation is based, and re-optimizing the smoothing parameters, starting\nfrom the previous estimates. This routine implements this.\n","ec":"bam.update(b, data, chunk.size = 10000)"},{"p":"mgcv","o":"smooth.construct.ad.smooth.spec","f":"hp_smooth.construct.ad.smooth.spec","d":"gam can use adaptive smooths of one or two variables, specified \nvia terms like s(...,bs=\"ad\",...). (gamm can not use such terms <U+2014> check out \npackage AdaptFit if this is a problem.) The basis for such a term is a (tensor product of) \np-spline(s) or cubic regression spline(s). Discrete P-spline type penalties are applied directly to the coefficients \nof the basis, but the penalties themselves have a basis representation, allowing the strength of the\npenalty to vary with the covariates. The coefficients of the penalty basis are the smoothing parameters.\n","ec":"smooth.construct.ad.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"smooth2random","f":"hp_smooth2random","d":"A generic function for converting mgcv smooth objects to forms suitable for estimation as random effects by e.g. lme. Exported mostly for use by other package developers. \n","ec":"smooth2random(object, vnames, type = 1)"},{"p":"mgcv","o":"smooth.construct.cs.smooth.spec","f":"hp_smooth.construct.cs.smooth.spec","d":"gam can use univariate penalized cubic regression spline smooths, specified via terms like\ns(x,bs=\"cr\"). s(x,bs=\"cs\") specifies a penalized cubic regression spline which has had its penalty modified \nto shrink towards zero at high enough smoothing parameters (as the smoothing parameter goes to infinity a normal cubic spline tends to a \nstraight line.) s(x,bs=\"cc\") specifies a cyclic penalized cubic regression spline smooth.\n","ec":"smooth.construct.cs.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"PredictMat","f":"hp_PredictMat","d":" Wrapper functions for construction of and prediction from smooth\nterms in a GAM. The purpose of the wrappers is to allow user-transparant\nre-parameterization of smooth terms, in order to allow identifiability\nconstraints to be absorbed into the parameterization of each term, if required.\nThe routine also handles <U+2018>by<U+2019> variables and construction of identifiability constraints automatically, \nalthough this behaviour can be over-ridden.\n","ec":"PredictMat(object, data, n = nrow(data))"},{"p":"mgcv","o":"pen.edf","f":"hp_pen.edf","d":"Finds the coefficients penalized by each penalty and adds up their effective degrees of freedom.\nVery useful for t2 terms, but hard to interpret for terms where the penalties penalize \noverlapping sets of parameters (e.g. te terms). \n","ec":"pen.edf(x)"},{"p":"mgcv","o":"gam.mh","f":"hp_gam.mh","d":"GAM coefficients can be simulated directly from the Gaussian approximation to the posterior for the coefficients, or using a simple Metropolis Hastings sampler. See also ginla.\n","ec":"gam.mh(b, ns = 10000, burn = 1000, t.df = 40, rw.scale = 0.25, thin = 1)"},{"p":"mgcv","o":"ziplss","f":"hp_ziplss","d":"The ziplss family implements a zero inflated (hurdle) Poisson model in which one linear predictor \ncontrols the probability of presence  and the other controls the mean given presence.\nUseable only with gam, the linear predictors are specified via a list of formulae. \nShould be used with care: simply having a large number of zeroes is not an indication of zero inflation. \n","ec":"ziplss(link = list(\"identity\", \"identity\"))"},{"p":"mgcv","o":"mono.con","f":"hp_mono.con","d":"Finds linear constraints sufficient for monotonicity (and\noptionally upper and/or lower boundedness) of a cubic regression\nspline. The basis representation assumed is that given by the\ngam, \"cr\" basis: that is the spline has a set of knots,\nwhich have fixed x values, but the y values of which constitute the\nparameters of the spline.\n","ec":"mono.con(x, up = TRUE, lower = NA, upper = NA)"},{"p":"mgcv","o":"gam.fit","f":"hp_gam.fit","d":" This is an internal function of package mgcv. It is a modification\nof the function glm.fit, designed to be called from gam when perfomance iteration is selected (not the default). The major\nmodification is that rather than solving a weighted least squares problem at each IRLS step, \na weighted, penalized least squares problem\nis solved at each IRLS step with smoothing parameters associated with each penalty chosen by GCV or UBRE,\nusing routine magic. \nFor further information on usage see code for gam. Some regularization of the \nIRLS weights is also permitted as a way of addressing identifiability related problems (see \ngam.control). Negative binomial parameter estimation is\nsupported.\n","ec":"gam.fit(G, start = NULL, etastart = NULL, mustart = NULL, family = gaussian(), control = gam.control(), gamma = 1, fixedSteps = (control$maxit + 1), ...)"},{"p":"mgcv","o":"pcls","f":"hp_pcls","d":"Solves least squares problems with quadratic penalties subject to linear\nequality and inequality constraints using quadratic programming.\n","ec":"pcls(M)"},{"p":"mgcv","o":"Predict.matrix.cr.smooth","f":"hp_Predict.matrix.cr.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.cr.smooth(object, data)"},{"p":"mgcv","o":"notLog","f":"hp_notLog","d":" It is common practice in statistical optimization to use log-parameterizations when a \nparameter ought to be positive. i.e. if an optimization parameter a should be non-negative then \nwe use a=exp(b) and optimize with respect to the unconstrained parameter b. This often works \nwell, but it does imply a rather limited working range for b: using 8 byte doubles, for example, \nif b's magnitude gets much above 700 then a overflows or underflows. This can cause \nproblems for numerical optimization methods. \n","ec":"notLog(x)"},{"p":"mgcv","o":"tw","f":"hp_tw","d":"Tweedie families, designed for use with gam from the mgcv library.\nRestricted to variance function powers between 1 and 2. A useful alternative to quasi when a\nfull likelihood is desirable. Tweedie is for use with fixed p. tw is for use when p\nis to be estimated during fitting. For fixed p between 1 and 2 the Tweedie is an exponential family \ndistribution with variance given by the mean to the power p.\n","ec":"tw(theta = NULL, link = \"log\", a = 1.01, b = 1.99)"},{"p":"mgcv","o":"trind.generator","f":"hp_trind.generator","d":"Generates index arrays for upper triangular storage up to order four. Useful when\nworking with higher order derivatives, which generate symmetric arrays. \nMainly intended for internal use.\n","ec":"trind.generator(K = 2, ifunc = FALSE, reverse = !ifunc)"},{"p":"mgcv","o":"bandchol","f":"hp_bandchol","d":"Computes Choleski decomposition of a (symmetric positive definite) band-diagonal matrix, A. \n","ec":"bandchol(B)"},{"p":"mgcv","o":"psum.chisq","f":"hp_psum.chisq","d":" Evaluates the c.d.f. of a weighted sum of chi-squared random variables\nby the method of Davies (1973, 1980). That is it computes ","ec":"psum.chisq(q, lb, df = rep(1, length(lb)), nc = rep(0, length(lb)), sigz = 0, lower.tail = FALSE, tol = 2e-05, nlim = 1e+05, trace = FALSE)"},{"p":"mgcv","o":"Xbd","f":"hp_Xbd","d":"Routines for computing with discretized model matrices as described in Wood et al. (2017) and Li and Wood (2019).\n","ec":"Xbd(X, beta, k, ks, ts, dt, v, qc, drop = NULL, lt = NULL)"},{"p":"mgcv","o":"extract.lme.cov2","f":"hp_extract.lme.cov2","d":" This is a service routine for gamm. Extracts \nthe estimated covariance matrix of the data from an lme object, allowing the \nuser control about which levels of random effects to include in this \ncalculation. extract.lme.cov forms the full matrix explicitly:\nextract.lme.cov2 tries to be more economical than this.\n","ec":"extract.lme.cov2(b, data = NULL, start.level = 1)"},{"p":"mgcv","o":"smooth.construct.ps.smooth.spec","f":"hp_smooth.construct.ps.smooth.spec","d":"gam can use univariate P-splines as proposed by Eilers and Marx (1996), \nspecified via terms like s(x,bs=\"ps\"). These terms use B-spline bases \npenalized by discrete penalties applied directly to \nthe basis coefficients. Cyclic P-splines are specified by model terms like s(x,bs=\"cp\",...). \nThese bases can be used in tensor product smooths (see te).\n","ec":"smooth.construct.ps.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"ldTweedie","f":"hp_ldTweedie","d":"A function to evaluate the log of the Tweedie density for variance powers between 1 and 2, inclusive.\nAlso evaluates first and second derivatives of log density w.r.t. its scale parameter, phi, and p, \nor w.r.t. rho=log(phi) and theta where p = (a+b*exp(theta))/(1+exp(theta)).\n","ec":"ldTweedie(y, mu = y, p = 1.5, phi = 1, rho = NA, theta = NA, a = 1.001, b = 1.999, all.derivs = FALSE)"},{"p":"mgcv","o":"dDeta","f":"hp_dDeta","d":"INTERNAL function. Distribution families provide derivatives of the deviance and link w.r.t. mu = inv_link(eta).\nThis routine converts these to the required derivatives of the deviance w.r.t. eta, the linear predictor.\n","ec":"dDeta(y, mu, wt, theta, fam, deriv = 0)"},{"p":"mgcv","o":"ls.size","f":"hp_ls.size","d":"Produces a named array giving the size, in bytes, of the elements of a list.\n","ec":"ls.size(x)"},{"p":"mgcv","o":"ginla","f":"hp_ginla","d":"Apply Integrated Nested Laplace Approximation (INLA, Rue et al. 2009) to models estimable by gam or bam, using the INLA variant described in Wood (2019). Produces marginal posterior densities for each coefficient, selected coefficients or linear transformations of the coefficient vector. \n","ec":"ginla(G, A = NULL, nk = 16, nb = 100, J = 1, interactive = FALSE, integ = 0, approx = 0)"},{"p":"mgcv","o":"fs.boundary","f":"hp_fs.boundary","d":"Implements a finite area test function based on one proposed by Tim Ramsay (2002).\n","ec":"fs.boundary(r0 = 0.1, r = 0.5, l = 3, n.theta = 20)"},{"p":"mgcv","o":"gam.check","f":"hp_gam.check","d":" Takes a fitted gam object produced by gam() and produces some diagnostic information\nabout the fitting procedure and results. The default is to produce 4 residual\nplots, some information about the convergence of the smoothness selection optimization, and to run \ndiagnostic tests of whether the basis dimension choises are adequate. Care should be taken in interpreting the results when applied to gam objects returned by gamm.\n","ec":"gam.check(b, old.style = FALSE, type = c(\"deviance\", \"pearson\", \"response\"), k.sample = 5000, k.rep = 200, rep = 0, level = 0.9, rl.col = 2, rep.col = \"gray80\", ...)"},{"p":"mgcv","o":"gam2objective","f":"hp_gam2objective","d":"Estimation of GAM smoothing parameters is most stable if\noptimization of the UBRE/AIC or GCV score is outer to the penalized iteratively\nre-weighted least squares scheme used to estimate the model given smoothing \nparameters. These functions evaluate the GCV/UBRE/AIC score of a GAM model, given\nsmoothing parameters, in a manner suitable for use by optim or nlm.\nNot normally called directly, but rather service routines for gam.outer.\n","ec":"gam2objective(lsp, args, ...)"},{"p":"mgcv","o":"Predict.matrix.t2.smooth","f":"hp_Predict.matrix.t2.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.t2.smooth(object, data)"},{"p":"mgcv","o":"smooth.construct.ds.smooth.spec","f":"hp_smooth.construct.ds.smooth.spec","d":"Thin plate spline smoothers are a special case of the isotropic splines discussed in Duchon (1977). A subset of this more \ngeneral class can be invoked by terms like s(x,z,bs=\"ds\",m=c(1,.5) in a gam model formula.\nIn the notation of Duchon (1977) m is given by m[1] (default value 2), while s is given by m[2] (default value 0).\n","ec":"smooth.construct.ds.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"extract.lme.cov","f":"hp_extract.lme.cov","d":" This is a service routine for gamm. Extracts \nthe estimated covariance matrix of the data from an lme object, allowing the \nuser control about which levels of random effects to include in this \ncalculation. extract.lme.cov forms the full matrix explicitly:\nextract.lme.cov2 tries to be more economical than this.\n","ec":"extract.lme.cov(b, data = NULL, start.level = 1)"},{"p":"mgcv","o":"choldrop","f":"hp_choldrop","d":"Given a Cholesky factor, R, of a matrix, A, choldrop finds the Cholesky factor of A[-k,-k],\nwhere k is an integer. cholup finds the factor of A + uu^T (update) or A - uu^T (downdate).\n","ec":"choldrop(R, k)"},{"p":"mgcv","o":"spasm.construct","f":"hp_spasm.construct","d":"These are experimental sparse smoothing functions, and should \nbe left well alone!\n","ec":"spasm.construct(object, data)"},{"p":"mgcv","o":"print.anova.gam","f":"hp_print.anova.gam","d":" Performs hypothesis tests relating to one or more fitted\ngam objects. For a single fitted gam object, Wald tests of\nthe significance of each parametric and smooth term are performed, so interpretation \nis analogous to drop1 rather than anova.lm (i.e. it's like type III ANOVA, \nrather than a sequential type I ANOVA). Otherwise the fitted models are compared using an analysis of deviance table or GLRT test: this latter approach should not be use to test the significance of terms which can be penalized \nto zero. Models to be compared should be fitted to the same data using the same smoothing parameter selection method.\n","ec":"print.anova.gam(x, digits = max(3, getOption(\"digits\") - 3), ...)"},{"p":"mgcv","o":"rig","f":"hp_rig","d":"Generates inverse Gaussian random deviates.\n","ec":"rig(n, mean, scale)"},{"p":"mgcv","o":"place.knots","f":"hp_place.knots","d":"Given a univariate array of covariate values, places a set of knots for a regression spline evenly through the \ncovariate values.\n","ec":"place.knots(x, nk)"},{"p":"mgcv","o":"fix.family.link","f":"hp_fix.family.link","d":" Generalized Additive Model fitting by <U+2018>outer<U+2019> iteration,\nrequires extra derivatives of the variance and link functions to be \nadded to family objects. The first 3 functions add what is needed. Model checking can\nbe aided by adding quantile and random deviate generating functions to the family. \nThe final two functions do this.\n","ec":"fix.family.link(fam)"},{"p":"mgcv","o":"cholup","f":"hp_cholup","d":"Given a Cholesky factor, R, of a matrix, A, choldrop finds the Cholesky factor of A[-k,-k],\nwhere k is an integer. cholup finds the factor of A + uu^T (update) or A - uu^T (downdate).\n","ec":"cholup(R, u, up = TRUE)"},{"p":"mgcv","o":"Predict.matrix.duchon.spline","f":"hp_Predict.matrix.duchon.spline","d":"Thin plate spline smoothers are a special case of the isotropic splines discussed in Duchon (1977). A subset of this more \ngeneral class can be invoked by terms like s(x,z,bs=\"ds\",m=c(1,.5) in a gam model formula.\nIn the notation of Duchon (1977) m is given by m[1] (default value 2), while s is given by m[2] (default value 0).\n","ec":"Predict.matrix.duchon.spline(object, data)"},{"p":"mgcv","o":"fs.test","f":"hp_fs.test","d":"Implements a finite area test function based on one proposed by Tim Ramsay (2002).\n","ec":"fs.test(x, y, r0 = 0.1, r = 0.5, l = 3, b = 1, exclude = TRUE)"},{"p":"mgcv","o":"negbin","f":"hp_negbin","d":"The gam modelling function is designed to be able to use \nthe negbin family (a modification of MASS library negative.binomial family \nby Venables and Ripley), or the nb function designed for integrated estimation of \nparameter theta. \\theta is the parameter such that var(y) = \\mu + \\mu^2/\\theta, where \\mu = E(y).\n","ec":"negbin(theta = stop(\"'theta' must be specified\"), link = \"log\")"},{"p":"mgcv","o":"sp.vcov","f":"hp_sp.vcov","d":" Extracts the estimated covariance matrix for the log smoothing parameter\nestimates from a (RE)ML estimated gam object, provided the fit was with a method \nthat evaluated the required Hessian.\n","ec":"sp.vcov(x, edge.correct = TRUE, reg = 0.001)"},{"p":"mgcv","o":"diagXVXd","f":"hp_diagXVXd","d":"Routines for computing with discretized model matrices as described in Wood et al. (2017) and Li and Wood (2019).\n","ec":"diagXVXd(X, V, k, ks, ts, dt, v, qc, drop = NULL, nthreads = 1, lt = NULL, rt = NULL)"},{"p":"mgcv","o":"r.mvt","f":"hp_r.mvt","d":" Generates multivariate normal or t random deviates, and evaluates the corresponding log densities.\n","ec":"r.mvt(n, mu, V, df)"},{"p":"mgcv","o":"smooth.construct.re.smooth.spec","f":"hp_smooth.construct.re.smooth.spec","d":"gam can deal with simple independent random effects, by exploiting the link \nbetween smooths and random effects to treat random effects as smooths. s(x,bs=\"re\") implements \nthis. Such terms can can have any number of predictors, which can be any mixture of numeric or factor \nvariables. The terms produce a parametric interaction of the predictors, and penalize the corresponding \ncoefficients with a multiple of the identity matrix, corresponding to an assumption of i.i.d. normality.\nSee details.\n","ec":"smooth.construct.re.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"Predict.matrix.random.effect","f":"hp_Predict.matrix.random.effect","d":"gam can deal with simple independent random effects, by exploiting the link \nbetween smooths and random effects to treat random effects as smooths. s(x,bs=\"re\") implements \nthis. Such terms can can have any number of predictors, which can be any mixture of numeric or factor \nvariables. The terms produce a parametric interaction of the predictors, and penalize the corresponding \ncoefficients with a multiple of the identity matrix, corresponding to an assumption of i.i.d. normality.\nSee details.\n","ec":"Predict.matrix.random.effect(object, data)"},{"p":"mgcv","o":"Tweedie","f":"hp_Tweedie","d":"Tweedie families, designed for use with gam from the mgcv library.\nRestricted to variance function powers between 1 and 2. A useful alternative to quasi when a\nfull likelihood is desirable. Tweedie is for use with fixed p. tw is for use when p\nis to be estimated during fitting. For fixed p between 1 and 2 the Tweedie is an exponential family \ndistribution with variance given by the mean to the power p.\n","ec":"Tweedie(p = 1, link = power(0))"},{"p":"mgcv","o":"plot.gam","f":"hp_plot.gam","d":" Takes a fitted gam object produced by gam() and plots the \ncomponent smooth functions that make it up, on the scale of the linear\npredictor. Optionally produces term plots for parametric model components\nas well.","ec":"plot.gam(x, residuals = FALSE, rug = NULL, se = TRUE, pages = 0, select = NULL, scale = -1, n = 100, n2 = 40, n3 = 3, theta = 30, phi = 30, jit = FALSE, xlab = NULL, ylab = NULL, main = NULL, ylim = NULL, xlim = NULL, too.far = 0.1, all.terms = FALSE, shade = FALSE, shade.col = \"gray80\", shift = 0, trans = I, seWithMean = FALSE, unconditional = FALSE, by.resids = FALSE, scheme = 0, ...)"},{"p":"mgcv","o":"summary.gam","f":"hp_summary.gam","d":" Takes a fitted gam object produced by gam() and produces various useful\nsummaries from it. (See sink to divert output to a file.)\n","ec":"summary.gam(object, dispersion = NULL, freq = FALSE, re.test = TRUE, ...)"},{"p":"mgcv","o":"totalPenaltySpace","f":"hp_totalPenaltySpace","d":"INTERNAL function to obtain (orthogonal) basis for the null space and\nrange space of the penalty, and obtain actual null space dimension\ncomponents are roughly rescaled to avoid any dominating.\n","ec":"totalPenaltySpace(S, H, off, p)"},{"p":"mgcv","o":"print.summary.gam","f":"hp_print.summary.gam","d":" Takes a fitted gam object produced by gam() and produces various useful\nsummaries from it. (See sink to divert output to a file.)\n","ec":"print.summary.gam(x, digits = max(3, getOption(\"digits\") - 3), signif.stars = getOption(\"show.signif.stars\"), ...)"},{"p":"mgcv","o":"formXtViX","f":"hp_formXtViX","d":" This is a service routine for gamm. Given,\nV, an estimated covariance matrix obtained using extract.lme.cov2 this\nroutine forms a matrix square root of  X^TV^{-1}X as efficiently as possible, given\nthe structure of V (usually sparse).\n","ec":"formXtViX(V, X)"},{"p":"mgcv","o":"scat","f":"hp_scat","d":"Family for use with gam or bam, implementing regression for the heavy tailed response\nvariables, y, using a scaled t model. The idea is that (y-\\mu)/\\sigma \\sim t_\\nu  where \nmu is determined by a linear predictor, while \\sigma and \\nu are parameters \nto be estimated alongside the smoothing parameters.\n","ec":"scat(theta = NULL, link = \"identity\", min.df = 3)"},{"p":"mgcv","o":"fix.family.rd","f":"hp_fix.family.rd","d":" Generalized Additive Model fitting by <U+2018>outer<U+2019> iteration,\nrequires extra derivatives of the variance and link functions to be \nadded to family objects. The first 3 functions add what is needed. Model checking can\nbe aided by adding quantile and random deviate generating functions to the family. \nThe final two functions do this.\n","ec":"fix.family.rd(fam)"},{"p":"mgcv","o":"model.matrix.gam","f":"hp_model.matrix.gam","d":"Obtains the model matrix from a fitted gam object.\n","ec":"model.matrix.gam(object, ...)"},{"p":"mgcv","o":"trichol","f":"hp_trichol","d":"Computes Choleski decomposition of a (symmetric positive definite) tri-diagonal matrix stored as a leading diagonal and sub/super diagonal.\n","ec":"trichol(ld, sd)"},{"p":"mgcv","o":"smooth.construct.mrf.smooth.spec","f":"hp_smooth.construct.mrf.smooth.spec","d":"For data observed over discrete spatial units, a simple Markov random field \nsmoother is sometimes appropriate. These functions provide such a smoother class for mgcv. \nSee details for how to deal with regions with missing data.\n","ec":"smooth.construct.mrf.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"XWXd","f":"hp_XWXd","d":"Routines for computing with discretized model matrices as described in Wood et al. (2017) and Li and Wood (2019).\n","ec":"XWXd(X, w, k, ks, ts, dt, v, qc, nthreads = 1, drop = NULL, ar.stop = -1, ar.row = -1, ar.w = -1, lt = NULL, rt = NULL)"},{"p":"mgcv","o":"polys.plot","f":"hp_polys.plot","d":" Produces plots of geographic regions defined by polygons, optionally filling the \npolygons with a color or grey shade dependent on a covariate.\n","ec":"polys.plot(pc, z = NULL, scheme = \"heat\", lab = \"\", ...)"},{"p":"mgcv","o":"Predict.matrix.Bspline.smooth","f":"hp_Predict.matrix.Bspline.smooth","d":"gam can use smoothing splines based on univariate B-spline bases\nwith derivative based penalties, specified via terms like s(x,bs=\"bs\",m=c(3,2)). m[1] controls the spline order, with m[1]=3 being a cubic spline, m[1]=2 being quadratic, and so on. The integrated square of the m[2]th derivative is used as the penalty. So m=c(3,2) is a conventional cubic spline. Any further elements of m, after the first 2, define the order of derivative in further penalties. If m is supplied as a single number, then it is taken to be m[1] and m[2]=m[1]-1, which is only a conventional smoothing spline in the m=3, cubic spline case. Notice that the definition of the spline order in terms of m[1] is intuitive, but differs to that used with the tprs and p.spline bases. See details for options for controlling the interval over which the penalty is evaluated (which can matter if it is necessary to extrapolate).\n","ec":"Predict.matrix.Bspline.smooth(object, data)"},{"p":"mgcv","o":"FFdes","f":"hp_FFdes","d":"Computes level 5 fractional factorial designs for up to 120 factors\nusing the agorithm of Sanchez and Sanchez (2005), and optionally central composite designs.\n","ec":"FFdes(size = 5, ccd = FALSE)"},{"p":"mgcv","o":"nb","f":"hp_nb","d":"The gam modelling function is designed to be able to use \nthe negbin family (a modification of MASS library negative.binomial family \nby Venables and Ripley), or the nb function designed for integrated estimation of \nparameter theta. \\theta is the parameter such that var(y) = \\mu + \\mu^2/\\theta, where \\mu = E(y).\n","ec":"nb(theta = NULL, link = \"log\")"},{"p":"mgcv","o":"sdiag<-","f":"hp_sdiag..","d":" Extracts or modifies sub- or super- diagonals of a matrix.\n","ec":"sdiag<-(A, k = 0, value)"},{"p":"mgcv","o":"Predict.matrix.sw","f":"hp_Predict.matrix.sw","d":" Creates a prediction matrix for a soap film smooth object,\nmapping the coefficients of the smooth to the linear predictor component for\nthe smooth.  This is the Predict.matrix method function required by gam.\n","ec":"Predict.matrix.sw(object, data)"},{"p":"mgcv","o":"cnorm","f":"hp_cnorm","d":"Family for use with gam or bam, implementing regression for censored\nnormal data. If y is the response with mean \\mu and standard deviation w^{-1/2}\\exp(\\theta),\nthen w^{1/2}(y-\\mu)\\exp(-\\theta) follows an N(0,1) distribution. That is\n","ec":"cnorm(theta = NULL, link = \"identity\")"},{"p":"mgcv","o":"smooth.construct.gp.smooth.spec","f":"hp_smooth.construct.gp.smooth.spec","d":"Gaussian process/kriging models based on simple covariance functions can be written in a very similar form to thin plate and Duchon spline models (e.g. Handcock, Meier, Nychka, 1994), and low rank versions produced by the eigen approximation method of Wood (2003). Kammann and Wand (2003) suggest a particularly simple form of the Matern covariance function with only a single smoothing parameter to estimate, and this class implements this and other similar models.  \n","ec":"smooth.construct.gp.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"print.gam","f":"hp_print.gam","d":" The default print method for a gam object. \n","ec":"print.gam(x, ...)"},{"p":"mgcv","o":"multinom","f":"hp_multinom","d":"Family for use with gam, implementing regression for categorical response data. Categories must be coded 0 to K, where K is a positive integer. gam should be called with a list of K formulae, one for each category except category zero (extra formulae for shared terms may also be supplied: see formula.gam). The first formula also specifies the response variable.      \n","ec":"multinom(K = 1)"},{"p":"mgcv","o":"smooth.construct.tensor.smooth.spec","f":"hp_smooth.construct.tensor.smooth.spec","d":"A special smooth.construct method function for creating tensor product smooths from any\ncombination of single penalty marginal smooths.\n","ec":"smooth.construct.tensor.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"gam2derivative","f":"hp_gam2derivative","d":"Estimation of GAM smoothing parameters is most stable if\noptimization of the UBRE/AIC or GCV score is outer to the penalized iteratively\nre-weighted least squares scheme used to estimate the model given smoothing \nparameters. These functions evaluate the GCV/UBRE/AIC score of a GAM model, given\nsmoothing parameters, in a manner suitable for use by optim or nlm.\nNot normally called directly, but rather service routines for gam.outer.\n","ec":"gam2derivative(lsp, args, ...)"},{"p":"mgcv","o":"Predict.matrix.tprs.smooth","f":"hp_Predict.matrix.tprs.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.tprs.smooth(object, data)"},{"p":"mgcv","o":"cox.ph","f":"hp_cox.ph","d":"The cox.ph family implements the Cox Proportional Hazards model with Peto's \ncorrection for ties, optional stratification, and estimation by penalized partial likelihood maximization, for use with \ngam. In the model formula, event time is the response. Under stratification the response has two columns: time\nand a numeric index for stratum.  The weights vector provides \nthe censoring information (0 for censoring, 1 for event). cox.ph deals with the case in which each subject has\none event/censoring time and one row of covariate values. When each subject has several time dependent\ncovariates see cox.pht. \n","ec":"cox.ph(link = \"identity\")"},{"p":"mgcv","o":"fix.family.ls","f":"hp_fix.family.ls","d":" Generalized Additive Model fitting by <U+2018>outer<U+2019> iteration,\nrequires extra derivatives of the variance and link functions to be \nadded to family objects. The first 3 functions add what is needed. Model checking can\nbe aided by adding quantile and random deviate generating functions to the family. \nThe final two functions do this.\n","ec":"fix.family.ls(fam)"},{"p":"mgcv","o":"cSplineDes","f":"hp_cSplineDes","d":" Uses splineDesign to set up the model matrix for a cyclic B-spline basis.\n","ec":"cSplineDes(x, knots, ord = 4, derivs = 0)"},{"p":"mgcv","o":"shash","f":"hp_shash","d":"The shash family implements the four-parameter sinh-arcsinh (shash) distribution of \nJones and Pewsey (2009). The location, scale, skewness and kurtosis of the density can depend \non additive smooth predictors. Useable only with gam, the linear predictors are specified \nvia a list of formulae. It is worth carefully considering whether the data are sufficient to support\nestimation of such a flexible model before using it.\n","ec":"shash(link = list(\"identity\", \"logeb\", \"identity\", \"identity\"), b = 0.01, phiPen = 0.001)"},{"p":"mgcv","o":"predict.gam","f":"hp_predict.gam","d":" Takes a fitted gam object produced by gam() \nand produces predictions given a new set of values for the model covariates \nor the original values used for the model fit. Predictions can be accompanied\nby standard errors, based on the posterior distribution of the model\ncoefficients. The routine can optionally return the matrix by which the model\ncoefficients must be pre-multiplied in order to yield the values of the linear predictor at\nthe supplied covariate values: this is useful for obtaining credible regions\nfor quantities derived from the model (e.g. derivatives of smooths), and for lookup table prediction outside\nR (see example code below).","ec":"predict.gam(object, newdata, type = \"link\", se.fit = FALSE, terms = NULL, exclude = NULL, block.size = NULL, newdata.guaranteed = FALSE, na.action = na.pass, unconditional = FALSE, iterms.type = NULL, ...)"},{"p":"mgcv","o":"Predict.matrix.mrf.smooth","f":"hp_Predict.matrix.mrf.smooth","d":"For data observed over discrete spatial units, a simple Markov random field \nsmoother is sometimes appropriate. These functions provide such a smoother class for mgcv. \nSee details for how to deal with regions with missing data.\n","ec":"Predict.matrix.mrf.smooth(object, data)"},{"p":"mgcv","o":"residuals.gam","f":"hp_residuals.gam","d":"Returns residuals for a fitted gam model\nobject. Pearson, deviance, working and response residuals are\navailable. \n","ec":"residuals.gam(object, type = \"deviance\", ...)"},{"p":"mgcv","o":"zipll","f":"hp_zipll","d":"The ziplss family implements a zero inflated (hurdle) Poisson model in which one linear predictor \ncontrols the probability of presence  and the other controls the mean given presence.\nUseable only with gam, the linear predictors are specified via a list of formulae. \nShould be used with care: simply having a large number of zeroes is not an indication of zero inflation. \n","ec":"zipll(y, g, eta, deriv = 0)"},{"p":"mgcv","o":"mroot","f":"hp_mroot","d":" Find a square root of a positive semi-definite matrix, \nhaving as few columns as possible. Uses either pivoted choleski \ndecomposition or singular value decomposition to do this.  \n","ec":"mroot(A, rank = NULL, method = \"chol\")"},{"p":"mgcv","o":"fixDependence","f":"hp_fixDependence","d":"Identifies columns of a matrix X2 which are linearly\ndependent on columns of a matrix X1. Primarily of use in setting up \nidentifiability constraints for nested GAMs. \n","ec":"fixDependence(X1, X2, tol = .Machine$double.eps^0.5, rank.def = 0, strict = FALSE)"},{"p":"mgcv","o":"logLik.gam","f":"hp_logLik.gam","d":" Function to extract the log-likelihood for a fitted gam\nmodel (note that the models are usually fitted by penalized likelihood maximization). \nUsed by AIC. See details for more information on AIC computation.  \n","ec":"logLik.gam(object, ...)"},{"p":"mgcv","o":"%.%","f":"hp_X...","d":"Produce model matrices or penalty matrices for a tensor product smooth from the model matrices or\npenalty matrices for the marginal bases of the smooth (marginals and results can be sparse). The model matrix construction uses row Kronecker products.\n","ec":"%.%(a, b)"},{"p":"mgcv","o":"d.mvt","f":"hp_d.mvt","d":" Generates multivariate normal or t random deviates, and evaluates the corresponding log densities.\n","ec":"d.mvt(x, mu, V, df, R = NULL)"},{"p":"mgcv","o":"tensor.prod.model.matrix","f":"hp_tensor.prod.model.matrix","d":"Produce model matrices or penalty matrices for a tensor product smooth from the model matrices or\npenalty matrices for the marginal bases of the smooth (marginals and results can be sparse). The model matrix construction uses row Kronecker products.\n","ec":"tensor.prod.model.matrix(X)"},{"p":"mgcv","o":"k.check","f":"hp_k.check","d":" Takes a fitted gam object produced by gam() and runs \ndiagnostic tests of whether the basis dimension choises are adequate. \n","ec":"k.check(b, subsample = 5000, n.rep = 400)"},{"p":"mgcv","o":"smooth.construct","f":"hp_smooth.construct","d":"Smooth terms in a GAM formula are turned into smooth specification objects of \nclass xx.smooth.spec during processing of the formula. Each of these objects is\nconverted to a smooth object using an appropriate smooth.construct function. New smooth classes \ncan be added by writing a new smooth.construct method function and a corresponding \nPredict.matrix method function (see example code below).\n","ec":"smooth.construct(object, data, knots)"},{"p":"mgcv","o":"gevlss","f":"hp_gevlss","d":"The gevlss family implements Generalized Extreme Value location scale additive models in which the location, scale and shape parameters depend on additive smooth predictors. Usable \nonly with gam, the linear predictors are specified via a list of formulae.\n","ec":"gevlss(link = list(\"identity\", \"identity\", \"logit\"))"},{"p":"mgcv","o":"Sl.setup","f":"hp_Sl.setup","d":"INTERNAL function for setting up a list representing a block diagonal penalty matrix\nfrom the object produced by gam.setup.\n","ec":"Sl.setup(G, cholesky = FALSE, no.repara = FALSE, sparse = FALSE)"},{"p":"mgcv","o":"Predict.matrix.tensor.smooth","f":"hp_Predict.matrix.tensor.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.tensor.smooth(object, data)"},{"p":"mgcv","o":"Rrank","f":"hp_Rrank","d":"Finds rank of upper triangular matrix R, by estimating condition\nnumber of upper rank by rank block, and reducing rank \nuntil this is acceptably low. Assumes R has been computed by a method that uses \npivoting, usually pivoted QR or Choleski.\n","ec":"Rrank(R, tol = .Machine$double.eps^0.9)"},{"p":"mgcv","o":"magic","f":"hp_magic","d":"Function to efficiently estimate smoothing parameters in generalized\nridge regression problems with multiple (quadratic) penalties, by GCV \nor UBRE. The function uses Newton's method in multi-dimensions, backed up by \nsteepest descent to iteratively adjust the smoothing parameters for each penalty \n(one penalty may have a smoothing parameter fixed at 1). \n","ec":"magic(y, X, sp, S, off, L = NULL, lsp0 = NULL, rank = NULL, H = NULL, C = NULL, w = NULL, gamma = 1, scale = 1, gcv = TRUE, ridge.parameter = NULL, control = list(tol = 1e-06, step.half = 25, rank.tol = .Machine$double.eps^0.5), extra.rss = 0, n.score = length(y), nthreads = 1)"},{"p":"mgcv","o":"gamSim","f":"hp_gamSim","d":" Function used to simulate data sets to illustrate the use of \ngam and gamm. Mostly used in help files to keep down \nthe length of the example code sections.\n","ec":"gamSim(eg = 1, n = 400, dist = \"normal\", scale = 2, verbose = TRUE)"},{"p":"mgcv","o":"gam.vcomp","f":"hp_gam.vcomp","d":"GAMs can be viewed as mixed models, where the smoothing parameters are related to variance \ncomponents. This routine extracts the estimated variance components associated with each smooth term, and if possible returns confidence intervals on the standard deviation scale.\n","ec":"gam.vcomp(x, rescale = TRUE, conf.lev = 0.95)"},{"p":"mgcv","o":"Sl.initial.repara","f":"hp_Sl.initial.repara","d":"INTERNAL routine to apply initial Sl re-parameterization to model matrix X,\nor, if inverse==TRUE, to apply inverse re-parametrization to parameter vector \nor covariance matrix.\n","ec":"Sl.initial.repara(Sl, X, inverse = FALSE, both.sides = TRUE, cov = TRUE, nt = 1)"},{"p":"mgcv","o":"s","f":"hp_s","d":" Function used in definition of smooth terms within\ngam model formulae. The function does not evaluate a (spline)\nsmooth - it exists purely to help set up a model using spline based smooths.\n","ec":"s(..., k = -1, fx = FALSE, bs = \"tp\", m = NA, by = NA, xt = NULL, id = NULL, sp = NULL, pc = NULL)"},{"p":"mgcv","o":"dpnorm","f":"hp_dpnorm","d":"Evaluates the difference between two N(0,1) cumulative distribution functions avoiding cancellation error.  \n","ec":"dpnorm(x0, x1)"},{"p":"mgcv","o":"ocat","f":"hp_ocat","d":"Family for use with gam or bam, implementing regression for ordered categorical data.\nA linear predictor provides the expected value of a latent variable following a logistic distribution. The \nprobability of this latent variable lying between certain cut-points provides the probability of the ordered \ncategorical variable being of the corresponding category. The cut-points are estimated along side the model \nsmoothing parameters (using the same criterion). The observed categories are coded 1, 2, 3, ... up to the \nnumber of categories. \n","ec":"ocat(theta = NULL, link = \"identity\", R = NULL)"},{"p":"mgcv","o":"mvn","f":"hp_mvn","d":"Family for use with gam implementing smooth multivariate Gaussian regression. \nThe means for each dimension are given by a separate linear predictor, which may contain smooth components. Extra linear predictors may also be specified giving terms which are shared between components (see formula.gam). The Choleski factor of the response precision matrix is estimated as part of fitting.\n","ec":"mvn(d = 2)"},{"p":"mgcv","o":"smooth.construct2","f":"hp_smooth.construct2","d":"Smooth terms in a GAM formula are turned into smooth specification objects of \nclass xx.smooth.spec during processing of the formula. Each of these objects is\nconverted to a smooth object using an appropriate smooth.construct function. New smooth classes \ncan be added by writing a new smooth.construct method function and a corresponding \nPredict.matrix method function (see example code below).\n","ec":"smooth.construct2(object, data, knots)"},{"p":"mgcv","o":"Predict.matrix.soap.film","f":"hp_Predict.matrix.soap.film","d":" Creates a prediction matrix for a soap film smooth object,\nmapping the coefficients of the smooth to the linear predictor component for\nthe smooth.  This is the Predict.matrix method function required by gam.\n","ec":"Predict.matrix.soap.film(object, data)"},{"p":"mgcv","o":"smooth.construct.sos.smooth.spec","f":"hp_smooth.construct.sos.smooth.spec","d":"gam can use isotropic smooths on the sphere, via terms like \ns(la,lo,bs=\"sos\",m=2,k=100). There must be exactly 2 arguments to such a smooth. \nThe first is taken to be latitude (in degrees) and the second longitude (in degrees). \nm (default 0) is an integer in the range -1 to 4 determining the order of the penalty used. \nFor m>0, (m+2)/2 is the penalty order, with m=2 equivalent to the usual second \nderivative penalty. m=0 signals to use the 2nd order spline on the sphere, computed by \nWendelberger's (1981) method. m = -1 results in a Duchon.spline being \nused (with m=2 and s=1/2), following an unpublished suggestion of Jean Duchon.\n","ec":"smooth.construct.sos.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"gam.outer","f":"hp_gam.outer","d":"Estimation of GAM smoothing parameters is most stable if\noptimization of the smoothness selection score (GCV, GACV, UBRE/AIC, REML, ML etc) \nis outer to the penalized iteratively\nre-weighted least squares scheme used to estimate the model given smoothing \nparameters.\n","ec":"gam.outer(lsp, fscale, family, control, method, optimizer, criterion, scale, gamma, G, start = NULL, nei = NULL, ...)"},{"p":"mgcv","o":"magic.post.proc","f":"hp_magic.post.proc","d":"Obtains Bayesian parameter covariance matrix, frequentist\nparameter estimator covariance matrix, estimated degrees of \nfreedom for each parameter and leading diagonal of influence/hat matrix, \nfor a penalized regression estimated by magic.\n","ec":"magic.post.proc(X, object, w = NULL)"},{"p":"mgcv","o":"spasm.sp","f":"hp_spasm.sp","d":"These are experimental sparse smoothing functions, and should \nbe left well alone!\n","ec":"spasm.sp(object, sp, w = rep(1, object$nobs), get.trH = TRUE, block = 0, centre = FALSE)"},{"p":"mgcv","o":"smooth.construct.sw.smooth.spec","f":"hp_smooth.construct.sw.smooth.spec","d":" Sets up basis functions and wiggliness penalties for\nsoap film smoothers (Wood, Bravington and Hedley, 2008). Soap film smoothers are based on the idea of\nconstructing a 2-D smooth as a film of soap connecting a smoothly varying\nclosed boundary. Unless smoothing very heavily, the film is distorted towards\nthe data. The smooths are designed not to smooth across boundary features (peninsulas,\nfor example).\n","ec":"smooth.construct.sw.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"qq.gam","f":"hp_qq.gam","d":"Takes a fitted gam object produced by gam() and produces\nQQ plots of its residuals (conditional on the fitted model\ncoefficients and scale parameter). If the model distributional\nassumptions are met then usually these plots should be close to a\nstraight line (although discrete data can yield marked random\ndepartures from this line). \n","ec":"qq.gam(object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \"pearson\", \"response\"), pch = \".\", rl.col = 2, rep.col = \"gray80\", ...)"},{"p":"mgcv","o":"formula.gam","f":"hp_formula.gam","d":" Description of gam formula (see Details), and how to extract it from a fitted gam object.\n","ec":"formula.gam(x, ...)"},{"p":"mgcv","o":"sdiag","f":"hp_sdiag","d":" Extracts or modifies sub- or super- diagonals of a matrix.\n","ec":"sdiag(A, k = 0)"},{"p":"mgcv","o":"null.space.dimension","f":"hp_null.space.dimension","d":" The thin plate spline penalties give zero penalty to some\nfunctions. The space of these functions is spanned by a set of\npolynomial terms. null.space.dimension finds the dimension of this space, M, given\nthe number of covariates that the smoother is a function of, d,\nand the order of the smoothing penalty, m. If m does not\nsatisfy 2m>d then the smallest possible dimension\nfor the null space is found given d and the requirement that\nthe smooth should be visually smooth.  \n","ec":"null.space.dimension(d, m)"},{"p":"mgcv","o":"gam.side","f":"hp_gam.side","d":" GAM formulae with repeated variables may only correspond to\nidentifiable models given some side conditions. This routine works \nout appropriate side conditions, based on zeroing redundant parameters.\nIt is called from mgcv:::gam.setup and is not intended to be called by users. \n","ec":"gam.side(sm, Xp, tol = .Machine$double.eps^0.5, with.pen = FALSE)"},{"p":"mgcv","o":"ldetS","f":"hp_ldetS","d":"INTERNAL function calculating the log generalized determinant of penalty matrix S stored blockwise in an Sl list\n(which is the output of Sl.setup).\n","ec":"ldetS(Sl, rho, fixed, np, root = FALSE, repara = TRUE, nt = 1, deriv = 2, sparse = FALSE)"},{"p":"mgcv","o":"smooth.construct.cr.smooth.spec","f":"hp_smooth.construct.cr.smooth.spec","d":"gam can use univariate penalized cubic regression spline smooths, specified via terms like\ns(x,bs=\"cr\"). s(x,bs=\"cs\") specifies a penalized cubic regression spline which has had its penalty modified \nto shrink towards zero at high enough smoothing parameters (as the smoothing parameter goes to infinity a normal cubic spline tends to a \nstraight line.) s(x,bs=\"cc\") specifies a cyclic penalized cubic regression spline smooth.\n","ec":"smooth.construct.cr.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"pdIdnot","f":"hp_pdIdnot","d":" This set of functions is a modification of the  pdMat class pdIdent\nfrom library nlme. The modification is to replace the log parameterization used in pdMat\nwith a notLog2 parameterization, since the latter avoids\nindefiniteness in the likelihood and associated convergence problems: the\nparameters also relate to variances rather than standard deviations, for\nconsistency with the pdTens class. The functions are particularly useful for\nworking with Generalized Additive Mixed Models where variance parameters/smoothing parameters can\nbe very large or very small, so that overflow or underflow can be a problem.\n","ec":"pdIdnot(value = numeric(0), form = NULL, nam = NULL, data = sys.frame(sys.parent()))"},{"p":"mgcv","o":"slanczos","f":"hp_slanczos","d":" Uses Lanczos iteration to find the truncated eigen-decomposition of a symmetric matrix. \n","ec":"slanczos(A, k = 10, kl = -1, tol = .Machine$double.eps^0.5, nt = 1)"},{"p":"mgcv","o":"XWyd","f":"hp_XWyd","d":"Routines for computing with discretized model matrices as described in Wood et al. (2017) and Li and Wood (2019).\n","ec":"XWyd(X, w, y, k, ks, ts, dt, v, qc, drop = NULL, ar.stop = -1, ar.row = -1, ar.w = -1, lt = NULL)"},{"p":"mgcv","o":"jagam","f":"hp_jagam","d":"Facilities to auto-generate model specification code and associated data to simulate with GAMs in JAGS (or BUGS). This is useful for inference about models with complex random effects structure best coded in JAGS. It is a very innefficient approach to making inferences about standard GAMs. The idea is that jagam generates template JAGS code, and associated data, for the smooth part of the model. This template is then directly edited to include other stochastic components. After simulation with the resulting model, facilities are provided for plotting and prediction with the model smooth components. \n","ec":"jagam(formula, family = gaussian, data = list(), file, weights = NULL, na.action, offset = NULL, knots = NULL, sp = NULL, drop.unused.levels = TRUE, control = gam.control(), centred = TRUE, sp.prior = \"gamma\", diagonalize = FALSE)"},{"p":"mgcv","o":"vcov.gam","f":"hp_vcov.gam","d":" Extracts the Bayesian posterior covariance matrix of the\nparameters or frequentist covariance matrix of the parameter estimators \nfrom a fitted gam object.\n","ec":"vcov.gam(object, sandwich = FALSE, freq = FALSE, dispersion = NULL, unconditional = FALSE, ...)"},{"p":"mgcv","o":"uniquecombs","f":"hp_uniquecombs","d":"This routine returns a matrix or data frame containing all the unique rows of the\nmatrix or data frame supplied as its argument. That is, all the duplicate rows are\nstripped out. Note that the ordering of the rows on exit need not be the same\nas on entry. It also returns an index attribute for relating the result back \nto the original matrix. \n","ec":"uniquecombs(x, ordered = FALSE)"},{"p":"mgcv","o":"betar","f":"hp_betar","d":"Family for use with gam or bam, implementing regression for beta distributed data on (0,1).\nA linear predictor controls the mean, \\mu of the beta distribution, while the variance is then\n\\mu(1-\\mu)/(1+\\phi), with parameter \\phi being estimated during \nfitting, alongside the smoothing parameters.\n","ec":"betar(theta = NULL, link = \"logit\", eps = .Machine$double.eps * 100)"},{"p":"mgcv","o":"Predict.matrix2","f":"hp_Predict.matrix2","d":" Takes smooth objects produced by smooth.construct methods and obtains the matrix mapping \nthe parameters associated with such a smooth to the predicted values of the smooth at a set of new covariate values.\n","ec":"Predict.matrix2(object, data)"},{"p":"mgcv","o":"dmvn","f":"hp_dmvn","d":" Generates multivariate normal or t random deviates, and evaluates the corresponding log densities.\n","ec":"dmvn(x, mu, V, R = NULL)"},{"p":"mgcv","o":"twlss","f":"hp_twlss","d":"Tweedie family in which the mean, power and scale parameters can all depend on smooth linear predictors. Restricted to estimation via the extended Fellner Schall method of Wood and Fasiolo (2017). Only usable with gam. Tweedie distributions are exponential family with variance given by \\phi \\mu^p where \\phi is a scale parameter, p a parameter (here between 1 and 2) and \\mu is the mean. \n","ec":"twlss(link = list(\"log\", \"identity\", \"identity\"), a = 1.01, b = 1.99)"},{"p":"mgcv","o":"spasm.smooth","f":"hp_spasm.smooth","d":"These are experimental sparse smoothing functions, and should \nbe left well alone!\n","ec":"spasm.smooth(object, X, residual = FALSE, block = 0)"},{"p":"mgcv","o":"predict.bam","f":"hp_predict.bam","d":" In most cases essentially a wrapper for predict.gam for prediction from a \nmodel fitted by bam. Can compute on a parallel cluster. For models fitted using discrete\nmethods with discrete=TRUE then discrete prediction methods are used instead. \n","ec":"predict.bam(object, newdata, type = \"link\", se.fit = FALSE, terms = NULL, exclude = NULL, block.size = 50000, newdata.guaranteed = FALSE, na.action = na.pass, cluster = NULL, discrete = TRUE, n.threads = 1, gc.level = 0, ...)"},{"p":"mgcv","o":"t2","f":"hp_t2","d":" Alternative to te for defining tensor product smooths\nin a gam formula. Results in a construction in which the penalties are \nnon-overlapping multiples of identity matrices (with some rows and columns zeroed). \nThe construction, which is due to Fabian Scheipl (mgcv implementation, 2010), is analogous to Smoothing Spline ANOVA \n(Gu, 2002), but using low rank penalized regression spline marginals. The main advantage of this construction \nis that it is useable with gamm4 from package gamm4.\n","ec":"t2(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, xt = NULL, id = NULL, sp = NULL, full = FALSE, ord = NULL, pc = NULL)"},{"p":"mgcv","o":"Predict.matrix.sf","f":"hp_Predict.matrix.sf","d":" Creates a prediction matrix for a soap film smooth object,\nmapping the coefficients of the smooth to the linear predictor component for\nthe smooth.  This is the Predict.matrix method function required by gam.\n","ec":"Predict.matrix.sf(object, data)"},{"p":"mgcv","o":"smooth.construct.t2.smooth.spec","f":"hp_smooth.construct.t2.smooth.spec","d":"A special smooth.construct method function for creating tensor product smooths from any\ncombination of single penalty marginal smooths, using the construction of Wood, Scheipl and Faraway (2013). \n","ec":"smooth.construct.t2.smooth.spec(object, data, knots)"},{"p":"mgcv","o":"concurvity","f":"hp_concurvity","d":"Produces summary measures of concurvity between gam components.\n","ec":"concurvity(b, full = TRUE)"},{"p":"mgcv","o":"get.var","f":"hp_get.var","d":" This routine takes a text string and a data frame or list. It first sees if the \nstring is the name of a variable in the data frame/ list. If it is then the value of this variable is returned. \nOtherwise the routine tries to evaluate the expression within the data.frame/list (but nowhere else) and if \nsuccessful returns the result. If neither step works then NULL is returned. The routine is useful for\nprocessing gam formulae. If the variable is a matrix then it is coerced to a numeric vector, by default.","ec":"get.var(txt, data, vecMat = TRUE)"},{"p":"mgcv","o":"Predict.matrix.pspline.smooth","f":"hp_Predict.matrix.pspline.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.pspline.smooth(object, data)"},{"p":"mgcv","o":"vis.gam","f":"hp_vis.gam","d":" Produces perspective or contour plot views of gam model\npredictions, fixing all but the values in view to the  values supplied in cond. \n","ec":"vis.gam(x, view = NULL, cond = list(), n.grid = 30, too.far = 0, col = NA, color = \"heat\", contour.col = NULL, se = -1, type = \"link\", plot.type = \"persp\", zlim = NULL, nCol = 50, lp = 1, ...)"},{"p":"mgcv","o":"gam.fit5.post.proc","f":"hp_gam.fit5.post.proc","d":"INTERNAL function for post-processing the output of gam.fit5.\n","ec":"gam.fit5.post.proc(object, Sl, L, lsp0, S, off, gamma)"},{"p":"mgcv","o":"gamlss.gH","f":"hp_gamlss.gH","d":" Mainly intended for internal use with location scale model families.\nGiven the derivatives of the log-likelihood wrt the linear predictor, this function obtains\nthe derivatives and Hessian wrt the regression coefficients and derivatives of\nthe Hessian w.r.t. the smoothing parameters. For input derivative array packing conventions see trind.generator.\n","ec":"gamlss.gH(X, jj, l1, l2, i2, l3 = 0, i3 = 0, l4 = 0, i4 = 0, d1b = 0, d2b = 0, deriv = 0, fh = NULL, D = NULL, sandwich = FALSE)"},{"p":"mgcv","o":"ziP","f":"hp_ziP","d":"Family for use with gam or bam, implementing regression for zero inflated Poisson data\nwhen the complimentary log log of the zero probability is linearly dependent on the log of the Poisson parameter. Use with great care, noting that simply having many zero response observations is not an indication of zero inflation: the question is whether you have too many zeroes given the specified model.\n","ec":"ziP(theta = NULL, link = \"identity\", b = 0)"},{"p":"mgcv","o":"notExp2","f":"hp_notExp2","d":"notLog2 and notExp2 are alternatives to log\nand exp or notLog and notExp for\nre-parameterization of variance parameters. They are used by the\npdTens and pdIdnot classes which in turn implement\nsmooths for gamm.\n","ec":"notExp2(x, d = .Options$mgcv.vc.logrange, b = 1/d)"},{"p":"mgcv","o":"gfam","f":"hp_gfam","d":"Family for use with gam or bam allowing a univariate response vector to be made up of variables from several different distributions. The response variable is supplied as a 2 column matrix, where the first column contains the response observations and the second column indexes the distribution (family) from which it comes. gfam takes a list of families as its single argument.\n","ec":"gfam(fl)"},{"p":"mgcv","o":"interpret.gam","f":"hp_interpret.gam","d":" This is an internal function of package mgcv. It is a service routine for\ngam which splits off the strictly parametric part of the model formula, returning \nit as a formula, and interprets the smooth parts of the model formula. \n","ec":"interpret.gam(gf, extra.special = NULL)"},{"p":"mgcv","o":"Sl.inirep","f":"hp_Sl.inirep","d":"INTERNAL routine to apply initial Sl re-parameterization to model matrix X,\nor, if inverse==TRUE, to apply inverse re-parametrization to parameter vector \nor covariance matrix.\n","ec":"Sl.inirep(Sl, X, l = 0, r = 0, nt = 1)"},{"p":"mgcv","o":"anova.gam","f":"hp_anova.gam","d":" Performs hypothesis tests relating to one or more fitted\ngam objects. For a single fitted gam object, Wald tests of\nthe significance of each parametric and smooth term are performed, so interpretation \nis analogous to drop1 rather than anova.lm (i.e. it's like type III ANOVA, \nrather than a sequential type I ANOVA). Otherwise the fitted models are compared using an analysis of deviance table or GLRT test: this latter approach should not be use to test the significance of terms which can be penalized \nto zero. Models to be compared should be fitted to the same data using the same smoothing parameter selection method.\n","ec":"anova.gam(object, ..., dispersion = NULL, test = NULL, freq = FALSE)"},{"p":"mgcv","o":"gam.control","f":"hp_gam.control","d":" This is an internal function of package mgcv which allows \ncontrol of the numerical options for fitting a GAM. \nTypically users will want to modify the defaults if model fitting fails to\nconverge, or if the warnings are generated which suggest a \nloss of numerical stability during fitting.  To change the default\nchoise of fitting method, see gam arguments method and optimizer.\n","ec":"gam.control(nthreads = 1, ncv.threads = 1, irls.reg = 0, epsilon = 1e-07, maxit = 200, mgcv.tol = 1e-07, mgcv.half = 15, trace = FALSE, rank.tol = .Machine$double.eps^0.5, nlm = list(), optim = list(), newton = list(), idLinksBases = TRUE, scalePenalty = TRUE, efs.lspmax = 15, efs.tol = 0.1, keepData = FALSE, scale.est = \"fletcher\", edge.correct = FALSE)"},{"p":"mgcv","o":"Predict.matrix.cs.smooth","f":"hp_Predict.matrix.cs.smooth","d":"The various built in smooth classes for use with gam have associate Predict.matrix \nmethod functions to enable prediction from the fitted model. ","ec":"Predict.matrix.cs.smooth(object, data)"},{"p":"mgcv","o":"tensor.prod.penalties","f":"hp_tensor.prod.penalties","d":"Produce model matrices or penalty matrices for a tensor product smooth from the model matrices or\npenalty matrices for the marginal bases of the smooth (marginals and results can be sparse). The model matrix construction uses row Kronecker products.\n","ec":"tensor.prod.penalties(S)"},{"p":"mgcv","o":"smooth.info","f":"hp_smooth.info","d":"Takes a smooth specification object and adds extra basis specific information to it before smooth constructor called. Default method returns supplied object unmodified.\n","ec":"smooth.info(object)"},{"p":"mgcv","o":"gammals","f":"hp_gammals","d":"The gammals family implements gamma location scale additive models in which \nthe log of the mean and the log of the scale parameter (see details) can depend on additive smooth predictors. Useable only with gam, the linear predictors are specified via a list of formulae.\n","ec":"gammals(link = list(\"identity\", \"log\"), b = -7)"},{"p":"mgcv","o":"fix.family.var","f":"hp_fix.family.var","d":" Generalized Additive Model fitting by <U+2018>outer<U+2019> iteration,\nrequires extra derivatives of the variance and link functions to be \nadded to family objects. The first 3 functions add what is needed. Model checking can\nbe aided by adding quantile and random deviate generating functions to the family. \nThe final two functions do this.\n","ec":"fix.family.var(fam)"},{"p":"mgcv","o":"Sl.repara","f":"hp_Sl.repara","d":"INTERNAL routine to apply re-parameterization from log-determinant of penalty matrix, ldetS to\nmodel matrix, X, blockwise.\n","ec":"Sl.repara(rp, X, inverse = FALSE, both.sides = TRUE)"},{"p":"mgcv","o":"gam.fit3","f":"hp_gam.fit3","d":"Estimation of GAM smoothing parameters is most stable if\noptimization of the UBRE/AIC, GCV, GACV, REML or ML score is outer to the penalized iteratively\nre-weighted least squares scheme used to estimate the model given smoothing \nparameters.\n","ec":"gam.fit3(x, y, sp, Eb, UrS = list(), weights = rep(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep(0, nobs), U1 = diag(ncol(x)), Mp = -1, family = gaussian(), control = gam.control(), intercept = TRUE, deriv = 2, gamma = 1, scale = 1, printWarn = TRUE, scoreType = \"REML\", null.coef = rep(0, ncol(x)), pearson.extra = 0, dev.extra = 0, n.true = -1, Sl = NULL, nei = NULL, ...)"},{"p":"munsell","o":"darker","f":"hp_darker","d":"Decreases the value of the Munsell colour by 1.\n","ec":"darker(col, steps = 1)"},{"p":"munsell","o":"desaturate","f":"hp_desaturate","d":"Decreases the chroma of the Munsell colour by one step steps (multiples of 2).\n","ec":"desaturate(col, steps = 1)"},{"p":"munsell","o":"text_colour","f":"hp_text_colour","d":"Get the appropriate text colour for writing on a munsell colour.\n","ec":"text_colour(cols)"},{"p":"munsell","o":"mnsl2hvc","f":"hp_mnsl2hvc","d":"Takes a text specification of a Munsell colour and returns\nthe hue, chroma and value triplet.\n","ec":"mnsl2hvc(col, ...)"},{"p":"munsell","o":"mnsl","f":"hp_mnsl","d":"Take a character string representation of a Munsell colour and returns the \nhex specification of that colour\n","ec":"mnsl(col, ...)"},{"p":"munsell","o":"mnsl_hues","f":"hp_mnsl_hues","d":"Returns a character vector of the Munsell hues in hue order starting at 2.5R and excluding grey (\"N\").\n","ec":"mnsl_hues()"},{"p":"munsell","o":"lighter","f":"hp_lighter","d":"Increases the value of the Munsell colour.\n","ec":"lighter(col, steps = 1)"},{"p":"munsell","o":"fix_mnsl","f":"hp_fix_mnsl","d":"Takes correctly specified but undefined colours and outputs something\nsensible.  Normally this happens when the chroma is too high.  So,  here\nsensible means the colour with the same hue and value and maximum defined\nchroma.\n","ec":"fix_mnsl(col)"},{"p":"munsell","o":"seq_mnsl","f":"hp_seq_mnsl","d":"Generates a sequence of Munsell colours.  The sequence is generated by \nfinding the closest munsell colours to a equidistant sequence of colours in  #' LUV space.\n","ec":"seq_mnsl(from, to, n, fix = FALSE)"},{"p":"munsell","o":"in_gamut","f":"hp_in_gamut","d":"Not all possible correctly formatted Munsell colours result in a colour\nrepresentable in RGB space.  This function checks if the colour is\nrepresentable.\n","ec":"in_gamut(col, fix = FALSE)"},{"p":"munsell","o":"complement","f":"hp_complement","d":"Finds the munsell colour with the same chroma and value but on the opposite\nside of the hue circle. The complement is not defined \nfor greys (hue == \"N\"), and the function returns the grey untransformed.\n","ec":"complement(col, ...)"},{"p":"munsell","o":"check_mnsl","f":"hp_check_mnsl","d":"Checks user supplied munsell specification for validity.  \nI.e. colour is of form \"h v/c\" and h,  v and c take valid values.\n","ec":"check_mnsl(col)"},{"p":"munsell","o":"hvc2mnsl","f":"hp_hvc2mnsl","d":"Takes separate specifications of hue, value and chroma and returns the \ntext specification of that colour.\n","ec":"hvc2mnsl(hue, value = NULL, chroma = NULL, ...)"},{"p":"munsell","o":"value_slice","f":"hp_value_slice","d":"Plots slices of the Munsell colour system where value is constant.\n","ec":"value_slice(value.name = 1:10, back.col = \"white\")"},{"p":"munsell","o":"rgb2mnsl","f":"hp_rgb2mnsl","d":"Finds the closest Munsell colour (in LUV space) to the specified sRGB colour\n","ec":"rgb2mnsl(R, G = NULL, B = NULL)"},{"p":"munsell","o":"saturate","f":"hp_saturate","d":"Increases the chroma of the Munsell colour by step steps (multiples of 2).\n","ec":"saturate(col, steps = 1)"},{"p":"munsell","o":"plot_mnsl","f":"hp_plot_mnsl","d":"Takes munsell text specifications and plots colour squares of them.\n","ec":"plot_mnsl(cols, back.col = \"white\", ...)"},{"p":"munsell","o":"mnsl2hex","f":"hp_mnsl2hex","d":"Take a character string representation of a Munsell colour and returns the \nhex specification of that colour\n","ec":"mnsl2hex(col, ...)"},{"p":"munsell","o":"complement_slice","f":"hp_complement_slice","d":"Plot a hue and its complement at all values and chromas\n","ec":"complement_slice(hue.name, back.col = \"white\")"},{"p":"munsell","o":"plot_hex","f":"hp_plot_hex","d":"Quick way to look at a set of hex colours.\n","ec":"plot_hex(hex.colour, back.col = \"white\")"},{"p":"munsell","o":"chroma_slice","f":"hp_chroma_slice","d":"Plots slices of the Munsell colour system where chroma is constant.\n","ec":"chroma_slice(chroma.name = seq(0, 26, by = 2), back.col = \"white\")"},{"p":"munsell","o":"plot_closest","f":"hp_plot_closest","d":"Take an sRGB colour and plots it along with the closest Munsell colour (using rgb2mnsl to find it)\n","ec":"plot_closest(R, G = NULL, B = NULL, back.col = \"white\")"},{"p":"munsell","o":"rygbp","f":"hp_rygbp","d":"Moves the hue of a munsell colour in the direction red->yellow->green->blue->purple->red\n","ec":"rygbp(col, steps = 1)"},{"p":"munsell","o":"hue_slice","f":"hp_hue_slice","d":"Plots slices of the Munsell colour system where hue is constant.\n","ec":"hue_slice(hue.name = \"all\", back.col = \"white\")"},{"p":"munsell","o":"pbgyr","f":"hp_pbgyr","d":"Moves the hue of a munsell colour in the direction purple->blue->green->yellow->red->purple\n","ec":"pbgyr(col, steps = 1)"},{"p":"nlme","o":"pdIdent","f":"hp_pdIdent","d":"This function is a constructor for the pdIdent class,\nrepresenting a multiple of the identity positive-definite matrix. \nThe matrix associated with object is represented by 1\nunrestricted parameter, given by the logarithm of the square-root of\nthe diagonal value. When value is \nnumeric(0), an uninitialized pdMat object, a one-sided\nformula, or a vector of character strings, object is returned\nas an uninitialized pdIdent object (with just some of its\nattributes and its class defined) and needs to have its coefficients\nassigned later, generally using the coef or matrix replacement\nfunctions. If value is an initialized pdMat object,\nobject will be constructed from\nas.matrix(value). Finally, if value is a numeric value,\nit is assumed to represent the unrestricted coefficient of the\nunderlying positive-definite  matrix.  \n","ec":"pdIdent(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"varExp","f":"hp_varExp","d":"This function is a constructor for the varExp class,\nrepresenting an exponential variance function structure. Letting\nv denote the variance covariate and \\sigma^2(v)\ndenote the variance function evaluated at v, the exponential\nvariance function is defined as \\sigma^2(v) = \\exp(2\\theta\n    v), where \\theta is the variance\nfunction coefficient. When a grouping factor is present, a different\n\\theta is used for each factor level.\n","ec":"varExp(value = numeric(0), form = ~fitted(.), fixed = NULL)"},{"p":"nlme","o":"plot.lme","f":"hp_plot.lme","d":"Diagnostic plots for the linear mixed-effects fit are obtained. The\nform argument gives considerable flexibility in the type of\nplot specification. A conditioning expression (on the right side of a\n| operator) always implies that different panels are used for\neach level of the conditioning factor, according to a Trellis\ndisplay. If form is a one-sided formula, histograms of the\nvariable on the right hand side of the formula, before a |\noperator, are displayed (the Trellis function histogram is\nused). If form is two-sided and both its left and\nright hand side variables are numeric, scatter plots are displayed\n(the Trellis function xyplot is used). Finally, if form\nis two-sided and its left had side variable is a factor, box-plots of\nthe right hand side variable by the levels of the left hand side\nvariable are displayed (the Trellis function  bwplot is used). \n","ec":"plot.lme(x, form = resid(., type = \"pearson\") ~ fitted(.), abline, id = NULL, idLabels = NULL, idResType = c(\"pearson\", \"normalized\"), grid, ...)"},{"p":"nlme","o":"getCovariate","f":"hp_getCovariate","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include corStruct, corSpatial,\ndata.frame, and varFunc.\n","ec":"getCovariate(object, form = formula(object), data)"},{"p":"nlme","o":"coef<-","f":"hp_coef..","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include all \"pdMat\",\n\"corStruct\" and \"varFunc\" classes,\n\"reStruct\", and \"modelStruct\".\n","ec":"coef<-(object, ..., value)"},{"p":"nlme","o":"corSymm","f":"hp_corSymm","d":"This function is a constructor for the corSymm class,\nrepresenting a general correlation structure. The internal\nrepresentation of this structure, in terms of unconstrained\nparameters, uses the spherical parametrization defined in Pinheiro and\nBates (1996).  Objects created using this constructor must later be\ninitialized using the  appropriate Initialize method. \n","ec":"corSymm(value = numeric(0), form = ~1, fixed = FALSE)"},{"p":"nlme","o":"ranef","f":"hp_ranef","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include lmList and lme.\n","ec":"ranef(object, ...)"},{"p":"nlme","o":"corMatrix","f":"hp_corMatrix","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include all corStruct classes.\n","ec":"corMatrix(object, ...)"},{"p":"nlme","o":"quinModel","f":"hp_quinModel","d":"A model function for a model used with the Quinidine data.\nThis function calls compiled C code.\n","ec":"quinModel(Subject, time, conc, dose, interval, lV, lKa, lCl)"},{"p":"nlme","o":"lmList","f":"hp_lmList","d":"Data is partitioned according to the levels of the grouping\nfactor g and individual lm fits are obtained for each\ndata partition, using the model defined in object.\n","ec":"lmList(object, data, level, subset, na.action = na.fail, pool = TRUE, warn.lm = TRUE)"},{"p":"nlme","o":"lmeStruct","f":"hp_lmeStruct","d":"A linear mixed-effects structure is a list of model components\nrepresenting different sets of parameters in the linear mixed-effects\nmodel. An lmeStruct list must contain at least a\nreStruct object, but may also contain corStruct and\nvarFunc objects. NULL arguments are not included in the\nlmeStruct list. \n","ec":"lmeStruct(reStruct, corStruct = NULL, varStruct = NULL)"},{"p":"nlme","o":"isInitialized","f":"hp_isInitialized","d":"Checks if object has been initialized (generally through a call\nto Initialize), by searching for components and attributes\nwhich are modified during initialization.\n","ec":"isInitialized(object)"},{"p":"nlme","o":"pooledSD","f":"hp_pooledSD","d":"The pooled estimated standard deviation is obtained by adding together\nthe residual sum of squares for each non-null element of\nobject, dividing by the sum of the corresponding residual\ndegrees-of-freedom, and taking the square-root.\n","ec":"pooledSD(object)"},{"p":"nlme","o":"getGroups","f":"hp_getGroups","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include corStruct, data.frame,\ngls, lme, lmList, and varFunc.\n","ec":"getGroups(object, form = formula(object), level, data, sep = \"/\")"},{"p":"nlme","o":"lme.lmList","f":"hp_lme.lmList","d":"If the random effects names defined in random are a subset of\nthe lmList object coefficient names, initial estimates for the\ncovariance matrix of the random effects are obtained (overwriting any\nvalues given in random). formula(fixed) and the\ndata argument in the calling sequence used to obtain\nfixed are passed as the fixed and data arguments\nto lme.formula, together with any other additional arguments in\nthe function call. See the documentation on lme.formula for a\ndescription of that function. \n","ec":"lme.lmList(fixed, data = sys.frame(sys.parent()), random, correlation = NULL, weights = NULL, subset, method = c(\"REML\", \"ML\"), na.action = na.fail, control = list(), contrasts = NULL, keep.data = TRUE)"},{"p":"nlme","o":"corExp","f":"hp_corExp","d":"This function is a constructor for the \"corExp\" class,\nrepresenting an exponential spatial correlation structure. Letting\nd denote the range and n denote the nugget\neffect, the correlation between two observations a distance\nr apart is \\exp(-r/d) when no nugget effect\nis present and (1-n) \\exp(-r/d) when a nugget\neffect is assumed. Objects created using this constructor must later be\ninitialized using the appropriate Initialize method.\n","ec":"corExp(value = numeric(0), form = ~1, nugget = FALSE, metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"lme.formula","f":"hp_lme.formula","d":"This generic function fits a linear mixed-effects model in the\nformulation described in Laird and Ware (1982) but allowing for nested\nrandom effects. The within-group errors are allowed to be correlated\nand/or have unequal variances.\n","ec":"lme.formula(fixed, data = sys.frame(sys.parent()), random = pdSymm(eval(as.call(fixed[-2]))), correlation = NULL, weights = NULL, subset, method = c(\"REML\", \"ML\"), na.action = na.fail, control = list(), contrasts = NULL, keep.data = TRUE)"},{"p":"nlme","o":"gapply","f":"hp_gapply","d":"Applies the function to the distinct sets of rows of the data frame\ndefined by groups.\n","ec":"gapply(object, which, FUN, form = formula(object), level, groups = getGroups(object, form, level), ...)"},{"p":"nlme","o":"corSpher","f":"hp_corSpher","d":"This function is a constructor for the corSpher class,\nrepresenting a spherical spatial correlation structure. Letting\nd denote the range and n denote the nugget\neffect, the correlation between two observations a distance\nr < d apart is 1-1.5(r/d)+0.5(r/d)^3 when no\nnugget effect is present and (1-n)\n    (1-1.5(r/d)+0.5(r/d)^3)  \nwhen a nugget effect is assumed. If r \\geq d the\ncorrelation is zero. Objects created using this constructor must later\nbe initialized using the appropriate Initialize method. \n","ec":"corSpher(value = numeric(0), form = ~1, nugget = FALSE, metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"VarCorr","f":"hp_VarCorr","d":"This function calculates the estimated variances, standard\ndeviations, and correlations between the random-effects terms in a\nlinear mixed-effects model, of class \"lme\", or a nonlinear\nmixed-effects model, of class \"nlme\".  The within-group error\nvariance and standard deviation are also calculated.\n","ec":"VarCorr(x, sigma = 1, ...)"},{"p":"nlme","o":"glsStruct","f":"hp_glsStruct","d":"A generalized least squares structure is a list of model components\nrepresenting different sets of parameters in the linear \nmodel. A glsStruct  may contain corStruct and\nvarFunc objects. NULL arguments are not included in the\nglsStruct list. \n","ec":"glsStruct(corStruct = NULL, varStruct = NULL)"},{"p":"nlme","o":"collapse","f":"hp_collapse","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Currently, only a groupedData\nmethod is available. \n","ec":"collapse(object, ...)"},{"p":"nlme","o":"balancedGrouped","f":"hp_balancedGrouped","d":"Create a groupedData object from a data matrix.  This function\ncan be used only with balanced data.  The opposite conversion, from a\ngroupedData object to a matrix, is done with asTable.\n","ec":"balancedGrouped(form, data, labels = NULL, units = NULL)"},{"p":"nlme","o":"nlme.formula","f":"hp_nlme.formula","d":"This generic function fits a nonlinear mixed-effects model in the\nformulation described in Lindstrom and Bates (1990) but allowing for nested\nrandom effects. The within-group errors are allowed to be correlated\nand/or have unequal variances.\n","ec":"nlme.formula(model, data = sys.frame(sys.parent()), fixed, random, groups, start, correlation = NULL, weights = NULL, subset, method = c(\"ML\", \"REML\"), na.action = na.fail, naPattern, control = list(), verbose = FALSE)"},{"p":"nlme","o":"pdSymm","f":"hp_pdSymm","d":"This function is a constructor for the pdSymm class,\nrepresenting a general positive-definite matrix. If the matrix\nassociated with object is of dimension n, it is\nrepresented by n(n+1)/2 unrestricted parameters,\nusing the matrix-logarithm parametrization described in Pinheiro and\nBates (1996). When value is numeric(0), an uninitialized\npdMat object, a one-sided\nformula, or a vector of character strings, object is returned\nas an uninitialized pdSymm object (with just some of its\nattributes and its class defined) and needs to have its coefficients\nassigned later, generally using the coef or matrix replacement\nfunctions. If value is an initialized pdMat object,\nobject will be constructed from\nas.matrix(value). Finally, if value is a numeric vector,\nit is assumed to represent the unrestricted coefficients of the\nmatrix-logarithm parametrization of the underlying positive-definite\nmatrix.  \n","ec":"pdSymm(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"asOneFormula","f":"hp_asOneFormula","d":"The names of all variables used in the formulas extracted from the\nobjects defined in ... are converted into a single linear\nformula, with the variables names separated by +. \n","ec":"asOneFormula(..., omit = c(\".\", \"pi\"))"},{"p":"nlme","o":"nlme.nlsList","f":"hp_nlme.nlsList","d":"If the random effects names defined in random are a subset of\nthe lmList object coefficient names, initial estimates for the\ncovariance matrix of the random effects are obtained (overwriting any\nvalues given in random). formula(fixed) and the\ndata argument in the calling sequence used to obtain\nfixed are passed as the fixed and data arguments\nto nlme.formula, together with any other additional arguments in\nthe function call. See the documentation on nlme.formula for a\ndescription of that function. \n","ec":"nlme.nlsList(model, data = sys.frame(sys.parent()), fixed, random = fixed, groups, start, correlation = NULL, weights = NULL, subset, method = c(\"ML\", \"REML\"), na.action = na.fail, naPattern, control = list(), verbose = FALSE)"},{"p":"nlme","o":"phenoModel","f":"hp_phenoModel","d":"A model function for a model used with the Phenobarb data.\nThis function uses compiled C code to improve execution speed.\n","ec":"phenoModel(Subject, time, dose, lCl, lV)"},{"p":"nlme","o":"pdMatrix","f":"hp_pdMatrix","d":"The positive-definite matrix represented by object, or a\nsquare-root factor of it is obtained. Letting \\Sigma denote a\npositive-definite matrix, a square-root factor of \\Sigma is\nany square matrix L such that \\Sigma = L'L. This function extracts \\Sigma or L.\n","ec":"pdMatrix(object, factor = FALSE)"},{"p":"nlme","o":"groupedData","f":"hp_groupedData","d":"An object of the groupedData class is constructed from the\nformula and data by attaching the formula as an\nattribute of the data, along with any of outer, inner,\nlabels, and units that are given.  If\norder.groups is TRUE the grouping factor is converted to\nan ordered factor with the ordering determined by\nFUN. Depending on the number of grouping levels and the type of\nprimary covariate, the returned object will be of one of three\nclasses: nfnGroupedData - numeric covariate, single level of\nnesting; nffGroupedData - factor covariate, single level of\nnesting; and nmGroupedData - multiple levels of\nnesting. Several modeling and plotting functions can use the formula\nstored with a groupedData object to construct default plots and\nmodels. \n","ec":"groupedData(formula, data = NULL, order.groups = TRUE, FUN = function(x) max(x, na.rm = TRUE), outer = NULL, inner = NULL, labels = NULL, units = NULL)"},{"p":"nlme","o":"nlsList.formula","f":"hp_nlsList.formula","d":"Data is partitioned according to the levels of the grouping\nfactor defined in model and individual nls fits are\nobtained for each data partition, using the model defined in\nmodel.\n","ec":"nlsList.formula(model, data, start = NULL, control, level, subset, na.action = na.fail, pool = TRUE, warn.nls = NA)"},{"p":"nlme","o":"Initialize","f":"hp_Initialize","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: corStruct, lmeStruct,\nreStruct, and varFunc.\n","ec":"Initialize(object, data, ...)"},{"p":"nlme","o":"ACF","f":"hp_ACF","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: gls and  lme.\n","ec":"ACF(object, maxLag, ...)"},{"p":"nlme","o":"fdHess","f":"hp_fdHess","d":"Evaluate an approximate Hessian and gradient of a scalar function\nusing finite differences.\n","ec":"fdHess(pars, fun, ..., .relStep = .Machine$double.eps^(1/3), minAbsPar = 0)"},{"p":"nlme","o":"lmeControl","f":"hp_lmeControl","d":"The values supplied in the lmeControl() call replace the\ndefaults, and a list with all settings (i.e., values for\nall possible arguments) is returned.  The returned list is\nused as the control argument to the lme function.\n","ec":"lmeControl(maxIter = 50, msMaxIter = 50, tolerance = 1e-06, niterEM = 25, msMaxEval = 200, msTol = 1e-07, msVerbose = FALSE, returnObject = FALSE, gradHess = TRUE, apVar = TRUE, .relStep = .Machine$double.eps^(1/3), minAbsParApVar = 0.05, opt = c(\"nlminb\", \"optim\"), optimMethod = \"BFGS\", natural = TRUE, sigma = NULL, allow.n.lt.q = FALSE, ...)"},{"p":"nlme","o":"getResponse","f":"hp_getResponse","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include data.frame, gls, lme,\nand lmList.\n","ec":"getResponse(object, form = formula(object))"},{"p":"nlme","o":"pdLogChol","f":"hp_pdLogChol","d":"This function is a constructor for the pdLogChol class,\nrepresenting a general positive-definite matrix.  If the matrix\nassociated with object is of dimension n, it is\nrepresented by n(n+1)/2 unrestricted parameters,\nusing the log-Cholesky parametrization described in Pinheiro and\nBates (1996).\n","ec":"pdLogChol(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"glsControl","f":"hp_glsControl","d":"The values supplied in the function call replace the defaults and a\nlist with all possible arguments is returned. The returned list is\nused as the control argument to the gls function.\n","ec":"glsControl(maxIter = 50L, msMaxIter = 200L, tolerance = 1e-06, msTol = 1e-07, msVerbose = FALSE, singular.ok = FALSE, returnObject = FALSE, apVar = TRUE, .relStep = .Machine$double.eps^(1/3), opt = c(\"nlminb\", \"optim\"), optimMethod = \"BFGS\", minAbsParApVar = 0.05, natural = TRUE, sigma = NULL)"},{"p":"nlme","o":"glsApVar","f":"hp_glsApVar","d":"These are functions used by gls to call its compiled C\ncode. They are exported to allow experimentation with modified versions.\n","ec":"glsApVar(glsSt, sigma, conLin = attr(glsSt, \"conLin\"), .relStep = .Machine$double.eps^(1/3), minAbsPar = 0, natural = TRUE)"},{"p":"nlme","o":"nlmeStruct","f":"hp_nlmeStruct","d":"A nonlinear mixed-effects structure is a list of model components\nrepresenting different sets of parameters in the nonlinear mixed-effects\nmodel. An nlmeStruct list must contain at least a\nreStruct object, but may also contain corStruct and\nvarFunc objects. NULL arguments are not included in the\nnlmeStruct list. \n","ec":"nlmeStruct(reStruct, corStruct = NULL, varStruct = NULL)"},{"p":"nlme","o":"reStruct","f":"hp_reStruct","d":"This function is a constructor for the reStruct class,\nrepresenting a random effects structure and consisting of a list of\npdMat objects, plus a settings attribute containing\ninformation for the optimization algorithm used to fit the associated\nmixed-effects model.\n","ec":"reStruct(object, pdClass = \"pdLogChol\", REML = FALSE, data = sys.frame(sys.parent()))"},{"p":"nlme","o":"getGroupsFormula","f":"hp_getGroupsFormula","d":"The conditioning expression associated with formula(object)\n(i.e. the expression after the | operator) is returned either as\na named list of one-sided formulas, or a single one-sided formula,\ndepending on the value of asList. The components of the\nreturned list are ordered from outermost to innermost level and are\nnamed after the grouping factor expression.\n","ec":"getGroupsFormula(object, asList = FALSE, sep = \"/\")"},{"p":"nlme","o":"needUpdate","f":"hp_needUpdate","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. By default, it tries to extract a\nneedUpdate attribute of object. If this is NULL\nor FALSE it returns FALSE; else it returns TRUE.\nUpdating of objects usually takes place in iterative algorithms in\nwhich auxiliary quantities associated with the object, and not being\noptimized over, may change.\n","ec":"needUpdate(object)"},{"p":"nlme","o":"corCompSymm","f":"hp_corCompSymm","d":"This function is a constructor for the corCompSymm class,\nrepresenting a compound symmetry structure corresponding to uniform\ncorrelation. Objects created using this constructor must later be\ninitialized using the appropriate Initialize method. \n","ec":"corCompSymm(value = 0, form = ~1, fixed = FALSE)"},{"p":"nlme","o":"intervals","f":"hp_intervals","d":"Confidence intervals on the parameters associated with the model\nrepresented by object are obtained. This function is generic;\nmethod functions can be written to handle specific classes of\nobjects. Classes which already have methods for this function include:\ngls, lme, and lmList. \n","ec":"intervals(object, level = 0.95, ...)"},{"p":"nlme","o":"logDet","f":"hp_logDet","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: corStruct, several pdMat classes,\nand reStruct. \n","ec":"logDet(object, ...)"},{"p":"nlme","o":"corNatural","f":"hp_corNatural","d":"This function is a constructor for the corNatural class,\nrepresenting a general correlation structure in the <U+201C>natural<U+201D>\nparameterization, which is described under pdNatural.\nObjects created using this constructor must later be\ninitialized using the  appropriate Initialize method. \n","ec":"corNatural(value = numeric(0), form = ~1, fixed = FALSE)"},{"p":"nlme","o":"isBalanced","f":"hp_isBalanced","d":"Check the design of the experiment or study for balance.\n","ec":"isBalanced(object, countOnly = FALSE, level)"},{"p":"nlme","o":"gsummary","f":"hp_gsummary","d":"Provide a summary of the variables in a data frame by groups of rows.\nThis is most useful with a groupedData object to examine the\nvariables by group.\n","ec":"gsummary(object, FUN = function(x) mean(x, na.rm = TRUE), omitGroupingFactor = FALSE, form = formula(object), level, groups = getGroups(object, form, level), invariantsOnly = FALSE, ...)"},{"p":"nlme","o":"nfGroupedData","f":"hp_nfGroupedData","d":"These functions are provided for compatibility with older versions of\nnlme only, and may be defunct as soon as the next release.\n","ec":"nfGroupedData(formula, data = NULL, order.groups = TRUE, FUN = function(x) max(x, na.rm = TRUE), outer = NULL, inner = NULL, labels = NULL, units = NULL)"},{"p":"nlme","o":"pdCompSymm","f":"hp_pdCompSymm","d":"This function is a constructor for the pdCompSymm class,\nrepresenting a positive-definite matrix with compound symmetry\nstructure (constant diagonal and constant off-diagonal elements). The\nunderlying matrix is represented by 2 unrestricted parameters.\nWhen value is numeric(0), an uninitialized pdMat\nobject, a one-sided formula, or a vector of character strings,\nobject is returned  as an uninitialized pdCompSymm\nobject (with just some of its  attributes and its class defined) and\nneeds to have its coefficients assigned later, generally using the\ncoef or matrix replacement functions. If value is\nan initialized\npdMat object, object will be constructed from \nas.matrix(value). Finally, if value is a numeric vector\nof length 2, it is assumed to represent the unrestricted coefficients\nof the underlying positive-definite matrix.  \n","ec":"pdCompSymm(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"compareFits","f":"hp_compareFits","d":"The columns in object1 and object2 are put together in\nmatrices which allow direct comparison of the individual elements for\neach object. Missing columns in either object are replaced by\nNAs.\n","ec":"compareFits(object1, object2, which = 1:ncol(object1))"},{"p":"nlme","o":"comparePred","f":"hp_comparePred","d":"Predicted values are obtained at the specified values of\nprimary for each object. If either object1 or\nobject2 have a grouping structure\n(i.e. getGroups(object) is not NULL), predicted values\nare obtained for each group. When both objects determine groups, the\ngroup levels must be the same. If other covariates besides\nprimary are used in the prediction model, their group-wise averages\n(numeric covariates) or most frequent values (categorical covariates)\nare used to obtain the predicted values. The original observations are\nalso included in the returned object. \n","ec":"comparePred(object1, object2, primary = NULL, minimum = min(primary), maximum = max(primary), length.out = 51, level = NULL, ...)"},{"p":"nlme","o":"matrix<-","f":"hp_matrix..","d":"This function is generic; method functions can be written to handle\nspecific classes of objects.  Classes which already have methods for\nthis function include pdMat, pdBlocked, and\nreStruct.\n","ec":"matrix<-(object, value)"},{"p":"nlme","o":"allCoef","f":"hp_allCoef","d":"The extractor function is applied to each object in ..., with\nthe result being converted to a vector. A map attribute is\nincluded to indicate which pieces of the returned vector correspond to\nthe original objects in dots.\n","ec":"allCoef(..., extract = coef)"},{"p":"nlme","o":"varConstPower","f":"hp_varConstPower","d":"This function is a constructor for the varConstPower class,\nrepresenting a constant plus power variance function\nstructure. Letting v denote the variance covariate and\n\\sigma^2(v) denote the variance function evaluated at\nv, the constant plus power variance function is defined as\n\\sigma^2(v) = (\\theta_1 + |v|^\\theta_2)^2, where \\theta_1,\\theta_2 are the variance  \nfunction coefficients. When a grouping factor is present, different\n\\theta_1,\\theta_2 are used for each factor level.\n","ec":"varConstPower(const = numeric(0), power = numeric(0), form = ~fitted(.), fixed = NULL)"},{"p":"nlme","o":"fixed.effects","f":"hp_fixed.effects","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include lmList and lme.\n","ec":"fixed.effects(object, ...)"},{"p":"nlme","o":"pdConstruct","f":"hp_pdConstruct","d":"This function is an alternative constructor for the pdMat\nclass associated with object and is mostly used internally in other\nfunctions. See the documentation on the principal constructor\nfunction, generally with the same name as the pdMat class of\nobject. \n","ec":"pdConstruct(object, value, form, nam, data, ...)"},{"p":"nlme","o":"pdMat","f":"hp_pdMat","d":"This function gives an alternative way of constructing an object\ninheriting from the pdMat class named in pdClass, or\nfrom data.class(object) if object inherits from\npdMat,  and is mostly used internally in other functions. See\nthe documentation on the principal constructor function, generally\nwith the same name as the pdMat class of object.\n","ec":"pdMat(value = numeric(0), form = NULL, nam = NULL, data = parent.frame(), pdClass = \"pdSymm\")"},{"p":"nlme","o":"corFactor","f":"hp_corFactor","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include all corStruct classes.\n","ec":"corFactor(object, ...)"},{"p":"nlme","o":"nlsList","f":"hp_nlsList","d":"Data is partitioned according to the levels of the grouping\nfactor defined in model and individual nls fits are\nobtained for each data partition, using the model defined in\nmodel.\n","ec":"nlsList(model, data, start, control, level, subset, na.action = na.fail, pool = TRUE, warn.nls = NA)"},{"p":"nlme","o":"varFixed","f":"hp_varFixed","d":"This function is a constructor for the varFixed class,\nrepresenting a variance function with fixed variances. Letting v\ndenote the variance covariate defined in value, the variance\nfunction \\sigma^2(v) for this class is\n\\sigma^2(v)=|v|. The variance covariate v is\nevaluated once at initialization and remains fixed thereafter. No\ncoefficients are required to represent this variance function.\n","ec":"varFixed(value = ~1)"},{"p":"nlme","o":"lme","f":"hp_lme","d":"This generic function fits a linear mixed-effects model in the\nformulation described in Laird and Ware (1982) but allowing for nested\nrandom effects. The within-group errors are allowed to be correlated\nand/or have unequal variances.\n","ec":"lme(fixed, data = sys.frame(sys.parent()), random, correlation = NULL, weights = NULL, subset, method = c(\"REML\", \"ML\"), na.action = na.fail, control = list(), contrasts = NULL, keep.data = TRUE)"},{"p":"nlme","o":"nmGroupedData","f":"hp_nmGroupedData","d":"These functions are provided for compatibility with older versions of\nnlme only, and may be defunct as soon as the next release.\n","ec":"nmGroupedData(formula, data = NULL, order.groups = TRUE, FUN = function(x) max(x, na.rm = TRUE), outer = NULL, inner = NULL, labels = NULL, units = NULL)"},{"p":"nlme","o":"corRatio","f":"hp_corRatio","d":"This function is a constructor for the corRatio class,\nrepresenting a rational quadratic spatial correlation structure. Letting\nd denote the range and n denote the nugget\neffect, the correlation between two observations a distance\nr apart is 1/(1+(r/d)^2) when no nugget effect\nis present and (1-n)/(1+(r/d)^2) when a\nnugget effect is  assumed. Objects created using this constructor need\nto be later initialized using the appropriate Initialize\nmethod. \n","ec":"corRatio(value = numeric(0), form = ~1, nugget = FALSE, metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"lmList.formula","f":"hp_lmList.formula","d":"Data is partitioned according to the levels of the grouping\nfactor g and individual lm fits are obtained for each\ndata partition, using the model defined in object.\n","ec":"lmList.formula(object, data, level, subset, na.action = na.fail, pool = TRUE, warn.lm = TRUE)"},{"p":"nlme","o":"gls","f":"hp_gls","d":"This function fits a linear model using generalized least\nsquares. The errors are allowed to be correlated and/or have unequal\nvariances.  \n","ec":"gls(model, data = sys.frame(sys.parent()), correlation = NULL, weights = NULL, subset, method = c(\"REML\", \"ML\"), na.action = na.fail, control = list(), verbose = FALSE)"},{"p":"nlme","o":"Dim","f":"hp_Dim","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: \"corSpatial\", \"corStruct\",\n\"pdCompSymm\", \"pdDiag\", \"pdIdent\", \"pdMat\",\nand \"pdSymm\".\n","ec":"Dim(object, ...)"},{"p":"nlme","o":"splitFormula","f":"hp_splitFormula","d":"Splits the right hand side of form into a list of subformulas\naccording to the presence of sep. The left hand side of\nform, if present, will be ignored. The length of the returned\nlist will be equal to the number of occurrences of sep in\nform plus one. \n","ec":"splitFormula(form, sep = \"/\")"},{"p":"nlme","o":"getVarCov","f":"hp_getVarCov","d":"Extract the variance-covariance matrix from a fitted model, such as a\nmixed-effects model.\n","ec":"getVarCov(obj, ...)"},{"p":"nlme","o":"varWeights","f":"hp_varWeights","d":"The inverse of the standard deviations corresponding to the variance\nfunction structure represented by object are returned.\n","ec":"varWeights(object)"},{"p":"nlme","o":"gnlsControl","f":"hp_gnlsControl","d":"The values supplied in the function call replace the defaults and a\nlist with all possible arguments is returned. The returned list is\nused as the control argument to the gnls function.\n","ec":"gnlsControl(maxIter = 50, nlsMaxIter = 7, msMaxIter = 50, minScale = 0.001, tolerance = 1e-06, nlsTol = 0.001, msTol = 1e-07, returnObject = FALSE, msVerbose = FALSE, apVar = TRUE, .relStep = .Machine$double.eps^(1/3), opt = c(\"nlminb\", \"optim\"), optimMethod = \"BFGS\", minAbsParApVar = 0.05, sigma = NULL)"},{"p":"nlme","o":"LDEsysMat","f":"hp_LDEsysMat","d":"Generate the system matrix for the linear differential equations\ndetermined by a compartment model.\n","ec":"LDEsysMat(pars, incidence)"},{"p":"nlme","o":"corIdent","f":"hp_corIdent","d":"These functions are provided for compatibility with older versions of\nnlme only, and may be defunct as soon as the next release.\n","ec":"corIdent(form = NULL)"},{"p":"nlme","o":"varConstProp","f":"hp_varConstProp","d":"This function is a constructor for the varConstProp class,\nrepresenting a variance function structure corresponding to\na two-component error model (additive and proportional error). Letting\nv denote the variance covariate and \\sigma^2(v)\ndenote the variance function evaluated at v, the two-component variance\nfunction is defined as\n\\sigma^2(v) = a^2 + b^2 * v^{2}, where a is\nthe additive component and b is the relative error component.  In order\nto avoid overparameterisation of the model, it is recommended to use\nthe possibility to fix sigma, preferably to a value of 1 (see examples).\n","ec":"varConstProp(const = numeric(0), prop = numeric(0), form = ~fitted(.), fixed = NULL)"},{"p":"nlme","o":"pdBlocked","f":"hp_pdBlocked","d":"This function is a constructor for the pdBlocked class,\nrepresenting a positive-definite block-diagonal matrix. Each\nblock-diagonal element of the underlying  matrix is itself a\npositive-definite matrix and is represented internally as an\nindividual pdMat object. When value is\nnumeric(0), a list of uninitialized pdMat objects, a\nlist of one-sided formulas, or a list of vectors \nof character strings,  object is returned\nas an uninitialized pdBlocked object (with just some of its\nattributes and its class defined) and needs to have its coefficients\nassigned later, generally using the coef or matrix replacement\nfunctions. If value is a list of  initialized pdMat\nobjects, object will be constructed from the list obtained by\napplying as.matrix to each of the pdMat elements of\nvalue. Finally, if value is a list of numeric vectors,\nthey are assumed to represent the unrestricted coefficients\nof the block-diagonal elements of the  underlying positive-definite\nmatrix.  \n","ec":"pdBlocked(value = numeric(0), form = NULL, nam = NULL, data = parent.frame(), pdClass = \"pdSymm\")"},{"p":"nlme","o":"getData","f":"hp_getData","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include gls, lme,\nand lmList.\n","ec":"getData(object)"},{"p":"nlme","o":"covariate<-","f":"hp_covariate..","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include all \"varFunc\" classes.\n","ec":"covariate<-(object, value)"},{"p":"nlme","o":"corAR1","f":"hp_corAR1","d":"This function is a constructor for the corAR1 class,\nrepresenting an autocorrelation structure of order 1. Objects\ncreated using this constructor must later be initialized using the\nappropriate Initialize method. \n","ec":"corAR1(value = 0, form = ~1, fixed = FALSE)"},{"p":"nlme","o":"getCovariateFormula","f":"hp_getCovariateFormula","d":"The right hand side of formula(object), without any\nconditioning expressions (i.e. any expressions after a |\noperator) is returned as a one-sided formula.\n","ec":"getCovariateFormula(object)"},{"p":"nlme","o":"anova.lme","f":"hp_anova.lme","d":"When only one fitted model object is present, a data frame with the\nnumerator degrees of freedom, denominator degrees of\nfreedom, F-values, and P-values for Wald tests for the terms in the\nmodel (when Terms and L are NULL), a combination\nof model terms (when Terms in not NULL), or linear\ncombinations of the model coefficients (when L is not\nNULL).  Otherwise, when multiple fitted objects are being\ncompared, a data frame with the degrees of freedom, the (restricted)\nlog-likelihood, the Akaike Information Criterion (AIC), and the\nBayesian Information Criterion (BIC) of each object is returned.  If\ntest=TRUE, whenever two consecutive  objects have different\nnumber of degrees of freedom, a likelihood ratio statistic with the\nassociated p-value is included in the returned data frame.\n","ec":"anova.lme(object, ..., test = TRUE, type = c(\"sequential\", \"marginal\"), adjustSigma = TRUE, Terms, L, verbose = FALSE)"},{"p":"nlme","o":"varPower","f":"hp_varPower","d":"This function is a constructor for the varPower class,\nrepresenting a power variance function structure. Letting\nv denote the variance covariate and \\sigma^2(v)\ndenote the variance function evaluated at v, the power\nvariance function is defined as \\sigma^2(v) = |v|^{2\\theta}, where \\theta is the variance \nfunction coefficient. When a grouping factor is present, a different\n\\theta is used for each factor level.\n","ec":"varPower(value = numeric(0), form = ~fitted(.), fixed = NULL)"},{"p":"nlme","o":"pdDiag","f":"hp_pdDiag","d":"This function is a constructor for the pdDiag class,\nrepresenting a diagonal positive-definite matrix. If the matrix\nassociated with object is of dimension n, it is\nrepresented by n unrestricted parameters, given by the logarithm\nof the square-root of the diagonal values. When value is\nnumeric(0), an uninitialized pdMat object, a one-sided\nformula, or a vector of character strings, object is returned\nas an uninitialized pdDiag object (with just some of its\nattributes and its class defined) and needs to have its coefficients\nassigned later, generally using the coef or matrix replacement\nfunctions. If value is an initialized pdMat object,\nobject will be constructed from\nas.matrix(value). Finally, if value is a numeric vector,\nit is assumed to represent the unrestricted coefficients of the\nunderlying positive-definite\nmatrix.  \n","ec":"pdDiag(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"corGaus","f":"hp_corGaus","d":"This function is a constructor for the corGaus class,\nrepresenting a Gaussian spatial correlation structure. Letting\nd denote the range and n denote the nugget\neffect, the correlation between two observations a distance\nr apart is \\exp(-(r/d)^2) when no nugget\neffect is present and (1-n) \\exp(-(r/d)^2)\nwhen a nugget effect is assumed. Objects created using this\nconstructor must later be initialized using the appropriate\n'  Initialize method. \n","ec":"corGaus(value = numeric(0), form = ~1, nugget = FALSE, metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"gnlsStruct","f":"hp_gnlsStruct","d":"A generalized nonlinear least squares structure is a list of model\ncomponents representing different sets of parameters in the nonlinear \nmodel. A gnlsStruct  may contain corStruct and\nvarFunc objects. NULL arguments are not included in the\ngnlsStruct list. \n","ec":"gnlsStruct(corStruct = NULL, varStruct = NULL)"},{"p":"nlme","o":"glsEstimate","f":"hp_glsEstimate","d":"These are functions used by gls to call its compiled C\ncode. They are exported to allow experimentation with modified versions.\n","ec":"glsEstimate(object, conLin = attr(object, \"conLin\"), control = list(singular.ok = FALSE))"},{"p":"nlme","o":"Variogram","f":"hp_Variogram","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include default, gls and lme. See\nthe appropriate method documentation for a description of the\narguments. \n","ec":"Variogram(object, distance, ...)"},{"p":"nlme","o":"Names<-","f":"hp_Names..","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: formula, modelStruct,\npdBlocked, pdMat, and reStruct.\n","ec":"Names<-(object, ..., value)"},{"p":"nlme","o":"corARMA","f":"hp_corARMA","d":"This function is a constructor for the corARMA class,\nrepresenting an autocorrelation-moving average correlation structure\nof order (p, q). Objects created using this constructor must later\nbe initialized using the appropriate Initialize method. \n","ec":"corARMA(value = double(p + q), form = ~1, p = 0, q = 0, fixed = FALSE)"},{"p":"nlme","o":"getResponseFormula","f":"hp_getResponseFormula","d":"The left hand side of formula{object} is returned as a\none-sided formula. \n","ec":"getResponseFormula(object)"},{"p":"nlme","o":"pdFactor","f":"hp_pdFactor","d":"A square-root factor of the positive-definite matrix represented by\nobject is obtained. Letting \\Sigma denote a\npositive-definite matrix, a square-root factor of \\Sigma is\nany square matrix L such that \\Sigma = L'L. This function extracts L.\n","ec":"pdFactor(object)"},{"p":"nlme","o":"varComb","f":"hp_varComb","d":"This function is a constructor for the varComb class,\nrepresenting a combination of variance functions. The corresponding\nvariance function is equal to the product of the variance functions of\nthe varFunc objects listed in ....\n","ec":"varComb(...)"},{"p":"nlme","o":"pdNatural","f":"hp_pdNatural","d":"This function is a constructor for the pdNatural class,\nrepresenting a general positive-definite matrix, using a natural\nparametrization . If the matrix associated with object is of\ndimension n, it is represented by n(n+1)/2\nparameters. Letting \\sigma_{ij} denote the ij-th\nelement of the underlying positive definite matrix and\n\\rho_{ij}=\\sigma_{i}/\\sqrt{\\sigma_{ii}\\sigma_{jj}},\\;i\\neq j denote the associated\n\"correlations\", the \"natural\" parameters are given by\n\\sqrt{\\sigma_{ii}}, \\;i=1,\\ldots,n and\n\\log((1+\\rho_{ij})/(1-\\rho_{ij})),\\; i \\neq\n    j. Note that all\nnatural parameters are individually unrestricted, but not jointly\nunrestricted (meaning that not all unrestricted vectors would give\npositive-definite matrices). Therefore, this parametrization should\nNOT be used for optimization. It is mostly used for deriving\napproximate confidence intervals on parameters following the\noptimization of an objective function. When value is\nnumeric(0), an uninitialized pdMat object, a one-sided\nformula, or a vector of character strings, object is returned\nas an uninitialized pdSymm object (with just some of its\nattributes and its class defined) and needs to have its coefficients\nassigned later, generally using the coef or matrix replacement\nfunctions. If value is an initialized pdMat object,\nobject will be constructed from\nas.matrix(value). Finally, if value is a numeric \nvector, it is assumed to represent the natural parameters of the\nunderlying positive-definite matrix.  \n","ec":"pdNatural(value = numeric(0), form = NULL, nam = NULL, data = parent.frame())"},{"p":"nlme","o":"asTable","f":"hp_asTable","d":"Create a tabular representation of the response in a balanced\ngroupedData object.\n","ec":"asTable(object)"},{"p":"nlme","o":"corCAR1","f":"hp_corCAR1","d":"This function is a constructor for the corCAR1 class,\nrepresenting an autocorrelation structure of order 1, with a\ncontinuous time covariate. Objects created using this constructor must\nbe later initialized using the appropriate Initialize\nmethod.  \n","ec":"corCAR1(value = 0.2, form = ~1, fixed = FALSE)"},{"p":"nlme","o":"fixef","f":"hp_fixef","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include lmList and lme.\n","ec":"fixef(object, ...)"},{"p":"nlme","o":"gnls","f":"hp_gnls","d":"This function fits a nonlinear model using generalized least\nsquares. The errors are allowed to be correlated and/or have unequal\nvariances.  \n","ec":"gnls(model, data = sys.frame(sys.parent()), params, start, correlation = NULL, weights = NULL, subset, na.action = na.fail, naPattern, control = list(), verbose = FALSE)"},{"p":"nlme","o":"Names","f":"hp_Names","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: formula, modelStruct,\npdBlocked, pdMat, and reStruct.\n","ec":"Names(object, ...)"},{"p":"nlme","o":"varFunc","f":"hp_varFunc","d":"If object is a one-sided formula, it is used as the argument to\nvarFixed and the resulting object is returned. Else, if\nobject inherits from class varFunc, it is returned\nunchanged. \n","ec":"varFunc(object)"},{"p":"nlme","o":"corSpatial","f":"hp_corSpatial","d":"This function is a constructor for the corSpatial class,\nrepresenting a spatial correlation structure. This class is \"virtual\",\nhaving four \"real\" classes, corresponding to specific spatial\ncorrelation structures, associated with it: corExp,\ncorGaus, corLin, corRatio, and\ncorSpher. The returned object will inherit from one of these\n\"real\" classes, determined by the type argument, and from the\n\"virtual\" corSpatial class. Objects created using this\nconstructor must later be initialized using the appropriate\nInitialize method. \n","ec":"corSpatial(value = numeric(0), form = ~1, nugget = FALSE, type = c(\"spherical\", \"exponential\", \"gaussian\", \"linear\", \"rational\"), metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"nlmeControl","f":"hp_nlmeControl","d":"The values supplied in the function call replace the defaults and a\nlist with all possible arguments is returned.  The returned list is\nused as the control argument to the nlme function.\n","ec":"nlmeControl(maxIter = 50, pnlsMaxIter = 7, msMaxIter = 50, minScale = 0.001, tolerance = 1e-05, niterEM = 25, pnlsTol = 0.001, msTol = 1e-06, returnObject = FALSE, msVerbose = FALSE, msWarnNoConv = TRUE, gradHess = TRUE, apVar = TRUE, .relStep = .Machine$double.eps^(1/3), minAbsParApVar = 0.05, opt = c(\"nlminb\", \"nlm\"), natural = TRUE, sigma = NULL, ...)"},{"p":"nlme","o":"simulate.lme","f":"hp_simulate.lme","d":"The model object is fit to the data.  Using\nthe fitted values of the parameters, nsim new data vectors from\nthis model are simulated.  Both object and m2 are fit by\nmaximum likelihood (ML) and/or by restricted maximum likelihood (REML)\nto each of the simulated data vectors.\n","ec":"simulate.lme(object, nsim = 1, seed = as.integer(runif(1, 0, .Machine$integer.max)), m2, method = c(\"REML\", \"ML\"), niterEM = c(40, 200), useGen, ...)"},{"p":"nlme","o":"coefficients<-","f":"hp_coefficients..","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include all \"pdMat\",\n\"corStruct\" and \"varFunc\" classes,\n\"reStruct\", and \"modelStruct\".\n","ec":"coefficients<-(object, ..., value)"},{"p":"nlme","o":"varIdent","f":"hp_varIdent","d":"This function is a constructor for the varIdent class,\nrepresenting a constant variance function structure. If no grouping\nfactor is present in form, the variance function is constant\nand equal to one, and no coefficients required to represent it. When\nform includes a grouping factor with M > 1 levels, the\nvariance function allows M different variances, one  for each level of\nthe factor. For identifiability reasons, the coefficients of the\nvariance function represent the ratios between the variances and a\nreference variance (corresponding to a reference group\nlevel). Therefore, only M-1 coefficients are needed to represent\nthe variance function. By default, if the elements in value are\nunnamed, the first group level is taken as the reference level.\n","ec":"varIdent(value = numeric(0), form = ~1, fixed = NULL)"},{"p":"nlme","o":"augPred","f":"hp_augPred","d":"Predicted values are obtained at the specified values of\nprimary.  If object has a grouping structure\n(i.e. getGroups(object) is not NULL), predicted values\nare obtained for each group.  If level has more than one\nelement, predictions are obtained for each level of the\nmax(level) grouping factor.  If other covariates besides\nprimary are used in the prediction model, their average\n(numeric covariates) or most frequent value (categorical covariates)\nare used to obtain the predicted values.  The original observations\nare also included in the returned object.\n","ec":"augPred(object, primary = NULL, minimum = min(primary), maximum = max(primary), length.out = 51, ...)"},{"p":"nlme","o":"nlme","f":"hp_nlme","d":"This generic function fits a nonlinear mixed-effects model in the\nformulation described in Lindstrom and Bates (1990) but allowing for nested\nrandom effects. The within-group errors are allowed to be correlated\nand/or have unequal variances.\n","ec":"nlme(model, data = sys.frame(sys.parent()), fixed, random = fixed, groups, start, correlation = NULL, weights = NULL, subset, method = c(\"ML\", \"REML\"), na.action = na.fail, naPattern, control = list(), verbose = FALSE)"},{"p":"nlme","o":"corLin","f":"hp_corLin","d":"This function is a constructor for the corLin class,\nrepresenting a linear spatial correlation structure. Letting\nd denote the range and n denote the nugget\neffect, the correlation between two observations a distance\nr < d apart is 1-(r/d) when no nugget effect\nis present and (1-n) (1 -(r/d)) when a nugget\neffect is assumed. If r \\geq d the correlation is\nzero. Objects created using this constructor must later be\ninitialized using the appropriate Initialize method. \n","ec":"corLin(value = numeric(0), form = ~1, nugget = FALSE, metric = c(\"euclidean\", \"maximum\", \"manhattan\"), fixed = FALSE)"},{"p":"nlme","o":"random.effects","f":"hp_random.effects","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include lmList and lme.\n","ec":"random.effects(object, ...)"},{"p":"nlme","o":"recalc","f":"hp_recalc","d":"This function is generic; method functions can be written to handle\nspecific classes of objects. Classes which already have methods for\nthis function include: corStruct, modelStruct,\nreStruct, and varFunc.\n","ec":"recalc(object, conLin, ...)"},{"p":"openxlsx","o":"getBaseFont","f":"hp_getBaseFont","d":"Return the workbook default font\n","ec":"getBaseFont(wb)"},{"p":"openxlsx","o":"sheetVisible","f":"hp_sheetVisible","d":"DEPRECATED - Use function 'sheetVisibility()\n","ec":"sheetVisible(wb)"},{"p":"openxlsx","o":"insertPlot","f":"hp_insertPlot","d":"The current plot is saved to a temporary image file using dev.copy.\nThis file is then written to the workbook using insertImage.\n","ec":"insertPlot(wb, sheet, width = 6, height = 4, xy = NULL, startRow = 1, startCol = 1, fileType = \"png\", units = \"in\", dpi = 300)"},{"p":"openxlsx","o":"temp_xlsx","f":"hp_temp_xlsx","d":"helper function to create tempory directory for testing purpose\n","ec":"temp_xlsx(name = \"temp_xlsx\")"},{"p":"openxlsx","o":"getDateOrigin","f":"hp_getDateOrigin","d":"Return the date origin used internally by an xlsx or xlsm file\n","ec":"getDateOrigin(xlsxFile)"},{"p":"openxlsx","o":"getTables","f":"hp_getTables","d":"List Excel tables in a workbook\n","ec":"getTables(wb, sheet)"},{"p":"openxlsx","o":"read.xlsx","f":"hp_read.xlsx","d":"Read data from an Excel file or Workbook object into a data.frame\n","ec":"read.xlsx(xlsxFile, sheet, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = \".\", namedRegion = NULL, na.strings = \"NA\", fillMergedCells = FALSE)"},{"p":"openxlsx","o":"getWindowSize","f":"hp_getWindowSize","d":"Set and Get Window Size for xlsx file\n","ec":"getWindowSize(wb)"},{"p":"openxlsx","o":"setWindowSize","f":"hp_setWindowSize","d":"Set and Get Window Size for xlsx file\n","ec":"setWindowSize(wb, xWindow = NULL, yWindow = NULL, windowWidth = NULL, windowHeight = NULL)"},{"p":"openxlsx","o":"deleteNamedRegion","f":"hp_deleteNamedRegion","d":"Create / delete a named region\n","ec":"deleteNamedRegion(wb, name)"},{"p":"openxlsx","o":"groupColumns","f":"hp_groupColumns","d":"Group a selection of columns\n","ec":"groupColumns(wb, sheet, cols, hidden = FALSE, level = -1)"},{"p":"openxlsx","o":"groupRows","f":"hp_groupRows","d":"Group a selection of rows\n","ec":"groupRows(wb, sheet, rows, hidden = FALSE, level = -1)"},{"p":"openxlsx","o":"getNamedRegions","f":"hp_getNamedRegions","d":"Return a vector of named regions in a xlsx file or\nWorkbook object\n","ec":"getNamedRegions(x)"},{"p":"openxlsx","o":"showGridLines","f":"hp_showGridLines","d":"Set worksheet gridlines to show or hide.\n","ec":"showGridLines(wb, sheet, showGridLines = FALSE)"},{"p":"openxlsx","o":"pageSetup","f":"hp_pageSetup","d":"Set page margins, orientation and print scaling\n","ec":"pageSetup(wb, sheet, orientation = NULL, scale = 100, left = 0.7, right = 0.7, top = 0.75, bottom = 0.75, header = 0.3, footer = 0.3, fitToWidth = FALSE, fitToHeight = FALSE, paperSize = NULL, printTitleRows = NULL, printTitleCols = NULL, summaryRow = NULL, summaryCol = NULL)"},{"p":"openxlsx","o":"setLastModifiedBy","f":"hp_setLastModifiedBy","d":"Just a wrapper of wb$changeLastModifiedBy()\n","ec":"setLastModifiedBy(wb, LastModifiedBy)"},{"p":"openxlsx","o":"get_worksheet_entries","f":"hp_get_worksheet_entries","d":"Get all entries from workbook worksheet without xml tags\n","ec":"get_worksheet_entries(wb, sheet)"},{"p":"openxlsx","o":"removeTable","f":"hp_removeTable","d":"List Excel tables in a workbook\n","ec":"removeTable(wb, sheet, table)"},{"p":"openxlsx","o":"activeSheet<-","f":"hp_activeSheet..","d":"Get and set active sheet of the workbook\n","ec":"activeSheet<-(wb, value)"},{"p":"openxlsx","o":"createNamedRegion","f":"hp_createNamedRegion","d":"Create / delete a named region\n","ec":"createNamedRegion(wb, sheet, cols, rows, name, overwrite = FALSE)"},{"p":"openxlsx","o":"removeColWidths","f":"hp_removeColWidths","d":"Remove column widths from a worksheet\n","ec":"removeColWidths(wb, sheet, cols)"},{"p":"openxlsx","o":"writeDataTable","f":"hp_writeDataTable","d":"Write to a worksheet and format as an Excel table\n","ec":"writeDataTable(wb, sheet, x, startCol = 1, startRow = 1, xy = NULL, colNames = TRUE, rowNames = FALSE, tableStyle = openxlsx_getOp(\"tableStyle\", \"TableStyleLight9\"), tableName = NULL, headerStyle = openxlsx_getOp(\"headerStyle\"), withFilter = openxlsx_getOp(\"withFilter\", TRUE), keepNA = openxlsx_getOp(\"keepNA\", FALSE), na.string = openxlsx_getOp(\"na.string\"), sep = \", \", stack = FALSE, firstColumn = openxlsx_getOp(\"firstColumn\", FALSE), lastColumn = openxlsx_getOp(\"lastColumn\", FALSE), bandedRows = openxlsx_getOp(\"bandedRows\", TRUE), bandedCols = openxlsx_getOp(\"bandedCols\", FALSE), col.names, row.names)"},{"p":"openxlsx","o":"createComment","f":"hp_createComment","d":"Create a cell Comment object to pass to writeComment()\n","ec":"createComment(comment, author = Sys.getenv(\"USERNAME\"), style = NULL, visible = TRUE, width = 2, height = 4)"},{"p":"openxlsx","o":"writeFormula","f":"hp_writeFormula","d":"Write a a character vector containing Excel formula to a worksheet.\n","ec":"writeFormula(wb, sheet, x, startCol = 1, startRow = 1, array = FALSE, xy = NULL)"},{"p":"openxlsx","o":"sheetVisibility<-","f":"hp_sheetVisibility..","d":"Get and set worksheet visible state\n","ec":"sheetVisibility<-(wb, value)"},{"p":"openxlsx","o":"removeFilter","f":"hp_removeFilter","d":"Removes filters from addFilter() and writeData()\n","ec":"removeFilter(wb, sheet)"},{"p":"openxlsx","o":"sheets","f":"hp_sheets","d":"DEPRECATED. Use names().\n","ec":"sheets(wb)"},{"p":"openxlsx","o":"removeComment","f":"hp_removeComment","d":"Remove a cell comment from a worksheet\n","ec":"removeComment(wb, sheet, cols, rows, gridExpand = TRUE)"},{"p":"openxlsx","o":"removeWorksheet","f":"hp_removeWorksheet","d":"Remove a worksheet from a Workbook object\n","ec":"removeWorksheet(wb, sheet)"},{"p":"openxlsx","o":"activeSheet","f":"hp_activeSheet","d":"Get and set active sheet of the workbook\n","ec":"activeSheet(wb)"},{"p":"openxlsx","o":"worksheetOrder","f":"hp_worksheetOrder","d":"Get/set order of worksheets in a Workbook object\n","ec":"worksheetOrder(wb)"},{"p":"openxlsx","o":"buildWorkbook","f":"hp_buildWorkbook","d":"Build a workbook from a data.frame or named list\n","ec":"buildWorkbook(x, asTable = FALSE, ...)"},{"p":"openxlsx","o":"worksheetOrder<-","f":"hp_worksheetOrder..","d":"Get/set order of worksheets in a Workbook object\n","ec":"worksheetOrder<-(wb, value)"},{"p":"openxlsx","o":"setHeader","f":"hp_setHeader","d":"DEPRECATED\n","ec":"setHeader(wb, text, position = \"center\")"},{"p":"openxlsx","o":"saveWorkbook","f":"hp_saveWorkbook","d":"save a Workbook object to file\n","ec":"saveWorkbook(wb, file, overwrite = FALSE, returnValue = FALSE)"},{"p":"openxlsx","o":"createStyle","f":"hp_createStyle","d":"Create a new style to apply to worksheet cells\n","ec":"createStyle(fontName = NULL, fontSize = NULL, fontColour = NULL, numFmt = openxlsx_getOp(\"numFmt\", \"GENERAL\"), border = NULL, borderColour = openxlsx_getOp(\"borderColour\", \"black\"), borderStyle = openxlsx_getOp(\"borderStyle\", \"thin\"), bgFill = NULL, fgFill = NULL, halign = NULL, valign = NULL, textDecoration = NULL, wrapText = FALSE, textRotation = NULL, indent = NULL, locked = NULL, hidden = NULL)"},{"p":"openxlsx","o":"addStyle","f":"hp_addStyle","d":"Function adds a style to a specified set of cells.\n","ec":"addStyle(wb, sheet, style, rows, cols, gridExpand = FALSE, stack = FALSE)"},{"p":"openxlsx","o":"removeCellMerge","f":"hp_removeCellMerge","d":"Unmerges any merged cells that intersect\nwith the region specified by, min(cols):max(cols) X min(rows):max(rows)\n","ec":"removeCellMerge(wb, sheet, cols, rows)"},{"p":"openxlsx","o":"auto_heights","f":"hp_auto_heights","d":"Compute optimal row heights for cell with fixed with and\nenabled automatic row heights parameter\n","ec":"auto_heights(wb, sheet, selected, fontsize = NULL, factor = 1, base_height = 15, extra_height = 12)"},{"p":"openxlsx","o":"ungroupColumns","f":"hp_ungroupColumns","d":"Ungroup a selection of columns\n","ec":"ungroupColumns(wb, sheet, cols)"},{"p":"openxlsx","o":"writeComment","f":"hp_writeComment","d":"Write a Comment object to a worksheet\n","ec":"writeComment(wb, sheet, col, row, comment, xy = NULL)"},{"p":"openxlsx","o":"modifyBaseFont","f":"hp_modifyBaseFont","d":"Modify the default font for this workbook\n","ec":"modifyBaseFont(wb, fontSize = 11, fontColour = \"black\", fontName = \"Calibri\")"},{"p":"openxlsx","o":"renameWorksheet","f":"hp_renameWorksheet","d":"Rename a worksheet\n","ec":"renameWorksheet(wb, sheet, newName)"},{"p":"openxlsx","o":"sheetVisible<-","f":"hp_sheetVisible..","d":"DEPRECATED - Use function 'sheetVisibility()\n","ec":"sheetVisible<-(wb, value)"},{"p":"openxlsx","o":"convertToDateTime","f":"hp_convertToDateTime","d":"Convert from excel time number to R POSIXct type.\n","ec":"convertToDateTime(x, origin = \"1900-01-01\", ...)"},{"p":"openxlsx","o":"addFilter","f":"hp_addFilter","d":"Add excel column filters to a worksheet\n","ec":"addFilter(wb, sheet, rows, cols)"},{"p":"openxlsx","o":"addCreator","f":"hp_addCreator","d":"Just a wrapper of wb$addCreator()\n","ec":"addCreator(wb, Creator)"},{"p":"openxlsx","o":"getSheetNames","f":"hp_getSheetNames","d":"Returns the worksheet names within an xlsx file\n","ec":"getSheetNames(file)"},{"p":"openxlsx","o":"makeHyperlinkString","f":"hp_makeHyperlinkString","d":"Wrapper to create internal hyperlink string to pass to writeFormula(). Either link to external urls or local files or straight to cells of local Excel sheets.\n","ec":"makeHyperlinkString(sheet, row = 1, col = 1, text = NULL, file = NULL)"},{"p":"openxlsx","o":"getCreators","f":"hp_getCreators","d":"Just a wrapper of wb$getCreators()\nGet the names of the\n","ec":"getCreators(wb)"},{"p":"openxlsx","o":"conditionalFormat","f":"hp_conditionalFormat","d":"DEPRECATED! USE conditionalFormatting()\n","ec":"conditionalFormat(wb, sheet, cols, rows, rule = NULL, style = NULL, type = \"expression\")"},{"p":"openxlsx","o":"openXL","f":"hp_openXL","d":"This function tries to open a Microsoft Excel\n(xls/xlsx) file or an openxlsx Workbook with the proper\napplication, in a portable manner.\n","ec":"openXL(file = NULL)"},{"p":"openxlsx","o":"deleteDataColumn","f":"hp_deleteDataColumn","d":"Deletes the whole column from a workbook, shifting the remaining columns to the left\n","ec":"deleteDataColumn(wb, sheet, col)"},{"p":"openxlsx","o":"readWorkbook","f":"hp_readWorkbook","d":"Read data from an Excel file or Workbook object into a data.frame\n","ec":"readWorkbook(xlsxFile, sheet = 1, startRow = 1, colNames = TRUE, rowNames = FALSE, detectDates = FALSE, skipEmptyRows = TRUE, skipEmptyCols = TRUE, rows = NULL, cols = NULL, check.names = FALSE, sep.names = \".\", namedRegion = NULL, na.strings = \"NA\", fillMergedCells = FALSE)"},{"p":"openxlsx","o":"freezePane","f":"hp_freezePane","d":"Freeze a worksheet pane\n","ec":"freezePane(wb, sheet, firstActiveRow = NULL, firstActiveCol = NULL, firstRow = FALSE, firstCol = FALSE)"},{"p":"openxlsx","o":"dataValidation","f":"hp_dataValidation","d":"Add Excel data validation to cells\n","ec":"dataValidation(wb, sheet, cols, rows, type, operator, value, allowBlank = TRUE, showInputMsg = TRUE, showErrorMsg = TRUE)"},{"p":"openxlsx","o":"setFooter","f":"hp_setFooter","d":"DEPRECATED\n","ec":"setFooter(wb, text, position = \"center\")"},{"p":"openxlsx","o":"conditionalFormatting","f":"hp_conditionalFormatting","d":"Add conditional formatting to cells\n","ec":"conditionalFormatting(wb, sheet, cols, rows, rule = NULL, style = NULL, type = \"expression\", ...)"},{"p":"openxlsx","o":"getCellRefs","f":"hp_getCellRefs","d":"Return excel cell coordinates from (x,y) coordinates\n","ec":"getCellRefs(cellCoords)"},{"p":"openxlsx","o":"protectWorksheet","f":"hp_protectWorksheet","d":"Protect or unprotect a worksheet from modifications by the user in the graphical user interface. Replaces an existing protection.\n","ec":"protectWorksheet(wb, sheet, protect = TRUE, password = NULL, lockSelectingLockedCells = NULL, lockSelectingUnlockedCells = NULL, lockFormattingCells = NULL, lockFormattingColumns = NULL, lockFormattingRows = NULL, lockInsertingColumns = NULL, lockInsertingRows = NULL, lockInsertingHyperlinks = NULL, lockDeletingColumns = NULL, lockDeletingRows = NULL, lockSorting = NULL, lockAutoFilter = NULL, lockPivotTables = NULL, lockObjects = NULL, lockScenarios = NULL)"},{"p":"openxlsx","o":"setColWidths","f":"hp_setColWidths","d":"Set worksheet column widths to specific width or \"auto\".\n","ec":"setColWidths(wb, sheet, cols, widths = 8.43, hidden = rep(FALSE, length(cols)), ignoreMergedCells = FALSE)"},{"p":"openxlsx","o":"setRowHeights","f":"hp_setRowHeights","d":"Set worksheet row heights\n","ec":"setRowHeights(wb, sheet, rows, heights, fontsize = NULL, factor = 1, base_height = 15, extra_height = 12, wrap = TRUE)"},{"p":"openxlsx","o":"int2col","f":"hp_int2col","d":"Converts an integer to an Excel column label.\n","ec":"int2col(x)"},{"p":"openxlsx","o":"col2int","f":"hp_col2int","d":"Converts an Excel column label to an integer.\n","ec":"col2int(x)"},{"p":"openxlsx","o":"insertImage","f":"hp_insertImage","d":"Insert an image into a worksheet\n","ec":"insertImage(wb, sheet, file, width = 6, height = 3, startRow = 1, startCol = 1, units = \"in\", dpi = 300)"},{"p":"openxlsx","o":"convertToDate","f":"hp_convertToDate","d":"Convert from excel date number to R Date type\n","ec":"convertToDate(x, origin = \"1900-01-01\", ...)"},{"p":"openxlsx","o":"loadWorkbook","f":"hp_loadWorkbook","d":"loadWorkbook returns a workbook object conserving styles and\nformatting of the original .xlsx file.\n","ec":"loadWorkbook(file, xlsxFile = NULL, isUnzipped = FALSE, na.convert = TRUE)"},{"p":"openxlsx","o":"createWorkbook","f":"hp_createWorkbook","d":"Create a new Workbook object\n","ec":"createWorkbook(creator = ifelse(.Platform$OS.type == \"windows\", Sys.getenv(\"USERNAME\"), Sys.getenv(\"USER\")), title = NULL, subject = NULL, category = NULL)"},{"p":"openxlsx","o":"writeData","f":"hp_writeData","d":"Write an object to worksheet with optional styling.\n","ec":"writeData(wb, sheet, x, startCol = 1, startRow = 1, array = FALSE, xy = NULL, colNames = TRUE, rowNames = FALSE, headerStyle = openxlsx_getOp(\"headerStyle\"), borders = openxlsx_getOp(\"borders\", \"none\"), borderColour = openxlsx_getOp(\"borderColour\", \"black\"), borderStyle = openxlsx_getOp(\"borderStyle\", \"thin\"), withFilter = openxlsx_getOp(\"withFilter\", FALSE), keepNA = openxlsx_getOp(\"keepNA\", FALSE), na.string = openxlsx_getOp(\"na.string\"), name = NULL, sep = \", \", col.names, row.names)"},{"p":"openxlsx","o":"setHeaderFooter","f":"hp_setHeaderFooter","d":"Set document headers and footers\n","ec":"setHeaderFooter(wb, sheet, header = NULL, footer = NULL, evenHeader = NULL, evenFooter = NULL, firstHeader = NULL, firstFooter = NULL)"},{"p":"openxlsx","o":"protectWorkbook","f":"hp_protectWorkbook","d":"Protect or unprotect a workbook from modifications by the user in the graphical user interface. Replaces an existing protection.\n","ec":"protectWorkbook(wb, protect = TRUE, password = NULL, lockStructure = FALSE, lockWindows = FALSE, type = 1L)"},{"p":"openxlsx","o":"write.xlsx","f":"hp_write.xlsx","d":"write a data.frame or list of data.frames to an xlsx file\n","ec":"write.xlsx(x, file, asTable = FALSE, overwrite = TRUE, ...)"},{"p":"openxlsx","o":"op.openxlsx","f":"hp_op.openxlsx","d":"See and get the openxlsx options\n","ec":""},{"p":"openxlsx","o":"openxlsx_setOp","f":"hp_openxlsx_setOp","d":"See and get the openxlsx options\n","ec":"openxlsx_setOp(x, value)"},{"p":"openxlsx","o":"convertFromExcelRef","f":"hp_convertFromExcelRef","d":"Convert excel column name to integer index e.g. \"J\" to 10\n","ec":"convertFromExcelRef(col)"},{"p":"openxlsx","o":"getStyles","f":"hp_getStyles","d":"Returns list of style objects in the workbook\n","ec":"getStyles(wb)"},{"p":"openxlsx","o":"openxlsx_getOp","f":"hp_openxlsx_getOp","d":"See and get the openxlsx options\n","ec":"openxlsx_getOp(x, default = NULL)"},{"p":"openxlsx","o":"addWorksheet","f":"hp_addWorksheet","d":"Add a worksheet to a Workbook object\n","ec":"addWorksheet(wb, sheetName, gridLines = openxlsx_getOp(\"gridLines\", TRUE), tabColour = NULL, zoom = 100, header = openxlsx_getOp(\"header\"), footer = openxlsx_getOp(\"footer\"), evenHeader = openxlsx_getOp(\"evenHeader\"), evenFooter = openxlsx_getOp(\"evenFooter\"), firstHeader = openxlsx_getOp(\"firstHeader\"), firstFooter = openxlsx_getOp(\"firstFooter\"), visible = TRUE, paperSize = openxlsx_getOp(\"paperSize\", 9), orientation = openxlsx_getOp(\"orientation\", \"portrait\"), vdpi = openxlsx_getOp(\"vdpi\", 300), hdpi = openxlsx_getOp(\"hdpi\", 300))"},{"p":"openxlsx","o":"mergeCells","f":"hp_mergeCells","d":"Merge cells within a worksheet\n","ec":"mergeCells(wb, sheet, cols, rows)"},{"p":"openxlsx","o":"pageBreak","f":"hp_pageBreak","d":"insert page breaks into a worksheet\n","ec":"pageBreak(wb, sheet, i, type = \"row\")"},{"p":"openxlsx","o":"copyWorkbook","f":"hp_copyWorkbook","d":"Just a wrapper of wb$copy()\n","ec":"copyWorkbook(wb)"},{"p":"openxlsx","o":"ungroupRows","f":"hp_ungroupRows","d":"Ungroup a selection of rows\n","ec":"ungroupRows(wb, sheet, rows)"},{"p":"openxlsx","o":"removeRowHeights","f":"hp_removeRowHeights","d":"Remove row heights from a worksheet\n","ec":"removeRowHeights(wb, sheet, rows)"},{"p":"openxlsx","o":"cloneWorksheet","f":"hp_cloneWorksheet","d":"Clone a worksheet to a Workbook object\n","ec":"cloneWorksheet(wb, sheetName, clonedSheet)"},{"p":"openxlsx","o":"deleteData","f":"hp_deleteData","d":"Delete contents and styling from a cell.\n","ec":"deleteData(wb, sheet, cols, rows, gridExpand = FALSE)"},{"p":"openxlsx","o":"sheetVisibility","f":"hp_sheetVisibility","d":"Get and set worksheet visible state\n","ec":"sheetVisibility(wb)"},{"p":"openxlsx","o":"replaceStyle","f":"hp_replaceStyle","d":"Replace an existing cell style\n","ec":"replaceStyle(wb, index, newStyle)"},{"p":"pillar","o":"squeeze","f":"hp_squeeze","d":"\n","ec":"squeeze(x, width = NULL, ...)"},{"p":"pillar","o":"expect_known_display","f":"hp_expect_known_display","d":"\n","ec":"expect_known_display(object, file, ..., width = 80L, crayon = TRUE)"},{"p":"pillar","o":"tbl_format_body","f":"hp_tbl_format_body","d":"\n","ec":"tbl_format_body(x, setup, ...)"},{"p":"pillar","o":"set_char_opts","f":"hp_set_char_opts","d":"These functions are reexported as tibble::char() and tibble::set_char_opts().\n","ec":"set_char_opts(x, ..., min_chars = NULL, shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"))"},{"p":"pillar","o":"pillar_shaft","f":"hp_pillar_shaft","d":"Internal class for formatting the data for a column.\npillar_shaft() is a coercion method that must be implemented\nfor your data type to display it in a tibble.\n","ec":"pillar_shaft(x, ...)"},{"p":"pillar","o":"ctl_new_rowid_pillar","f":"hp_ctl_new_rowid_pillar","d":"\n","ec":"ctl_new_rowid_pillar(controller, x, width, ..., title = NULL, type = NULL)"},{"p":"pillar","o":"char","f":"hp_char","d":"These functions are reexported as tibble::char() and tibble::set_char_opts().\n","ec":"char(x, ..., min_chars = NULL, shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"))"},{"p":"pillar","o":"glimpse","f":"hp_glimpse","d":"glimpse() is like a transposed version of print():\ncolumns run down the page, and data runs across.\nThis makes it possible to see every column in a data frame.\nIt's a little like str() applied to a data frame\nbut it tries to show you as much data as possible.\n(And it always shows the underlying data, even when applied\nto a remote data source.)\n","ec":"glimpse(x, width = NULL, ...)"},{"p":"pillar","o":"scale_x_num","f":"hp_scale_x_num","d":"\n","ec":"scale_x_num(..., position = \"bottom\", guide = ggplot2::waiver(), rescaler = NULL, super = NULL)"},{"p":"pillar","o":"extra_cols","f":"hp_extra_cols","d":"\n","ec":"extra_cols(x, ...)"},{"p":"pillar","o":"new_pillar_title","f":"hp_new_pillar_title","d":"Call format() on the result to render column titles.\n","ec":"new_pillar_title(x, ...)"},{"p":"pillar","o":"is_vector_s3","f":"hp_is_vector_s3","d":"\n","ec":"is_vector_s3(x)"},{"p":"pillar","o":"obj_sum","f":"hp_obj_sum","d":"type_sum() gives a brief summary of object type. Objects that commonly\noccur in a data frame should return a string with four or less characters.\nFor most inputs, the argument is forwarded to vctrs::vec_ptype_abbr().\n","ec":"obj_sum(x)"},{"p":"pillar","o":"tbl_format_header","f":"hp_tbl_format_header","d":"\n","ec":"tbl_format_header(x, setup, ...)"},{"p":"pillar","o":"style_bold","f":"hp_style_bold","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_bold(x)"},{"p":"pillar","o":"style_subtle_num","f":"hp_style_subtle_num","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_subtle_num(x, negative)"},{"p":"pillar","o":"colonnade","f":"hp_colonnade","d":"\n","ec":"colonnade(x, has_row_id = TRUE, width = NULL, ...)"},{"p":"pillar","o":"new_pillar_component","f":"hp_new_pillar_component","d":"\n","ec":"new_pillar_component(x, ..., width, min_width = NULL)"},{"p":"pillar","o":"size_sum","f":"hp_size_sum","d":"type_sum() gives a brief summary of object type. Objects that commonly\noccur in a data frame should return a string with four or less characters.\nFor most inputs, the argument is forwarded to vctrs::vec_ptype_abbr().\n","ec":"size_sum(x)"},{"p":"pillar","o":"tbl_format_footer","f":"hp_tbl_format_footer","d":"\n","ec":"tbl_format_footer(x, setup, ...)"},{"p":"pillar","o":"ctl_new_pillar","f":"hp_ctl_new_pillar","d":"\n","ec":"ctl_new_pillar(controller, x, width, ..., title = NULL)"},{"p":"pillar","o":"tbl_sum","f":"hp_tbl_sum","d":"tbl_sum() gives a brief textual description of a table-like object,\nwhich should include the dimensions and the data source in the first element,\nand additional information in the other elements (such as grouping for dplyr).\nThe default implementation forwards to obj_sum().\n","ec":"tbl_sum(x)"},{"p":"pillar","o":"scale_y_num","f":"hp_scale_y_num","d":"\n","ec":"scale_y_num(..., guide = ggplot2::waiver(), rescaler = NULL, super = NULL)"},{"p":"pillar","o":"new_pillar_shaft","f":"hp_new_pillar_shaft","d":"The new_pillar_shaft() constructor creates objects of the \"pillar_shaft\"\nclass.\nThis is a virtual or abstract class, you must specify the class\nargument.\nBy convention, this should be a string that starts with \"pillar_shaft_\".\nSee vignette(\"extending\", package = \"tibble\") for usage examples.\n","ec":"new_pillar_shaft(x, ..., width = NULL, min_width = width, type_sum = NULL, class = NULL, subclass = NULL)"},{"p":"pillar","o":"new_pillar_type","f":"hp_new_pillar_type","d":"Calls type_sum() to format the type.\nCall format() on the result to render column types.\n","ec":"new_pillar_type(x, ...)"},{"p":"pillar","o":"ctl_new_pillar_list","f":"hp_ctl_new_pillar_list","d":"\n","ec":"ctl_new_pillar_list(controller, x, width, ..., title = NULL, first_pillar = NULL)"},{"p":"pillar","o":"align","f":"hp_align","d":"Facilitates easy alignment of strings within a character vector. Designed to\nhelp implementers of formatters for custom data types.\n","ec":"align(x, width = NULL, align = c(\"left\", \"right\"), space = \" \")"},{"p":"pillar","o":"set_num_opts","f":"hp_set_num_opts","d":"These functions are reexported as tibble::num() and tibble::set_num_opts().\n","ec":"set_num_opts(x, ..., sigfig = NULL, digits = NULL, label = NULL, scale = NULL, notation = c(\"fit\", \"dec\", \"sci\", \"eng\", \"si\"), fixed_exponent = NULL, extra_sigfig = NULL)"},{"p":"pillar","o":"get_max_extent","f":"hp_get_max_extent","d":"get_extent() calculates the display width for each string in a character\nvector.\n","ec":"get_max_extent(x)"},{"p":"pillar","o":"new_pillar","f":"hp_new_pillar","d":"\n","ec":"new_pillar(components, ..., width = NULL, class = NULL, extra = deprecated())"},{"p":"pillar","o":"tbl_format_setup","f":"hp_tbl_format_setup","d":"tbl_format_setup() is called by format.tbl().\nThis method collects information that is common to the header, body,\nand footer parts of a tibble.\nExamples:\n","ec":"tbl_format_setup(x, width = NULL, ..., n = NULL, max_extra_cols = NULL, max_footer_lines = NULL, focus = NULL)"},{"p":"pillar","o":"type_sum","f":"hp_type_sum","d":"type_sum() gives a brief summary of object type. Objects that commonly\noccur in a data frame should return a string with four or less characters.\nFor most inputs, the argument is forwarded to vctrs::vec_ptype_abbr().\n","ec":"type_sum(x)"},{"p":"pillar","o":"format_type_sum","f":"hp_format_type_sum","d":"Called on values returned from type_sum() for defining the description\nin the capital.\n","ec":"format_type_sum(x, width, ...)"},{"p":"pillar","o":"pillar","f":"hp_pillar","d":"pillar() creates an object that formats a vector.\nThe output uses one row for a title (if given), one row for the type,\nand vec_size(x) rows for the data.\n","ec":"pillar(x, title = NULL, width = NULL, ...)"},{"p":"pillar","o":"style_subtle","f":"hp_style_subtle","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_subtle(x)"},{"p":"pillar","o":"format_glimpse","f":"hp_format_glimpse","d":"\n","ec":"format_glimpse(x, ...)"},{"p":"pillar","o":"dim_desc","f":"hp_dim_desc","d":"Multi-dimensional objects are formatted as <U+2060>a x b x ...<U+2060>, for vectors the\nlength is returned.\n","ec":"dim_desc(x)"},{"p":"pillar","o":"style_na","f":"hp_style_na","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_na(x)"},{"p":"pillar","o":"get_extent","f":"hp_get_extent","d":"get_extent() calculates the display width for each string in a character\nvector.\n","ec":"get_extent(x)"},{"p":"pillar","o":"new_pillar_shaft_simple","f":"hp_new_pillar_shaft_simple","d":"The new_pillar_shaft() constructor creates objects of the \"pillar_shaft\"\nclass.\nThis is a virtual or abstract class, you must specify the class\nargument.\nBy convention, this should be a string that starts with \"pillar_shaft_\".\nSee vignette(\"extending\", package = \"tibble\") for usage examples.\n","ec":"new_pillar_shaft_simple(formatted, ..., width = NULL, align = \"left\", min_width = NULL, na = NULL, na_indent = 0L, shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"), short_formatted = NULL)"},{"p":"pillar","o":"style_neg","f":"hp_style_neg","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_neg(x)"},{"p":"pillar","o":"new_ornament","f":"hp_new_ornament","d":"This function is useful if your data renders differently depending on the\navailable width. In this case, implement the pillar_shaft() method for your\nclass to return a subclass of \"pillar_shaft\" and have the format() method\nfor this subclass call new_ornament(). See the implementation of\npillar_shaft.numeric() and format.pillar_shaft_decimal() for an example.\n","ec":"new_ornament(x, width = NULL, align = NULL)"},{"p":"pillar","o":"num","f":"hp_num","d":"These functions are reexported as tibble::num() and tibble::set_num_opts().\n","ec":"num(x, ..., sigfig = NULL, digits = NULL, label = NULL, scale = NULL, notation = c(\"fit\", \"dec\", \"sci\", \"eng\", \"si\"), fixed_exponent = NULL, extra_sigfig = NULL)"},{"p":"pillar","o":"pillar_component","f":"hp_pillar_component","d":"\n","ec":"pillar_component(x)"},{"p":"pillar","o":"style_num","f":"hp_style_num","d":"Functions that allow implementers of formatters for custom data types to\nmaintain a consistent style with the default data types.\n","ec":"style_num(x, negative, significant = rep_along(x, TRUE))"},{"p":"prettyunits","o":"pretty_ms","f":"hp_pretty_ms","d":"Pretty formatting of milliseconds\n","ec":"pretty_ms(ms, compact = FALSE)"},{"p":"prettyunits","o":"pretty_signif","f":"hp_pretty_signif","d":"Round a value to a defined number of significant digits printing out trailing\nzeros, if applicable\n","ec":"pretty_signif(x, digits = 6, sci_range = 6, sci_sep = \"e\")"},{"p":"prettyunits","o":"pretty_colour","f":"hp_pretty_colour","d":"Color definition (like RGB) to a name\n","ec":"pretty_colour(color)"},{"p":"prettyunits","o":"pretty_color","f":"hp_pretty_color","d":"Color definition (like RGB) to a name\n","ec":"pretty_color(color)"},{"p":"prettyunits","o":"pretty_round","f":"hp_pretty_round","d":"Round a value to a defined number of digits printing out trailing zeros, if\napplicable\n","ec":"pretty_round(x, digits = 0, sci_range = Inf, sci_sep = \"e\")"},{"p":"prettyunits","o":"pretty_dt","f":"hp_pretty_dt","d":"Pretty formatting of time intervals (difftime objects)\n","ec":"pretty_dt(dt, compact = FALSE)"},{"p":"prettyunits","o":"compute_num","f":"hp_compute_num","d":"Use pretty_num() to format numbers compute_num() is the underlying\nengine that may be useful for custom formatting.\n","ec":"compute_num(number, smallest_prefix = \"y\")"},{"p":"prettyunits","o":"vague_dt","f":"hp_vague_dt","d":"Human readable format of a time interval\n","ec":"vague_dt(dt, format = c(\"default\", \"short\", \"terse\"))"},{"p":"prettyunits","o":"pretty_num","f":"hp_pretty_num","d":"Use pretty_num() to format numbers compute_num() is the underlying\nengine that may be useful for custom formatting.\n","ec":"pretty_num(number, style = c(\"default\", \"nopad\", \"6\"))"},{"p":"prettyunits","o":"time_ago","f":"hp_time_ago","d":"It calls vague_dt to do the actual formatting.\n","ec":"time_ago(date, format = c(\"default\", \"short\", \"terse\"))"},{"p":"prettyunits","o":"pretty_p_value","f":"hp_pretty_p_value","d":"p-values in a human-readable string\n","ec":"pretty_p_value(x, minval = 1e-04)"},{"p":"prettyunits","o":"pretty_bytes","f":"hp_pretty_bytes","d":"Use pretty_bytes() to format bytes. compute_bytes() is the underlying\nengine that may be useful for custom formatting.\n","ec":"pretty_bytes(bytes, style = c(\"default\", \"nopad\", \"6\"))"},{"p":"prettyunits","o":"compute_bytes","f":"hp_compute_bytes","d":"Use pretty_bytes() to format bytes. compute_bytes() is the underlying\nengine that may be useful for custom formatting.\n","ec":"compute_bytes(bytes, smallest_unit = \"B\")"},{"p":"prettyunits","o":"pretty_sec","f":"hp_pretty_sec","d":"Pretty formatting of seconds\n","ec":"pretty_sec(sec, compact = FALSE)"},{"p":"purrr","o":"map2_dfc","f":"hp_map2_dfc","d":"\n","ec":"map2_dfc(.x, .y, .f, ...)"},{"p":"purrr","o":"invoke_map_lgl","f":"hp_invoke_map_lgl","d":"\n","ec":"invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"list_rbind","f":"hp_list_rbind","ec":"list_rbind(x, ..., names_to = rlang::zap(), ptype = NULL)"},{"p":"purrr","o":"discard","f":"hp_discard","d":"keep() selects all elements where .p evaluates to TRUE;\ndiscard() selects all elements where .p evaluates to FALSE.\ncompact() discards elements where .p evaluates to an empty vector.\n","ec":"discard(.x, .p, ...)"},{"p":"purrr","o":"rbernoulli","f":"hp_rbernoulli","d":"\n","ec":"rbernoulli(n, p = 0.5)"},{"p":"purrr","o":"pmap","f":"hp_pmap","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"prepend","f":"hp_prepend","d":"\n","ec":"prepend(x, values, before = NULL)"},{"p":"purrr","o":"map2_df","f":"hp_map2_df","d":"\n","ec":"map2_df(.x, .y, .f, ..., .id = NULL)"},{"p":"purrr","o":"invoke_map_df","f":"hp_invoke_map_df","d":"\n","ec":"invoke_map_df(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"list_cbind","f":"hp_list_cbind","ec":"list_cbind(x, ..., name_repair = c(\"unique\", \"universal\", \"check_unique\"), size = NULL)"},{"p":"purrr","o":"pmap_lgl","f":"hp_pmap_lgl","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap_lgl(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map_dbl","f":"hp_map_dbl","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map_dbl(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"walk2","f":"hp_walk2","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"walk2(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"pluck_exists","f":"hp_pluck_exists","d":"pluck() implements a generalised form of [[ that allow you to index\ndeeply and flexibly into data structures. It always succeeds, returning\n.default if the index you are trying to access does not exist or is NULL.\n","ec":"pluck_exists(.x, ...)"},{"p":"purrr","o":"flatten_dbl","f":"hp_flatten_dbl","d":"\n","ec":"flatten_dbl(.x)"},{"p":"purrr","o":"walk","f":"hp_walk","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"walk(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"rdunif","f":"hp_rdunif","d":"\n","ec":"rdunif(n, b, a = 1)"},{"p":"purrr","o":"flatten_df","f":"hp_flatten_df","d":"\n","ec":"flatten_df(.x, .id = NULL)"},{"p":"purrr","o":"discard_at","f":"hp_discard_at","d":"Keep/discard elements based on their name/position\n","ec":"discard_at(x, at)"},{"p":"purrr","o":"array_tree","f":"hp_array_tree","d":"array_branch() and array_tree() enable arrays to be\nused with purrr's functionals by turning them into lists. The\ndetails of the coercion are controlled by the margin\nargument. array_tree() creates an hierarchical list (a tree)\nthat has as many levels as dimensions specified in margin,\nwhile array_branch() creates a flat list (by analogy, a\nbranch) along all mentioned dimensions.\n","ec":"array_tree(array, margin = NULL)"},{"p":"purrr","o":"detect_index","f":"hp_detect_index","d":"Find the value or position of the first match\n","ec":"detect_index(.x, .f, ..., .dir = c(\"forward\", \"backward\"), .right = NULL)"},{"p":"purrr","o":"lift_lv","f":"hp_lift_lv","d":"\n","ec":"lift_lv(..f, ...)"},{"p":"purrr","o":"invoke_map_dbl","f":"hp_invoke_map_dbl","d":"\n","ec":"invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"pmap_int","f":"hp_pmap_int","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap_int(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"splice","f":"hp_splice","d":"\n","ec":"splice(...)"},{"p":"purrr","o":"imodify","f":"hp_imodify","d":"Unlike map() and its variants which always return a fixed object\ntype (list for map(), integer vector for map_int(), etc), the\nmodify() family always returns the same type as the input object.\n","ec":"imodify(.x, .f, ...)"},{"p":"purrr","o":"imap_dbl","f":"hp_imap_dbl","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"imap_dbl(.x, .f, ...)"},{"p":"purrr","o":"list_assign","f":"hp_list_assign","d":"list_modify() is inspired by utils::modifyList().\n","ec":"list_assign(.x, ..., .is_node = NULL)"},{"p":"purrr","o":"lmap_at","f":"hp_lmap_at","d":"lmap(), lmap_at() and lmap_if() are similar to map(), map_at() and\nmap_if(), except instead of mapping over .x[[i]], they instead map over\n.x[i].\n","ec":"lmap_at(.x, .at, .f, ...)"},{"p":"purrr","o":"transpose","f":"hp_transpose","d":"\n","ec":"transpose(.l, .names = NULL)"},{"p":"purrr","o":"reduce2_right","f":"hp_reduce2_right","d":"\n","ec":"reduce2_right(.x, .y, .f, ..., .init)"},{"p":"purrr","o":"as_mapper","f":"hp_as_mapper","d":"as_mapper is the powerhouse behind the varied function\nspecifications that most purrr functions allow. It is an S3\ngeneric. The default method forwards its arguments to\nrlang::as_function().\n","ec":"as_mapper(.f, ...)"},{"p":"purrr","o":"reduce","f":"hp_reduce","d":"reduce() is an operation that combines the elements of a vector\ninto a single value. The combination is driven by .f, a binary\nfunction that takes two values and returns a single value: reducing\nf over 1:3 computes the value f(f(1, 2), 3).\n","ec":"reduce(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"))"},{"p":"purrr","o":"invoke_map","f":"hp_invoke_map","d":"\n","ec":"invoke_map(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"pmap_df","f":"hp_pmap_df","d":"\n","ec":"pmap_df(.l, .f, ..., .id = NULL)"},{"p":"purrr","o":"lift_ld","f":"hp_lift_ld","d":"\n","ec":"lift_ld(..f, ...)"},{"p":"purrr","o":"map2_raw","f":"hp_map2_raw","d":"\n","ec":"map2_raw(.x, .y, .f, ...)"},{"p":"purrr","o":"tail_while","f":"hp_tail_while","d":"Find head/tail that all satisfies a predicate.\n","ec":"tail_while(.x, .p, ...)"},{"p":"purrr","o":"at_depth","f":"hp_at_depth","d":"This function is defunct and has been replaced by map_depth().\nSee also modify_depth() for a version that preserves the types of\nthe elements of the tree.\n","ec":"at_depth(.x, .depth, .f, ...)"},{"p":"purrr","o":"lmap","f":"hp_lmap","d":"lmap(), lmap_at() and lmap_if() are similar to map(), map_at() and\nmap_if(), except instead of mapping over .x[[i]], they instead map over\n.x[i].\n","ec":"lmap(.x, .f, ...)"},{"p":"purrr","o":"modify_if","f":"hp_modify_if","d":"Unlike map() and its variants which always return a fixed object\ntype (list for map(), integer vector for map_int(), etc), the\nmodify() family always returns the same type as the input object.\n","ec":"modify_if(.x, .p, .f, ..., .else = NULL)"},{"p":"purrr","o":"has_element","f":"hp_has_element","d":"Does a list contain an object?\n","ec":"has_element(.x, .y)"},{"p":"purrr","o":"map2_chr","f":"hp_map2_chr","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2_chr(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map_int","f":"hp_map_int","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map_int(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"accumulate_right","f":"hp_accumulate_right","d":"\n","ec":"accumulate_right(.x, .f, ..., .init)"},{"p":"purrr","o":"pmap_dfr","f":"hp_pmap_dfr","d":"\n","ec":"pmap_dfr(.l, .f, ..., .id = NULL)"},{"p":"purrr","o":"vec_depth","f":"hp_vec_depth","d":"The depth of a vector is how many levels that you can index/pluck into it.\npluck_depth() was previously called vec_depth().\n","ec":"vec_depth(x)"},{"p":"purrr","o":"map_lgl","f":"hp_map_lgl","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map_lgl(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"simplify","f":"hp_simplify","d":"\n","ec":"simplify(.x, .type = NULL)"},{"p":"purrr","o":"map_raw","f":"hp_map_raw","d":"\n","ec":"map_raw(.x, .f, ...)"},{"p":"purrr","o":"modify_in","f":"hp_modify_in","d":"pluck()\n","ec":"modify_in(.x, .where, .f, ...)"},{"p":"purrr","o":"safely","f":"hp_safely","d":"Creates a modified version of .f that always succeeds. It returns a list\nwith components result and error. If the function succeeds, result\ncontains the returned value and error is NULL. If an error occurred,\nerror is an error object and result is either NULL or otherwise.\n","ec":"safely(.f, otherwise = NULL, quiet = TRUE)"},{"p":"purrr","o":"flatten_dfr","f":"hp_flatten_dfr","d":"\n","ec":"flatten_dfr(.x, .id = NULL)"},{"p":"purrr","o":"insistently","f":"hp_insistently","d":"insistently() takes a function and modifies it to retry after given\namount of time whenever it errors.\n","ec":"insistently(f, rate = rate_backoff(), quiet = TRUE)"},{"p":"purrr","o":"lift_dv","f":"hp_lift_dv","d":"\n","ec":"lift_dv(..f, ..., .unnamed = FALSE)"},{"p":"purrr","o":"map_depth","f":"hp_map_depth","d":"map_depth() calls map(.y, .f) on all .y at the specified .depth in\n.x. modify_depth() calls modify(.y, .f) on .y at the specified\n.depth in .x.\n","ec":"map_depth(.x, .depth, .f, ..., .ragged = .depth < 0, .is_node = NULL)"},{"p":"purrr","o":"every","f":"hp_every","d":"A logical vector of length 1.\n","ec":"every(.x, .p, ...)"},{"p":"purrr","o":"invoke_map_chr","f":"hp_invoke_map_chr","d":"\n","ec":"invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"map_vec","f":"hp_map_vec","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map_vec(.x, .f, ..., .ptype = NULL, .progress = FALSE)"},{"p":"purrr","o":"pwalk","f":"hp_pwalk","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pwalk(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"imap_lgl","f":"hp_imap_lgl","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"imap_lgl(.x, .f, ...)"},{"p":"purrr","o":"imap_chr","f":"hp_imap_chr","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"imap_chr(.x, .f, ...)"},{"p":"purrr","o":"rate_sleep","f":"hp_rate_sleep","d":"If the rate's internal counter exceeds the maximum number of times\nit is allowed to sleep, rate_sleep() throws an error of class\npurrr_error_rate_excess.\n","ec":"rate_sleep(rate, quiet = TRUE)"},{"p":"purrr","o":"quietly","f":"hp_quietly","d":"Create a modified version of .f that captures side-effects along with\nthe return value of the function and returns a list containing\nthe result, output, messages and warnings.\n","ec":"quietly(.f)"},{"p":"purrr","o":"detect","f":"hp_detect","d":"Find the value or position of the first match\n","ec":"detect(.x, .f, ..., .dir = c(\"forward\", \"backward\"), .right = NULL, .default = NULL)"},{"p":"purrr","o":"flatten","f":"hp_flatten","d":"\n","ec":"flatten(.x)"},{"p":"purrr","o":"pmap_dfc","f":"hp_pmap_dfc","d":"\n","ec":"pmap_dfc(.l, .f, ...)"},{"p":"purrr","o":"%@%","f":"hp_X...","d":"\n","ec":"%@%(x, name)"},{"p":"purrr","o":"pluck","f":"hp_pluck","d":"pluck() implements a generalised form of [[ that allow you to index\ndeeply and flexibly into data structures. It always succeeds, returning\n.default if the index you are trying to access does not exist or is NULL.\n","ec":"pluck(.x, ..., .default = NULL)"},{"p":"purrr","o":"map_if","f":"hp_map_if","d":"The functions map_if() and map_at() take .x as input, apply\nthe function .f to some of the elements of .x, and return a\nlist of the same length as the input.\n","ec":"map_if(.x, .p, .f, ..., .else = NULL)"},{"p":"purrr","o":"lift","f":"hp_lift","d":"\n","ec":"lift(..f, ..., .unnamed = FALSE)"},{"p":"purrr","o":"cross","f":"hp_cross","d":"\n","ec":"cross(.l, .filter = NULL)"},{"p":"purrr","o":"flatten_dfc","f":"hp_flatten_dfc","d":"\n","ec":"flatten_dfc(.x)"},{"p":"purrr","o":"pmap_raw","f":"hp_pmap_raw","d":"\n","ec":"pmap_raw(.l, .f, ...)"},{"p":"purrr","o":"imap_int","f":"hp_imap_int","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"imap_int(.x, .f, ...)"},{"p":"purrr","o":"cross2","f":"hp_cross2","d":"\n","ec":"cross2(.x, .y, .filter = NULL)"},{"p":"purrr","o":"list_transpose","f":"hp_list_transpose","d":"list_transpose() turns a list-of-lists \"inside-out\". For instance it turns a pair of\nlists into a list of pairs, or a list of pairs into a pair of lists. For\nexample, if you had a list of length n where each component had values a\nand b, list_transpose() would make a list with elements a and\nb that contained lists of length n.\n","ec":"list_transpose(x, ..., template = NULL, simplify = NA, ptype = NULL, default = NULL)"},{"p":"purrr","o":"cross3","f":"hp_cross3","d":"\n","ec":"cross3(.x, .y, .z, .filter = NULL)"},{"p":"purrr","o":"rerun","f":"hp_rerun","d":"\n","ec":"rerun(.n, ...)"},{"p":"purrr","o":"lift_dl","f":"hp_lift_dl","d":"\n","ec":"lift_dl(..f, ..., .unnamed = FALSE)"},{"p":"purrr","o":"lmap_if","f":"hp_lmap_if","d":"lmap(), lmap_at() and lmap_if() are similar to map(), map_at() and\nmap_if(), except instead of mapping over .x[[i]], they instead map over\n.x[i].\n","ec":"lmap_if(.x, .p, .f, ..., .else = NULL)"},{"p":"purrr","o":"list_along","f":"hp_list_along","d":"\n","ec":"list_along(x)"},{"p":"purrr","o":"cross_df","f":"hp_cross_df","d":"\n","ec":"cross_df(.l, .filter = NULL)"},{"p":"purrr","o":"imap_dfc","f":"hp_imap_dfc","d":"\n","ec":"imap_dfc(.x, .f, ...)"},{"p":"purrr","o":"update_list","f":"hp_update_list","d":"\n","ec":"update_list(.x, ...)"},{"p":"purrr","o":"keep","f":"hp_keep","d":"keep() selects all elements where .p evaluates to TRUE;\ndiscard() selects all elements where .p evaluates to FALSE.\ncompact() discards elements where .p evaluates to an empty vector.\n","ec":"keep(.x, .p, ...)"},{"p":"purrr","o":"rate_delay","f":"hp_rate_delay","d":"These helpers create rate settings that you can pass to insistently() and\nslowly(). You can also use them in your own functions with rate_sleep().\n","ec":"rate_delay(pause = 1, max_times = Inf)"},{"p":"purrr","o":"cross_d","f":"hp_cross_d","d":"\n","ec":"cross_d(...)"},{"p":"purrr","o":"map_dfr","f":"hp_map_dfr","d":"\n","ec":"map_dfr(.x, .f, ..., .id = NULL)"},{"p":"purrr","o":"list_simplify","f":"hp_list_simplify","d":"Simplification maintains a one-to-one correspondence between the input\nand output, implying that each element of x must contain a one element\nvector or a one-row data frame. If you don't want to maintain this\ncorrespondence, then you probably want either list_c()/list_rbind() or\nlist_flatten().\n","ec":"list_simplify(x, ..., strict = TRUE, ptype = NULL)"},{"p":"purrr","o":"slowly","f":"hp_slowly","d":"slowly() takes a function and modifies it to wait a given\namount of time between each call.\n","ec":"slowly(f, rate = rate_delay(), quiet = TRUE)"},{"p":"purrr","o":"flatten_chr","f":"hp_flatten_chr","d":"\n","ec":"flatten_chr(.x)"},{"p":"purrr","o":"when","f":"hp_when","d":"\n","ec":"when(., ...)"},{"p":"purrr","o":"map2_vec","f":"hp_map2_vec","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2_vec(.x, .y, .f, ..., .ptype = NULL, .progress = FALSE)"},{"p":"purrr","o":"none","f":"hp_none","d":"A logical vector of length 1.\n","ec":"none(.x, .p, ...)"},{"p":"purrr","o":"flatten_lgl","f":"hp_flatten_lgl","d":"\n","ec":"flatten_lgl(.x)"},{"p":"purrr","o":"head_while","f":"hp_head_while","d":"Find head/tail that all satisfies a predicate.\n","ec":"head_while(.x, .p, ...)"},{"p":"purrr","o":"modify_at","f":"hp_modify_at","d":"Unlike map() and its variants which always return a fixed object\ntype (list for map(), integer vector for map_int(), etc), the\nmodify() family always returns the same type as the input object.\n","ec":"modify_at(.x, .at, .f, ...)"},{"p":"purrr","o":"pluck_depth","f":"hp_pluck_depth","d":"The depth of a vector is how many levels that you can index/pluck into it.\npluck_depth() was previously called vec_depth().\n","ec":"pluck_depth(x, is_node = NULL)"},{"p":"purrr","o":"flatten_raw","f":"hp_flatten_raw","d":"\n","ec":"flatten_raw(.x)"},{"p":"purrr","o":"cross_n","f":"hp_cross_n","d":"\n","ec":"cross_n(...)"},{"p":"purrr","o":"rate_reset","f":"hp_rate_reset","d":"If the rate's internal counter exceeds the maximum number of times\nit is allowed to sleep, rate_sleep() throws an error of class\npurrr_error_rate_excess.\n","ec":"rate_reset(rate)"},{"p":"purrr","o":"imap_dfr","f":"hp_imap_dfr","d":"\n","ec":"imap_dfr(.x, .f, ..., .id = NULL)"},{"p":"purrr","o":"reduce2","f":"hp_reduce2","d":"reduce() is an operation that combines the elements of a vector\ninto a single value. The combination is driven by .f, a binary\nfunction that takes two values and returns a single value: reducing\nf over 1:3 computes the value f(f(1, 2), 3).\n","ec":"reduce2(.x, .y, .f, ..., .init)"},{"p":"purrr","o":"auto_browse","f":"hp_auto_browse","d":"A function wrapped with auto_browse() will automatically enter an\ninteractive debugger using browser() when ever it encounters an error.\n","ec":"auto_browse(.f)"},{"p":"purrr","o":"attr_getter","f":"hp_attr_getter","d":"attr_getter() generates an attribute accessor function; i.e., it\ngenerates a function for extracting an attribute with a given\nname. Unlike the base R attr() function with default options, it\ndoesn't use partial matching.\n","ec":"attr_getter(attr)"},{"p":"purrr","o":"invoke_map_raw","f":"hp_invoke_map_raw","d":"\n","ec":"invoke_map_raw(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"modify","f":"hp_modify","d":"Unlike map() and its variants which always return a fixed object\ntype (list for map(), integer vector for map_int(), etc), the\nmodify() family always returns the same type as the input object.\n","ec":"modify(.x, .f, ...)"},{"p":"purrr","o":"map_dfc","f":"hp_map_dfc","d":"\n","ec":"map_dfc(.x, .f, ...)"},{"p":"purrr","o":"map","f":"hp_map","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map2_dbl","f":"hp_map2_dbl","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2_dbl(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"modify2","f":"hp_modify2","d":"Unlike map() and its variants which always return a fixed object\ntype (list for map(), integer vector for map_int(), etc), the\nmodify() family always returns the same type as the input object.\n","ec":"modify2(.x, .y, .f, ...)"},{"p":"purrr","o":"array_branch","f":"hp_array_branch","d":"array_branch() and array_tree() enable arrays to be\nused with purrr's functionals by turning them into lists. The\ndetails of the coercion are controlled by the margin\nargument. array_tree() creates an hierarchical list (a tree)\nthat has as many levels as dimensions specified in margin,\nwhile array_branch() creates a flat list (by analogy, a\nbranch) along all mentioned dimensions.\n","ec":"array_branch(array, margin = NULL)"},{"p":"purrr","o":"some","f":"hp_some","d":"A logical vector of length 1.\n","ec":"some(.x, .p, ...)"},{"p":"purrr","o":"rate_backoff","f":"hp_rate_backoff","d":"These helpers create rate settings that you can pass to insistently() and\nslowly(). You can also use them in your own functions with rate_sleep().\n","ec":"rate_backoff(pause_base = 1, pause_cap = 60, pause_min = 1, max_times = 3, jitter = TRUE)"},{"p":"purrr","o":"map2_lgl","f":"hp_map2_lgl","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2_lgl(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"pluck<-","f":"hp_pluck..","d":"pluck() implements a generalised form of [[ that allow you to index\ndeeply and flexibly into data structures. It always succeeds, returning\n.default if the index you are trying to access does not exist or is NULL.\n","ec":"pluck<-(.x, ..., value)"},{"p":"purrr","o":"list_c","f":"hp_list_c","ec":"list_c(x, ..., ptype = NULL)"},{"p":"purrr","o":"simplify_all","f":"hp_simplify_all","d":"\n","ec":"simplify_all(.x, .type = NULL)"},{"p":"purrr","o":"flatten_int","f":"hp_flatten_int","d":"\n","ec":"flatten_int(.x)"},{"p":"purrr","o":"compact","f":"hp_compact","d":"keep() selects all elements where .p evaluates to TRUE;\ndiscard() selects all elements where .p evaluates to FALSE.\ncompact() discards elements where .p evaluates to an empty vector.\n","ec":"compact(.x, .p = identity)"},{"p":"purrr","o":"pmap_chr","f":"hp_pmap_chr","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap_chr(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"invoke_map_dfc","f":"hp_invoke_map_dfc","d":"\n","ec":"invoke_map_dfc(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"map_at","f":"hp_map_at","d":"The functions map_if() and map_at() take .x as input, apply\nthe function .f to some of the elements of .x, and return a\nlist of the same length as the input.\n","ec":"map_at(.x, .at, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map2","f":"hp_map2","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map_chr","f":"hp_map_chr","d":"The map functions transform their input by applying a function to\neach element of a list or atomic vector and returning an object of\nthe same length as the input.\n","ec":"map_chr(.x, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"map2_int","f":"hp_map2_int","d":"These functions are variants of map() that iterate over two arguments at\na time.\n","ec":"map2_int(.x, .y, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"imap_raw","f":"hp_imap_raw","d":"\n","ec":"imap_raw(.x, .f, ...)"},{"p":"purrr","o":"list_merge","f":"hp_list_merge","d":"list_modify() is inspired by utils::modifyList().\n","ec":"list_merge(.x, ..., .is_node = NULL)"},{"p":"purrr","o":"pmap_vec","f":"hp_pmap_vec","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap_vec(.l, .f, ..., .ptype = NULL, .progress = FALSE)"},{"p":"purrr","o":"as_vector","f":"hp_as_vector","d":"\n","ec":"as_vector(.x, .type = NULL)"},{"p":"purrr","o":"list_modify","f":"hp_list_modify","d":"list_modify() is inspired by utils::modifyList().\n","ec":"list_modify(.x, ..., .is_node = NULL)"},{"p":"purrr","o":"invoke_map_dfr","f":"hp_invoke_map_dfr","d":"\n","ec":"invoke_map_dfr(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"possibly","f":"hp_possibly","d":"Create a modified version of .f that return a default value (otherwise)\nwhenever an error occurs.\n","ec":"possibly(.f, otherwise = NULL, quiet = TRUE)"},{"p":"purrr","o":"invoke_map_int","f":"hp_invoke_map_int","d":"\n","ec":"invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)"},{"p":"purrr","o":"lift_vd","f":"hp_lift_vd","d":"\n","ec":"lift_vd(..f, ..., .type)"},{"p":"purrr","o":"compose","f":"hp_compose","d":"Create a new function that is the composition of multiple functions,\ni.e. compose(f, g) is equivalent to function(...) f(g(...)).\n","ec":"compose(..., .dir = c(\"backward\", \"forward\"))"},{"p":"purrr","o":"negate","f":"hp_negate","d":"Negating a function changes TRUE to FALSE and FALSE to TRUE.\n","ec":"negate(.p)"},{"p":"purrr","o":"partial","f":"hp_partial","d":"Partial function application allows you to modify a function by pre-filling\nsome of the arguments. It is particularly useful in conjunction with\nfunctionals and other function operators.\n","ec":"partial(.f, ..., .env = deprecated(), .lazy = deprecated(), .first = deprecated())"},{"p":"purrr","o":"invoke","f":"hp_invoke","d":"\n","ec":"invoke(.f, .x = NULL, ..., .env = NULL)"},{"p":"purrr","o":"pmap_dbl","f":"hp_pmap_dbl","d":"These functions are variants of map() that iterate over multiple arguments\nsimultaneously. They are parallel in the sense that each input is processed\nin parallel with the others, not in the sense of multicore computing, i.e.\nthey share the same notion of \"parallel\" as base::pmax() and base::pmin().\n","ec":"pmap_dbl(.l, .f, ..., .progress = FALSE)"},{"p":"purrr","o":"modify_tree","f":"hp_modify_tree","d":"modify_tree() allows you to recursively modify a list, supplying functions\nthat either modify each leaf or each node (or both).\n","ec":"modify_tree(x, ..., leaf = identity, is_node = NULL, pre = identity, post = identity)"},{"p":"purrr","o":"lift_vl","f":"hp_lift_vl","d":"\n","ec":"lift_vl(..f, ..., .type)"},{"p":"purrr","o":"assign_in","f":"hp_assign_in","d":"pluck()\n","ec":"assign_in(x, where, value)"},{"p":"purrr","o":"accumulate2","f":"hp_accumulate2","d":"accumulate() sequentially applies a 2-argument function to elements of a\nvector. Each application of the function uses the initial value or result\nof the previous application as the first argument. The second argument is\nthe next value of the vector. The results of each application are\nreturned in a list. The accumulation can optionally terminate before\nprocessing the whole vector in response to a done() signal returned by\nthe accumulation function.\n","ec":"accumulate2(.x, .y, .f, ..., .init, .simplify = NA, .ptype = NULL)"},{"p":"purrr","o":"map2_dfr","f":"hp_map2_dfr","d":"\n","ec":"map2_dfr(.x, .y, .f, ..., .id = NULL)"},{"p":"purrr","o":"accumulate","f":"hp_accumulate","d":"accumulate() sequentially applies a 2-argument function to elements of a\nvector. Each application of the function uses the initial value or result\nof the previous application as the first argument. The second argument is\nthe next value of the vector. The results of each application are\nreturned in a list. The accumulation can optionally terminate before\nprocessing the whole vector in response to a done() signal returned by\nthe accumulation function.\n","ec":"accumulate(.x, .f, ..., .init, .dir = c(\"forward\", \"backward\"), .simplify = NA, .ptype = NULL)"},{"p":"purrr","o":"keep_at","f":"hp_keep_at","d":"Keep/discard elements based on their name/position\n","ec":"keep_at(x, at)"},{"p":"purrr","o":"map_df","f":"hp_map_df","d":"\n","ec":"map_df(.x, .f, ..., .id = NULL)"},{"p":"purrr","o":"chuck","f":"hp_chuck","d":"chuck() implements a generalised form of [[ that allow you to index\ndeeply and flexibly into data structures. If the index you are trying to\naccess does not exist (or is NULL), it will throw (i.e. chuck) an error.\n","ec":"chuck(.x, ...)"},{"p":"purrr","o":"modify_depth","f":"hp_modify_depth","d":"map_depth() calls map(.y, .f) on all .y at the specified .depth in\n.x. modify_depth() calls modify(.y, .f) on .y at the specified\n.depth in .x.\n","ec":"modify_depth(.x, .depth, .f, ..., .ragged = .depth < 0, .is_node = NULL)"},{"p":"purrr","o":"is_rate","f":"hp_is_rate","d":"These helpers create rate settings that you can pass to insistently() and\nslowly(). You can also use them in your own functions with rate_sleep().\n","ec":"is_rate(x)"},{"p":"purrr","o":"imap","f":"hp_imap","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"imap(.x, .f, ...)"},{"p":"purrr","o":"reduce_right","f":"hp_reduce_right","d":"\n","ec":"reduce_right(.x, .f, ..., .init)"},{"p":"purrr","o":"iwalk","f":"hp_iwalk","d":"imap(x, ...), an indexed map, is short hand for\nmap2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...)\nif it does not. This is useful if you need to compute on both the value\nand the position of an element.\n","ec":"iwalk(.x, .f, ...)"},{"p":"purrr","o":"list_flatten","f":"hp_list_flatten","d":"Flattening a list removes a single layer of internal hierarchy,\ni.e. it inlines elements that are lists leaving non-lists alone.\n","ec":"list_flatten(x, ..., name_spec = \"{outer}_{inner}\", name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\"))"},{"p":"R6","o":"is.R6Class","f":"hp_is.R6Class","d":"Checks for R6 class generators and R6 objects.\n","ec":"is.R6Class(x)"},{"p":"R6","o":"is.R6","f":"hp_is.R6","d":"Checks for R6 class generators and R6 objects.\n","ec":"is.R6(x)"},{"p":"R6","o":"R6Class","f":"hp_R6Class","d":"R6 objects are essentially environments, structured in a way that makes them\nlook like an object in a more typical object-oriented language than R. They\nsupport public and private members, as well as inheritance across different\npackages.\n","ec":"R6Class(classname = NULL, public = list(), private = NULL, active = NULL, inherit = NULL, lock_objects = TRUE, class = TRUE, portable = TRUE, lock_class = FALSE, cloneable = TRUE, parent_env = parent.frame(), lock)"},{"p":"RColorBrewer","o":"brewer.pal.info","f":"hp_brewer.pal.info","d":"Creates nice looking color palettes especially for thematic maps","ec":""},{"p":"RColorBrewer","o":"brewer.pal","f":"hp_brewer.pal","d":"Creates nice looking color palettes especially for thematic maps","ec":"brewer.pal(n, name)"},{"p":"RColorBrewer","o":"display.brewer.all","f":"hp_display.brewer.all","d":"Creates nice looking color palettes especially for thematic maps","ec":"display.brewer.all(n = NULL, type = \"all\", select = NULL, exact.n = TRUE, colorblindFriendly = FALSE)"},{"p":"RColorBrewer","o":"display.brewer.pal","f":"hp_display.brewer.pal","d":"Creates nice looking color palettes especially for thematic maps","ec":"display.brewer.pal(n, name)"},{"p":"Rcpp","o":"loadRcppModules","f":"hp_loadRcppModules","d":"Note: As of release 0.12.5, this function is deprecated;\nloadModule should be used instead.\n","ec":"loadRcppModules(direct = TRUE)"},{"p":"Rcpp","o":"prompt","f":"hp_prompt","d":"-NA-","ec":"prompt(object, filename = NULL, name = NULL, ...)"},{"p":"Rcpp","o":".__T__prompt:utils","f":"hp_.__T__prompt.utils","d":"-NA-","ec":""},{"p":"Rcpp","o":".__C__C++Field","f":"hp_.__C__C..Field","d":"-NA-","ec":""},{"p":"Rcpp","o":".__C__C++Class","f":"hp_.__C__C..Class","d":"-NA-","ec":""},{"p":"Rcpp","o":"LdFlags","f":"hp_LdFlags","d":"In Rcpp versions prior to release 0.10.1 of November 2013,\nLdFlags and RcppLdFlags were used to return the required\nflags and options for the system linker to link to the Rcpp user\nlibrary. Since we no longer build or ship a user library, these\nfunctions now return an empty string. As of Rcpp release 0.12.19,\nthese functions are now deprecated.\n","ec":"LdFlags()"},{"p":"Rcpp","o":"Rcpp.package.skeleton","f":"hp_Rcpp.package.skeleton","d":"Rcpp.package.skeleton automates the creation of \na new source package that intends to use features of Rcpp. \n","ec":"Rcpp.package.skeleton(name = \"anRpackage\", list = character(), environment = .GlobalEnv, path = \".\", force = FALSE, code_files = character(), cpp_files = character(), example_code = TRUE, attributes = TRUE, module = FALSE, author = \"Your Name\", maintainer = if (missing(author)) \"Your Name\" else author, email = \"your@email.com\", license = \"GPL (>= 2)\")"},{"p":"Rcpp","o":".__C__C++Object","f":"hp_.__C__C..Object","d":"-NA-","ec":""},{"p":"Rcpp","o":"sizeof","f":"hp_sizeof","d":"demangle gives the demangled type, sizeof its size (in bytes). \n","ec":"sizeof(type = \"int\", ...)"},{"p":"Rcpp","o":"registerPlugin","f":"hp_registerPlugin","d":"Register an inline plugin for use with \nsourceCpp or cppFunction. Inline plugins are functions\nthat return a list with additional includes, environment variables, and\nother compilation context. \n","ec":"registerPlugin(name, plugin)"},{"p":"Rcpp","o":"compileAttributes","f":"hp_compileAttributes","d":"Scan the source files within a package for attributes and generate code as required. Generates the bindings required to call C++ functions from R for functions adorned with the Rcpp::export attribute.\n","ec":"compileAttributes(pkgdir = \".\", verbose = getOption(\"verbose\"))"},{"p":"Rcpp","o":"cpp_object_initializer","f":"hp_cpp_object_initializer","d":"The Rcpp utilizes several internal functions which\nneed to visible within its namespace, yet are not user-facing. This\npage provides basic documentation for them.\n","ec":"cpp_object_initializer(.self, .refClassDef, ..., .object_pointer)"},{"p":"Rcpp","o":"populate","f":"hp_populate","d":"Populates a namespace or an environment with the content of a module\n","ec":"populate(module, env)"},{"p":"Rcpp","o":".__C__C++OverloadedMethods","f":"hp_.__C__C..OverloadedMethods","d":"-NA-","ec":""},{"p":"Rcpp","o":".__C__C++Function","f":"hp_.__C__C..Function","d":"-NA-","ec":""},{"p":"Rcpp","o":"evalCpp","f":"hp_evalCpp","d":"Evaluates a C++ expression. This creates a C++ function using \ncppFunction and calls it to get the result. \n","ec":"evalCpp(code, depends = character(), plugins = character(), includes = character(), rebuild = FALSE, cacheDir = getOption(\"rcpp.cache.dir\", tempdir()), showOutput = verbose, verbose = getOption(\"verbose\"))"},{"p":"Rcpp","o":".__C__Module","f":"hp_.__C__Module","d":"-NA-","ec":""},{"p":"Rcpp","o":"exposeClass","f":"hp_exposeClass","d":"The arguments specify a C++ class and some combination of\nconstructors, fields and methods to be shared with R by creating a\ncorresponding reference class in R.\nThe information needed in the call to exposeClass() is the\nsimplest possible in order to create a C++ module for the class; for\nexample, fields and methods in this class need only be identified by\ntheir name.\nInherited fields and methods can also be included, but more\ninformation is needed.\nThe function writes a C++ source file,\ncontaining a module definition to expose the class to\nR, plus one line of R source to create the corresponding reference\nclass.\n","ec":"exposeClass(class, constructors, fields, methods, file = paste0(CppClass, \"Module.cpp\"), header = character(), module = paste0(\"class_\", class), CppClass = class, readOnly = character(), rename = character(), Rfile = TRUE)"},{"p":"Rcpp","o":".__T__initialize:methods","f":"hp_.__T__initialize.methods","d":"-NA-","ec":""},{"p":"Rcpp","o":".__T__.DollarNames:utils","f":"hp_.__T__.DollarNames.utils","d":"-NA-","ec":""},{"p":"Rcpp","o":"sourceCpp","f":"hp_sourceCpp","d":"sourceCpp parses the specified C++ file or source code and looks for functions marked with the Rcpp::export attribute\nand RCPP_MODULE declarations. A shared library is then built and its exported functions and Rcpp modules are made available in the specified environment.\n","ec":"sourceCpp(file = \"\", code = NULL, env = globalenv(), embeddedR = TRUE, rebuild = FALSE, cacheDir = getOption(\"rcpp.cache.dir\", tempdir()), cleanupCacheDir = FALSE, showOutput = verbose, verbose = getOption(\"verbose\"), dryRun = FALSE, windowsDebugDLL = FALSE, echo = TRUE)"},{"p":"Rcpp","o":"demangle","f":"hp_demangle","d":"demangle gives the demangled type, sizeof its size (in bytes). \n","ec":"demangle(type = \"int\", ...)"},{"p":"Rcpp","o":"formals<-","f":"hp_formals..","d":"-NA-","ec":"formals<-(fun, envir = environment(fun), value)"},{"p":"Rcpp","o":".DollarNames","f":"hp_.DollarNames","d":"-NA-","ec":".DollarNames(x, pattern)"},{"p":"Rcpp","o":".__T__$:base","f":"hp_.__T__..base","d":"-NA-","ec":""},{"p":"Rcpp","o":"Module","f":"hp_Module","d":"Retrieves an Rcpp module from a dynamic library, usually associated with a \npackage.\n","ec":"Module(module, PACKAGE = methods::getPackageName(where), where = topenv(parent.frame()), mustStart = FALSE)"},{"p":"Rcpp","o":".__T__formals<-:base","f":"hp_.__T__formals...base","d":"-NA-","ec":""},{"p":"Rcpp","o":"loadRcppClass","f":"hp_loadRcppClass","d":"These routines create a class definition in R for an exposed C++\nclass, setting up and executing a load action to incorporate the C++\npointer information.\nNeither function should normally need to be called directly; for most applications,\na call to\nexposeClass() will create both C++ and R code files to\nexpose the C++ class.\n","ec":"loadRcppClass(Class, CppClass = Class, module = paste0(\"class_\", Class), fields = character(), contains = character(), methods = list(), saveAs = Class, where = topenv(parent.frame()), ...)"},{"p":"Rcpp","o":"RcppLdFlags","f":"hp_RcppLdFlags","d":"In Rcpp versions prior to release 0.10.1 of November 2013,\nLdFlags and RcppLdFlags were used to return the required\nflags and options for the system linker to link to the Rcpp user\nlibrary. Since we no longer build or ship a user library, these\nfunctions now return an empty string. As of Rcpp release 0.12.19,\nthese functions are now deprecated.\n","ec":"RcppLdFlags()"},{"p":"Rcpp","o":"cpp_object_dummy","f":"hp_cpp_object_dummy","d":"The Rcpp utilizes several internal functions which\nneed to visible within its namespace, yet are not user-facing. This\npage provides basic documentation for them.\n","ec":"cpp_object_dummy(.self, .refClassDef)"},{"p":"Rcpp","o":".__C__C++Constructor","f":"hp_.__C__C..Constructor","d":"-NA-","ec":""},{"p":"Rcpp","o":"getRcppVersion","f":"hp_getRcppVersion","d":"Helper function to report the package version of the R installation.\n","ec":"getRcppVersion(devel = FALSE)"},{"p":"Rcpp","o":"loadModule","f":"hp_loadModule","d":"One or more calls to loadModule will be included in the source\ncode for a package to load modules and optionally expose objects from\nthem.  The actual extraction of the module takes place at load time.\n","ec":"loadModule(module, what = character(), loadNow, env = topenv(parent.frame()))"},{"p":"Rcpp","o":"setRcppClass","f":"hp_setRcppClass","d":"These routines create a class definition in R for an exposed C++\nclass, setting up and executing a load action to incorporate the C++\npointer information.\nNeither function should normally need to be called directly; for most applications,\na call to\nexposeClass() will create both C++ and R code files to\nexpose the C++ class.\n","ec":"setRcppClass(Class, CppClass, module, fields = list(), contains = character(), methods = list(), saveAs = Class, where = topenv(parent.frame()), ...)"},{"p":"Rcpp","o":"Rcpp.plugin.maker","f":"hp_Rcpp.plugin.maker","d":"This function helps packages making inline plugins. \n","ec":"Rcpp.plugin.maker(include.before = \"\", include.after = \"\", LinkingTo = unique(c(package, \"Rcpp\")), Depends = unique(c(package, \"Rcpp\")), Imports = unique(c(package, \"Rcpp\")), libs = \"\", Makevars = NULL, Makevars.win = NULL, package = \"Rcpp\")"},{"p":"Rcpp","o":"cppFunction","f":"hp_cppFunction","d":"Dynamically define an R function with C++ source code. Compiles and links a shared library with bindings to the C++ function then defines an R function that uses .Call to invoke the library.\n","ec":"cppFunction(code, depends = character(), plugins = character(), includes = character(), env = parent.frame(), rebuild = FALSE, cacheDir = getOption(\"rcpp.cache.dir\", tempdir()), showOutput = verbose, verbose = getOption(\"verbose\"), echo = TRUE)"},{"p":"Rcpp","o":".__C__RcppClass","f":"hp_.__C__RcppClass","d":"-NA-","ec":""},{"p":"Rcpp","o":".__T__show:methods","f":"hp_.__T__show.methods","d":"-NA-","ec":""},{"p":"readr","o":"parse_logical","f":"hp_parse_logical","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"parse_logical(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"date_names_lang","f":"hp_date_names_lang","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>http://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names_lang(language)"},{"p":"readr","o":"read_rds","f":"hp_read_rds","d":"Consistent wrapper around saveRDS() and readRDS().\nwrite_rds() does not compress by default as space is generally cheaper\nthan time.\n","ec":"read_rds(file, refhook = NULL)"},{"p":"readr","o":"col_factor","f":"hp_col_factor","d":"parse_factor() is similar to factor(), but generates a warning if\nlevels have been specified and some elements of x are not found in those\nlevels.\n","ec":"col_factor(levels = NULL, ordered = FALSE, include_na = FALSE)"},{"p":"readr","o":"format_delim","f":"hp_format_delim","d":"These functions are equivalent to write_csv() etc., but instead\nof writing to disk, they return a string.\n","ec":"format_delim(x, delim, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", quote_escape = deprecated())"},{"p":"readr","o":"fwf_empty","f":"hp_fwf_empty","d":"A fixed width file can be a very compact representation of numeric data.\nIt's also very fast to parse, because every field is in the same place in\nevery line. Unfortunately, it's painful to parse because you need to\ndescribe the length of every field. Readr aims to make it as easy as possible\nby providing a number of different ways to describe the field structure.\n","ec":"fwf_empty(file, skip = 0, skip_empty_rows = FALSE, col_names = NULL, comment = \"\", n = 100L)"},{"p":"readr","o":"parse_integer","f":"hp_parse_integer","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"parse_integer(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"read_lines_raw_chunked","f":"hp_read_lines_raw_chunked","d":"Read lines from a file or string by chunk.\n","ec":"read_lines_raw_chunked(file, callback, chunk_size = 10000, skip = 0, progress = show_progress())"},{"p":"readr","o":"write_delim","f":"hp_write_delim","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_delim(x, file, delim = \" \", na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"spec_delim","f":"hp_spec_delim","d":"When printed, only the first 20 columns are printed by default. To override,\nset options(readr.num_columns) can be used to modify this (a value of 0\nturns off printing).\n","ec":"spec_delim(file, delim = NULL, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, col_names = TRUE, col_types = list(), col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, n_max = 0, guess_max = 1000, name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"read_delim","f":"hp_read_delim","d":"read_csv() and read_tsv() are special cases of the more general\nread_delim(). They're useful for reading the most common types of\nflat file data, comma separated values and tab separated values,\nrespectively. read_csv2() uses <U+2060>;<U+2060> for the field separator and <U+2060>,<U+2060> for the\ndecimal point. This format is common in some European countries.\n","ec":"read_delim(file, delim = NULL, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"readr_example","f":"hp_readr_example","d":"readr comes bundled with a number of sample files in its inst/extdata\ndirectory. This function make them easy to access\n","ec":"readr_example(file = NULL)"},{"p":"readr","o":"fwf_cols","f":"hp_fwf_cols","d":"A fixed width file can be a very compact representation of numeric data.\nIt's also very fast to parse, because every field is in the same place in\nevery line. Unfortunately, it's painful to parse because you need to\ndescribe the length of every field. Readr aims to make it as easy as possible\nby providing a number of different ways to describe the field structure.\n","ec":"fwf_cols(...)"},{"p":"readr","o":"col_character","f":"hp_col_character","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"col_character()"},{"p":"readr","o":"read_csv_chunked","f":"hp_read_csv_chunked","d":"Read a delimited file by chunks\n","ec":"read_csv_chunked(file, callback, chunk_size = 10000, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, guess_max = chunk_size, progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"parse_number","f":"hp_parse_number","d":"This parses the first number it finds, dropping any non-numeric characters\nbefore the first number and all characters after the first number. The\ngrouping mark specified by the locale is ignored inside the number.\n","ec":"parse_number(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"DataFrameCallback","f":"hp_DataFrameCallback","d":"These classes are used to define callback behaviors.\n","ec":""},{"p":"readr","o":"read_lines","f":"hp_read_lines","d":"read_lines() reads up to n_max lines from a file. New lines are\nnot included in the output. read_lines_raw() produces a list of raw\nvectors, and is useful for handling data with unknown encoding.\nwrite_lines() takes a character vector or list of raw vectors, appending a\nnew line after each entry.\n","ec":"read_lines(file, skip = 0, skip_empty_rows = FALSE, n_max = Inf, locale = default_locale(), na = character(), lazy = should_read_lazy(), num_threads = readr_threads(), progress = show_progress())"},{"p":"readr","o":"output_column","f":"hp_output_column","d":"This is a generic function that applied to each column before it is saved\nto disk. It provides a hook for S3 classes that need special handling.\n","ec":"output_column(x, name)"},{"p":"readr","o":"col_skip","f":"hp_col_skip","d":"Use this function to ignore a column when reading in a file.\nTo skip all columns not otherwise specified, use cols_only().\n","ec":"col_skip()"},{"p":"readr","o":"col_date","f":"hp_col_date","d":"Parse date/times\n","ec":"col_date(format = \"\")"},{"p":"readr","o":"write_excel_csv2","f":"hp_write_excel_csv2","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_excel_csv2(x, file, na = \"NA\", append = FALSE, col_names = !append, delim = \";\", quote = \"all\", escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"read_delim_chunked","f":"hp_read_delim_chunked","d":"Read a delimited file by chunks\n","ec":"read_delim_chunked(file, callback, delim = NULL, chunk_size = 10000, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, guess_max = chunk_size, progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"melt_csv2_chunked","f":"hp_melt_csv2_chunked","d":"For certain non-rectangular data formats, it can be useful to parse the data\ninto a melted format where each row represents a single token.\n","ec":"melt_csv2_chunked(file, callback, chunk_size = 10000, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"tokenizer_csv","f":"hp_tokenizer_csv","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_csv(na = \"NA\", quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip_empty_rows = TRUE)"},{"p":"readr","o":"parse_guess","f":"hp_parse_guess","d":"parse_guess() returns the parser vector; guess_parser()\nreturns the name of the parser. These functions use a number of heuristics\nto determine which type of vector is \"best\". Generally they try to err of\nthe side of safety, as it's straightforward to override the parsing choice\nif needed.\n","ec":"parse_guess(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE, guess_integer = FALSE)"},{"p":"readr","o":"write_lines","f":"hp_write_lines","d":"read_lines() reads up to n_max lines from a file. New lines are\nnot included in the output. read_lines_raw() produces a list of raw\nvectors, and is useful for handling data with unknown encoding.\nwrite_lines() takes a character vector or list of raw vectors, appending a\nnew line after each entry.\n","ec":"write_lines(x, file, sep = \"\\n\", na = \"NA\", append = FALSE, num_threads = readr_threads(), path = deprecated())"},{"p":"readr","o":"count_fields","f":"hp_count_fields","d":"This is useful for diagnosing problems with functions that fail\nto parse correctly.\n","ec":"count_fields(file, tokenizer, skip = 0, n_max = -1L)"},{"p":"readr","o":"write_excel_csv","f":"hp_write_excel_csv","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_excel_csv(x, file, na = \"NA\", append = FALSE, col_names = !append, delim = \",\", quote = \"all\", escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"format_csv2","f":"hp_format_csv2","d":"These functions are equivalent to write_csv() etc., but instead\nof writing to disk, they return a string.\n","ec":"format_csv2(x, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", quote_escape = deprecated())"},{"p":"readr","o":"format_csv","f":"hp_format_csv","d":"These functions are equivalent to write_csv() etc., but instead\nof writing to disk, they return a string.\n","ec":"format_csv(x, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", quote_escape = deprecated())"},{"p":"readr","o":"format_tsv","f":"hp_format_tsv","d":"These functions are equivalent to write_csv() etc., but instead\nof writing to disk, they return a string.\n","ec":"format_tsv(x, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", quote_escape = deprecated())"},{"p":"readr","o":"col_datetime","f":"hp_col_datetime","d":"Parse date/times\n","ec":"col_datetime(format = \"\")"},{"p":"readr","o":"spec_tsv","f":"hp_spec_tsv","d":"When printed, only the first 20 columns are printed by default. To override,\nset options(readr.num_columns) can be used to modify this (a value of 0\nturns off printing).\n","ec":"spec_tsv(file, col_names = TRUE, col_types = list(), col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000, progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"parse_datetime","f":"hp_parse_datetime","d":"Parse date/times\n","ec":"parse_datetime(x, format = \"\", na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"spec","f":"hp_spec","d":"cols_condense() takes a spec object and condenses its definition by setting\nthe default column type to the most frequent type and only listing columns\nwith a different type.\n","ec":"spec(x)"},{"p":"readr","o":"write_csv","f":"hp_write_csv","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_csv(x, file, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"read_csv","f":"hp_read_csv","d":"read_csv() and read_tsv() are special cases of the more general\nread_delim(). They're useful for reading the most common types of\nflat file data, comma separated values and tab separated values,\nrespectively. read_csv2() uses <U+2060>;<U+2060> for the field separator and <U+2060>,<U+2060> for the\ndecimal point. This format is common in some European countries.\n","ec":"read_csv(file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"guess_encoding","f":"hp_guess_encoding","d":"Uses stringi::stri_enc_detect(): see the documentation there\nfor caveats.\n","ec":"guess_encoding(file, n_max = 10000, threshold = 0.2)"},{"p":"readr","o":"melt_table","f":"hp_melt_table","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_table(file, locale = default_locale(), na = \"NA\", skip = 0, n_max = Inf, guess_max = min(n_max, 1000), progress = show_progress(), comment = \"\", skip_empty_rows = FALSE)"},{"p":"readr","o":"read_table2","f":"hp_read_table2","d":"\n","ec":"read_table2(file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = \"NA\", skip = 0, n_max = Inf, guess_max = min(n_max, 1000), progress = show_progress(), comment = \"\", skip_empty_rows = TRUE)"},{"p":"readr","o":"read_builtin","f":"hp_read_builtin","d":"Consistent wrapper around data() that forces the promise. This is also a\nstronger parallel to loading data from a file.\n","ec":"read_builtin(x, package = NULL)"},{"p":"readr","o":"read_csv2_chunked","f":"hp_read_csv2_chunked","d":"Read a delimited file by chunks\n","ec":"read_csv2_chunked(file, callback, chunk_size = 10000, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, guess_max = chunk_size, progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"tokenizer_line","f":"hp_tokenizer_line","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_line(na = character(), skip_empty_rows = TRUE)"},{"p":"readr","o":"cols_only","f":"hp_cols_only","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest. In general you can substitute list() for\ncols() without changing the behavior.\n","ec":"cols_only(...)"},{"p":"readr","o":"col_guess","f":"hp_col_guess","d":"parse_guess() returns the parser vector; guess_parser()\nreturns the name of the parser. These functions use a number of heuristics\nto determine which type of vector is \"best\". Generally they try to err of\nthe side of safety, as it's straightforward to override the parsing choice\nif needed.\n","ec":"col_guess()"},{"p":"readr","o":"clipboard","f":"hp_clipboard","d":"This is useful in the read_delim() functions to read from the clipboard.\n","ec":"clipboard()"},{"p":"readr","o":"guess_parser","f":"hp_guess_parser","d":"parse_guess() returns the parser vector; guess_parser()\nreturns the name of the parser. These functions use a number of heuristics\nto determine which type of vector is \"best\". Generally they try to err of\nthe side of safety, as it's straightforward to override the parsing choice\nif needed.\n","ec":"guess_parser(x, locale = default_locale(), guess_integer = FALSE, na = c(\"\", \"NA\"))"},{"p":"readr","o":"parse_vector","f":"hp_parse_vector","d":"Parse a character vector.\n","ec":"parse_vector(x, collector, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"fwf_widths","f":"hp_fwf_widths","d":"A fixed width file can be a very compact representation of numeric data.\nIt's also very fast to parse, because every field is in the same place in\nevery line. Unfortunately, it's painful to parse because you need to\ndescribe the length of every field. Readr aims to make it as easy as possible\nby providing a number of different ways to describe the field structure.\n","ec":"fwf_widths(widths, col_names = NULL)"},{"p":"readr","o":"date_names","f":"hp_date_names","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>http://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c(\"AM\", \"PM\"))"},{"p":"readr","o":"read_file_raw","f":"hp_read_file_raw","d":"read_file() reads a complete file into a single object: either a\ncharacter vector of length one, or a raw vector. write_file() takes a\nsingle string, or a raw vector, and writes it exactly as is.  Raw vectors\nare useful when dealing with binary data, or if you have text data with\nunknown encoding.\n","ec":"read_file_raw(file)"},{"p":"readr","o":"locale","f":"hp_locale","d":"A locale object tries to capture all the defaults that can vary between\ncountries. You set the locale in once, and the details are automatically\npassed on down to the columns parsers. The defaults have been chosen to\nmatch R (i.e. US English) as closely as possible. See\nvignette(\"locales\") for more details.\n","ec":"locale(date_names = \"en\", date_format = \"%AD\", time_format = \"%AT\", decimal_mark = \".\", grouping_mark = \",\", tz = \"UTC\", encoding = \"UTF-8\", asciify = FALSE)"},{"p":"readr","o":"write_csv2","f":"hp_write_csv2","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_csv2(x, file, na = \"NA\", append = FALSE, col_names = !append, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"melt_table2","f":"hp_melt_table2","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_table2(file, locale = default_locale(), na = \"NA\", skip = 0, n_max = Inf, progress = show_progress(), comment = \"\", skip_empty_rows = FALSE)"},{"p":"readr","o":"parse_factor","f":"hp_parse_factor","d":"parse_factor() is similar to factor(), but generates a warning if\nlevels have been specified and some elements of x are not found in those\nlevels.\n","ec":"parse_factor(x, levels = NULL, ordered = FALSE, na = c(\"\", \"NA\"), locale = default_locale(), include_na = TRUE, trim_ws = TRUE)"},{"p":"readr","o":"default_locale","f":"hp_default_locale","d":"A locale object tries to capture all the defaults that can vary between\ncountries. You set the locale in once, and the details are automatically\npassed on down to the columns parsers. The defaults have been chosen to\nmatch R (i.e. US English) as closely as possible. See\nvignette(\"locales\") for more details.\n","ec":"default_locale()"},{"p":"readr","o":"tokenizer_fwf","f":"hp_tokenizer_fwf","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_fwf(begin, end, na = \"NA\", comment = \"\", trim_ws = TRUE, skip_empty_rows = TRUE)"},{"p":"readr","o":"melt_tsv_chunked","f":"hp_melt_tsv_chunked","d":"For certain non-rectangular data formats, it can be useful to parse the data\ninto a melted format where each row represents a single token.\n","ec":"melt_tsv_chunked(file, callback, chunk_size = 10000, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"should_read_lazy","f":"hp_should_read_lazy","d":"This function consults the option readr.read_lazy to figure out whether to\ndo lazy reading or not. If the option is unset, the default is FALSE,\nmeaning readr will read files eagerly, not lazily. If you want to use this\noption to express a preference for lazy reading, do this:\n","ec":"should_read_lazy()"},{"p":"readr","o":"melt_tsv","f":"hp_melt_tsv","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_tsv(file, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"read_table","f":"hp_read_table","d":"read_table() is designed to read the type of textual\ndata where each column is separated by one (or more) columns of space.\n","ec":"read_table(file, col_names = TRUE, col_types = NULL, locale = default_locale(), na = \"NA\", skip = 0, n_max = Inf, guess_max = min(n_max, 1000), progress = show_progress(), comment = \"\", show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"read_lines_raw","f":"hp_read_lines_raw","d":"read_lines() reads up to n_max lines from a file. New lines are\nnot included in the output. read_lines_raw() produces a list of raw\nvectors, and is useful for handling data with unknown encoding.\nwrite_lines() takes a character vector or list of raw vectors, appending a\nnew line after each entry.\n","ec":"read_lines_raw(file, skip = 0, n_max = -1L, num_threads = readr_threads(), progress = show_progress())"},{"p":"readr","o":"tokenizer_log","f":"hp_tokenizer_log","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_log(trim_ws)"},{"p":"readr","o":"spec_csv2","f":"hp_spec_csv2","d":"When printed, only the first 20 columns are printed by default. To override,\nset options(readr.num_columns) can be used to modify this (a value of 0\nturns off printing).\n","ec":"spec_csv2(file, col_names = TRUE, col_types = list(), col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000, progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"spec_table","f":"hp_spec_table","d":"When printed, only the first 20 columns are printed by default. To override,\nset options(readr.num_columns) can be used to modify this (a value of 0\nturns off printing).\n","ec":"spec_table(file, col_names = TRUE, col_types = list(), locale = default_locale(), na = \"NA\", skip = 0, n_max = 0, guess_max = 1000, progress = show_progress(), comment = \"\", show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"read_csv2","f":"hp_read_csv2","d":"read_csv() and read_tsv() are special cases of the more general\nread_delim(). They're useful for reading the most common types of\nflat file data, comma separated values and tab separated values,\nrespectively. read_csv2() uses <U+2060>;<U+2060> for the field separator and <U+2060>,<U+2060> for the\ndecimal point. This format is common in some European countries.\n","ec":"read_csv2(file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"type_convert","f":"hp_type_convert","d":"This is useful if you need to do some manual munging - you can read the\ncolumns in as character, clean it up with (e.g.) regular expressions and\nthen let readr take another stab at parsing it. The name is a homage to\nthe base utils::type.convert().\n","ec":"type_convert(df, col_types = NULL, na = c(\"\", \"NA\"), trim_ws = TRUE, locale = default_locale(), guess_integer = FALSE)"},{"p":"readr","o":"AccumulateCallback","f":"hp_AccumulateCallback","d":"These classes are used to define callback behaviors.\n","ec":""},{"p":"readr","o":"col_integer","f":"hp_col_integer","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"col_integer()"},{"p":"readr","o":"date_names_langs","f":"hp_date_names_langs","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>http://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names_langs()"},{"p":"readr","o":"melt_delim","f":"hp_melt_delim","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_delim(file, delim, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, n_max = Inf, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"col_time","f":"hp_col_time","d":"Parse date/times\n","ec":"col_time(format = \"\")"},{"p":"readr","o":"read_file","f":"hp_read_file","d":"read_file() reads a complete file into a single object: either a\ncharacter vector of length one, or a raw vector. write_file() takes a\nsingle string, or a raw vector, and writes it exactly as is.  Raw vectors\nare useful when dealing with binary data, or if you have text data with\nunknown encoding.\n","ec":"read_file(file, locale = default_locale())"},{"p":"readr","o":"melt_delim_chunked","f":"hp_melt_delim_chunked","d":"For certain non-rectangular data formats, it can be useful to parse the data\ninto a melted format where each row represents a single token.\n","ec":"melt_delim_chunked(file, callback, chunk_size = 10000, delim, quote = \"\\\"\", escape_backslash = FALSE, escape_double = TRUE, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, comment = \"\", trim_ws = FALSE, skip = 0, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"tokenizer_delim","f":"hp_tokenizer_delim","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_delim(delim, quote = \"\\\"\", na = \"NA\", quoted_na = TRUE, comment = \"\", trim_ws = TRUE, escape_double = TRUE, escape_backslash = FALSE, skip_empty_rows = TRUE)"},{"p":"readr","o":"tokenize","f":"hp_tokenize","d":"Turns input into a character vector. Usually the tokenization is done purely\nin C++, and never exposed to R (because that requires a copy). This function\nis useful for testing, or when a file doesn't parse correctly and you want\nto see the underlying tokens.\n","ec":"tokenize(file, tokenizer = tokenizer_csv(), skip = 0, n_max = -1L)"},{"p":"readr","o":"read_log","f":"hp_read_log","d":"This is a fairly standard format for log files - it uses both quotes\nand square brackets for quoting, and there may be literal quotes embedded\nin a quoted string. The dash, \"-\", is used for missing values.\n","ec":"read_log(file, col_names = FALSE, col_types = NULL, trim_ws = TRUE, skip = 0, n_max = Inf, show_col_types = should_show_types(), progress = show_progress())"},{"p":"readr","o":"spec_csv","f":"hp_spec_csv","d":"When printed, only the first 20 columns are printed by default. To override,\nset options(readr.num_columns) can be used to modify this (a value of 0\nturns off printing).\n","ec":"spec_csv(file, col_names = TRUE, col_types = list(), col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = 0, guess_max = 1000, name_repair = \"unique\", num_threads = readr_threads(), progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"melt_csv_chunked","f":"hp_melt_csv_chunked","d":"For certain non-rectangular data formats, it can be useful to parse the data\ninto a melted format where each row represents a single token.\n","ec":"melt_csv_chunked(file, callback, chunk_size = 10000, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"melt_fwf","f":"hp_melt_fwf","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_fwf(file, col_positions, locale = default_locale(), na = c(\"\", \"NA\"), comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"local_edition","f":"hp_local_edition","d":"with_edition() allows you to change the active edition of readr for a given\nblock of code. local_edition() allows you to change the active edition of\nreadr until the end of the current function or file.\n","ec":"local_edition(edition, env = parent.frame())"},{"p":"readr","o":"write_tsv","f":"hp_write_tsv","d":"The <U+2060>write_*()<U+2060> family of functions are an improvement to analogous function such\nas write.csv() because they are approximately twice as fast. Unlike write.csv(),\nthese functions do not include row names as a column in the written file.\nA generic function, output_column(), is applied to each variable\nto coerce columns to suitable output.\n","ec":"write_tsv(x, file, na = \"NA\", append = FALSE, col_names = !append, quote = \"none\", escape = c(\"double\", \"backslash\", \"none\"), eol = \"\\n\", num_threads = readr_threads(), progress = show_progress(), path = deprecated(), quote_escape = deprecated())"},{"p":"readr","o":"read_lines_chunked","f":"hp_read_lines_chunked","d":"Read lines from a file or string by chunk.\n","ec":"read_lines_chunked(file, callback, chunk_size = 10000, skip = 0, locale = default_locale(), na = character(), progress = show_progress())"},{"p":"readr","o":"tokenizer_ws","f":"hp_tokenizer_ws","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_ws(na = \"NA\", comment = \"\", skip_empty_rows = TRUE)"},{"p":"readr","o":"col_logical","f":"hp_col_logical","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"col_logical()"},{"p":"readr","o":"cols","f":"hp_cols","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest. In general you can substitute list() for\ncols() without changing the behavior.\n","ec":"cols(..., .default = col_guess())"},{"p":"readr","o":"cols_condense","f":"hp_cols_condense","d":"cols_condense() takes a spec object and condenses its definition by setting\nthe default column type to the most frequent type and only listing columns\nwith a different type.\n","ec":"cols_condense(x)"},{"p":"readr","o":"fwf_positions","f":"hp_fwf_positions","d":"A fixed width file can be a very compact representation of numeric data.\nIt's also very fast to parse, because every field is in the same place in\nevery line. Unfortunately, it's painful to parse because you need to\ndescribe the length of every field. Readr aims to make it as easy as possible\nby providing a number of different ways to describe the field structure.\n","ec":"fwf_positions(start, end = NULL, col_names = NULL)"},{"p":"readr","o":"show_progress","f":"hp_show_progress","d":"By default, readr shows progress bars. However, progress reporting is\nsuppressed if any of the following conditions hold:\n","ec":"show_progress()"},{"p":"readr","o":"tokenizer_tsv","f":"hp_tokenizer_tsv","d":"Explicitly create tokenizer objects. Usually you will not call these\nfunction, but will instead use one of the use friendly wrappers like\nread_csv().\n","ec":"tokenizer_tsv(na = \"NA\", quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip_empty_rows = TRUE)"},{"p":"readr","o":"ListCallback","f":"hp_ListCallback","d":"These classes are used to define callback behaviors.\n","ec":""},{"p":"readr","o":"melt_csv2","f":"hp_melt_csv2","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_csv2(file, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"parse_date","f":"hp_parse_date","d":"Parse date/times\n","ec":"parse_date(x, format = \"\", na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"parse_character","f":"hp_parse_character","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"parse_character(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"read_fwf","f":"hp_read_fwf","d":"A fixed width file can be a very compact representation of numeric data.\nIt's also very fast to parse, because every field is in the same place in\nevery line. Unfortunately, it's painful to parse because you need to\ndescribe the length of every field. Readr aims to make it as easy as possible\nby providing a number of different ways to describe the field structure.\n","ec":"read_fwf(file, col_positions = fwf_empty(file, skip, n = guess_max), col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(n_max, 1000), progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), lazy = should_read_lazy(), skip_empty_rows = TRUE)"},{"p":"readr","o":"edition_get","f":"hp_edition_get","d":"Retrieve the currently active edition\n","ec":"edition_get()"},{"p":"readr","o":"read_tsv_chunked","f":"hp_read_tsv_chunked","d":"Read a delimited file by chunks\n","ec":"read_tsv_chunked(file, callback, chunk_size = 10000, col_names = TRUE, col_types = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, guess_max = chunk_size, progress = show_progress(), show_col_types = should_show_types(), skip_empty_rows = TRUE)"},{"p":"readr","o":"datasource","f":"hp_datasource","d":"Create a source object.\n","ec":"datasource(file, skip = 0, skip_empty_rows = FALSE, comment = \"\", skip_quote = TRUE)"},{"p":"readr","o":"parse_time","f":"hp_parse_time","d":"Parse date/times\n","ec":"parse_time(x, format = \"\", na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"write_rds","f":"hp_write_rds","d":"Consistent wrapper around saveRDS() and readRDS().\nwrite_rds() does not compress by default as space is generally cheaper\nthan time.\n","ec":"write_rds(x, file, compress = c(\"none\", \"gz\", \"bz2\", \"xz\"), version = 2, refhook = NULL, text = FALSE, path = deprecated(), ...)"},{"p":"readr","o":"ChunkCallback","f":"hp_ChunkCallback","d":"These classes are used to define callback behaviors.\n","ec":""},{"p":"readr","o":"col_double","f":"hp_col_double","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"col_double()"},{"p":"readr","o":"col_number","f":"hp_col_number","d":"This parses the first number it finds, dropping any non-numeric characters\nbefore the first number and all characters after the first number. The\ngrouping mark specified by the locale is ignored inside the number.\n","ec":"col_number()"},{"p":"readr","o":"parse_double","f":"hp_parse_double","d":"Use <U+2060>parse_*()<U+2060> if you have a character vector you want to parse. Use\n<U+2060>col_*()<U+2060> in conjunction with a <U+2060>read_*()<U+2060> function to parse the\nvalues as they're read in.\n","ec":"parse_double(x, na = c(\"\", \"NA\"), locale = default_locale(), trim_ws = TRUE)"},{"p":"readr","o":"problems","f":"hp_problems","d":"Readr functions will only throw an error if parsing fails in an unrecoverable\nway. However, there are lots of potential problems that you might want to\nknow about - these are stored in the problems attribute of the\noutput, which you can easily access with this function.\nstop_for_problems() will throw an error if there are any parsing\nproblems: this is useful for automated scripts where you want to throw\nan error as soon as you encounter a problem.\n","ec":"problems(x = .Last.value)"},{"p":"readr","o":"write_file","f":"hp_write_file","d":"read_file() reads a complete file into a single object: either a\ncharacter vector of length one, or a raw vector. write_file() takes a\nsingle string, or a raw vector, and writes it exactly as is.  Raw vectors\nare useful when dealing with binary data, or if you have text data with\nunknown encoding.\n","ec":"write_file(x, file, append = FALSE, path = deprecated())"},{"p":"readr","o":"stop_for_problems","f":"hp_stop_for_problems","d":"Readr functions will only throw an error if parsing fails in an unrecoverable\nway. However, there are lots of potential problems that you might want to\nknow about - these are stored in the problems attribute of the\noutput, which you can easily access with this function.\nstop_for_problems() will throw an error if there are any parsing\nproblems: this is useful for automated scripts where you want to throw\nan error as soon as you encounter a problem.\n","ec":"stop_for_problems(x)"},{"p":"readr","o":"melt_csv","f":"hp_melt_csv","d":"\nThis function has been superseded in readr and moved to the meltr package.\n","ec":"melt_csv(file, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, progress = show_progress(), skip_empty_rows = FALSE)"},{"p":"readr","o":"read_tsv","f":"hp_read_tsv","d":"read_csv() and read_tsv() are special cases of the more general\nread_delim(). They're useful for reading the most common types of\nflat file data, comma separated values and tab separated values,\nrespectively. read_csv2() uses <U+2060>;<U+2060> for the field separator and <U+2060>,<U+2060> for the\ndecimal point. This format is common in some European countries.\n","ec":"read_tsv(file, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), quoted_na = TRUE, quote = \"\\\"\", comment = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = show_progress(), name_repair = \"unique\", num_threads = readr_threads(), show_col_types = should_show_types(), skip_empty_rows = TRUE, lazy = should_read_lazy())"},{"p":"readr","o":"with_edition","f":"hp_with_edition","d":"with_edition() allows you to change the active edition of readr for a given\nblock of code. local_edition() allows you to change the active edition of\nreadr until the end of the current function or file.\n","ec":"with_edition(edition, code)"},{"p":"readr","o":"as.col_spec","f":"hp_as.col_spec","d":"This is most useful for generating a specification using the short form\n","ec":"as.col_spec(x)"},{"p":"readr","o":"SideEffectChunkCallback","f":"hp_SideEffectChunkCallback","d":"These classes are used to define callback behaviors.\n","ec":""},{"p":"readr","o":"readr_threads","f":"hp_readr_threads","d":"The number of threads returned can be set by\n","ec":"readr_threads()"},{"p":"readr","o":"should_show_types","f":"hp_should_show_types","d":"Wrapper around getOption(\"readr.show_col_types\") that implements some fall\nback logic if the option is unset. This returns:\n","ec":"should_show_types()"},{"p":"readxl","o":"format_from_signature","f":"hp_format_from_signature","d":"Determine if files are xls or xlsx (or from the xlsx family).\n","ec":"format_from_signature(path)"},{"p":"readxl","o":"format_from_ext","f":"hp_format_from_ext","d":"Determine if files are xls or xlsx (or from the xlsx family).\n","ec":"format_from_ext(path)"},{"p":"readxl","o":"readxl_progress","f":"hp_readxl_progress","d":"By default, readxl displays a progress spinner unless\none of the following is TRUE:\n","ec":"readxl_progress()"},{"p":"readxl","o":"read_xlsx","f":"hp_read_xlsx","d":"Read xls and xlsx files\n","ec":"read_xlsx(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = \"unique\")"},{"p":"readxl","o":"excel_format","f":"hp_excel_format","d":"Determine if files are xls or xlsx (or from the xlsx family).\n","ec":"excel_format(path, guess = TRUE)"},{"p":"readxl","o":"read_excel","f":"hp_read_excel","d":"Read xls and xlsx files\n","ec":"read_excel(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = \"unique\")"},{"p":"readxl","o":"excel_sheets","f":"hp_excel_sheets","d":"The list of sheet names is especially useful when you want to iterate over\nall of the sheets in a workbook. The vignette(\"readxl-workflows\") article\nprovides several worked examples of this, showing how to combine readxl with\nother packages in the tidyverse, such as purrr, or with base R functions like\nlapply().\n","ec":"excel_sheets(path)"},{"p":"readxl","o":"read_xls","f":"hp_read_xls","d":"Read xls and xlsx files\n","ec":"read_xls(path, sheet = NULL, range = NULL, col_names = TRUE, col_types = NULL, na = \"\", trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = min(1000, n_max), progress = readxl_progress(), .name_repair = \"unique\")"},{"p":"readxl","o":"readxl_example","f":"hp_readxl_example","d":"readxl comes bundled with some example files in its inst/extdata\ndirectory. This function make them easy to access.\n","ec":"readxl_example(path = NULL)"},{"p":"rematch","o":"re_match","f":"hp_re_match","d":"This function is a small wrapper on the regexpr\nbase R function, to provide an API that is easier to use.\n","ec":"re_match(pattern, text, ...)"},{"p":"rematch","o":"re_match_all","f":"hp_re_match_all","d":"This function is a thin wrapper on the gregexpr\nbase R function, to provide an API that is easier to use. It is\nsimilar to re_match, but extracts all matches, including\npotentially named capture groups.\n","ec":"re_match_all(pattern, text, ...)"},{"p":"rematch2","o":"re_exec_all","f":"hp_re_exec_all","d":"Match a regular expression to a string, and return matches, match positions,\nand capture groups.  This function is like its\nmatch counterpart, except it returns\nmatch/capture group start and end positions in addition to the matched\nvalues.\n","ec":"re_exec_all(text, pattern, perl = TRUE, ...)"},{"p":"rematch2","o":"bind_re_match","f":"hp_bind_re_match","d":"Taking a data frame and a column name as input, this function will run\nre_match and bind the results as new columns to the original\ntable., returning a tibble. This makes it friendly for\npipe-oriented programming with magrittr.\n","ec":"bind_re_match(df, from, ..., keep_match = FALSE)"},{"p":"rematch2","o":"$.rematch_records","f":"hp_X..rematch_records","d":"Match a regular expression to a string, and return matches, match positions,\nand capture groups.  This function is like its\nmatch counterpart, except it returns match/capture\ngroup start and end positions in addition to the matched values.\n","ec":"$.rematch_records(x, name)"},{"p":"rematch2","o":"$.rematch_allrecords","f":"hp_X..rematch_allrecords","d":"Match a regular expression to a string, and return matches, match positions,\nand capture groups.  This function is like its\nmatch counterpart, except it returns match/capture\ngroup start and end positions in addition to the matched values.\n","ec":"$.rematch_allrecords(x, name)"},{"p":"rematch2","o":"re_match","f":"hp_re_match","d":"re_match wraps regexpr and returns the\nmatch results in a convenient data frame. The data frame has one\ncolumn for each capture group if perl=TRUE, and one final columns\ncalled .match for the matching (sub)string. The columns of the capture\ngroups are named if the groups themselves are named.\n","ec":"re_match(text, pattern, perl = TRUE, ...)"},{"p":"rematch2","o":"re_match_all","f":"hp_re_match_all","d":"This function is a thin wrapper on the gregexpr\nbase R function, to extract the matching (sub)strings as a data frame.\nIt extracts all matches, and potentially their capture groups as well.\n","ec":"re_match_all(text, pattern, perl = TRUE, ...)"},{"p":"rematch2","o":"bind_re_match_","f":"hp_bind_re_match_","d":"Taking a data frame and a column name as input, this function will run\nre_match and bind the results as new columns to the original\ntable., returning a tibble. This makes it friendly for\npipe-oriented programming with magrittr.\n","ec":"bind_re_match_(df, from, ..., keep_match = FALSE)"},{"p":"rematch2","o":"re_exec","f":"hp_re_exec","d":"Match a regular expression to a string, and return matches, match positions,\nand capture groups.  This function is like its\nmatch counterpart, except it returns match/capture\ngroup start and end positions in addition to the matched values.\n","ec":"re_exec(text, pattern, perl = TRUE, ...)"},{"p":"rlang","o":"get_expr","f":"hp_get_expr","d":"These helpers are useful to make your function work generically\nwith quosures and raw expressions. First call get_expr() to\nextract an expression. Once you're done processing the expression,\ncall set_expr() on the original object to update the expression.\nYou can return the result of set_expr(), either a formula or an\nexpression depending on the input type. Note that set_expr() does\nnot change its input, it creates a new object.\n","ec":"get_expr(x, default = x)"},{"p":"rlang","o":"is_raw","f":"hp_is_raw","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_raw(x, n = NULL)"},{"p":"rlang","o":"check_dots_used","f":"hp_check_dots_used","d":"When ... arguments are passed to methods, it is assumed there\nmethod will match and use these arguments. If this isn't the case,\nthis often indicates a programming error. Call check_dots_used()\nto fail with an error when unused arguments are detected.\n","ec":"check_dots_used(env = caller_env(), call = caller_env(), error = NULL, action = deprecated())"},{"p":"rlang","o":"set_attrs","f":"hp_set_attrs","d":"\n","ec":"set_attrs(.x, ...)"},{"p":"rlang","o":"search_env","f":"hp_search_env","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"search_env(name)"},{"p":"rlang","o":"is_logical","f":"hp_is_logical","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_logical(x, n = NULL)"},{"p":"rlang","o":"int","f":"hp_int","d":"\n","ec":"int(...)"},{"p":"rlang","o":"env_print","f":"hp_env_print","d":"This prints:\n","ec":"env_print(env = caller_env())"},{"p":"rlang","o":"is_syntactic_literal","f":"hp_is_syntactic_literal","d":"In rlang, an expression is the return type of parse_expr(), the\nset of objects that can be obtained from parsing R code. Under this\ndefinition expressions include numbers, strings, NULL, symbols,\nand function calls. These objects can be classified as:\n","ec":"is_syntactic_literal(x)"},{"p":"rlang","o":"env_binding_are_locked","f":"hp_env_binding_are_locked","d":"\n","ec":"env_binding_are_locked(env, nms = NULL)"},{"p":"rlang","o":"%@%","f":"hp_X...","d":"This operator extracts or sets attributes for regular objects and\nS4 fields for S4 objects.\n","ec":"%@%(x, name)"},{"p":"rlang","o":"entrace","f":"hp_entrace","d":"entrace() is a low level function. See global_entrace() for a\nuser-friendly way of enriching errors and other conditions from\nyour RProfile.\n","ec":"entrace(cnd, ..., top = NULL, bottom = NULL)"},{"p":"rlang","o":"has_length","f":"hp_has_length","d":"This is a function for the common task of testing the length of an\nobject. It checks the length of an object in a non-generic way:\nbase::length() methods are ignored.\n","ec":"has_length(x, n = NULL)"},{"p":"rlang","o":"is_lang","f":"hp_is_lang","d":"\nThese functions are deprecated, please use is_call() and its n\nargument instead.\n","ec":"is_lang(x, name = NULL, n = NULL, ns = NULL)"},{"p":"rlang","o":"env_label","f":"hp_env_label","d":"Special environments like the global environment have their own\nnames. env_name() returns:\n","ec":"env_label(env)"},{"p":"rlang","o":"is_true","f":"hp_is_true","d":"These functions bypass R's automatic conversion rules and check\nthat x is literally TRUE or FALSE.\n","ec":"is_true(x)"},{"p":"rlang","o":"inject","f":"hp_inject","d":"inject() evaluates an expression with injection\nsupport. There are three main usages:\n","ec":"inject(expr, env = caller_env())"},{"p":"rlang","o":"is_call_simple","f":"hp_is_call_simple","d":"call_name() and call_ns() extract the function name or\nnamespace of simple calls as a string. They return NULL for\ncomplex calls.\n","ec":"is_call_simple(x, ns = NULL)"},{"p":"rlang","o":"is_false","f":"hp_is_false","d":"These functions bypass R's automatic conversion rules and check\nthat x is literally TRUE or FALSE.\n","ec":"is_false(x)"},{"p":"rlang","o":"wref_key","f":"hp_wref_key","d":"Get key/value from a weak reference object\n","ec":"wref_key(x)"},{"p":"rlang","o":"warning_cnd","f":"hp_warning_cnd","d":"These constructors create subclassed conditions, the objects that\npower the error, warning, and message system in R.\n","ec":"warning_cnd(class = NULL, ..., message = \"\", call = NULL, use_cli_format = NULL)"},{"p":"rlang","o":"as_data_pronoun","f":"hp_as_data_pronoun","d":"A data mask is an environment (or possibly\nmultiple environments forming an ancestry) containing user-supplied\nobjects. Objects in the mask have precedence over objects in the\nenvironment (i.e. they mask those objects). Many R functions\nevaluate quoted expressions in a data mask so these expressions can\nrefer to objects within the user data.\n","ec":"as_data_pronoun(data)"},{"p":"rlang","o":"ffi_standalone_check_number_1.0.7","f":"hp_ffi_standalone_check_number_1.0.7","d":"Internal API for standalone-types-check\n","ec":""},{"p":"rlang","o":"chr_unserialise_unicode","f":"hp_chr_unserialise_unicode","d":"\n","ec":"chr_unserialise_unicode(chr)"},{"p":"rlang","o":"env_coalesce","f":"hp_env_coalesce","d":"Both these functions preserve active bindings and promises (the\nlatter are only preserved on R >= 4.0.0).\n","ec":"env_coalesce(env, from)"},{"p":"rlang","o":"expr","f":"hp_expr","d":"expr() defuses an R expression with\ninjection support.\n","ec":"expr(expr)"},{"p":"rlang","o":"fn_body","f":"hp_fn_body","d":"fn_body() is a simple wrapper around base::body(). It always\nreturns a <U+2060>\\{<U+2060> expression and throws an error when the input is a\nprimitive function (whereas body() returns NULL). The setter\nversion preserves attributes, unlike <U+2060>body<-<U+2060>.\n","ec":"fn_body(fn = caller_fn())"},{"p":"rlang","o":"env_bind_active","f":"hp_env_bind_active","d":"These functions create bindings in an environment. The bindings are\nsupplied through ... as pairs of names and values or expressions.\nenv_bind() is equivalent to evaluating a <U+2060><-<U+2060> expression within\nthe given environment. This function should take care of the\nmajority of use cases but the other variants can be useful for\nspecific problems.\n","ec":"env_bind_active(.env, ...)"},{"p":"rlang","o":"current_call","f":"hp_current_call","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"current_call()"},{"p":"rlang","o":"ns_imports_env","f":"hp_ns_imports_env","d":"Namespaces are the environment where all the functions of a package\nlive. The parent environments of namespaces are the imports\nenvironments, which contain all the functions imported from other\npackages.\n","ec":"ns_imports_env(x = caller_env())"},{"p":"rlang","o":"is_scalar_integer","f":"hp_is_scalar_integer","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_integer(x)"},{"p":"rlang","o":"is_zap","f":"hp_is_zap","d":"zap() creates a sentinel object that indicates that an object\nshould be removed. For instance, named zaps instruct env_bind()\nand call_modify() to remove those objects from the environment or\nthe call.\n","ec":"is_zap(x)"},{"p":"rlang","o":"call_modify","f":"hp_call_modify","d":"If you are working with a user-supplied call, make sure the\narguments are standardised with call_match() before\nmodifying the call.\n","ec":"call_modify(.call, ..., .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .standardise = NULL, .env = caller_env())"},{"p":"rlang","o":"is_lgl_na","f":"hp_is_lgl_na","d":"\n","ec":"is_lgl_na(x)"},{"p":"rlang","o":"global_entrace","f":"hp_global_entrace","d":"global_entrace() enriches base errors, warnings, and messages\nwith rlang features.\n","ec":"global_entrace(enable = TRUE, class = c(\"error\", \"warning\", \"message\"))"},{"p":"rlang","o":"is_bare_vector","f":"hp_is_bare_vector","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_vector(x, n = NULL)"},{"p":"rlang","o":"pkg_env_name","f":"hp_pkg_env_name","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"pkg_env_name(pkg)"},{"p":"rlang","o":"return_from","f":"hp_return_from","d":"\n","ec":"return_from(frame, value = NULL)"},{"p":"rlang","o":"env_length","f":"hp_env_length","d":"env_names() returns object names from an enviroment env as a\ncharacter vector. All names are returned, even those starting with\na dot. env_length() returns the number of bindings.\n","ec":"env_length(env)"},{"p":"rlang","o":"is_missing","f":"hp_is_missing","d":"These functions help using the missing argument as a regular R\nobject.\n","ec":"is_missing(x)"},{"p":"rlang","o":"dots_list","f":"hp_dots_list","d":"list2(...) is equivalent to list(...) with a few additional\nfeatures, collectively called dynamic dots. While\nlist2() hard-code these features, dots_list() is a lower-level\nversion that offers more control.\n","ec":"dots_list(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":"on_load","f":"hp_on_load","d":"on_load() is for your own package and runs expressions when the\nnamespace is not sealed yet. This means you can modify existing\nbinding or create new ones. This is not the case with\non_package_load() which runs expressions after a foreign package\nhas finished loading, at which point its namespace is sealed.\n","ec":"on_load(expr, env = parent.frame(), ns = topenv(env))"},{"p":"rlang","o":"flatten_lgl","f":"hp_flatten_lgl","d":"\n","ec":"flatten_lgl(x)"},{"p":"rlang","o":"env_get","f":"hp_env_get","d":"env_get() extracts an object from an enviroment env. By\ndefault, it does not look in the parent environments.\nenv_get_list() extracts multiple objects from an environment into\na named list.\n","ec":"env_get(env = caller_env(), nm, default, inherit = FALSE, last = empty_env())"},{"p":"rlang","o":"peek_option","f":"hp_peek_option","d":"For local_options() and push_options(), the old option\nvalues. peek_option() returns the current value of an option\nwhile the plural peek_options() returns a list of current\noption values.\n","ec":"peek_option(name)"},{"p":"rlang","o":"is_scalar_double","f":"hp_is_scalar_double","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_double(x)"},{"p":"rlang","o":"raw_deparse_str","f":"hp_raw_deparse_str","d":"\n","ec":"raw_deparse_str(x, prefix = NULL, suffix = NULL)"},{"p":"rlang","o":"frame_fn","f":"hp_frame_fn","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"frame_fn(frame = caller_env())"},{"p":"rlang","o":"is_call","f":"hp_is_call","d":"This function tests if x is a call. This is a\npattern-matching predicate that returns FALSE if name and n\nare supplied and the call does not match these properties.\n","ec":"is_call(x, name = NULL, n = NULL, ns = NULL)"},{"p":"rlang","o":"is_formula","f":"hp_is_formula","d":"is_formula() tests whether x is a call to ~. is_bare_formula()\ntests in addition that x does not inherit from anything else than\n\"formula\".\n","ec":"is_formula(x, scoped = NULL, lhs = NULL)"},{"p":"rlang","o":"na_lgl","f":"hp_na_lgl","d":"\n","ec":""},{"p":"rlang","o":".data","f":"hp_.data","d":"The .data and .env pronouns make it explicit where to find\nobjects when programming with data-masked\nfunctions.\n","ec":""},{"p":"rlang","o":"is_spliced_bare","f":"hp_is_spliced_bare","d":"The splicing operator <U+2060>!!!<U+2060> operates both in values contexts like\nlist2() and dots_list(), and in metaprogramming contexts like\nexpr(), enquos(), or inject(). While the end result looks the\nsame, the implementation is different and much more efficient in\nthe value cases. This difference in implementation may cause\nperformance issues for instance when going from:\n","ec":"is_spliced_bare(x)"},{"p":"rlang","o":"enquos","f":"hp_enquos","d":"enquo() and enquos() defuse function arguments.\nA defused expression can be examined, modified, and injected into\nother expressions.\n","ec":"enquos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .ignore_null = c(\"none\", \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":"is_spliced","f":"hp_is_spliced","d":"The splicing operator <U+2060>!!!<U+2060> operates both in values contexts like\nlist2() and dots_list(), and in metaprogramming contexts like\nexpr(), enquos(), or inject(). While the end result looks the\nsame, the implementation is different and much more efficient in\nthe value cases. This difference in implementation may cause\nperformance issues for instance when going from:\n","ec":"is_spliced(x)"},{"p":"rlang","o":"flatten_if","f":"hp_flatten_if","d":"\n","ec":"flatten_if(x, predicate = is_spliced)"},{"p":"rlang","o":"format_error_bullets","f":"hp_format_error_bullets","d":"format_error_bullets() takes a character vector and returns a single\nstring (or an empty vector if the input is empty). The elements of\nthe input vector are assembled as a list of bullets, depending on\ntheir names:\n","ec":"format_error_bullets(x)"},{"p":"rlang","o":"new_quosures","f":"hp_new_quosures","d":"This small S3 class provides methods for [ and c() and ensures\nthe following invariants:\n","ec":"new_quosures(x)"},{"p":"rlang","o":"is_character","f":"hp_is_character","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_character(x, n = NULL)"},{"p":"rlang","o":"as_name","f":"hp_as_name","d":"as_name() converts symbols to character strings. The\nconversion is deterministic. That is, the roundtrip symbol -> name -> symbol always gives the same result.\n","ec":"as_name(x)"},{"p":"rlang","o":"arg_match0","f":"hp_arg_match0","d":"This is equivalent to base::match.arg() with a few differences:\n","ec":"arg_match0(arg, values, arg_nm = caller_arg(arg), error_call = caller_env())"},{"p":"rlang","o":"done","f":"hp_done","d":"A value boxed with done() signals to its caller that it\nshould stop iterating. Use it to shortcircuit a loop.\n","ec":"done(x)"},{"p":"rlang","o":"is_closure","f":"hp_is_closure","d":"The R language defines two different types of functions: primitive\nfunctions, which are low-level, and closures, which are the regular\nkind of functions.\n","ec":"is_closure(x)"},{"p":"rlang","o":"global_frame","f":"hp_global_frame","d":"\nDeprecated as of rlang 0.3.0.\n","ec":"global_frame()"},{"p":"rlang","o":"pairlist2","f":"hp_pairlist2","d":"This pairlist constructor uses dynamic dots. Use\nit to manually create argument lists for calls or parameter lists\nfor functions.\n","ec":"pairlist2(...)"},{"p":"rlang","o":"new_logical","f":"hp_new_logical","d":"\n","ec":"new_logical(n, names = NULL)"},{"p":"rlang","o":"is_empty","f":"hp_is_empty","d":"Is object an empty vector or NULL?\n","ec":"is_empty(x)"},{"p":"rlang","o":"empty_env","f":"hp_empty_env","d":"The empty environment is the only one that does not have a parent.\nIt is always used as the tail of an environment chain such as the\nsearch path (see search_envs()).\n","ec":"empty_env()"},{"p":"rlang","o":"is_bare_double","f":"hp_is_bare_double","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_double(x, n = NULL)"},{"p":"rlang","o":"as_function","f":"hp_as_function","d":"as_function() transforms a one-sided formula into a function.\nThis powers the lambda syntax in packages like purrr.\n","ec":"as_function(x, env = global_env(), ..., arg = caller_arg(x), call = caller_env())"},{"p":"rlang","o":"UQS","f":"hp_UQS","d":"\nThese operators are deprecated in favour of\n!! and !!!.\n","ec":"UQS(x)"},{"p":"rlang","o":"rep_along","f":"hp_rep_along","d":"These functions take the idea of seq_along() and apply it to\nrepeating values.\n","ec":"rep_along(along, x)"},{"p":"rlang","o":"quo_set_env","f":"hp_quo_set_env","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_set_env(quo, env)"},{"p":"rlang","o":"splice","f":"hp_splice","d":"The splicing operator <U+2060>!!!<U+2060> operates both in values contexts like\nlist2() and dots_list(), and in metaprogramming contexts like\nexpr(), enquos(), or inject(). While the end result looks the\nsame, the implementation is different and much more efficient in\nthe value cases. This difference in implementation may cause\nperformance issues for instance when going from:\n","ec":"splice(x)"},{"p":"rlang","o":"syms","f":"hp_syms","d":"Symbols are a kind of defused expression that\nrepresent objects in environments.\n","ec":"syms(x)"},{"p":"rlang","o":"is_primitive_lazy","f":"hp_is_primitive_lazy","d":"The R language defines two different types of functions: primitive\nfunctions, which are low-level, and closures, which are the regular\nkind of functions.\n","ec":"is_primitive_lazy(x)"},{"p":"rlang","o":"caller_env","f":"hp_caller_env","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"caller_env(n = 1)"},{"p":"rlang","o":"is_scalar_character","f":"hp_is_scalar_character","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_character(x)"},{"p":"rlang","o":"new_environment","f":"hp_new_environment","d":"These functions create new environments.\n","ec":"new_environment(data = list(), parent = empty_env())"},{"p":"rlang","o":"env_cache","f":"hp_env_cache","d":"env_cache() is a wrapper around env_get() and env_poke()\ndesigned to retrieve a cached value from env.\n","ec":"env_cache(env, nm, default)"},{"p":"rlang","o":"is_named2","f":"hp_is_named2","d":"is_named() always returns TRUE for empty vectors because\n","ec":"is_named2(x)"},{"p":"rlang","o":"flatten_chr","f":"hp_flatten_chr","d":"\n","ec":"flatten_chr(x)"},{"p":"rlang","o":"flatten_raw","f":"hp_flatten_raw","d":"\n","ec":"flatten_raw(x)"},{"p":"rlang","o":"cnd","f":"hp_cnd","d":"These constructors create subclassed conditions, the objects that\npower the error, warning, and message system in R.\n","ec":"cnd(class, ..., message = \"\", call = NULL, use_cli_format = NULL)"},{"p":"rlang","o":"exprs_auto_name","f":"hp_exprs_auto_name","d":"This gives default names to unnamed elements of a list of\nexpressions (or expression wrappers such as formulas or\nquosures), deparsed with as_label().\n","ec":"exprs_auto_name(exprs, ..., repair_auto = c(\"minimal\", \"unique\"), repair_quiet = FALSE)"},{"p":"rlang","o":"lang","f":"hp_lang","d":"\nThese functions are deprecated, please use call2() and\nnew_call() instead.\n","ec":"lang(.fn, ..., .ns = NULL)"},{"p":"rlang","o":"flatten_cpl","f":"hp_flatten_cpl","d":"\n","ec":"flatten_cpl(x)"},{"p":"rlang","o":"quo_expr","f":"hp_quo_expr","d":"\nThis function is deprecated, please use quo_squash() instead.\n","ec":"quo_expr(quo, warn = FALSE)"},{"p":"rlang","o":"is_integer","f":"hp_is_integer","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_integer(x, n = NULL)"},{"p":"rlang","o":"f_label","f":"hp_f_label","d":"Equivalent of expr_text() and expr_label() for formulas.\n","ec":"f_label(x)"},{"p":"rlang","o":"exiting","f":"hp_exiting","d":"\n","ec":"exiting(handler)"},{"p":"rlang","o":"env_clone","f":"hp_env_clone","d":"Both these functions preserve active bindings and promises (the\nlatter are only preserved on R >= 4.0.0).\n","ec":"env_clone(env, parent = env_parent(env))"},{"p":"rlang","o":"%<~%","f":"hp_X....","d":"These functions create bindings in an environment. The bindings are\nsupplied through ... as pairs of names and values or expressions.\nenv_bind() is equivalent to evaluating a <U+2060><-<U+2060> expression within\nthe given environment. This function should take care of the\nmajority of use cases but the other variants can be useful for\nspecific problems.\n","ec":"%<~%(lhs, rhs)"},{"p":"rlang","o":"as_utf8_character","f":"hp_as_utf8_character","d":"\n","ec":"as_utf8_character(x)"},{"p":"rlang","o":"is_scoped","f":"hp_is_scoped","d":"\n","ec":"is_scoped(nm)"},{"p":"rlang","o":"search_envs","f":"hp_search_envs","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"search_envs()"},{"p":"rlang","o":"is_atomic","f":"hp_is_atomic","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_atomic(x, n = NULL)"},{"p":"rlang","o":"names2<-","f":"hp_names2..","d":"names2() always returns a character vector, even when an\nobject does not have a names attribute. In this case, it returns\na vector of empty names \"\". It also standardises missing names to\n\"\".\n","ec":"names2<-(x, value)"},{"p":"rlang","o":"cnd_type","f":"hp_cnd_type","d":"Use cnd_type() to check what type a condition is.\n","ec":"cnd_type(cnd)"},{"p":"rlang","o":"scoped_env","f":"hp_scoped_env","d":"\n","ec":"scoped_env(nm)"},{"p":"rlang","o":"is_bare_string","f":"hp_is_bare_string","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_string(x, n = NULL)"},{"p":"rlang","o":"as_list","f":"hp_as_list","d":"\n","ec":"as_list(x)"},{"p":"rlang","o":"is_namespace","f":"hp_is_namespace","d":"Is an object a namespace environment?\n","ec":"is_namespace(x)"},{"p":"rlang","o":"is_bare_character","f":"hp_is_bare_character","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_character(x, n = NULL)"},{"p":"rlang","o":"zap","f":"hp_zap","d":"zap() creates a sentinel object that indicates that an object\nshould be removed. For instance, named zaps instruct env_bind()\nand call_modify() to remove those objects from the environment or\nthe call.\n","ec":"zap()"},{"p":"rlang","o":"ns_registry_env","f":"hp_ns_registry_env","d":"Note that the namespace registry does not behave like a normal\nenvironment because the parent is NULL instead of the empty\nenvironment. This is exported for expert usage in development tools\nonly.\n","ec":"ns_registry_env()"},{"p":"rlang","o":"is_scalar_logical","f":"hp_is_scalar_logical","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_logical(x)"},{"p":"rlang","o":"call_ns","f":"hp_call_ns","d":"call_name() and call_ns() extract the function name or\nnamespace of simple calls as a string. They return NULL for\ncomplex calls.\n","ec":"call_ns(call)"},{"p":"rlang","o":"new_formula","f":"hp_new_formula","d":"Create a formula\n","ec":"new_formula(lhs, rhs, env = caller_env())"},{"p":"rlang","o":"!!!","f":"hp_X...","d":"The splice operator <U+2060>!!!<U+2060> implemented in dynamic dots\ninjects a list of arguments into a function call. It belongs to the\nfamily of injection operators and provides the same\nfunctionality as do.call().\n","ec":"!!!(x)"},{"p":"rlang","o":"wref_value","f":"hp_wref_value","d":"Get key/value from a weak reference object\n","ec":"wref_value(x)"},{"p":"rlang","o":"quo_set_expr","f":"hp_quo_set_expr","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_set_expr(quo, expr)"},{"p":"rlang","o":"expr_print","f":"hp_expr_print","d":"expr_print(), powered by expr_deparse(), is an alternative\nprinter for R expressions with a few improvements over the base R\nprinter.\n","ec":"expr_print(x, ...)"},{"p":"rlang","o":"new_double","f":"hp_new_double","d":"\n","ec":"new_double(n, names = NULL)"},{"p":"rlang","o":"last_trace","f":"hp_last_trace","ec":"last_trace(drop = NULL)"},{"p":"rlang","o":"dots_n","f":"hp_dots_n","d":"This returns the number of arguments currently forwarded in ...\nas an integer.\n","ec":"dots_n(...)"},{"p":"rlang","o":"cpl","f":"hp_cpl","d":"\n","ec":"cpl(...)"},{"p":"rlang","o":"env_name","f":"hp_env_name","d":"Special environments like the global environment have their own\nnames. env_name() returns:\n","ec":"env_name(env)"},{"p":"rlang","o":"is_attached","f":"hp_is_attached","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"is_attached(x)"},{"p":"rlang","o":"as_character","f":"hp_as_character","d":"\n","ec":"as_character(x, encoding = NULL)"},{"p":"rlang","o":"is_scalar_atomic","f":"hp_is_scalar_atomic","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_atomic(x)"},{"p":"rlang","o":"check_dots_empty","f":"hp_check_dots_empty","d":"... can be inserted in a function signature to force users to\nfully name the details arguments. In this case, supplying data in\n... is almost always a programming error. This function checks\nthat ... is empty and fails otherwise.\n","ec":"check_dots_empty(env = caller_env(), error = NULL, call = caller_env(), action = abort)"},{"p":"rlang","o":"is_bytes","f":"hp_is_bytes","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_bytes(x, n = NULL)"},{"p":"rlang","o":"is_complex","f":"hp_is_complex","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_complex(x, n = NULL, finite = NULL)"},{"p":"rlang","o":"as_string","f":"hp_as_string","d":"as_string() converts symbols to character strings.\n","ec":"as_string(x)"},{"p":"rlang","o":"is_vector","f":"hp_is_vector","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_vector(x, n = NULL)"},{"p":"rlang","o":"fn_env<-","f":"hp_fn_env..","d":"Closure environments define the scope of functions (see env()).\nWhen a function call is evaluated, R creates an evaluation frame\nthat inherits from the closure environment. This makes all objects\ndefined in the closure environment and all its parents available to\ncode executed within the function.\n","ec":"fn_env<-(x, value)"},{"p":"rlang","o":"check_dots_unnamed","f":"hp_check_dots_unnamed","d":"In functions like paste(), named arguments in ... are often a\nsign of misspelled argument names. Call check_dots_unnamed() to\nfail with an error when named arguments are detected.\n","ec":"check_dots_unnamed(env = caller_env(), error = NULL, call = caller_env(), action = abort)"},{"p":"rlang","o":"get_env","f":"hp_get_env","d":"These functions dispatch internally with methods for functions,\nformulas and frames. If called with a missing argument, the\nenvironment of the current evaluation frame is returned. If you\ncall get_env() with an environment, it acts as the identity\nfunction and the environment is simply returned (this helps\nsimplifying code when writing generic functions for environments).\n","ec":"get_env(env, default = NULL)"},{"p":"rlang","o":"new_quosure","f":"hp_new_quosure","ec":"new_quosure(expr, env = caller_env())"},{"p":"rlang","o":"obj_address","f":"hp_obj_address","d":"Address of an R object\n","ec":"obj_address(x)"},{"p":"rlang","o":"is_integerish","f":"hp_is_integerish","d":"These predicates check whether R considers a number vector to be\ninteger-like, according to its own tolerance check (which is in\nfact delegated to the C library). This function is not adapted to\ndata analysis, see the help for base::is.integer() for examples\nof how to check for whole numbers.\n","ec":"is_integerish(x, n = NULL, finite = NULL)"},{"p":"rlang","o":"is_done_box","f":"hp_is_done_box","d":"A value boxed with done() signals to its caller that it\nshould stop iterating. Use it to shortcircuit a loop.\n","ec":"is_done_box(x, empty = NULL)"},{"p":"rlang","o":"is_bare_bytes","f":"hp_is_bare_bytes","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_bytes(x, n = NULL)"},{"p":"rlang","o":"fn_fmls_names<-","f":"hp_fn_fmls_names..","d":"fn_fmls() returns a named list of formal arguments.\nfn_fmls_names() returns the names of the arguments.\nfn_fmls_syms() returns formals as a named list of symbols. This\nis especially useful for forwarding arguments in constructed calls.\n","ec":"fn_fmls_names<-(fn, value)"},{"p":"rlang","o":"quo","f":"hp_quo","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"quo(expr)"},{"p":"rlang","o":"data_syms","f":"hp_data_syms","d":"Symbols are a kind of defused expression that\nrepresent objects in environments.\n","ec":"data_syms(x)"},{"p":"rlang","o":"is_scalar_list","f":"hp_is_scalar_list","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_list(x)"},{"p":"rlang","o":"eval_bare","f":"hp_eval_bare","d":"eval_bare() is a lower-level version of function base::eval().\nTechnically, it is a simple wrapper around the C function\nRf_eval(). You generally don't need to use eval_bare() instead\nof eval(). Its main advantage is that it handles stack-sensitive\ncalls (such as return(), on.exit() or parent.frame()) more\nconsistently when you pass an enviroment of a frame on the call\nstack.\n","ec":"eval_bare(expr, env = parent.frame())"},{"p":"rlang","o":"is_pairlist","f":"hp_is_pairlist","d":"These functions are experimental. We are still figuring out a good\nnaming convention to refer to the different lisp-like lists in R.\n","ec":"is_pairlist(x)"},{"p":"rlang","o":"as_bytes","f":"hp_as_bytes","d":"Construct, manipulate and display vectors of byte sizes. These are numeric\nvectors, so you can compare them numerically, but they can also be compared\nto human readable values such as '10MB'.\n","ec":"as_bytes(x)"},{"p":"rlang","o":"reset_message_verbosity","f":"hp_reset_message_verbosity","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"reset_message_verbosity(id)"},{"p":"rlang","o":"fn_fmls<-","f":"hp_fn_fmls..","d":"fn_fmls() returns a named list of formal arguments.\nfn_fmls_names() returns the names of the arguments.\nfn_fmls_syms() returns formals as a named list of symbols. This\nis especially useful for forwarding arguments in constructed calls.\n","ec":"fn_fmls<-(fn, value)"},{"p":"rlang","o":"inherits_all","f":"hp_inherits_all","ec":"inherits_all(x, class)"},{"p":"rlang","o":"is_installed","f":"hp_is_installed","d":"These functions check that packages are installed with minimal side\neffects. If installed, the packages will be loaded but not\nattached.\n","ec":"is_installed(pkg, ..., version = NULL, compare = NULL)"},{"p":"rlang","o":"check_installed","f":"hp_check_installed","d":"These functions check that packages are installed with minimal side\neffects. If installed, the packages will be loaded but not\nattached.\n","ec":"check_installed(pkg, reason = NULL, ..., version = NULL, compare = NULL, action = NULL, call = caller_env())"},{"p":"rlang","o":"dbl","f":"hp_dbl","d":"\n","ec":"dbl(...)"},{"p":"rlang","o":"is_dbl_na","f":"hp_is_dbl_na","d":"\n","ec":"is_dbl_na(x)"},{"p":"rlang","o":"is_bare_integer","f":"hp_is_bare_integer","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_integer(x, n = NULL)"},{"p":"rlang","o":"fn_fmls_names","f":"hp_fn_fmls_names","d":"fn_fmls() returns a named list of formal arguments.\nfn_fmls_names() returns the names of the arguments.\nfn_fmls_syms() returns formals as a named list of symbols. This\nis especially useful for forwarding arguments in constructed calls.\n","ec":"fn_fmls_names(fn = caller_fn())"},{"p":"rlang","o":"quo_text","f":"hp_quo_text","d":"\n","ec":"quo_text(quo, width = 60L, nlines = Inf)"},{"p":"rlang","o":"quo_is_null","f":"hp_quo_is_null","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_is_null(quo)"},{"p":"rlang","o":"set_env","f":"hp_set_env","d":"These functions dispatch internally with methods for functions,\nformulas and frames. If called with a missing argument, the\nenvironment of the current evaluation frame is returned. If you\ncall get_env() with an environment, it acts as the identity\nfunction and the environment is simply returned (this helps\nsimplifying code when writing generic functions for environments).\n","ec":"set_env(env, new_env = caller_env())"},{"p":"rlang","o":"abort","f":"hp_abort","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"abort(message = NULL, class = NULL, ..., call, body = NULL, footer = NULL, trace = NULL, parent = NULL, use_cli_format = NULL, .inherit = TRUE, .internal = FALSE, .file = NULL, .frame = caller_env(), .trace_bottom = NULL, .subclass = deprecated())"},{"p":"rlang","o":"enquo","f":"hp_enquo","d":"enquo() and enquos() defuse function arguments.\nA defused expression can be examined, modified, and injected into\nother expressions.\n","ec":"enquo(arg)"},{"p":"rlang","o":"is_double","f":"hp_is_double","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_double(x, n = NULL, finite = NULL)"},{"p":"rlang","o":"env_browse","f":"hp_env_browse","d":"env_browse() returns the previous value of\nenv_is_browsed() (a logical), invisibly.\n","ec":"env_browse(env, value = TRUE)"},{"p":"rlang","o":"inherits_any","f":"hp_inherits_any","ec":"inherits_any(x, class)"},{"p":"rlang","o":"as_complex","f":"hp_as_complex","d":"\n","ec":"as_complex(x)"},{"p":"rlang","o":"is_copyable","f":"hp_is_copyable","d":"When an object is modified, R generally copies it (sometimes\nlazily) to enforce value semantics.\nHowever, some internal types are uncopyable. If you try to copy\nthem, either with <U+2060><-<U+2060> or by argument passing, you actually create\nreferences to the original object rather than actual\ncopies. Modifying these references can thus have far reaching side\neffects.\n","ec":"is_copyable(x)"},{"p":"rlang","o":"%@%<-","f":"hp_X.....","d":"This operator extracts or sets attributes for regular objects and\nS4 fields for S4 objects.\n","ec":"%@%<-(x, name, value)"},{"p":"rlang","o":"%|%","f":"hp_X...","d":"Note: This operator is now out of scope for rlang. It will be\nreplaced by a vctrs-powered operator (probably in the funs package) at which point the\nrlang version of <U+2060>%|%<U+2060> will be deprecated.\n","ec":"%|%(x, y)"},{"p":"rlang","o":"call_args","f":"hp_call_args","d":"Extract arguments from a call\n","ec":"call_args(call)"},{"p":"rlang","o":"!!","f":"hp_X..","d":"The injection operator <U+2060>!!<U+2060> injects a value or\nexpression inside another expression. In other words, it modifies a\npiece of code before R evaluates it.\n","ec":"!!(x)"},{"p":"rlang","o":"new_weakref","f":"hp_new_weakref","d":"A weak reference is a special R object which makes it possible to keep a\nreference to an object without preventing garbage collection of that object.\nIt can also be used to keep data about an object without preventing GC of the\nobject, similar to WeakMaps in JavaScript.\n","ec":"new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)"},{"p":"rlang","o":"cnd_header","f":"hp_cnd_header","d":"cnd_message() assembles an error message from three generics:\n","ec":"cnd_header(cnd, ...)"},{"p":"rlang","o":"is_primitive_eager","f":"hp_is_primitive_eager","d":"The R language defines two different types of functions: primitive\nfunctions, which are low-level, and closures, which are the regular\nkind of functions.\n","ec":"is_primitive_eager(x)"},{"p":"rlang","o":"expr_name","f":"hp_expr_name","d":"\n","ec":"expr_name(expr)"},{"p":"rlang","o":"scoped_interactive","f":"hp_scoped_interactive","d":"\n","ec":"scoped_interactive(value = TRUE, frame = caller_env())"},{"p":"rlang","o":"as_closure","f":"hp_as_closure","d":"as_closure() is like as_function() but also wraps primitive\nfunctions inside closures. Some special control flow primitives\nlike if, for, or break can't be wrapped and will cause an\nerror.\n","ec":"as_closure(x, env = caller_env())"},{"p":"rlang","o":"is_dictionaryish","f":"hp_is_dictionaryish","d":"Like is_named() but also checks that names are unique.\n","ec":"is_dictionaryish(x)"},{"p":"rlang","o":"is_quosure","f":"hp_is_quosure","ec":"is_quosure(x)"},{"p":"rlang","o":"locally","f":"hp_locally","d":"\n","ec":"locally(expr)"},{"p":"rlang","o":"parse_quos","f":"hp_parse_quos","d":"These functions parse and transform text into R expressions. This\nis the first step to interpret or evaluate a piece of R code\nwritten by a programmer.\n","ec":"parse_quos(x, env)"},{"p":"rlang","o":"env_lock","f":"hp_env_lock","d":"\n","ec":"env_lock(env)"},{"p":"rlang","o":"call_standardise","f":"hp_call_standardise","d":"\n","ec":"call_standardise(call, env = caller_env())"},{"p":"rlang","o":"coerce_class","f":"hp_coerce_class","d":"\n\n","ec":"coerce_class(.x, .to, ...)"},{"p":"rlang","o":"eval_tidy","f":"hp_eval_tidy","d":"eval_tidy() is a variant of base::eval() that powers the tidy\nevaluation framework. Like eval() it accepts user data as\nargument. Whereas eval() simply transforms the data to an\nenvironment, eval_tidy() transforms it to a data mask with as_data_mask(). Evaluating in a data\nmask enables the following features:\n","ec":"eval_tidy(expr, data = NULL, env = caller_env())"},{"p":"rlang","o":"set_names","f":"hp_set_names","d":"This is equivalent to stats::setNames(), with more features and\nstricter argument checking.\n","ec":"set_names(x, nm = x, ...)"},{"p":"rlang","o":"base_env","f":"hp_base_env","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"base_env()"},{"p":"rlang","o":"scoped_options","f":"hp_scoped_options","d":"\n","ec":"scoped_options(..., .frame = caller_env())"},{"p":"rlang","o":"as_double","f":"hp_as_double","d":"\n","ec":"as_double(x)"},{"p":"rlang","o":"with_handlers","f":"hp_with_handlers","d":"\n","ec":"with_handlers(.expr, ...)"},{"p":"rlang","o":"rep_named","f":"hp_rep_named","d":"These functions take the idea of seq_along() and apply it to\nrepeating values.\n","ec":"rep_named(names, x)"},{"p":"rlang","o":"bytes","f":"hp_bytes","d":"\n","ec":"bytes(...)"},{"p":"rlang","o":"fn_body<-","f":"hp_fn_body..","d":"fn_body() is a simple wrapper around base::body(). It always\nreturns a <U+2060>\\{<U+2060> expression and throws an error when the input is a\nprimitive function (whereas body() returns NULL). The setter\nversion preserves attributes, unlike <U+2060>body<-<U+2060>.\n","ec":"fn_body<-(fn, value)"},{"p":"rlang","o":"have_name","f":"hp_have_name","d":"is_named() always returns TRUE for empty vectors because\n","ec":"have_name(x)"},{"p":"rlang","o":"inherits_only","f":"hp_inherits_only","ec":"inherits_only(x, class)"},{"p":"rlang","o":"is_scalar_complex","f":"hp_is_scalar_complex","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_complex(x)"},{"p":"rlang","o":"with_env","f":"hp_with_env","d":"\n","ec":"with_env(env, expr)"},{"p":"rlang","o":":=","f":"hp_X..","d":"The base ... syntax supports:\n","ec":":=(x, y)"},{"p":"rlang","o":"is_box","f":"hp_is_box","d":"new_box() is similar to base::I() but it protects a value by\nwrapping it in a scalar list rather than by adding an attribute.\nunbox() retrieves the boxed value. is_box() tests whether an\nobject is boxed with optional class. as_box() ensures that a\nvalue is wrapped in a box. as_box_if() does the same but only if\nthe value matches a predicate.\n","ec":"is_box(x, class = NULL)"},{"p":"rlang","o":"is_int_na","f":"hp_is_int_na","d":"\n","ec":"is_int_na(x)"},{"p":"rlang","o":"parse_exprs","f":"hp_parse_exprs","d":"These functions parse and transform text into R expressions. This\nis the first step to interpret or evaluate a piece of R code\nwritten by a programmer.\n","ec":"parse_exprs(x)"},{"p":"rlang","o":"is_string","f":"hp_is_string","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_string(x, string = NULL)"},{"p":"rlang","o":"na_chr","f":"hp_na_chr","d":"-NA-","ec":"-NA-"},{"p":"rlang","o":"is_list","f":"hp_is_list","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_list(x, n = NULL)"},{"p":"rlang","o":"trace_length","f":"hp_trace_length","d":"A backtrace captures the sequence of calls that lead to the current\nfunction (sometimes called the call stack). Because of lazy\nevaluation, the call stack in R is actually a tree, which the\nprint() method for this object will reveal.\n","ec":"trace_length(trace)"},{"p":"rlang","o":"quos","f":"hp_quos","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"quos(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .unquote_names = TRUE)"},{"p":"rlang","o":"as_integer","f":"hp_as_integer","d":"\n","ec":"as_integer(x)"},{"p":"rlang","o":"inform","f":"hp_inform","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"inform(message = NULL, class = NULL, ..., body = NULL, footer = NULL, parent = NULL, use_cli_format = NULL, .inherit = NULL, .file = NULL, .frequency = c(\"always\", \"regularly\", \"once\"), .frequency_id = NULL, .subclass = deprecated())"},{"p":"rlang","o":"try_fetch","f":"hp_try_fetch","d":"\n","ec":"try_fetch(expr, ...)"},{"p":"rlang","o":"squash_if","f":"hp_squash_if","d":"\n","ec":"squash_if(x, predicate = is_spliced)"},{"p":"rlang","o":"expr_text","f":"hp_expr_text","d":"\n","ec":"expr_text(expr, width = 60L, nlines = Inf)"},{"p":"rlang","o":"englue","f":"hp_englue","d":"englue() creates a string with the glue operators <U+2060>{<U+2060> and <U+2060>{{<U+2060>. These operators are\nnormally used to inject names within dynamic dots.\nenglue() makes them available anywhere within a function.\n","ec":"englue(x, env = caller_env(), error_call = current_env(), error_arg = \"x\")"},{"p":"rlang","o":"is_reference","f":"hp_is_reference","d":"There are typically two situations where two symbols may refer to\nthe same object.\n","ec":"is_reference(x, y)"},{"p":"rlang","o":"with_options","f":"hp_with_options","d":"For local_options() and push_options(), the old option\nvalues. peek_option() returns the current value of an option\nwhile the plural peek_options() returns a list of current\noption values.\n","ec":"with_options(.expr, ...)"},{"p":"rlang","o":"env","f":"hp_env","d":"These functions create new environments.\n","ec":"env(...)"},{"p":"rlang","o":"as_data_mask","f":"hp_as_data_mask","d":"A data mask is an environment (or possibly\nmultiple environments forming an ancestry) containing user-supplied\nobjects. Objects in the mask have precedence over objects in the\nenvironment (i.e. they mask those objects). Many R functions\nevaluate quoted expressions in a data mask so these expressions can\nrefer to objects within the user data.\n","ec":"as_data_mask(data)"},{"p":"rlang","o":"is_bare_atomic","f":"hp_is_bare_atomic","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_atomic(x, n = NULL)"},{"p":"rlang","o":"is_bare_integerish","f":"hp_is_bare_integerish","d":"These predicates check whether R considers a number vector to be\ninteger-like, according to its own tolerance check (which is in\nfact delegated to the C library). This function is not adapted to\ndata analysis, see the help for base::is.integer() for examples\nof how to check for whole numbers.\n","ec":"is_bare_integerish(x, n = NULL, finite = NULL)"},{"p":"rlang","o":"na_int","f":"hp_na_int","d":"\n","ec":""},{"p":"rlang","o":"seq2","f":"hp_seq2","d":"These helpers take two endpoints and return the sequence of all\nintegers within that interval. For seq2_along(), the upper\nendpoint is taken from the length of a vector. Unlike\nbase::seq(), they return an empty vector if the starting point is\na larger integer than the end point.\n","ec":"seq2(from, to)"},{"p":"rlang","o":"ffi_standalone_is_bool_1.0.7","f":"hp_ffi_standalone_is_bool_1.0.7","d":"Internal API for standalone-types-check\n","ec":""},{"p":"rlang","o":"maybe_missing","f":"hp_maybe_missing","d":"These functions help using the missing argument as a regular R\nobject.\n","ec":"maybe_missing(x, default = missing_arg())"},{"p":"rlang","o":"f_env<-","f":"hp_f_env..","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_env<-(x, value)"},{"p":"rlang","o":"is_chr_na","f":"hp_is_chr_na","d":"\n","ec":"is_chr_na(x)"},{"p":"rlang","o":"f_text","f":"hp_f_text","d":"Equivalent of expr_text() and expr_label() for formulas.\n","ec":"f_text(x, width = 60L, nlines = Inf)"},{"p":"rlang","o":"env_names","f":"hp_env_names","d":"env_names() returns object names from an enviroment env as a\ncharacter vector. All names are returned, even those starting with\na dot. env_length() returns the number of bindings.\n","ec":"env_names(env)"},{"p":"rlang","o":"quo_is_call","f":"hp_quo_is_call","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_is_call(quo, name = NULL, n = NULL, ns = NULL)"},{"p":"rlang","o":"last_messages","f":"hp_last_messages","d":"last_warnings() and last_messages() return a list of all\nwarnings and messages that occurred during the last R command.\n","ec":"last_messages(n = NULL)"},{"p":"rlang","o":"is_na","f":"hp_is_na","d":"\n","ec":"is_na(x)"},{"p":"rlang","o":"dots_values","f":"hp_dots_values","d":"This is a tool for advanced users. It captures dots, processes\nunquoting and splicing operators, and evaluates them. Unlike\ndots_list(), it does not flatten spliced objects, instead they\nare attributed a spliced class (see splice()). You can process\nspliced objects manually, perhaps with a custom predicate (see\nflatten_if()).\n","ec":"dots_values(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"), .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":"missing_arg","f":"hp_missing_arg","d":"These functions help using the missing argument as a regular R\nobject.\n","ec":"missing_arg()"},{"p":"rlang","o":"prim_name","f":"hp_prim_name","d":"Name of a primitive function\n","ec":"prim_name(prim)"},{"p":"rlang","o":"quo_name","f":"hp_quo_name","d":"\n","ec":"quo_name(quo)"},{"p":"rlang","o":"quos_auto_name","f":"hp_quos_auto_name","d":"This gives default names to unnamed elements of a list of\nexpressions (or expression wrappers such as formulas or\nquosures), deparsed with as_label().\n","ec":"quos_auto_name(quos)"},{"p":"rlang","o":"is_condition","f":"hp_is_condition","d":"Is object a condition?\n","ec":"is_condition(x)"},{"p":"rlang","o":"pkg_env","f":"hp_pkg_env","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"pkg_env(pkg)"},{"p":"rlang","o":"is_interactive","f":"hp_is_interactive","d":"Like base::interactive(), is_interactive() returns TRUE when\nthe function runs interactively and FALSE when it runs in batch\nmode. It also checks, in this order:\n","ec":"is_interactive()"},{"p":"rlang","o":"fn_fmls","f":"hp_fn_fmls","d":"fn_fmls() returns a named list of formal arguments.\nfn_fmls_names() returns the names of the arguments.\nfn_fmls_syms() returns formals as a named list of symbols. This\nis especially useful for forwarding arguments in constructed calls.\n","ec":"fn_fmls(fn = caller_fn())"},{"p":"rlang","o":"quo_label","f":"hp_quo_label","d":"\n","ec":"quo_label(quo)"},{"p":"rlang","o":"calling","f":"hp_calling","d":"\n","ec":"calling(handler)"},{"p":"rlang","o":"string","f":"hp_string","d":"\n","ec":"string(x, encoding = NULL)"},{"p":"rlang","o":"set_expr","f":"hp_set_expr","d":"These helpers are useful to make your function work generically\nwith quosures and raw expressions. First call get_expr() to\nextract an expression. Once you're done processing the expression,\ncall set_expr() on the original object to update the expression.\nYou can return the result of set_expr(), either a formula or an\nexpression depending on the input type. Note that set_expr() does\nnot change its input, it creates a new object.\n","ec":"set_expr(x, value)"},{"p":"rlang","o":"is_quosures","f":"hp_is_quosures","d":"This small S3 class provides methods for [ and c() and ensures\nthe following invariants:\n","ec":"is_quosures(x)"},{"p":"rlang","o":"ll","f":"hp_ll","d":"list2(...) is equivalent to list(...) with a few additional\nfeatures, collectively called dynamic dots. While\nlist2() hard-code these features, dots_list() is a lower-level\nversion that offers more control.\n","ec":"ll(...)"},{"p":"rlang","o":"is_message","f":"hp_is_message","d":"Is object a condition?\n","ec":"is_message(x)"},{"p":"rlang","o":"node_poke_cdar","f":"hp_node_poke_cdar","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_cdar(x, newcdr)"},{"p":"rlang","o":"f_rhs<-","f":"hp_f_rhs..","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_rhs<-(x, value)"},{"p":"rlang","o":"enexprs","f":"hp_enexprs","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"enexprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .ignore_null = c(\"none\", \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":"current_fn","f":"hp_current_fn","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"current_fn()"},{"p":"rlang","o":"as_box_if","f":"hp_as_box_if","ec":"as_box_if(.x, .p, .class = NULL, ...)"},{"p":"rlang","o":"node_caar","f":"hp_node_caar","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_caar(x)"},{"p":"rlang","o":"ctxt_frame","f":"hp_ctxt_frame","d":"\nDeprecated as of rlang 0.3.0.\n","ec":"ctxt_frame(n = 1)"},{"p":"rlang","o":"env_is_browsed","f":"hp_env_is_browsed","d":"env_browse() returns the previous value of\nenv_is_browsed() (a logical), invisibly.\n","ec":"env_is_browsed(env)"},{"p":"rlang","o":"env_parent","f":"hp_env_parent","d":"See the section on inheritance in env()'s documentation.\n","ec":"env_parent(env = caller_env(), n = 1)"},{"p":"rlang","o":"new_data_mask","f":"hp_new_data_mask","d":"A data mask is an environment (or possibly\nmultiple environments forming an ancestry) containing user-supplied\nobjects. Objects in the mask have precedence over objects in the\nenvironment (i.e. they mask those objects). Many R functions\nevaluate quoted expressions in a data mask so these expressions can\nrefer to objects within the user data.\n","ec":"new_data_mask(bottom, top = bottom)"},{"p":"rlang","o":"exec","f":"hp_exec","d":"This function constructs and evaluates a call to .fn.\nIt has two primary uses:\n","ec":"exec(.fn, ..., .env = caller_env())"},{"p":"rlang","o":"UQ","f":"hp_UQ","d":"\nThese operators are deprecated in favour of\n!! and !!!.\n","ec":"UQ(x)"},{"p":"rlang","o":"squash","f":"hp_squash","d":"\n","ec":"squash(x)"},{"p":"rlang","o":"is_bare_logical","f":"hp_is_bare_logical","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_logical(x, n = NULL)"},{"p":"rlang","o":"%||%","f":"hp_X....","d":"This infix function makes it easy to replace NULLs with a default\nvalue. It's inspired by the way that Ruby's or operation (||)\nworks.\n","ec":"%||%(x, y)"},{"p":"rlang","o":"is_bare_formula","f":"hp_is_bare_formula","d":"is_formula() tests whether x is a call to ~. is_bare_formula()\ntests in addition that x does not inherit from anything else than\n\"formula\".\n","ec":"is_bare_formula(x, scoped = TRUE, lhs = NULL)"},{"p":"rlang","o":"node_poke_cddr","f":"hp_node_poke_cddr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_cddr(x, newcdr)"},{"p":"rlang","o":"cnd_message","f":"hp_cnd_message","d":"cnd_message() assembles an error message from three generics:\n","ec":"cnd_message(cnd, ..., inherit = TRUE, prefix = FALSE)"},{"p":"rlang","o":"new_complex","f":"hp_new_complex","d":"\n","ec":"new_complex(n, names = NULL)"},{"p":"rlang","o":"is_scalar_vector","f":"hp_is_scalar_vector","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_vector(x)"},{"p":"rlang","o":"vec_poke_n","f":"hp_vec_poke_n","d":"\n","ec":"vec_poke_n(x, start, y, from = 1L, n = length(y))"},{"p":"rlang","o":"message_cnd","f":"hp_message_cnd","d":"These constructors create subclassed conditions, the objects that\npower the error, warning, and message system in R.\n","ec":"message_cnd(class = NULL, ..., message = \"\", call = NULL, use_cli_format = NULL)"},{"p":"rlang","o":"is_warning","f":"hp_is_warning","d":"Is object a condition?\n","ec":"is_warning(x)"},{"p":"rlang","o":"global_handle","f":"hp_global_handle","d":"global_handle() sets up a default configuration for error,\nwarning, and message handling. It calls:\n","ec":"global_handle(entrace = TRUE, prompt_install = TRUE)"},{"p":"rlang","o":"names2","f":"hp_names2","d":"names2() always returns a character vector, even when an\nobject does not have a names attribute. In this case, it returns\na vector of empty names \"\". It also standardises missing names to\n\"\".\n","ec":"names2(x)"},{"p":"rlang","o":"call2","f":"hp_call2","d":"Quoted function calls are one of the two types of\nsymbolic objects in R. They represent the action of\ncalling a function, possibly with arguments. There are two ways of\ncreating a quoted call:\n","ec":"call2(.fn, ..., .ns = NULL)"},{"p":"rlang","o":"format_error_call","f":"hp_format_error_call","d":"Either a string formatted as code or NULL if a simple\ncall could not be generated.\n","ec":"format_error_call(call)"},{"p":"rlang","o":"node_cadr","f":"hp_node_cadr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_cadr(x)"},{"p":"rlang","o":"vec_poke_range","f":"hp_vec_poke_range","d":"\n","ec":"vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)"},{"p":"rlang","o":"list2","f":"hp_list2","d":"list2(...) is equivalent to list(...) with a few additional\nfeatures, collectively called dynamic dots. While\nlist2() hard-code these features, dots_list() is a lower-level\nversion that offers more control.\n","ec":"list2(...)"},{"p":"rlang","o":"is_error","f":"hp_is_error","d":"Is object a condition?\n","ec":"is_error(x)"},{"p":"rlang","o":"squash_dbl","f":"hp_squash_dbl","d":"\n","ec":"squash_dbl(x)"},{"p":"rlang","o":"env_parents","f":"hp_env_parents","d":"See the section on inheritance in env()'s documentation.\n","ec":"env_parents(env = caller_env(), last = global_env())"},{"p":"rlang","o":"lgl","f":"hp_lgl","d":"\n","ec":"lgl(...)"},{"p":"rlang","o":"warn","f":"hp_warn","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"warn(message = NULL, class = NULL, ..., body = NULL, footer = NULL, parent = NULL, use_cli_format = NULL, .inherit = NULL, .frequency = c(\"always\", \"regularly\", \"once\"), .frequency_id = NULL, .subclass = deprecated())"},{"p":"rlang","o":"f_rhs","f":"hp_f_rhs","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_rhs(f)"},{"p":"rlang","o":"parse_expr","f":"hp_parse_expr","d":"These functions parse and transform text into R expressions. This\nis the first step to interpret or evaluate a piece of R code\nwritten by a programmer.\n","ec":"parse_expr(x)"},{"p":"rlang","o":"is_bare_numeric","f":"hp_is_bare_numeric","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_numeric(x, n = NULL)"},{"p":"rlang","o":"local_error_call","f":"hp_local_error_call","d":"local_error_call() is an alternative to explicitly passing a\ncall argument to abort(). It sets the call (or a value that\nindicates where to find the call, see below) in a local binding\nthat is automatically picked up by abort().\n","ec":"local_error_call(call, frame = caller_env())"},{"p":"rlang","o":"node_poke_tag","f":"hp_node_poke_tag","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_tag(x, newtag)"},{"p":"rlang","o":"is_named","f":"hp_is_named","d":"is_named() always returns TRUE for empty vectors because\n","ec":"is_named(x)"},{"p":"rlang","o":"f_env","f":"hp_f_env","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_env(f)"},{"p":"rlang","o":"env_binding_unlock","f":"hp_env_binding_unlock","d":"\n","ec":"env_binding_unlock(env, nms = NULL)"},{"p":"rlang","o":"f_lhs<-","f":"hp_f_lhs..","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_lhs<-(x, value)"},{"p":"rlang","o":"env_unbind","f":"hp_env_unbind","d":"env_unbind() is the complement of env_bind(). Like env_has(),\nit ignores the parent environments of env by default. Set\ninherit to TRUE to track down bindings in parent environments.\n","ec":"env_unbind(env = caller_env(), nms, inherit = FALSE)"},{"p":"rlang","o":"has_name","f":"hp_has_name","d":"This function returns a logical value that indicates if a data\nframe or another named object contains an element with a specific\nname. Note that has_name() only works with vectors. For instance,\nenvironments need the specialised function env_has().\n","ec":"has_name(x, name)"},{"p":"rlang","o":"push_options","f":"hp_push_options","d":"For local_options() and push_options(), the old option\nvalues. peek_option() returns the current value of an option\nwhile the plural peek_options() returns a list of current\noption values.\n","ec":"push_options(...)"},{"p":"rlang","o":"names_inform_repair","f":"hp_names_inform_repair","d":"Inform about name repair\n","ec":"names_inform_repair(old, new)"},{"p":"rlang","o":"caller_fn","f":"hp_caller_fn","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"caller_fn(n = 1)"},{"p":"rlang","o":"current_env","f":"hp_current_env","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"current_env()"},{"p":"rlang","o":"node_poke_caar","f":"hp_node_poke_caar","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_caar(x, newcar)"},{"p":"rlang","o":"is_bare_complex","f":"hp_is_bare_complex","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_complex(x, n = NULL)"},{"p":"rlang","o":"env_unlock","f":"hp_env_unlock","d":"This function should only be used in development tools or\ninteractively.\n","ec":"env_unlock(env)"},{"p":"rlang","o":"quo_is_symbolic","f":"hp_quo_is_symbolic","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_is_symbolic(quo)"},{"p":"rlang","o":"call_inspect","f":"hp_call_inspect","d":"This function is a wrapper around base::match.call(). It returns\nits own function call.\n","ec":"call_inspect(...)"},{"p":"rlang","o":"with_bindings","f":"hp_with_bindings","d":"local_bindings() returns the values of old bindings\ninvisibly; with_bindings() returns the value of expr.\n","ec":"with_bindings(.expr, ..., .env = caller_env())"},{"p":"rlang","o":"enexpr","f":"hp_enexpr","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"enexpr(arg)"},{"p":"rlang","o":"quo_is_missing","f":"hp_quo_is_missing","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_is_missing(quo)"},{"p":"rlang","o":"as_quosure","f":"hp_as_quosure","ec":"as_quosure(x, env = NULL)"},{"p":"rlang","o":"is_lambda","f":"hp_is_lambda","d":"as_function() transforms a one-sided formula into a function.\nThis powers the lambda syntax in packages like purrr.\n","ec":"is_lambda(x)"},{"p":"rlang","o":"env_get_list","f":"hp_env_get_list","d":"env_get() extracts an object from an enviroment env. By\ndefault, it does not look in the parent environments.\nenv_get_list() extracts multiple objects from an environment into\na named list.\n","ec":"env_get_list(env = caller_env(), nms, default, inherit = FALSE, last = empty_env())"},{"p":"rlang","o":"error_cnd","f":"hp_error_cnd","d":"These constructors create subclassed conditions, the objects that\npower the error, warning, and message system in R.\n","ec":"error_cnd(class = NULL, ..., message = \"\", call = NULL, trace = NULL, parent = NULL, use_cli_format = NULL)"},{"p":"rlang","o":"ns_env","f":"hp_ns_env","d":"Namespaces are the environment where all the functions of a package\nlive. The parent environments of namespaces are the imports\nenvironments, which contain all the functions imported from other\npackages.\n","ec":"ns_env(x = caller_env())"},{"p":"rlang","o":"coerce_type","f":"hp_coerce_type","d":"\n\n","ec":"coerce_type(.x, .to, ...)"},{"p":"rlang","o":"node_poke_cadr","f":"hp_node_poke_cadr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_cadr(x, newcar)"},{"p":"rlang","o":"env_bind","f":"hp_env_bind","d":"These functions create bindings in an environment. The bindings are\nsupplied through ... as pairs of names and values or expressions.\nenv_bind() is equivalent to evaluating a <U+2060><-<U+2060> expression within\nthe given environment. This function should take care of the\nmajority of use cases but the other variants can be useful for\nspecific problems.\n","ec":"env_bind(.env, ...)"},{"p":"rlang","o":"local_bindings","f":"hp_local_bindings","d":"local_bindings() returns the values of old bindings\ninvisibly; with_bindings() returns the value of expr.\n","ec":"local_bindings(..., .env = .frame, .frame = caller_env())"},{"p":"rlang","o":"env_bury","f":"hp_env_bury","d":"\n","ec":"env_bury(.env, ...)"},{"p":"rlang","o":"is_bool","f":"hp_is_bool","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_bool(x)"},{"p":"rlang","o":"seq2_along","f":"hp_seq2_along","d":"These helpers take two endpoints and return the sequence of all\nintegers within that interval. For seq2_along(), the upper\nendpoint is taken from the length of a vector. Unlike\nbase::seq(), they return an empty vector if the starting point is\na larger integer than the end point.\n","ec":"seq2_along(from, x)"},{"p":"rlang","o":"new_call","f":"hp_new_call","d":"Create a new call from components\n","ec":"new_call(car, cdr = NULL)"},{"p":"rlang","o":"are_na","f":"hp_are_na","d":"\n","ec":"are_na(x)"},{"p":"rlang","o":"global_prompt_install","f":"hp_global_prompt_install","d":"When enabled, packageNotFoundError thrown by loadNamespace()\ncause a user prompt to install the missing package and continue\nwithout interrupting the current program.\n","ec":"global_prompt_install(enable = TRUE)"},{"p":"rlang","o":"expr_label","f":"hp_expr_label","d":"\n","ec":"expr_label(expr)"},{"p":"rlang","o":"dots_splice","f":"hp_dots_splice","d":"\n","ec":"dots_splice(..., .ignore_empty = c(\"trailing\", \"none\", \"all\"), .preserve_empty = FALSE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":".env","f":"hp_.env","d":"The .data and .env pronouns make it explicit where to find\nobjects when programming with data-masked\nfunctions.\n","ec":""},{"p":"rlang","o":"parse_bytes","f":"hp_parse_bytes","d":"Construct, manipulate and display vectors of byte sizes. These are numeric\nvectors, so you can compare them numerically, but they can also be compared\nto human readable values such as '10MB'.\n","ec":"parse_bytes(x)"},{"p":"rlang","o":"quo_is_symbol","f":"hp_quo_is_symbol","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_is_symbol(quo, name = NULL)"},{"p":"rlang","o":"is_cpl_na","f":"hp_is_cpl_na","d":"\n","ec":"is_cpl_na(x)"},{"p":"rlang","o":"is_node_list","f":"hp_is_node_list","d":"These functions are experimental. We are still figuring out a good\nnaming convention to refer to the different lisp-like lists in R.\n","ec":"is_node_list(x)"},{"p":"rlang","o":"as_environment","f":"hp_as_environment","d":"as_environment() coerces named vectors (including lists) to an\nenvironment. The names must be unique. If supplied an unnamed\nstring, it returns the corresponding package environment (see\npkg_env()).\n","ec":"as_environment(x, parent = NULL)"},{"p":"rlang","o":"env_binding_are_lazy","f":"hp_env_binding_are_lazy","d":"\n","ec":"env_binding_are_lazy(env, nms = NULL)"},{"p":"rlang","o":"quo_get_expr","f":"hp_quo_get_expr","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_get_expr(quo)"},{"p":"rlang","o":"cnd_body","f":"hp_cnd_body","d":"cnd_message() assembles an error message from three generics:\n","ec":"cnd_body(cnd, ...)"},{"p":"rlang","o":"flatten","f":"hp_flatten","d":"\n","ec":"flatten(x)"},{"p":"rlang","o":"type_of","f":"hp_type_of","d":"\n\n","ec":"type_of(x)"},{"p":"rlang","o":"quo_squash","f":"hp_quo_squash","d":"quo_squash() flattens all nested quosures within an expression.\nFor example it transforms <U+2060>^foo(^bar(), ^baz)<U+2060> to the bare\nexpression foo(bar(), baz).\n","ec":"quo_squash(quo, warn = FALSE)"},{"p":"rlang","o":"run_on_load","f":"hp_run_on_load","d":"on_load() is for your own package and runs expressions when the\nnamespace is not sealed yet. This means you can modify existing\nbinding or create new ones. This is not the case with\non_package_load() which runs expressions after a foreign package\nhas finished loading, at which point its namespace is sealed.\n","ec":"run_on_load(ns = topenv(parent.frame()))"},{"p":"rlang","o":"sym","f":"hp_sym","d":"Symbols are a kind of defused expression that\nrepresent objects in environments.\n","ec":"sym(x)"},{"p":"rlang","o":"unbox","f":"hp_unbox","d":"new_box() is similar to base::I() but it protects a value by\nwrapping it in a scalar list rather than by adding an attribute.\nunbox() retrieves the boxed value. is_box() tests whether an\nobject is boxed with optional class. as_box() ensures that a\nvalue is wrapped in a box. as_box_if() does the same but only if\nthe value matches a predicate.\n","ec":"unbox(box)"},{"p":"rlang","o":"is_function","f":"hp_is_function","d":"The R language defines two different types of functions: primitive\nfunctions, which are low-level, and closures, which are the regular\nkind of functions.\n","ec":"is_function(x)"},{"p":"rlang","o":"arg_match","f":"hp_arg_match","d":"This is equivalent to base::match.arg() with a few differences:\n","ec":"arg_match(arg, values = NULL, ..., multiple = FALSE, error_arg = caller_arg(arg), error_call = caller_env())"},{"p":"rlang","o":"is_primitive","f":"hp_is_primitive","d":"The R language defines two different types of functions: primitive\nfunctions, which are low-level, and closures, which are the regular\nkind of functions.\n","ec":"is_primitive(x)"},{"p":"rlang","o":"na_cpl","f":"hp_na_cpl","d":"\n","ec":""},{"p":"rlang","o":"new_box","f":"hp_new_box","d":"new_box() is similar to base::I() but it protects a value by\nwrapping it in a scalar list rather than by adding an attribute.\nunbox() retrieves the boxed value. is_box() tests whether an\nobject is boxed with optional class. as_box() ensures that a\nvalue is wrapped in a box. as_box_if() does the same but only if\nthe value matches a predicate.\n","ec":"new_box(.x, class = NULL, ...)"},{"p":"rlang","o":"exprs","f":"hp_exprs","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"exprs(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .unquote_names = TRUE)"},{"p":"rlang","o":"local_use_cli","f":"hp_local_use_cli","d":"\n","ec":"local_use_cli(..., format = TRUE, inline = FALSE, frame = caller_env())"},{"p":"rlang","o":"env_inherits","f":"hp_env_inherits","d":"This returns TRUE if x has ancestor among its parents.\n","ec":"env_inherits(env, ancestor)"},{"p":"rlang","o":"node_cdar","f":"hp_node_cdar","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_cdar(x)"},{"p":"rlang","o":"ensyms","f":"hp_ensyms","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"ensyms(..., .named = FALSE, .ignore_empty = c(\"trailing\", \"none\", \"all\"), .ignore_null = c(\"none\", \"all\"), .unquote_names = TRUE, .homonyms = c(\"keep\", \"first\", \"last\", \"error\"), .check_assign = FALSE)"},{"p":"rlang","o":"enquos0","f":"hp_enquos0","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"enquos0(...)"},{"p":"rlang","o":"switch_class","f":"hp_switch_class","d":"\n\n","ec":"switch_class(.x, ...)"},{"p":"rlang","o":"zap_srcref","f":"hp_zap_srcref","d":"There are a number of situations where R creates source references:\n","ec":"zap_srcref(x)"},{"p":"rlang","o":"is_callable","f":"hp_is_callable","d":"A callable object is an object that can appear in the function\nposition of a call (as opposed to argument position). This includes\nsymbolic objects that evaluate to a function or\nliteral functions embedded in the call.\n","ec":"is_callable(x)"},{"p":"rlang","o":"data_sym","f":"hp_data_sym","d":"Symbols are a kind of defused expression that\nrepresent objects in environments.\n","ec":"data_sym(x)"},{"p":"rlang","o":"ensym","f":"hp_ensym","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"ensym(arg)"},{"p":"rlang","o":"node_poke_cdr","f":"hp_node_poke_cdr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_cdr(x, newcdr)"},{"p":"rlang","o":"interrupt","f":"hp_interrupt","d":"interrupt() simulates a user interrupt of the kind that is\nsignalled with Ctrl-C. It is currently not possible to create\ncustom interrupt condition objects.\n","ec":"interrupt()"},{"p":"rlang","o":"flatten_dbl","f":"hp_flatten_dbl","d":"\n","ec":"flatten_dbl(x)"},{"p":"rlang","o":"call_match","f":"hp_call_match","d":"call_match() is like match.call() with these differences:\n","ec":"call_match(call = NULL, fn = NULL, ..., defaults = FALSE, dots_env = NULL, dots_expand = TRUE)"},{"p":"rlang","o":"new_raw","f":"hp_new_raw","d":"\n","ec":"new_raw(n, names = NULL)"},{"p":"rlang","o":"new_integer","f":"hp_new_integer","d":"\n","ec":"new_integer(n, names = NULL)"},{"p":"rlang","o":"env_binding_lock","f":"hp_env_binding_lock","d":"\n","ec":"env_binding_lock(env, nms = NULL)"},{"p":"rlang","o":"env_is_user_facing","f":"hp_env_is_user_facing","d":"Detects if env is user-facing, that is, whether it's an environment\nthat inherits from:\n","ec":"env_is_user_facing(env)"},{"p":"rlang","o":"env_poke","f":"hp_env_poke","d":"env_poke() will assign or reassign a binding in env if create\nis TRUE. If create is FALSE and a binding does not already\nexists, an error is issued.\n","ec":"env_poke(env = caller_env(), nm, value, inherit = FALSE, create = !inherit)"},{"p":"rlang","o":"qq_show","f":"hp_qq_show","d":"qq_show() helps examining injected expressions\ninside a function. This is useful for learning about injection and\nfor debugging injection code.\n","ec":"qq_show(expr)"},{"p":"rlang","o":"squash_int","f":"hp_squash_int","d":"\n","ec":"squash_int(x)"},{"p":"rlang","o":"is_scalar_integerish","f":"hp_is_scalar_integerish","d":"These predicates check whether R considers a number vector to be\ninteger-like, according to its own tolerance check (which is in\nfact delegated to the C library). This function is not adapted to\ndata analysis, see the help for base::is.integer() for examples\nof how to check for whole numbers.\n","ec":"is_scalar_integerish(x, finite = NULL)"},{"p":"rlang","o":"expr_interp","f":"hp_expr_interp","d":"\nexpr_interp() is deprecated, please use inject() instead.\n","ec":"expr_interp(x, env = NULL)"},{"p":"rlang","o":"node_cddr","f":"hp_node_cddr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_cddr(x)"},{"p":"rlang","o":"cnd_entrace","f":"hp_cnd_entrace","d":"entrace() is a low level function. See global_entrace() for a\nuser-friendly way of enriching errors and other conditions from\nyour RProfile.\n","ec":"cnd_entrace(cnd, ..., top = NULL, bottom = NULL)"},{"p":"rlang","o":"f_name","f":"hp_f_name","d":"Equivalent of expr_text() and expr_label() for formulas.\n","ec":"f_name(x)"},{"p":"rlang","o":"f_lhs","f":"hp_f_lhs","d":"f_rhs extracts the righthand side, f_lhs extracts the lefthand\nside, and f_env extracts the environment. All functions throw an\nerror if f is not a formula.\n","ec":"f_lhs(f)"},{"p":"rlang","o":"node_car","f":"hp_node_car","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_car(x)"},{"p":"rlang","o":"caller_arg","f":"hp_caller_arg","d":"caller_arg() is a variant of substitute() or ensym() for\narguments that reference other arguments. Unlike substitute()\nwhich returns an expression, caller_arg() formats the expression\nas a single line string which can be included in error messages.\n","ec":"caller_arg(arg)"},{"p":"rlang","o":"parse_quo","f":"hp_parse_quo","d":"These functions parse and transform text into R expressions. This\nis the first step to interpret or evaluate a piece of R code\nwritten by a programmer.\n","ec":"parse_quo(x, env)"},{"p":"rlang","o":"node_poke_car","f":"hp_node_poke_car","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_poke_car(x, newcar)"},{"p":"rlang","o":"fn_fmls_syms","f":"hp_fn_fmls_syms","d":"fn_fmls() returns a named list of formal arguments.\nfn_fmls_names() returns the names of the arguments.\nfn_fmls_syms() returns formals as a named list of symbols. This\nis especially useful for forwarding arguments in constructed calls.\n","ec":"fn_fmls_syms(fn = caller_fn())"},{"p":"rlang","o":"local_interactive","f":"hp_local_interactive","d":"Like base::interactive(), is_interactive() returns TRUE when\nthe function runs interactively and FALSE when it runs in batch\nmode. It also checks, in this order:\n","ec":"local_interactive(value = TRUE, frame = caller_env())"},{"p":"rlang","o":"is_environment","f":"hp_is_environment","d":"is_bare_environment() tests whether x is an environment without a s3 or\ns4 class.\n","ec":"is_environment(x)"},{"p":"rlang","o":"as_box","f":"hp_as_box","ec":"as_box(x, class = NULL)"},{"p":"rlang","o":"env_is_locked","f":"hp_env_is_locked","d":"\n","ec":"env_is_locked(env)"},{"p":"rlang","o":"is_symbolic","f":"hp_is_symbolic","d":"In rlang, an expression is the return type of parse_expr(), the\nset of objects that can be obtained from parsing R code. Under this\ndefinition expressions include numbers, strings, NULL, symbols,\nand function calls. These objects can be classified as:\n","ec":"is_symbolic(x)"},{"p":"rlang","o":"na_dbl","f":"hp_na_dbl","d":"\n","ec":""},{"p":"rlang","o":"catch_cnd","f":"hp_catch_cnd","d":"This is a small wrapper around tryCatch() that captures any\ncondition signalled while evaluating its argument. It is useful for\nsituations where you expect a specific condition to be signalled,\nfor debugging, and for unit testing.\n","ec":"catch_cnd(expr, classes = \"condition\")"},{"p":"rlang","o":"duplicate","f":"hp_duplicate","d":"duplicate() is an interface to the C-level duplicate() and\nshallow_duplicate() functions. It is mostly meant for users of\nthe C API of R, e.g. for debugging, experimenting, or prototyping C\ncode in R.\n","ec":"duplicate(x, shallow = FALSE)"},{"p":"rlang","o":"check_dots_empty0","f":"hp_check_dots_empty0","d":"check_dots_empty0() is a more efficient version of\ncheck_dots_empty() with a slightly different interface. Instead\nof inspecting the current environment for dots, it directly takes\n.... It is only meant for very low level functions where a\ncouple microseconds make a difference.\n","ec":"check_dots_empty0(..., call = caller_env())"},{"p":"rlang","o":"is_symbol","f":"hp_is_symbol","d":"Is object a symbol?\n","ec":"is_symbol(x, name = NULL)"},{"p":"rlang","o":"switch_type","f":"hp_switch_type","d":"\n\n","ec":"switch_type(.x, ...)"},{"p":"rlang","o":"cnd_footer","f":"hp_cnd_footer","d":"cnd_message() assembles an error message from three generics:\n","ec":"cnd_footer(cnd, ...)"},{"p":"rlang","o":"cnd_signal","f":"hp_cnd_signal","d":"cnd_signal() takes a condition as argument and emits the\ncorresponding signal. The type of signal depends on the class of\nthe condition:\n","ec":"cnd_signal(cnd, ...)"},{"p":"rlang","o":"is_node","f":"hp_is_node","d":"These functions are experimental. We are still figuring out a good\nnaming convention to refer to the different lisp-like lists in R.\n","ec":"is_node(x)"},{"p":"rlang","o":"env_bind_lazy","f":"hp_env_bind_lazy","d":"These functions create bindings in an environment. The bindings are\nsupplied through ... as pairs of names and values or expressions.\nenv_bind() is equivalent to evaluating a <U+2060><-<U+2060> expression within\nthe given environment. This function should take care of the\nmajority of use cases but the other variants can be useful for\nspecific problems.\n","ec":"env_bind_lazy(.env, ..., .eval_env = caller_env())"},{"p":"rlang","o":"reset_warning_verbosity","f":"hp_reset_warning_verbosity","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"reset_warning_verbosity(id)"},{"p":"rlang","o":"node_cdr","f":"hp_node_cdr","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_cdr(x)"},{"p":"rlang","o":"peek_options","f":"hp_peek_options","d":"For local_options() and push_options(), the old option\nvalues. peek_option() returns the current value of an option\nwhile the plural peek_options() returns a list of current\noption values.\n","ec":"peek_options(...)"},{"p":"rlang","o":"env_tail","f":"hp_env_tail","d":"See the section on inheritance in env()'s documentation.\n","ec":"env_tail(env = caller_env(), last = global_env())"},{"p":"rlang","o":"env_has","f":"hp_env_has","d":"env_has() is a vectorised predicate that queries whether an\nenvironment owns bindings personally (with inherit set to\nFALSE, the default), or sees them in its own environment or in\nany of its parents (with inherit = TRUE).\n","ec":"env_has(env = caller_env(), nms, inherit = FALSE)"},{"p":"rlang","o":"env_poke_parent","f":"hp_env_poke_parent","d":"These functions dispatch internally with methods for functions,\nformulas and frames. If called with a missing argument, the\nenvironment of the current evaluation frame is returned. If you\ncall get_env() with an environment, it acts as the identity\nfunction and the environment is simply returned (this helps\nsimplifying code when writing generic functions for environments).\n","ec":"env_poke_parent(env, new_env)"},{"p":"rlang","o":"scoped_bindings","f":"hp_scoped_bindings","d":"\n","ec":"scoped_bindings(..., .env = .frame, .frame = caller_env())"},{"p":"rlang","o":"cnd_inherits","f":"hp_cnd_inherits","d":"Like any R objects, errors captured with catchers like tryCatch()\nhave a class() which you can test with inherits().  However,\nwith chained errors, the class of a captured error might be\ndifferent than the error that was originally signalled. Use\ncnd_inherits() to detect whether an error or any of its parent\ninherits from a class.\n","ec":"cnd_inherits(cnd, class)"},{"p":"rlang","o":"is_scalar_raw","f":"hp_is_scalar_raw","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_raw(x)"},{"p":"rlang","o":"is_expression","f":"hp_is_expression","d":"In rlang, an expression is the return type of parse_expr(), the\nset of objects that can be obtained from parsing R code. Under this\ndefinition expressions include numbers, strings, NULL, symbols,\nand function calls. These objects can be classified as:\n","ec":"is_expression(x)"},{"p":"rlang","o":"node_tag","f":"hp_node_tag","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"node_tag(x)"},{"p":"rlang","o":"expr_deparse","f":"hp_expr_deparse","d":"expr_print(), powered by expr_deparse(), is an alternative\nprinter for R expressions with a few improvements over the base R\nprinter.\n","ec":"expr_deparse(x, ..., width = peek_option(\"width\"))"},{"p":"rlang","o":"is_bare_raw","f":"hp_is_bare_raw","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_raw(x, n = NULL)"},{"p":"rlang","o":"last_warnings","f":"hp_last_warnings","d":"last_warnings() and last_messages() return a list of all\nwarnings and messages that occurred during the last R command.\n","ec":"last_warnings(n = NULL)"},{"p":"rlang","o":"is_scalar_bytes","f":"hp_is_scalar_bytes","d":"These predicates check for a given type and whether the vector is\n\"scalar\", that is, of length 1.\n","ec":"is_scalar_bytes(x)"},{"p":"rlang","o":"squash_lgl","f":"hp_squash_lgl","d":"\n","ec":"squash_lgl(x)"},{"p":"rlang","o":"check_exclusive","f":"hp_check_exclusive","d":"check_exclusive() checks that only one argument is supplied out of\na set of mutually exclusive arguments. An informative error is\nthrown if multiple arguments are supplied.\n","ec":"check_exclusive(..., .require = TRUE, .frame = caller_env(), .call = .frame)"},{"p":"rlang","o":"call_name","f":"hp_call_name","d":"call_name() and call_ns() extract the function name or\nnamespace of simple calls as a string. They return NULL for\ncomplex calls.\n","ec":"call_name(call)"},{"p":"rlang","o":"check_required","f":"hp_check_required","d":"Throws an error if x is missing.\n","ec":"check_required(x, arg = caller_arg(x), call = caller_env())"},{"p":"rlang","o":"is_bare_list","f":"hp_is_bare_list","d":"These predicates check for a given type but only return TRUE for\nbare R objects. Bare objects have no class attributes. For example,\na data frame is a list, but not a bare list.\n","ec":"is_bare_list(x, n = NULL)"},{"p":"rlang","o":"global_env","f":"hp_global_env","d":"The search path is a chain of environments containing exported\nfunctions of attached packages.\n","ec":"global_env()"},{"p":"rlang","o":"trace_back","f":"hp_trace_back","d":"A backtrace captures the sequence of calls that lead to the current\nfunction (sometimes called the call stack). Because of lazy\nevaluation, the call stack in R is actually a tree, which the\nprint() method for this object will reveal.\n","ec":"trace_back(top = NULL, bottom = NULL)"},{"p":"rlang","o":"call_fn","f":"hp_call_fn","d":"\nDeprecated in rlang 0.4.11.\n","ec":"call_fn(call, env = caller_env())"},{"p":"rlang","o":"with_interactive","f":"hp_with_interactive","d":"Like base::interactive(), is_interactive() returns TRUE when\nthe function runs interactively and FALSE when it runs in batch\nmode. It also checks, in this order:\n","ec":"with_interactive(expr, value = TRUE)"},{"p":"rlang","o":"as_label","f":"hp_as_label","d":"as_label() transforms R objects into a short, human-readable\ndescription. You can use labels to:\n","ec":"as_label(x)"},{"p":"rlang","o":"as_logical","f":"hp_as_logical","d":"\n","ec":"as_logical(x)"},{"p":"rlang","o":"as_quosures","f":"hp_as_quosures","d":"This small S3 class provides methods for [ and c() and ensures\nthe following invariants:\n","ec":"as_quosures(x, env, named = FALSE)"},{"p":"rlang","o":"ns_env_name","f":"hp_ns_env_name","d":"Namespaces are the environment where all the functions of a package\nlive. The parent environments of namespaces are the imports\nenvironments, which contain all the functions imported from other\npackages.\n","ec":"ns_env_name(x = caller_env())"},{"p":"rlang","o":"quo_get_env","f":"hp_quo_get_env","d":"These tools inspect and modify quosures, a type of\ndefused expression that includes a reference to the\ncontext where it was created. A quosure is guaranteed to evaluate\nin its original environment and can refer to local objects safely.\n","ec":"quo_get_env(quo)"},{"p":"rlang","o":"friendly_type","f":"hp_friendly_type","d":"\n","ec":"friendly_type(type)"},{"p":"rlang","o":"new_function","f":"hp_new_function","d":"This constructs a new function given its three components:\nlist of arguments, body code and parent environment.\n","ec":"new_function(args, body, env = caller_env())"},{"p":"rlang","o":"new_list","f":"hp_new_list","d":"\n","ec":"new_list(n, names = NULL)"},{"p":"rlang","o":"enquo0","f":"hp_enquo0","d":"These advanced operators defuse R expressions.\nexpr(), enquo(), and enquos() are sufficient for most\npurposes but rlang provides these other operations, either for\ncompleteness or because they are useful to experts.\n","ec":"enquo0(arg)"},{"p":"rlang","o":"hash","f":"hp_hash","d":"The generated hash is guaranteed to be reproducible across platforms that\nhave the same endianness and are using the same R version.\n","ec":"hash(x)"},{"p":"rlang","o":"error_call","f":"hp_error_call","d":"Either a string formatted as code or NULL if a simple\ncall could not be generated.\n","ec":"error_call(call)"},{"p":"rlang","o":"call_args_names","f":"hp_call_args_names","d":"Extract arguments from a call\n","ec":"call_args_names(call)"},{"p":"rlang","o":"local_options","f":"hp_local_options","d":"For local_options() and push_options(), the old option\nvalues. peek_option() returns the current value of an option\nwhile the plural peek_options() returns a list of current\noption values.\n","ec":"local_options(..., .frame = caller_env())"},{"p":"rlang","o":"on_package_load","f":"hp_on_package_load","d":"on_load() is for your own package and runs expressions when the\nnamespace is not sealed yet. This means you can modify existing\nbinding or create new ones. This is not the case with\non_package_load() which runs expressions after a foreign package\nhas finished loading, at which point its namespace is sealed.\n","ec":"on_package_load(pkg, expr, env = parent.frame())"},{"p":"rlang","o":"env_binding_are_active","f":"hp_env_binding_are_active","d":"\n","ec":"env_binding_are_active(env, nms = NULL)"},{"p":"rlang","o":"signal","f":"hp_signal","d":"These functions are equivalent to base functions base::stop(),\nbase::warning(), and base::message(). They signal a condition\n(an error, warning, or message respectively) and make it easy to\nsupply condition metadata:\n","ec":"signal(message = \"\", class, ..., .subclass = deprecated())"},{"p":"rlang","o":"is_bare_environment","f":"hp_is_bare_environment","d":"is_bare_environment() tests whether x is an environment without a s3 or\ns4 class.\n","ec":"is_bare_environment(x)"},{"p":"rlang","o":"env_depth","f":"hp_env_depth","d":"This function returns the number of environments between env and\nthe empty environment, including env. The depth of\nenv is also the number of parents of env (since the empty\nenvironment counts as a parent).\n","ec":"env_depth(env)"},{"p":"rlang","o":"caller_call","f":"hp_caller_call","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"caller_call(n = 1)"},{"p":"rlang","o":"frame_call","f":"hp_frame_call","d":"These accessors retrieve properties of frames on the call stack.\nThe prefix indicates for which frame a property should be accessed:\n","ec":"frame_call(frame = caller_env())"},{"p":"rlang","o":"is_weakref","f":"hp_is_weakref","d":"Is object a weak reference?\n","ec":"is_weakref(x)"},{"p":"rlang","o":"chr","f":"hp_chr","d":"\n","ec":"chr(...)"},{"p":"rlang","o":"child_env","f":"hp_child_env","d":"\n","ec":"child_env(.parent, ...)"},{"p":"rlang","o":"is_null","f":"hp_is_null","d":"These type predicates aim to make type testing in R more\nconsistent. They are wrappers around base::typeof(), so operate\nat a level beneath S3/S4 etc.\n","ec":"is_null(x)"},{"p":"rlang","o":"squash_raw","f":"hp_squash_raw","d":"\n","ec":"squash_raw(x)"},{"p":"rlang","o":"squash_chr","f":"hp_squash_chr","d":"\n","ec":"squash_chr(x)"},{"p":"rlang","o":"new_character","f":"hp_new_character","d":"\n","ec":"new_character(n, names = NULL)"},{"p":"rlang","o":"fn_env","f":"hp_fn_env","d":"Closure environments define the scope of functions (see env()).\nWhen a function call is evaluated, R creates an evaluation frame\nthat inherits from the closure environment. This makes all objects\ndefined in the closure environment and all its parents available to\ncode executed within the function.\n","ec":"fn_env(fn)"},{"p":"rlang","o":"cnd_muffle","f":"hp_cnd_muffle","d":"Unlike exiting() handlers, calling() handlers must be explicit\nthat they have handled a condition to stop it from propagating to\nother handlers. Use cnd_muffle() within a calling handler (or as\na calling handler, see examples) to prevent any other handlers from\nbeing called for that condition.\n","ec":"cnd_muffle(cnd)"},{"p":"rlang","o":"last_error","f":"hp_last_error","ec":"last_error()"},{"p":"rlang","o":"invoke","f":"hp_invoke","d":"\nDeprecated in rlang 0.4.0 in favour of exec().\n","ec":"invoke(.fn, .args = list(), ..., .env = caller_env(), .bury = c(\".fn\", \"\"))"},{"p":"rlang","o":"squash_cpl","f":"hp_squash_cpl","d":"\n","ec":"squash_cpl(x)"},{"p":"rlang","o":"hash_file","f":"hp_hash_file","d":"The generated hash is guaranteed to be reproducible across platforms that\nhave the same endianness and are using the same R version.\n","ec":"hash_file(path)"},{"p":"rlang","o":"new_node","f":"hp_new_node","d":"Important: These functions are for expert R programmers only.\nYou should only use them if you feel comfortable manipulating low\nlevel R data structures at the C level. We export them at the R level\nin order to make it easy to prototype C code. They don't perform\nany type checking and can crash R very easily (try to take the CAR\nof an integer vector <U+2014> save any important objects beforehand!).\n","ec":"new_node(car, cdr = NULL)"},{"p":"rlang","o":"flatten_int","f":"hp_flatten_int","d":"\n","ec":"flatten_int(x)"},{"p":"scales","o":"col2hcl","f":"hp_col2hcl","d":"Transforms rgb to hcl, sets non-missing arguments and then backtransforms\nto rgb.\n","ec":"col2hcl(colour, h = NULL, c = NULL, l = NULL, alpha = NULL)"},{"p":"scales","o":"oob_censor","f":"hp_oob_censor","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_censor(x, range = c(0, 1), only.finite = TRUE)"},{"p":"scales","o":"rescale_max","f":"hp_rescale_max","d":"Rescale numeric vector to have specified maximum\n","ec":"rescale_max(x, to = c(0, 1), from = range(x, na.rm = TRUE))"},{"p":"scales","o":"transform_probit","f":"hp_transform_probit","d":"Probability transformation\n","ec":"transform_probit()"},{"p":"scales","o":"grey_pal","f":"hp_grey_pal","d":"Grey scale palette (discrete)\n","ec":"grey_pal(start = 0.2, end = 0.8)"},{"p":"scales","o":"breaks_pretty","f":"hp_breaks_pretty","d":"Uses default R break algorithm as implemented in pretty(). This is\nprimarily useful for date/times, as extended_breaks() should do a slightly\nbetter job for numeric scales.\n","ec":"breaks_pretty(n = 5, ...)"},{"p":"scales","o":"transform_date","f":"hp_transform_date","d":"Transformation for dates (class Date)\n","ec":"transform_date()"},{"p":"scales","o":"breaks_width","f":"hp_breaks_width","d":"Useful for numeric, date, and date-time scales.\n","ec":"breaks_width(width, offset = 0)"},{"p":"scales","o":"percent_format","f":"hp_percent_format","d":"\n","ec":"percent_format(accuracy = NULL, scale = 100, prefix = \"\", suffix = \"%\", big.mark = \" \", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"transform_time","f":"hp_transform_time","d":"Transformation for date-times (class POSIXt)\n","ec":"transform_time(tz = NULL)"},{"p":"scales","o":"asn_trans","f":"hp_asn_trans","d":"This is the variance stabilising transformation for the binomial\ndistribution.\n","ec":"asn_trans()"},{"p":"scales","o":"log_breaks","f":"hp_log_breaks","d":"This algorithm starts by looking for integer powers of base. If that\ndoesn't provide enough breaks, it then looks for additional intermediate\nbreaks which are integer multiples of integer powers of base. If that fails\n(which it can for very small ranges), we fall back to extended_breaks()\n","ec":"log_breaks(n = 5, base = 10)"},{"p":"scales","o":"pretty_breaks","f":"hp_pretty_breaks","d":"\n","ec":"pretty_breaks(n = 5, ...)"},{"p":"scales","o":"transform_timespan","f":"hp_transform_timespan","d":"transform_timespan() provides transformations for data encoding time passed\nalong with breaks and label formatting showing standard unit of time fitting\nthe range of the data. transform_hms() provides the same but using standard\nhms idioms and formatting.\n","ec":"transform_timespan(unit = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))"},{"p":"scales","o":"alpha","f":"hp_alpha","d":"Vectorised in both colour and alpha.\n","ec":"alpha(colour, alpha = NA)"},{"p":"scales","o":"colour_ramp","f":"hp_colour_ramp","d":"Returns a function that maps the interval [0,1] to a set of colours.\nInterpolation is performed in the CIELAB colour space. Similar to\ncolorRamp(space = 'Lab'), but hundreds of\ntimes faster, and provides results in \"#RRGGBB\" (or\n\"#RRGGBBAA\") character form instead of RGB colour matrices.\n","ec":"colour_ramp(colors, na.color = NA, alpha = TRUE)"},{"p":"scales","o":"date_breaks","f":"hp_date_breaks","d":"\n","ec":"date_breaks(width = \"1 month\")"},{"p":"scales","o":"label_date_short","f":"hp_label_date_short","d":"label_date() and label_time() label date/times using date/time format\nstrings. label_date_short() automatically constructs a short format string\nsufficient to uniquely identify labels. It's inspired by matplotlib's\nConciseDateFormatter,\nbut uses a slightly different approach: ConciseDateFormatter formats\n\"firsts\" (e.g. first day of month, first day of day) specially;\ndate_short() formats changes (e.g. new month, new year) specially.\nlabel_timespan() is intended to show time passed and adds common time units\nsuffix to the input (ns, us, ms, s, m, h, d, w).\n","ec":"label_date_short(format = c(\"%Y\", \"%b\", \"%d\", \"%H:%M\"), sep = \"\\n\")"},{"p":"scales","o":"ordinal_english","f":"hp_ordinal_english","d":"Round values to integers and then display as ordinal values (e.g. 1st, 2nd,\n3rd). Built-in rules are provided for English, French, and Spanish.\n","ec":"ordinal_english()"},{"p":"scales","o":"breaks_timespan","f":"hp_breaks_timespan","d":"As timespan units span a variety of bases (1000 below seconds, 60 for second\nand minutes, 24 for hours, and 7 for days), the range of the input data\ndetermines the base used for calculating breaks\n","ec":"breaks_timespan(unit = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"), n = 5)"},{"p":"scales","o":"transform_log","f":"hp_transform_log","ec":"transform_log(base = exp(1))"},{"p":"scales","o":"col_factor","f":"hp_col_factor","d":"Conveniently maps data values (numeric or factor/character) to colours\naccording to a given palette, which can be provided in a variety of formats.\n","ec":"col_factor(palette, domain, levels = NULL, ordered = FALSE, na.color = \"#808080\", alpha = FALSE, reverse = FALSE)"},{"p":"scales","o":"hms_trans","f":"hp_hms_trans","d":"transform_timespan() provides transformations for data encoding time passed\nalong with breaks and label formatting showing standard unit of time fitting\nthe range of the data. transform_hms() provides the same but using standard\nhms idioms and formatting.\n","ec":"hms_trans()"},{"p":"scales","o":"wrap_format","f":"hp_wrap_format","d":"\n","ec":"wrap_format(width)"},{"p":"scales","o":"demo_datetime","f":"hp_demo_datetime","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_datetime(x, ...)"},{"p":"scales","o":"pal_linetype","f":"hp_pal_linetype","d":"Based on a set supplied by Richard Pearson, University of Manchester\n","ec":"pal_linetype()"},{"p":"scales","o":"pal_shape","f":"hp_pal_shape","d":"Shape palette (discrete)\n","ec":"pal_shape(solid = TRUE)"},{"p":"scales","o":"abs_area","f":"hp_abs_area","d":"Area palettes (continuous)\n","ec":"abs_area(max)"},{"p":"scales","o":"oob_squish_infinite","f":"hp_oob_squish_infinite","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_squish_infinite(x, range = c(0, 1))"},{"p":"scales","o":"is.transform","f":"hp_is.transform","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"is.transform(x)"},{"p":"scales","o":"pal_hue","f":"hp_pal_hue","d":"Hue palette (discrete)\n","ec":"pal_hue(h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1)"},{"p":"scales","o":"transform_asn","f":"hp_transform_asn","d":"This is the variance stabilising transformation for the binomial\ndistribution.\n","ec":"transform_asn()"},{"p":"scales","o":"pal_viridis","f":"hp_pal_viridis","d":"Viridis palette\n","ec":"pal_viridis(alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\")"},{"p":"scales","o":"label_number_si","f":"hp_label_number_si","d":"\n","ec":"label_number_si(unit = \"\", accuracy = NULL, scale = 1, suffix = \"\", ...)"},{"p":"scales","o":"transform_asinh","f":"hp_transform_asinh","d":"Inverse Hyperbolic Sine transformation\n","ec":"transform_asinh()"},{"p":"scales","o":"label_comma","f":"hp_label_comma","d":"Use label_number() force decimal display of numbers (i.e. don't use\nscientific notation). label_comma() is a special case\nthat inserts a comma every three digits.\n","ec":"label_comma(accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, digits, ...)"},{"p":"scales","o":"transform_log1p","f":"hp_transform_log1p","ec":"transform_log1p()"},{"p":"scales","o":"label_timespan","f":"hp_label_timespan","d":"label_date() and label_time() label date/times using date/time format\nstrings. label_date_short() automatically constructs a short format string\nsufficient to uniquely identify labels. It's inspired by matplotlib's\nConciseDateFormatter,\nbut uses a slightly different approach: ConciseDateFormatter formats\n\"firsts\" (e.g. first day of month, first day of day) specially;\ndate_short() formats changes (e.g. new month, new year) specially.\nlabel_timespan() is intended to show time passed and adds common time units\nsuffix to the input (ns, us, ms, s, m, h, d, w).\n","ec":"label_timespan(unit = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"), space = FALSE, ...)"},{"p":"scales","o":"transform_sqrt","f":"hp_transform_sqrt","d":"This is the variance stabilising transformation for the Poisson\ndistribution.\n","ec":"transform_sqrt()"},{"p":"scales","o":"sqrt_trans","f":"hp_sqrt_trans","d":"This is the variance stabilising transformation for the Poisson\ndistribution.\n","ec":"sqrt_trans()"},{"p":"scales","o":"pvalue","f":"hp_pvalue","d":"\n","ec":"pvalue(x, accuracy = 0.001, decimal.mark = \".\", prefix = NULL, add_p = FALSE)"},{"p":"scales","o":"asinh_trans","f":"hp_asinh_trans","d":"Inverse Hyperbolic Sine transformation\n","ec":"asinh_trans()"},{"p":"scales","o":"identity_trans","f":"hp_identity_trans","d":"Identity transformation (do nothing)\n","ec":"identity_trans()"},{"p":"scales","o":"trans_range","f":"hp_trans_range","d":"Silently drops any ranges outside of the domain of transform.\n","ec":"trans_range(transform, x)"},{"p":"scales","o":"col_quantile","f":"hp_col_quantile","d":"Conveniently maps data values (numeric or factor/character) to colours\naccording to a given palette, which can be provided in a variety of formats.\n","ec":"col_quantile(palette, domain, n = 4, probs = seq(0, 1, length.out = n + 1), na.color = \"#808080\", alpha = FALSE, reverse = FALSE, right = FALSE)"},{"p":"scales","o":"label_dollar","f":"hp_label_dollar","d":"\n","ec":"label_dollar(accuracy = NULL, scale = 1, prefix = \"$\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, largest_with_cents = 1e+05, negative_parens = deprecated(), ...)"},{"p":"scales","o":"transform_exp","f":"hp_transform_exp","d":"Exponential transformation (inverse of log transformation)\n","ec":"transform_exp(base = exp(1))"},{"p":"scales","o":"trans_breaks","f":"hp_trans_breaks","d":"\n","ec":"trans_breaks(trans, inv, n = 5, ...)"},{"p":"scales","o":"label_bytes","f":"hp_label_bytes","d":"Scale bytes into human friendly units. Can use either SI units (e.g.\nkB = 1000 bytes) or binary units (e.g. kiB = 1024 bytes). See\nUnits of Information\non Wikipedia for more details.\n","ec":"label_bytes(units = \"auto_si\", accuracy = 1, scale = 1, ...)"},{"p":"scales","o":"transform_reverse","f":"hp_transform_reverse","d":"reversing transformation works by multiplying the input with -1. This means\nthat reverse transformation cannot easily be composed with transformations\nthat require positive input unless the reversing is done as a final step.\n","ec":"transform_reverse()"},{"p":"scales","o":"number_bytes_format","f":"hp_number_bytes_format","d":"\n","ec":"number_bytes_format(symbol = \"auto\", units = \"binary\", ...)"},{"p":"scales","o":"number","f":"hp_number","d":"This function is a low-level helper that powers many of the labelling\nfunctions. You should generally not need to call it directly unless you\nare creating your own labelling function.\n","ec":"number(x, accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \" \", decimal.mark = \".\", style_positive = c(\"none\", \"plus\", \"space\"), style_negative = c(\"hyphen\", \"minus\", \"parens\"), scale_cut = NULL, trim = TRUE, ...)"},{"p":"scales","o":"censor","f":"hp_censor","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"censor(x, range = c(0, 1), only.finite = TRUE)"},{"p":"scales","o":"fullseq","f":"hp_fullseq","d":"Generate sequence of fixed size intervals covering range.\n","ec":"fullseq(range, size, ...)"},{"p":"scales","o":"demo_continuous","f":"hp_demo_continuous","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_continuous(x, ...)"},{"p":"scales","o":"identity_pal","f":"hp_identity_pal","d":"Leaves values unchanged - useful when the data is already scaled.\n","ec":"identity_pal()"},{"p":"scales","o":"col_numeric","f":"hp_col_numeric","d":"Conveniently maps data values (numeric or factor/character) to colours\naccording to a given palette, which can be provided in a variety of formats.\n","ec":"col_numeric(palette, domain, na.color = \"#808080\", alpha = FALSE, reverse = FALSE)"},{"p":"scales","o":"oob_discard","f":"hp_oob_discard","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_discard(x, range = c(0, 1))"},{"p":"scales","o":"pal_grey","f":"hp_pal_grey","d":"Grey scale palette (discrete)\n","ec":"pal_grey(start = 0.2, end = 0.8)"},{"p":"scales","o":"demo_log10","f":"hp_demo_log10","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_log10(x, ...)"},{"p":"scales","o":"log2_trans","f":"hp_log2_trans","ec":"log2_trans()"},{"p":"scales","o":"cscale","f":"hp_cscale","d":"Continuous scale\n","ec":"cscale(x, palette, na.value = NA_real_, trans = transform_identity())"},{"p":"scales","o":"number_bytes","f":"hp_number_bytes","d":"\n","ec":"number_bytes(x, symbol = \"auto\", units = c(\"binary\", \"si\"), accuracy = 1, ...)"},{"p":"scales","o":"exp_trans","f":"hp_exp_trans","d":"Exponential transformation (inverse of log transformation)\n","ec":"exp_trans(base = exp(1))"},{"p":"scales","o":"oob_keep","f":"hp_oob_keep","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_keep(x, range = c(0, 1))"},{"p":"scales","o":"cbreaks","f":"hp_cbreaks","d":"\n","ec":"cbreaks(range, breaks = extended_breaks(), labels = scientific_format())"},{"p":"scales","o":"minor_breaks_n","f":"hp_minor_breaks_n","d":"Generate minor breaks between major breaks either spaced with a fixed width,\nor having a fixed number.\n","ec":"minor_breaks_n(n)"},{"p":"scales","o":"rescale_mid","f":"hp_rescale_mid","d":"Rescale vector to have specified minimum, midpoint, and maximum\n","ec":"rescale_mid(x, to, from, mid, ...)"},{"p":"scales","o":"dscale","f":"hp_dscale","d":"Discrete scale\n","ec":"dscale(x, palette, na.value = NA)"},{"p":"scales","o":"boxcox_trans","f":"hp_boxcox_trans","d":"The Box-Cox transformation is a flexible transformation, often used to\ntransform data towards normality. The modulus transformation generalises\nBox-Cox to also work with negative values.\n","ec":"boxcox_trans(p, offset = 0)"},{"p":"scales","o":"trim_to_domain","f":"hp_trim_to_domain","d":"Silently drops any ranges outside of the domain of transform.\n","ec":"trim_to_domain(transform, x)"},{"p":"scales","o":"breaks_log","f":"hp_breaks_log","d":"This algorithm starts by looking for integer powers of base. If that\ndoesn't provide enough breaks, it then looks for additional intermediate\nbreaks which are integer multiples of integer powers of base. If that fails\n(which it can for very small ranges), we fall back to extended_breaks()\n","ec":"breaks_log(n = 5, base = 10)"},{"p":"scales","o":"cut_short_scale","f":"hp_cut_short_scale","d":"This function is a low-level helper that powers many of the labelling\nfunctions. You should generally not need to call it directly unless you\nare creating your own labelling function.\n","ec":"cut_short_scale(space = FALSE)"},{"p":"scales","o":"math_format","f":"hp_math_format","d":"\n","ec":"math_format(expr = 10^.x, format = force)"},{"p":"scales","o":"viridis_pal","f":"hp_viridis_pal","d":"Viridis palette\n","ec":"viridis_pal(alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\")"},{"p":"scales","o":"parse_format","f":"hp_parse_format","d":"\n","ec":"parse_format()"},{"p":"scales","o":"squish","f":"hp_squish","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"squish(x, range = c(0, 1), only.finite = TRUE)"},{"p":"scales","o":"label_percent","f":"hp_label_percent","d":"Label percentages (2.5%, 50%, etc)\n","ec":"label_percent(accuracy = NULL, scale = 100, prefix = \"\", suffix = \"%\", big.mark = \" \", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"comma_format","f":"hp_comma_format","d":"\n","ec":"comma_format(accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, digits, ...)"},{"p":"scales","o":"pal_identity","f":"hp_pal_identity","d":"Leaves values unchanged - useful when the data is already scaled.\n","ec":"pal_identity()"},{"p":"scales","o":"demo_discrete","f":"hp_demo_discrete","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_discrete(x, ...)"},{"p":"scales","o":"hue_pal","f":"hp_hue_pal","d":"Hue palette (discrete)\n","ec":"hue_pal(h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, direction = 1)"},{"p":"scales","o":"rescale_none","f":"hp_rescale_none","d":"Don't perform rescaling\n","ec":"rescale_none(x, ...)"},{"p":"scales","o":"transform_log2","f":"hp_transform_log2","ec":"transform_log2()"},{"p":"scales","o":"zero_range","f":"hp_zero_range","d":"The machine epsilon is the difference between 1.0 and the next number\nthat can be represented by the machine. By default, this function\nuses epsilon * 1000 as the tolerance. First it scales the values so that\nthey have a mean of 1, and then it checks if the difference between\nthem is larger than the tolerance.\n","ec":"zero_range(x, tol = 1000 * .Machine$double.eps)"},{"p":"scales","o":"DiscreteRange","f":"hp_DiscreteRange","d":"Mutable ranges have a two methods (train and reset), and\nmake it possible to build up complete ranges with multiple passes.\n","ec":""},{"p":"scales","o":"pal_gradient_n","f":"hp_pal_gradient_n","d":"Arbitrary colour gradient palette (continuous)\n","ec":"pal_gradient_n(colours, values = NULL, space = \"Lab\")"},{"p":"scales","o":"transform_modulus","f":"hp_transform_modulus","d":"The Box-Cox transformation is a flexible transformation, often used to\ntransform data towards normality. The modulus transformation generalises\nBox-Cox to also work with negative values.\n","ec":"transform_modulus(p, offset = 1)"},{"p":"scales","o":"pal_div_gradient","f":"hp_pal_div_gradient","d":"Diverging colour gradient (continuous).\n","ec":"pal_div_gradient(low = mnsl(\"10B 4/6\"), mid = mnsl(\"N 8/0\"), high = mnsl(\"10R 4/6\"), space = \"Lab\")"},{"p":"scales","o":"cut_long_scale","f":"hp_cut_long_scale","d":"This function is a low-level helper that powers many of the labelling\nfunctions. You should generally not need to call it directly unless you\nare creating your own labelling function.\n","ec":"cut_long_scale(space = FALSE)"},{"p":"scales","o":"ordinal","f":"hp_ordinal","d":"\n","ec":"ordinal(x, prefix = \"\", suffix = \"\", big.mark = \" \", rules = ordinal_english(), ...)"},{"p":"scales","o":"label_date","f":"hp_label_date","d":"label_date() and label_time() label date/times using date/time format\nstrings. label_date_short() automatically constructs a short format string\nsufficient to uniquely identify labels. It's inspired by matplotlib's\nConciseDateFormatter,\nbut uses a slightly different approach: ConciseDateFormatter formats\n\"firsts\" (e.g. first day of month, first day of day) specially;\ndate_short() formats changes (e.g. new month, new year) specially.\nlabel_timespan() is intended to show time passed and adds common time units\nsuffix to the input (ns, us, ms, s, m, h, d, w).\n","ec":"label_date(format = \"%Y-%m-%d\", tz = \"UTC\", locale = NULL)"},{"p":"scales","o":"discard","f":"hp_discard","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"discard(x, range = c(0, 1))"},{"p":"scales","o":"label_time","f":"hp_label_time","d":"label_date() and label_time() label date/times using date/time format\nstrings. label_date_short() automatically constructs a short format string\nsufficient to uniquely identify labels. It's inspired by matplotlib's\nConciseDateFormatter,\nbut uses a slightly different approach: ConciseDateFormatter formats\n\"firsts\" (e.g. first day of month, first day of day) specially;\ndate_short() formats changes (e.g. new month, new year) specially.\nlabel_timespan() is intended to show time passed and adds common time units\nsuffix to the input (ns, us, ms, s, m, h, d, w).\n","ec":"label_time(format = \"%H:%M:%S\", tz = \"UTC\", locale = NULL)"},{"p":"scales","o":"transform_boxcox","f":"hp_transform_boxcox","d":"The Box-Cox transformation is a flexible transformation, often used to\ntransform data towards normality. The modulus transformation generalises\nBox-Cox to also work with negative values.\n","ec":"transform_boxcox(p, offset = 0)"},{"p":"scales","o":"comma","f":"hp_comma","d":"\n","ec":"comma(x, accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, digits, ...)"},{"p":"scales","o":"log1p_trans","f":"hp_log1p_trans","ec":"log1p_trans()"},{"p":"scales","o":"label_math","f":"hp_label_math","d":"label_parse() produces expression from strings by parsing them;\nlabel_math() constructs expressions by replacing the pronoun .x\nwith each string.\n","ec":"label_math(expr = 10^.x, format = force)"},{"p":"scales","o":"new_transform","f":"hp_new_transform","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"new_transform(name, transform, inverse, d_transform = NULL, d_inverse = NULL, breaks = extended_breaks(), minor_breaks = regular_minor_breaks(), format = format_format(), domain = c(-Inf, Inf))"},{"p":"scales","o":"demo_time","f":"hp_demo_time","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_time(x, ...)"},{"p":"scales","o":"log10_trans","f":"hp_log10_trans","ec":"log10_trans()"},{"p":"scales","o":"brewer_pal","f":"hp_brewer_pal","d":"Colour Brewer palette (discrete)\n","ec":"brewer_pal(type = \"seq\", palette = 1, direction = 1)"},{"p":"scales","o":"transform_probability","f":"hp_transform_probability","d":"Probability transformation\n","ec":"transform_probability(distribution, ...)"},{"p":"scales","o":"yj_trans","f":"hp_yj_trans","d":"The Yeo-Johnson transformation is a flexible transformation that is similar\nto Box-Cox, transform_boxcox(), but does not require input values to be\ngreater than zero.\n","ec":"yj_trans(p)"},{"p":"scales","o":"logit_trans","f":"hp_logit_trans","d":"Probability transformation\n","ec":"logit_trans()"},{"p":"scales","o":"breaks_extended","f":"hp_breaks_extended","d":"Uses Wilkinson's extended breaks algorithm as implemented in the\nlabeling package.\n","ec":"breaks_extended(n = 5, ...)"},{"p":"scales","o":"pal_dichromat","f":"hp_pal_dichromat","d":"Dichromat (colour-blind) palette (discrete)\n","ec":"pal_dichromat(name)"},{"p":"scales","o":"dichromat_pal","f":"hp_dichromat_pal","d":"Dichromat (colour-blind) palette (discrete)\n","ec":"dichromat_pal(name)"},{"p":"scales","o":"show_col","f":"hp_show_col","d":"A quick and dirty way to show colours in a plot.\n","ec":"show_col(colours, labels = TRUE, borders = NULL, cex_label = 1, ncol = NULL)"},{"p":"scales","o":"demo_timespan","f":"hp_demo_timespan","d":"These functions generate ggplot2 code needed to use scales functions for\nreal code.\n","ec":"demo_timespan(x, ...)"},{"p":"scales","o":"div_gradient_pal","f":"hp_div_gradient_pal","d":"Diverging colour gradient (continuous).\n","ec":"div_gradient_pal(low = mnsl(\"10B 4/6\"), mid = mnsl(\"N 8/0\"), high = mnsl(\"10R 4/6\"), space = \"Lab\")"},{"p":"scales","o":"pal_manual","f":"hp_pal_manual","d":"Manual palette (discrete)\n","ec":"pal_manual(values)"},{"p":"scales","o":"train_discrete","f":"hp_train_discrete","d":"Train (update) a discrete scale\n","ec":"train_discrete(new, existing = NULL, drop = FALSE, na.rm = FALSE, fct = NA)"},{"p":"scales","o":"transform_hms","f":"hp_transform_hms","d":"transform_timespan() provides transformations for data encoding time passed\nalong with breaks and label formatting showing standard unit of time fitting\nthe range of the data. transform_hms() provides the same but using standard\nhms idioms and formatting.\n","ec":"transform_hms()"},{"p":"scales","o":"manual_pal","f":"hp_manual_pal","d":"Manual palette (discrete)\n","ec":"manual_pal(values)"},{"p":"scales","o":"reverse_trans","f":"hp_reverse_trans","d":"reversing transformation works by multiplying the input with -1. This means\nthat reverse transformation cannot easily be composed with transformations\nthat require positive input unless the reversing is done as a final step.\n","ec":"reverse_trans()"},{"p":"scales","o":"regular_minor_breaks","f":"hp_regular_minor_breaks","d":"Places minor breaks between major breaks.\n","ec":"regular_minor_breaks(reverse = FALSE)"},{"p":"scales","o":"pseudo_log_trans","f":"hp_pseudo_log_trans","ec":"pseudo_log_trans(sigma = 1, base = exp(1))"},{"p":"scales","o":"seq_gradient_pal","f":"hp_seq_gradient_pal","d":"Sequential colour gradient palette (continuous)\n","ec":"seq_gradient_pal(low = mnsl(\"10B 4/6\"), high = mnsl(\"10R 4/6\"), space = \"Lab\")"},{"p":"scales","o":"ordinal_french","f":"hp_ordinal_french","d":"Round values to integers and then display as ordinal values (e.g. 1st, 2nd,\n3rd). Built-in rules are provided for English, French, and Spanish.\n","ec":"ordinal_french(gender = c(\"masculin\", \"feminin\"), plural = FALSE)"},{"p":"scales","o":"rescale","f":"hp_rescale","d":"Rescale continuous vector to have specified minimum and maximum\n","ec":"rescale(x, to, from, ...)"},{"p":"scales","o":"transform_logit","f":"hp_transform_logit","d":"Probability transformation\n","ec":"transform_logit()"},{"p":"scales","o":"train_continuous","f":"hp_train_continuous","d":"Strips attributes and always returns a numeric vector\n","ec":"train_continuous(new, existing = NULL)"},{"p":"scales","o":"rescale_pal","f":"hp_rescale_pal","d":"Just rescales the input to the specific output range.  Useful for\nalpha, size, and continuous position.\n","ec":"rescale_pal(range = c(0.1, 1))"},{"p":"scales","o":"col_bin","f":"hp_col_bin","d":"Conveniently maps data values (numeric or factor/character) to colours\naccording to a given palette, which can be provided in a variety of formats.\n","ec":"col_bin(palette, domain, bins = 7, pretty = TRUE, na.color = \"#808080\", alpha = FALSE, reverse = FALSE, right = FALSE)"},{"p":"scales","o":"ordinal_format","f":"hp_ordinal_format","d":"\n","ec":"ordinal_format(prefix = \"\", suffix = \"\", big.mark = \" \", rules = ordinal_english(), ...)"},{"p":"scales","o":"scientific_format","f":"hp_scientific_format","d":"\n","ec":"scientific_format(digits = 3, scale = 1, prefix = \"\", suffix = \"\", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"as.trans","f":"hp_as.trans","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"as.trans(x, arg = deparse(substitute(x)))"},{"p":"scales","o":"time_format","f":"hp_time_format","d":"\n","ec":"time_format(format = \"%H:%M:%S\", tz = \"UTC\", locale = NULL)"},{"p":"scales","o":"unit_format","f":"hp_unit_format","d":"\n","ec":"unit_format(accuracy = NULL, scale = 1, prefix = \"\", unit = \"m\", sep = \" \", suffix = paste0(sep, unit), big.mark = \" \", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"oob_censor_any","f":"hp_oob_censor_any","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_censor_any(x, range = c(0, 1))"},{"p":"scales","o":"is.trans","f":"hp_is.trans","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"is.trans(x)"},{"p":"scales","o":"label_parse","f":"hp_label_parse","d":"label_parse() produces expression from strings by parsing them;\nlabel_math() constructs expressions by replacing the pronoun .x\nwith each string.\n","ec":"label_parse()"},{"p":"scales","o":"modulus_trans","f":"hp_modulus_trans","d":"The Box-Cox transformation is a flexible transformation, often used to\ntransform data towards normality. The modulus transformation generalises\nBox-Cox to also work with negative values.\n","ec":"modulus_trans(p, offset = 1)"},{"p":"scales","o":"label_number_auto","f":"hp_label_number_auto","d":"Switches between number_format() and scientific_format() based on a set of\nheuristics designed to automatically generate useful labels across a wide\nrange of inputs\n","ec":"label_number_auto()"},{"p":"scales","o":"format_format","f":"hp_format_format","d":"\n","ec":"format_format(...)"},{"p":"scales","o":"expand_range","f":"hp_expand_range","d":"Expand a range with a multiplicative or additive constant\n","ec":"expand_range(range, mul = 0, add = 0, zero_width = 1)"},{"p":"scales","o":"pal_seq_gradient","f":"hp_pal_seq_gradient","d":"Sequential colour gradient palette (continuous)\n","ec":"pal_seq_gradient(low = mnsl(\"10B 4/6\"), high = mnsl(\"10R 4/6\"), space = \"Lab\")"},{"p":"scales","o":"trans_format","f":"hp_trans_format","d":"\n","ec":"trans_format(trans, format = scientific_format())"},{"p":"scales","o":"number_format","f":"hp_number_format","d":"\n","ec":"number_format(accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \" \", decimal.mark = \".\", style_positive = c(\"none\", \"plus\", \"space\"), style_negative = c(\"hyphen\", \"minus\", \"parens\"), scale_cut = NULL, trim = TRUE, ...)"},{"p":"scales","o":"probit_trans","f":"hp_probit_trans","d":"Probability transformation\n","ec":"probit_trans()"},{"p":"scales","o":"probability_trans","f":"hp_probability_trans","d":"Probability transformation\n","ec":"probability_trans(distribution, ...)"},{"p":"scales","o":"reciprocal_trans","f":"hp_reciprocal_trans","d":"Reciprocal transformation\n","ec":"reciprocal_trans()"},{"p":"scales","o":"transform_identity","f":"hp_transform_identity","d":"Identity transformation (do nothing)\n","ec":"transform_identity()"},{"p":"scales","o":"ordinal_spanish","f":"hp_ordinal_spanish","d":"Round values to integers and then display as ordinal values (e.g. 1st, 2nd,\n3rd). Built-in rules are provided for English, French, and Spanish.\n","ec":"ordinal_spanish()"},{"p":"scales","o":"transform_reciprocal","f":"hp_transform_reciprocal","d":"Reciprocal transformation\n","ec":"transform_reciprocal()"},{"p":"scales","o":"cut_time_scale","f":"hp_cut_time_scale","d":"This function is a low-level helper that powers many of the labelling\nfunctions. You should generally not need to call it directly unless you\nare creating your own labelling function.\n","ec":"cut_time_scale(space = FALSE)"},{"p":"scales","o":"oob_squish","f":"hp_oob_squish","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_squish(x, range = c(0, 1), only.finite = TRUE)"},{"p":"scales","o":"atanh_trans","f":"hp_atanh_trans","d":"Arc-tangent transformation\n","ec":"atanh_trans()"},{"p":"scales","o":"transform_pseudo_log","f":"hp_transform_pseudo_log","ec":"transform_pseudo_log(sigma = 1, base = exp(1))"},{"p":"scales","o":"date_trans","f":"hp_date_trans","d":"Transformation for dates (class Date)\n","ec":"date_trans()"},{"p":"scales","o":"oob_squish_any","f":"hp_oob_squish_any","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"oob_squish_any(x, range = c(0, 1))"},{"p":"scales","o":"time_trans","f":"hp_time_trans","d":"Transformation for date-times (class POSIXt)\n","ec":"time_trans(tz = NULL)"},{"p":"scales","o":"shape_pal","f":"hp_shape_pal","d":"Shape palette (discrete)\n","ec":"shape_pal(solid = TRUE)"},{"p":"scales","o":"label_log","f":"hp_label_log","d":"label_log() displays numbers as base^exponent, using superscript formatting.\n","ec":"label_log(base = 10, digits = 3)"},{"p":"scales","o":"squish_infinite","f":"hp_squish_infinite","d":"This set of functions modify data values outside a given range.\nThe <U+2060>oob_*()<U+2060> functions are designed to be passed as the oob argument of\nggplot2 continuous and binned scales, with oob_discard being an exception.\n","ec":"squish_infinite(x, range = c(0, 1))"},{"p":"scales","o":"label_ordinal","f":"hp_label_ordinal","d":"Round values to integers and then display as ordinal values (e.g. 1st, 2nd,\n3rd). Built-in rules are provided for English, French, and Spanish.\n","ec":"label_ordinal(prefix = \"\", suffix = \"\", big.mark = \" \", rules = ordinal_english(), ...)"},{"p":"scales","o":"dollar","f":"hp_dollar","d":"\n","ec":"dollar(x, accuracy = NULL, scale = 1, prefix = \"$\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, largest_with_cents = 1e+05, negative_parens = deprecated(), style_negative = c(\"hyphen\", \"minus\", \"parens\"), scale_cut = NULL, ...)"},{"p":"scales","o":"date_format","f":"hp_date_format","d":"\n","ec":"date_format(format = \"%Y-%m-%d\", tz = \"UTC\", locale = NULL)"},{"p":"scales","o":"pvalue_format","f":"hp_pvalue_format","d":"\n","ec":"pvalue_format(accuracy = 0.001, decimal.mark = \".\", prefix = NULL, add_p = FALSE)"},{"p":"scales","o":"gradient_n_pal","f":"hp_gradient_n_pal","d":"Arbitrary colour gradient palette (continuous)\n","ec":"gradient_n_pal(colours, values = NULL, space = \"Lab\")"},{"p":"scales","o":"pal_brewer","f":"hp_pal_brewer","d":"Colour Brewer palette (discrete)\n","ec":"pal_brewer(type = \"seq\", palette = 1, direction = 1)"},{"p":"scales","o":"ContinuousRange","f":"hp_ContinuousRange","d":"Mutable ranges have a two methods (train and reset), and\nmake it possible to build up complete ranges with multiple passes.\n","ec":""},{"p":"scales","o":"pal_area","f":"hp_pal_area","d":"Area palettes (continuous)\n","ec":"pal_area(range = c(1, 6))"},{"p":"scales","o":"minor_breaks_width","f":"hp_minor_breaks_width","d":"Generate minor breaks between major breaks either spaced with a fixed width,\nor having a fixed number.\n","ec":"minor_breaks_width(width, offset)"},{"p":"scales","o":"extended_breaks","f":"hp_extended_breaks","d":"Uses Wilkinson's extended breaks algorithm as implemented in the\nlabeling package.\n","ec":"extended_breaks(n = 5, ...)"},{"p":"scales","o":"compose_trans","f":"hp_compose_trans","d":"This transformer provides a general mechanism for composing two or more\ntransformers together. The most important use case is to combine reverse\nwith other transformations.\n","ec":"compose_trans(...)"},{"p":"scales","o":"log_trans","f":"hp_log_trans","ec":"log_trans(base = exp(1))"},{"p":"scales","o":"cut_si","f":"hp_cut_si","d":"This function is a low-level helper that powers many of the labelling\nfunctions. You should generally not need to call it directly unless you\nare creating your own labelling function.\n","ec":"cut_si(unit)"},{"p":"scales","o":"percent","f":"hp_percent","d":"\n","ec":"percent(x, accuracy = NULL, scale = 100, prefix = \"\", suffix = \"%\", big.mark = \" \", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"pal_rescale","f":"hp_pal_rescale","d":"Just rescales the input to the specific output range.  Useful for\nalpha, size, and continuous position.\n","ec":"pal_rescale(range = c(0.1, 1))"},{"p":"scales","o":"label_scientific","f":"hp_label_scientific","d":"Label numbers with scientific notation (e.g. 1e05, 1.5e-02)\n","ec":"label_scientific(digits = 3, scale = 1, prefix = \"\", suffix = \"\", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"transform_yj","f":"hp_transform_yj","d":"The Yeo-Johnson transformation is a flexible transformation that is similar\nto Box-Cox, transform_boxcox(), but does not require input values to be\ngreater than zero.\n","ec":"transform_yj(p)"},{"p":"scales","o":"transform_atanh","f":"hp_transform_atanh","d":"Arc-tangent transformation\n","ec":"transform_atanh()"},{"p":"scales","o":"transform_log10","f":"hp_transform_log10","ec":"transform_log10()"},{"p":"scales","o":"trans_new","f":"hp_trans_new","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"trans_new(name, transform, inverse, d_transform = NULL, d_inverse = NULL, breaks = extended_breaks(), minor_breaks = regular_minor_breaks(), format = format_format(), domain = c(-Inf, Inf))"},{"p":"scales","o":"dollar_format","f":"hp_dollar_format","d":"\n","ec":"dollar_format(accuracy = NULL, scale = 1, prefix = \"$\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, largest_with_cents = 1e+05, negative_parens = deprecated(), ...)"},{"p":"scales","o":"Range","f":"hp_Range","d":"Mutable ranges have a two methods (train and reset), and\nmake it possible to build up complete ranges with multiple passes.\n","ec":""},{"p":"scales","o":"muted","f":"hp_muted","d":"Mute standard colour\n","ec":"muted(colour, l = 30, c = 70)"},{"p":"scales","o":"transform_compose","f":"hp_transform_compose","d":"This transformer provides a general mechanism for composing two or more\ntransformers together. The most important use case is to combine reverse\nwith other transformations.\n","ec":"transform_compose(...)"},{"p":"scales","o":"as.transform","f":"hp_as.transform","d":"A transformation encapsulates a transformation and its inverse, as well\nas the information needed to create pleasing breaks and labels. The breaks()\nfunction is applied on the un-transformed range of the data, and the\nformat() function takes the output of the breaks() function and returns\nwell-formatted labels. Transformations may also include the derivatives of the\ntransformation and its inverse, but are not required to.\n","ec":"as.transform(x, arg = deparse(substitute(x)))"},{"p":"scales","o":"label_wrap","f":"hp_label_wrap","d":"Uses strwrap() to split long labels across multiple lines.\n","ec":"label_wrap(width)"},{"p":"scales","o":"linetype_pal","f":"hp_linetype_pal","d":"Based on a set supplied by Richard Pearson, University of Manchester\n","ec":"linetype_pal()"},{"p":"scales","o":"timespan_trans","f":"hp_timespan_trans","d":"transform_timespan() provides transformations for data encoding time passed\nalong with breaks and label formatting showing standard unit of time fitting\nthe range of the data. transform_hms() provides the same but using standard\nhms idioms and formatting.\n","ec":"timespan_trans(unit = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))"},{"p":"scales","o":"scientific","f":"hp_scientific","d":"\n","ec":"scientific(x, digits = 3, scale = 1, prefix = \"\", suffix = \"\", decimal.mark = \".\", trim = TRUE, ...)"},{"p":"scales","o":"area_pal","f":"hp_area_pal","d":"Area palettes (continuous)\n","ec":"area_pal(range = c(1, 6))"},{"p":"scales","o":"label_number","f":"hp_label_number","d":"Use label_number() force decimal display of numbers (i.e. don't use\nscientific notation). label_comma() is a special case\nthat inserts a comma every three digits.\n","ec":"label_number(accuracy = NULL, scale = 1, prefix = \"\", suffix = \"\", big.mark = \" \", decimal.mark = \".\", style_positive = c(\"none\", \"plus\", \"space\"), style_negative = c(\"hyphen\", \"minus\", \"parens\"), scale_cut = NULL, trim = TRUE, ...)"},{"p":"scales","o":"label_pvalue","f":"hp_label_pvalue","d":"Formatter for p-values, using \"<\" and \">\" for p-values close to 0 and 1.\n","ec":"label_pvalue(accuracy = 0.001, decimal.mark = \".\", prefix = NULL, add_p = FALSE)"},{"p":"scales","o":"label_currency","f":"hp_label_currency","d":"Format numbers as currency, rounding values to monetary or fractional\nmonetary using unit a convenient heuristic.\n","ec":"label_currency(accuracy = NULL, scale = 1, prefix = \"$\", suffix = \"\", big.mark = \",\", decimal.mark = \".\", trim = TRUE, largest_with_fractional = 1e+05, ...)"},{"p":"sjlabelled","o":"set_na","f":"hp_set_na","d":"This function replaces specific values of variables with NA.\n","ec":"set_na(x, ..., na, drop.levels = TRUE, as.tag = FALSE)"},{"p":"sjlabelled","o":"zap_labels","f":"hp_zap_labels","d":"For (partially) labelled vectors, zap_labels() will replace\nall values that have a value label attribute with NA;\nzap_unlabelled(), as counterpart, will replace all values\nthat don't have a value label attribute with NA.\ndrop_labels() drops all value labels for unused values,\ni.e. values that are not present in a vector. fill_labels() is the\ncounterpart to drop_labels() and adds value labels to\na partially labelled vector, i.e. if not all values are\nlabelled, non-labelled values get labels.\n","ec":"zap_labels(x, ...)"},{"p":"sjlabelled","o":"set_label","f":"hp_set_label","d":"This function adds variable labels as attribute\n(named \"label\") to the variable x, resp. to a\nset of variables in a data frame or a list-object. var_labels()\nis intended for use within pipe-workflows and has a tidyverse-consistent\nsyntax, including support for quasi-quotation (see 'Examples').\n","ec":"set_label(x, label)"},{"p":"sjlabelled","o":"add_labels","f":"hp_add_labels","d":"These functions add, replace or remove value labels to or from variables.\n","ec":"add_labels(x, ..., labels)"},{"p":"sjlabelled","o":"val_labels","f":"hp_val_labels","d":"This function adds labels as attribute (named \"labels\")\nto a variable or vector x, resp. to a set of variables in a\ndata frame or a list-object. A use-case is, for instance, the\nsjPlot-package, which supports labelled data and automatically\nassigns labels to axes or legends in plots or to be used in tables.\nval_labels() is intended for use within pipe-workflows and has a\ntidyverse-consistent syntax, including support for quasi-quotation\n(see 'Examples').\n","ec":"val_labels(x, ..., force.labels = FALSE, force.values = TRUE, drop.na = TRUE)"},{"p":"sjlabelled","o":"get_na","f":"hp_get_na","d":"This function retrieves tagged NA values and their associated\nvalue labels from a labelled vector.\n","ec":"get_na(x, as.tag = FALSE)"},{"p":"sjlabelled","o":"as_factor","f":"hp_as_factor","d":"This function converts a variable into a factor, but preserves\nvariable and value label attributes.\n","ec":"as_factor(x, ...)"},{"p":"sjlabelled","o":"set_labels","f":"hp_set_labels","d":"This function adds labels as attribute (named \"labels\")\nto a variable or vector x, resp. to a set of variables in a\ndata frame or a list-object. A use-case is, for instance, the\nsjPlot-package, which supports labelled data and automatically\nassigns labels to axes or legends in plots or to be used in tables.\nval_labels() is intended for use within pipe-workflows and has a\ntidyverse-consistent syntax, including support for quasi-quotation\n(see 'Examples').\n","ec":"set_labels(x, ..., labels, force.labels = FALSE, force.values = TRUE, drop.na = TRUE)"},{"p":"sjlabelled","o":"get_label","f":"hp_get_label","d":"This function returns the variable labels of labelled data.\n","ec":"get_label(x, ..., def.value = NULL, case = NULL)"},{"p":"sjlabelled","o":"as_character","f":"hp_as_character","d":"as_label() converts (replaces) values of a variable (also of factors\nor character vectors) with their associated value labels. Might\nbe helpful for factor variables.\nFor instance, if you have a Gender variable with 0/1 value, and associated\nlabels are male/female, this function would convert all 0 to male and\nall 1 to female and returns the new variable as factor.\nas_character() does the same as as_label(), but returns\na character vector.\n","ec":"as_character(x, ...)"},{"p":"sjlabelled","o":"read_spss","f":"hp_read_spss","d":"Import data from SPSS, SAS or Stata, including NA's, value and variable\nlabels.\n","ec":"read_spss(path, convert.factors = TRUE, drop.labels = FALSE, tag.na = FALSE, encoding = NULL, verbose = FALSE, atomic.to.fac = convert.factors)"},{"p":"sjlabelled","o":"write_stata","f":"hp_write_stata","d":"These functions write the content of a data frame to an SPSS, SAS or\nStata-file.\n","ec":"write_stata(x, path, drop.na = FALSE, version = 14)"},{"p":"sjlabelled","o":"as_labelled","f":"hp_as_labelled","d":"Converts a (labelled) vector of any class into a labelled\nclass vector, resp. adds a labelled class-attribute.\n","ec":"as_labelled(x, add.labels = FALSE, add.class = FALSE, skip.strings = FALSE, tag.na = FALSE)"},{"p":"sjlabelled","o":"get_term_labels","f":"hp_get_term_labels","d":"This function retrieves variable labels from model terms. In case\nof categorical variables, where one variable has multiple dummies,\nvariable name and category value is returned.\n","ec":"get_term_labels(models, mark.cat = FALSE, case = NULL, prefix = c(\"none\", \"varname\", \"label\"), ...)"},{"p":"sjlabelled","o":"read_sas","f":"hp_read_sas","d":"Import data from SPSS, SAS or Stata, including NA's, value and variable\nlabels.\n","ec":"read_sas(path, path.cat = NULL, convert.factors = TRUE, drop.labels = FALSE, encoding = NULL, verbose = FALSE, atomic.to.fac = convert.factors)"},{"p":"sjlabelled","o":"write_sas","f":"hp_write_sas","d":"These functions write the content of a data frame to an SPSS, SAS or\nStata-file.\n","ec":"write_sas(x, path, drop.na = FALSE)"},{"p":"sjlabelled","o":"get_labels","f":"hp_get_labels","d":"This function returns the value labels of labelled data.\n","ec":"get_labels(x, attr.only = FALSE, values = NULL, non.labelled = FALSE, drop.na = TRUE, drop.unused = FALSE)"},{"p":"sjlabelled","o":"convert_case","f":"hp_convert_case","d":"This function wraps to_any_case() from the snakecase\npackage with certain defaults for the sep_in and\nsep_out arguments, used for instance to convert cases in\nterm_labels.\n","ec":"convert_case(lab, case = NULL, verbose = FALSE, ...)"},{"p":"sjlabelled","o":"to_character","f":"hp_to_character","d":"as_label() converts (replaces) values of a variable (also of factors\nor character vectors) with their associated value labels. Might\nbe helpful for factor variables.\nFor instance, if you have a Gender variable with 0/1 value, and associated\nlabels are male/female, this function would convert all 0 to male and\nall 1 to female and returns the new variable as factor.\nas_character() does the same as as_label(), but returns\na character vector.\n","ec":"to_character(x, ...)"},{"p":"sjlabelled","o":"is_labelled","f":"hp_is_labelled","d":"This function checks whether x is of class labelled.\n","ec":"is_labelled(x)"},{"p":"sjlabelled","o":"term_labels","f":"hp_term_labels","d":"This function retrieves variable labels from model terms. In case\nof categorical variables, where one variable has multiple dummies,\nvariable name and category value is returned.\n","ec":"term_labels(models, mark.cat = FALSE, case = NULL, prefix = c(\"none\", \"varname\", \"label\"), ...)"},{"p":"sjlabelled","o":"drop_labels","f":"hp_drop_labels","d":"For (partially) labelled vectors, zap_labels() will replace\nall values that have a value label attribute with NA;\nzap_unlabelled(), as counterpart, will replace all values\nthat don't have a value label attribute with NA.\ndrop_labels() drops all value labels for unused values,\ni.e. values that are not present in a vector. fill_labels() is the\ncounterpart to drop_labels() and adds value labels to\na partially labelled vector, i.e. if not all values are\nlabelled, non-labelled values get labels.\n","ec":"drop_labels(x, ..., drop.na = TRUE)"},{"p":"sjlabelled","o":"get_values","f":"hp_get_values","d":"This function retrieves the values associated with value labels\nfrom labelled vectors. Data is also labelled\nwhen imported from SPSS, SAS or STATA via read_spss,\nread_sas or read_stata.\n","ec":"get_values(x, sort.val = TRUE, drop.na = FALSE)"},{"p":"sjlabelled","o":"remove_all_labels","f":"hp_remove_all_labels","d":"This function removes value and variable label attributes\nfrom a vector or data frame. These attributes are typically\nadded to variables when importing foreign data (see\nread_spss) or manually adding label attributes\nwith set_labels.\n","ec":"remove_all_labels(x)"},{"p":"sjlabelled","o":"read_stata","f":"hp_read_stata","d":"Import data from SPSS, SAS or Stata, including NA's, value and variable\nlabels.\n","ec":"read_stata(path, convert.factors = TRUE, drop.labels = FALSE, encoding = NULL, verbose = FALSE, atomic.to.fac = convert.factors)"},{"p":"sjlabelled","o":"remove_label","f":"hp_remove_label","d":"Remove variable labels from variables.\n","ec":"remove_label(x, ...)"},{"p":"sjlabelled","o":"unlabel","f":"hp_unlabel","d":"This function converts labelled class vectors\ninto a generic data format, which means that simply all labelled\nclass attributes will be removed, so all vectors / variables will most\nlikely become atomic.\n","ec":"unlabel(x, verbose = FALSE)"},{"p":"sjlabelled","o":"copy_labels","f":"hp_copy_labels","d":"Subsetting-functions usually drop value and variable labels from\nsubsetted data frames (if the original data frame has value and variable\nlabel attributes). This function copies these value and variable\nlabels back to subsetted data frames that have been subsetted, for instance,\nwith subset.\n","ec":"copy_labels(df_new, df_origin = NULL, ...)"},{"p":"sjlabelled","o":"get_dv_labels","f":"hp_get_dv_labels","d":"This function retrieves variable labels from model terms. In case\nof categorical variables, where one variable has multiple dummies,\nvariable name and category value is returned.\n","ec":"get_dv_labels(models, case = NULL, multi.resp = FALSE, mv = FALSE, ...)"},{"p":"sjlabelled","o":"set_label<-","f":"hp_set_label..","d":"This function adds variable labels as attribute\n(named \"label\") to the variable x, resp. to a\nset of variables in a data frame or a list-object. var_labels()\nis intended for use within pipe-workflows and has a tidyverse-consistent\nsyntax, including support for quasi-quotation (see 'Examples').\n","ec":"set_label<-(x, value)"},{"p":"sjlabelled","o":"to_label","f":"hp_to_label","d":"as_label() converts (replaces) values of a variable (also of factors\nor character vectors) with their associated value labels. Might\nbe helpful for factor variables.\nFor instance, if you have a Gender variable with 0/1 value, and associated\nlabels are male/female, this function would convert all 0 to male and\nall 1 to female and returns the new variable as factor.\nas_character() does the same as as_label(), but returns\na character vector.\n","ec":"to_label(x, ...)"},{"p":"sjlabelled","o":"remove_labels","f":"hp_remove_labels","d":"These functions add, replace or remove value labels to or from variables.\n","ec":"remove_labels(x, ..., labels)"},{"p":"sjlabelled","o":"zap_na_tags","f":"hp_zap_na_tags","d":"Replaces all tagged_na() values with\nregular NA.\n","ec":"zap_na_tags(x, ...)"},{"p":"sjlabelled","o":"replace_labels","f":"hp_replace_labels","d":"These functions add, replace or remove value labels to or from variables.\n","ec":"replace_labels(x, ..., labels)"},{"p":"sjlabelled","o":"response_labels","f":"hp_response_labels","d":"This function retrieves variable labels from model terms. In case\nof categorical variables, where one variable has multiple dummies,\nvariable name and category value is returned.\n","ec":"response_labels(models, case = NULL, multi.resp = FALSE, mv = FALSE, ...)"},{"p":"sjlabelled","o":"write_spss","f":"hp_write_spss","d":"These functions write the content of a data frame to an SPSS, SAS or\nStata-file.\n","ec":"write_spss(x, path, drop.na = FALSE, compress = FALSE)"},{"p":"sjlabelled","o":"read_data","f":"hp_read_data","d":"Import data from SPSS, SAS or Stata, including NA's, value and variable\nlabels.\n","ec":"read_data(path, convert.factors = TRUE, drop.labels = FALSE, encoding = NULL, verbose = FALSE, atomic.to.fac = convert.factors)"},{"p":"sjlabelled","o":"as_numeric","f":"hp_as_numeric","d":"This function converts (replaces) factor levels with the\nrelated factor level index number, thus the factor is converted to\na numeric variable.\n","ec":"as_numeric(x, ...)"},{"p":"sjlabelled","o":"tidy_labels","f":"hp_tidy_labels","d":"Duplicated value labels in variables may cause troubles when\nsaving labelled data, or computing cross tabs (cf.\nsjmisc::flat_table() or sjPlot::plot_xtab()).\ntidy_labels() repairs duplicated value labels by suffixing\nthem with the associated value.\n","ec":"tidy_labels(x, ..., sep = \"_\", remove = FALSE)"},{"p":"sjlabelled","o":"label_to_colnames","f":"hp_label_to_colnames","d":"This function sets variable labels as column names, to use \"labelled\ndata\" also for those functions that cannot cope with labelled data by default.\n","ec":"label_to_colnames(x, ...)"},{"p":"sjlabelled","o":"fill_labels","f":"hp_fill_labels","d":"For (partially) labelled vectors, zap_labels() will replace\nall values that have a value label attribute with NA;\nzap_unlabelled(), as counterpart, will replace all values\nthat don't have a value label attribute with NA.\ndrop_labels() drops all value labels for unused values,\ni.e. values that are not present in a vector. fill_labels() is the\ncounterpart to drop_labels() and adds value labels to\na partially labelled vector, i.e. if not all values are\nlabelled, non-labelled values get labels.\n","ec":"fill_labels(x, ...)"},{"p":"sjlabelled","o":"var_labels","f":"hp_var_labels","d":"This function adds variable labels as attribute\n(named \"label\") to the variable x, resp. to a\nset of variables in a data frame or a list-object. var_labels()\nis intended for use within pipe-workflows and has a tidyverse-consistent\nsyntax, including support for quasi-quotation (see 'Examples').\n","ec":"var_labels(x, ...)"},{"p":"sjlabelled","o":"to_numeric","f":"hp_to_numeric","d":"This function converts (replaces) factor levels with the\nrelated factor level index number, thus the factor is converted to\na numeric variable.\n","ec":"to_numeric(x, ...)"},{"p":"sjlabelled","o":"zap_unlabelled","f":"hp_zap_unlabelled","d":"For (partially) labelled vectors, zap_labels() will replace\nall values that have a value label attribute with NA;\nzap_unlabelled(), as counterpart, will replace all values\nthat don't have a value label attribute with NA.\ndrop_labels() drops all value labels for unused values,\ni.e. values that are not present in a vector. fill_labels() is the\ncounterpart to drop_labels() and adds value labels to\na partially labelled vector, i.e. if not all values are\nlabelled, non-labelled values get labels.\n","ec":"zap_unlabelled(x, ...)"},{"p":"sjlabelled","o":"to_factor","f":"hp_to_factor","d":"This function converts a variable into a factor, but preserves\nvariable and value label attributes.\n","ec":"to_factor(x, ...)"},{"p":"sjlabelled","o":"as_label","f":"hp_as_label","d":"as_label() converts (replaces) values of a variable (also of factors\nor character vectors) with their associated value labels. Might\nbe helpful for factor variables.\nFor instance, if you have a Gender variable with 0/1 value, and associated\nlabels are male/female, this function would convert all 0 to male and\nall 1 to female and returns the new variable as factor.\nas_character() does the same as as_label(), but returns\na character vector.\n","ec":"as_label(x, ...)"},{"p":"splines","o":"bs","f":"hp_bs","d":"Generate the B-spline basis matrix for a polynomial spline.\n","ec":"bs(x, df = NULL, knots = NULL, degree = 3, intercept = FALSE, Boundary.knots = range(x), warn.outside = TRUE)"},{"p":"splines","o":"splineKnots","f":"hp_splineKnots","d":"Return the knot vector corresponding to a spline object.\n","ec":"splineKnots(object)"},{"p":"splines","o":"as.polySpline","f":"hp_as.polySpline","d":"Create the piecewise polynomial representation of a spline object.\n","ec":"as.polySpline(object, ...)"},{"p":"splines","o":"interpSpline","f":"hp_interpSpline","d":"Create an interpolation spline, either from x and y\nvectors (default method), or from a formula / data.frame\ncombination (formula method).\n","ec":"interpSpline(obj1, obj2, bSpline = FALSE, period = NULL, ord = 4L, na.action = na.fail, sparse = FALSE)"},{"p":"splines","o":"splineDesign","f":"hp_splineDesign","d":"Evaluate the design matrix for the B-splines defined by knots\nat the values in x.\n","ec":"splineDesign(knots, x, ord = 4L, derivs = 0L, outer.ok = FALSE, sparse = FALSE)"},{"p":"splines","o":"asVector","f":"hp_asVector","d":"This is a generic function.  Methods for this function coerce objects\nof given classes to vectors.\n","ec":"asVector(object)"},{"p":"splines","o":"spline.des","f":"hp_spline.des","d":"Evaluate the design matrix for the B-splines defined by knots\nat the values in x.\n","ec":"spline.des(knots, x, ord = 4, derivs = integer(length(x)), outer.ok = FALSE, sparse = FALSE)"},{"p":"splines","o":"backSpline","f":"hp_backSpline","d":"Create a monotone inverse of a monotone natural spline.\n","ec":"backSpline(object)"},{"p":"splines","o":"ns","f":"hp_ns","d":"Generate the B-spline basis matrix for a natural cubic spline.\n","ec":"ns(x, df = NULL, knots = NULL, intercept = FALSE, Boundary.knots = range(x))"},{"p":"splines","o":"xyVector","f":"hp_xyVector","d":"Create an object to represent a set of x-y pairs.  The resulting\nobject can be treated as a matrix or as a data frame or as a vector.\nWhen treated as a vector it reduces to the y component only.\n","ec":"xyVector(x, y)"},{"p":"splines","o":"periodicSpline","f":"hp_periodicSpline","d":"Create a periodic interpolation spline, either from x and\ny vectors, or from a formula/data.frame combination.\n","ec":"periodicSpline(obj1, obj2, knots, period = 2 * pi, ord = 4L)"},{"p":"splines","o":"splineOrder","f":"hp_splineOrder","d":"Return the order of a spline object.\n","ec":"splineOrder(object)"},{"p":"splines","o":"polySpline","f":"hp_polySpline","d":"Create the piecewise polynomial representation of a spline object.\n","ec":"polySpline(object, ...)"},{"p":"stats","o":"asOneSidedFormula","f":"hp_asOneSidedFormula","d":"Names, calls, expressions (first element), numeric values, and\ncharacter strings are converted to one-sided formulae\nassociated with the global environment.\nIf the input is a formula, it must be\none-sided, in which case it is returned unaltered.\n","ec":"asOneSidedFormula(object)"},{"p":"stats","o":"r2dtable","f":"hp_r2dtable","d":"Generate random 2-way tables with given marginals using Patefield's\nalgorithm.\n","ec":"r2dtable(n, r, c)"},{"p":"stats","o":"drop.terms","f":"hp_drop.terms","d":"delete.response returns a terms object for the same\nmodel but with no response variable.\n","ec":"drop.terms(termobj, dropx = NULL, keep.response = FALSE)"},{"p":"stats","o":"confint.lm","f":"hp_confint.lm","d":"Computes confidence intervals for one or more parameters in a fitted\nmodel.  There is a default and a method for objects inheriting from class\n\"lm\".\n","ec":"confint.lm(object, parm, level = 0.95, ...)"},{"p":"stats","o":"is.mts","f":"hp_is.mts","d":"The function ts is used to create time-series objects.\n","ec":"is.mts(x)"},{"p":"stats","o":"nlminb","f":"hp_nlminb","d":"Unconstrained and box-constrained optimization using PORT routines.\n","ec":"nlminb(start, objective, gradient = NULL, hessian = NULL, ..., scale = 1, control = list(), lower = -Inf, upper = Inf)"},{"p":"stats","o":"alias","f":"hp_alias","d":"Find aliases (linearly dependent terms) in a linear model specified by\na formula.\n","ec":"alias(object, ...)"},{"p":"stats","o":"gaussian","f":"hp_gaussian","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"gaussian(link = \"identity\")"},{"p":"stats","o":"profile","f":"hp_profile","d":"Investigates the behavior of the objective function near the solution\nrepresented by fitted.\n","ec":"profile(fitted, ...)"},{"p":"stats","o":"ls.diag","f":"hp_ls.diag","d":"Computes basic statistics, including standard errors, t- and p-values\nfor the regression coefficients.\n","ec":"ls.diag(ls.out)"},{"p":"stats","o":"mahalanobis","f":"hp_mahalanobis","d":"Returns the squared Mahalanobis distance of all rows in x and the\nvector \\mu = center with respect to\n\\Sigma = cov.\nThis is (for vector x) defined as\n","ec":"mahalanobis(x, center, cov, inverted = FALSE, ...)"},{"p":"stats","o":"rmultinom","f":"hp_rmultinom","d":"Generate multinomially distributed random number vectors and\ncompute multinomial probabilities.\n","ec":"rmultinom(n, size, prob)"},{"p":"stats","o":"dpois","f":"hp_dpois","d":"Density, distribution function, quantile function and random\ngeneration for the Poisson distribution with parameter lambda.\n","ec":"dpois(x, lambda, log = FALSE)"},{"p":"stats","o":"numericDeriv","f":"hp_numericDeriv","d":"numericDeriv numerically evaluates the gradient of an expression.\n","ec":"numericDeriv(expr, theta, rho = parent.frame(), dir = 1, eps = .Machine$double.eps^(1/if (central) 3 else 2), central = FALSE)"},{"p":"stats","o":"makepredictcall","f":"hp_makepredictcall","d":"A utility to help model.frame.default create the right\nmatrices when predicting from models with terms like (univariate)\npoly or ns.\n","ec":"makepredictcall(var, call)"},{"p":"stats","o":"qlogis","f":"hp_qlogis","d":"Density, distribution function, quantile function and random\ngeneration for the logistic distribution with parameters\nlocation and scale.\n","ec":"qlogis(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"loadings","f":"hp_loadings","d":"Extract or print loadings in factor analysis (or principal\ncomponents analysis).\n","ec":"loadings(x, ...)"},{"p":"stats","o":"dlogis","f":"hp_dlogis","d":"Density, distribution function, quantile function and random\ngeneration for the logistic distribution with parameters\nlocation and scale.\n","ec":"dlogis(x, location = 0, scale = 1, log = FALSE)"},{"p":"stats","o":"nlm","f":"hp_nlm","d":"This function carries out a minimization of the function f\nusing a Newton-type algorithm.  See the references for details.\n","ec":"nlm(f, p, ..., hessian = FALSE, typsize = rep(1, length(p)), fscale = 1, print.level = 0, ndigit = 12, gradtol = 1e-06, stepmax = max(1000 * sqrt(sum((p/typsize)^2)), 1000), steptol = 1e-06, iterlim = 100, check.analyticals = TRUE)"},{"p":"stats","o":"residuals.glm","f":"hp_residuals.glm","d":"These functions are all methods for class glm or\nsummary.glm objects.\n","ec":"residuals.glm(object, type = c(\"deviance\", \"pearson\", \"working\", \"response\", \"partial\"), ...)"},{"p":"stats","o":"qcauchy","f":"hp_qcauchy","d":"Density, distribution function, quantile function and random\ngeneration for the Cauchy distribution with location parameter\nlocation and scale parameter scale.\n","ec":"qcauchy(p, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"nextn","f":"hp_nextn","d":"nextn returns the smallest integer,\ngreater than or equal to n, which can be obtained\nas a product of powers of the values contained in factors.\n","ec":"nextn(n, factors = c(2, 3, 5))"},{"p":"stats","o":"nls","f":"hp_nls","d":"Determine the nonlinear (weighted) least-squares estimates of the\nparameters of a nonlinear model.\n","ec":"nls(formula, data = parent.frame(), start, control = nls.control(), algorithm = c(\"default\", \"plinear\", \"port\"), trace = FALSE, subset, weights, na.action, model = FALSE, lower = -Inf, upper = Inf, ...)"},{"p":"stats","o":"plot.stepfun","f":"hp_plot.stepfun","d":"Method of the generic plot for stepfun\nobjects and utility for plotting piecewise constant functions.\n","ec":"plot.stepfun(x, xval, xlim, ylim = range(c(y, Fn.kn)), xlab = \"x\", ylab = \"f(x)\", main = NULL, add = FALSE, verticals = TRUE, do.points = (n < 1000), pch = par(\"pch\"), col = par(\"col\"), col.points = col, cex.points = par(\"cex\"), col.hor = col, col.vert = col, lty = par(\"lty\"), lwd = par(\"lwd\"), ...)"},{"p":"stats","o":"arima0.diag","f":"hp_arima0.diag","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"arima0.diag(...)"},{"p":"stats","o":"dummy.coef","f":"hp_dummy.coef","d":"This extracts coefficients in terms of the original levels of the\ncoefficients rather than the coded variables.\n","ec":"dummy.coef(object, ...)"},{"p":"stats","o":"ftable","f":"hp_ftable","d":"Create <U+2018>flat<U+2019> contingency tables.","ec":"ftable(x, ...)"},{"p":"stats","o":"as.formula","f":"hp_as.formula","d":"The generic function formula and its specific methods provide a\nway of extracting formulae which have been included in other objects.\n","ec":"as.formula(object, env = parent.frame())"},{"p":"stats","o":"pairwise.wilcox.test","f":"hp_pairwise.wilcox.test","d":"Calculate pairwise comparisons between group levels with corrections\nfor multiple testing.\n","ec":"pairwise.wilcox.test(x, g, p.adjust.method = p.adjust.methods, paired = FALSE, ...)"},{"p":"stats","o":"time","f":"hp_time","d":"time creates the vector of times at which a time series was sampled.\n","ec":"time(x, ...)"},{"p":"stats","o":"embed","f":"hp_embed","d":"Embeds the time series x into a low-dimensional\nEuclidean space.\n","ec":"embed(x, dimension = 1)"},{"p":"stats","o":"mantelhaen.test","f":"hp_mantelhaen.test","d":"Performs a Cochran-Mantel-Haenszel chi-squared test of the null that\ntwo nominal variables are conditionally independent in each stratum,\nassuming that there is no three-way interaction.\n","ec":"mantelhaen.test(x, y = NULL, z = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), correct = TRUE, exact = FALSE, conf.level = 0.95)"},{"p":"stats","o":"dwilcox","f":"hp_dwilcox","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon rank sum statistic\nobtained from samples with size m and n, respectively.\n","ec":"dwilcox(x, m, n, log = FALSE)"},{"p":"stats","o":"ar","f":"hp_ar","d":"Fit an autoregressive time series model to the data, by default\nselecting the complexity by AIC.\n","ec":"ar(x, aic = TRUE, order.max = NULL, method = c(\"yule-walker\", \"burg\", \"ols\", \"mle\", \"yw\"), na.action = na.fail, series = deparse1(substitute(x)), ...)"},{"p":"stats","o":"oneway.test","f":"hp_oneway.test","d":"Test whether two or more samples from normal distributions have the\nsame means.  The variances are not necessarily assumed to be equal.\n","ec":"oneway.test(formula, data, subset, na.action, var.equal = FALSE)"},{"p":"stats","o":"fligner.test","f":"hp_fligner.test","d":"Performs a Fligner-Killeen (median) test of the null that the\nvariances in each of the groups (samples) are the same.\n","ec":"fligner.test(x, ...)"},{"p":"stats","o":"bw.bcv","f":"hp_bw.bcv","d":"Bandwidth selectors for Gaussian kernels in density.\n","ec":"bw.bcv(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower)"},{"p":"stats","o":"predict.glm","f":"hp_predict.glm","d":"Obtains predictions and optionally estimates standard errors of those\npredictions from a fitted generalized linear model object.\n","ec":"predict.glm(object, newdata = NULL, type = c(\"link\", \"response\", \"terms\"), se.fit = FALSE, dispersion = NULL, terms = NULL, na.action = na.pass, ...)"},{"p":"stats","o":"rWishart","f":"hp_rWishart","d":"Generate n random matrices, distributed according to the\nWishart distribution with parameters Sigma and df,\nW_p(\\Sigma, m),\\ m=\\code{df},\\ \\Sigma=\\code{Sigma}.\n","ec":"rWishart(n, df, Sigma)"},{"p":"stats","o":"logLik","f":"hp_logLik","d":"This function is generic; method functions can be written to handle\nspecific classes of objects.  Classes which have methods for this\nfunction include: \"glm\", \"lm\", \"nls\" and\n\"Arima\".  Packages contain methods for other classes, such as\n\"fitdistr\", \"negbin\" and \"polr\" in package\nMASS, \"multinom\" in package nnet and\n\"gls\", \"gnls\" \"lme\" and others in package\nnlme.\n","ec":"logLik(object, ...)"},{"p":"stats","o":"confint.default","f":"hp_confint.default","d":"Computes confidence intervals for one or more parameters in a fitted\nmodel.  There is a default and a method for objects inheriting from class\n\"lm\".\n","ec":"confint.default(object, parm, level = 0.95, ...)"},{"p":"stats","o":"AIC","f":"hp_AIC","d":"Generic function calculating Akaike's <U+2018>An Information Criterion<U+2019> for\none or several fitted model objects for which a log-likelihood value\ncan be obtained, according to the formula\n-2 \\mbox{log-likelihood} + k n_{par},\nwhere n_{par} represents the number of parameters in the\nfitted model, and k = 2 for the usual AIC, or\nk = \\log(n)\n(n being the number of observations) for the so-called BIC or SBC\n(Schwarz's Bayesian criterion).\n","ec":"AIC(object, ..., k = 2)"},{"p":"stats","o":"rlogis","f":"hp_rlogis","d":"Density, distribution function, quantile function and random\ngeneration for the logistic distribution with parameters\nlocation and scale.\n","ec":"rlogis(n, location = 0, scale = 1)"},{"p":"stats","o":"bw.ucv","f":"hp_bw.ucv","d":"Bandwidth selectors for Gaussian kernels in density.\n","ec":"bw.ucv(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, tol = 0.1 * lower)"},{"p":"stats","o":"arima","f":"hp_arima","d":"Fit an ARIMA model to a univariate time series.\n","ec":"arima(x, order = c(0L, 0L, 0L), seasonal = list(order = c(0L, 0L, 0L), period = NA), xreg = NULL, include.mean = TRUE, transform.pars = TRUE, fixed = NULL, init = NULL, method = c(\"CSS-ML\", \"ML\", \"CSS\"), n.cond, SSinit = c(\"Gardner1980\", \"Rossignol2011\"), optim.method = \"BFGS\", optim.control = list(), kappa = 1e+06)"},{"p":"stats","o":"plot.ts","f":"hp_plot.ts","d":"Plotting method for objects inheriting from class \"ts\".\n","ec":"plot.ts(x, y = NULL, plot.type = c(\"multiple\", \"single\"), xy.labels, xy.lines, panel = lines, nc, yax.flip = FALSE, mar.multi = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1), oma.multi = c(6, 0, 5, 0), axes = TRUE, ...)"},{"p":"stats","o":"tsp","f":"hp_tsp","d":"tsp returns the tsp attribute (or NULL).\nIt is included for compatibility with S version 2. tsp<-\nsets the tsp attribute. hasTsp ensures x has a\ntsp attribute, by adding one if needed.\n","ec":"tsp(x)"},{"p":"stats","o":"model.extract","f":"hp_model.extract","d":"Returns the response, offset, subset, weights or other\nspecial components of a model frame passed as optional arguments to\nmodel.frame.\n","ec":"model.extract(frame, component)"},{"p":"stats","o":"tsp<-","f":"hp_tsp..","d":"tsp returns the tsp attribute (or NULL).\nIt is included for compatibility with S version 2. tsp<-\nsets the tsp attribute. hasTsp ensures x has a\ntsp attribute, by adding one if needed.\n","ec":"tsp<-(x, value)"},{"p":"stats","o":"stat.anova","f":"hp_stat.anova","d":"This is a utility function, used in lm and\nglm methods for anova(..., test != NULL)\nand should not be used by the average user.\n","ec":"stat.anova(table, test = c(\"Rao\", \"LRT\", \"Chisq\", \"F\", \"Cp\"), scale, df.scale, n)"},{"p":"stats","o":"update.formula","f":"hp_update.formula","d":"update.formula is used to update model formulae.\nThis typically involves adding or dropping terms,\nbut updates can be more general.\n","ec":"update.formula(old, new, ...)"},{"p":"stats","o":"qbeta","f":"hp_qbeta","d":"Density, distribution function, quantile function and random\ngeneration for the Beta distribution with parameters shape1 and\nshape2 (and optional non-centrality parameter ncp).\n","ec":"qbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"bw.SJ","f":"hp_bw.SJ","d":"Bandwidth selectors for Gaussian kernels in density.\n","ec":"bw.SJ(x, nb = 1000L, lower = 0.1 * hmax, upper = hmax, method = c(\"ste\", \"dpi\"), tol = 0.1 * lower)"},{"p":"stats","o":"factanal","f":"hp_factanal","d":"Perform maximum-likelihood factor analysis on a covariance matrix or\ndata matrix.\n","ec":"factanal(x, factors, data = NULL, covmat = NULL, n.obs = NA, subset, na.action, start = NULL, scores = c(\"none\", \"regression\", \"Bartlett\"), rotation = \"varimax\", control = NULL, ...)"},{"p":"stats","o":"drop.scope","f":"hp_drop.scope","d":"add.scope and drop.scope compute those terms that can be\nindividually added to or dropped from a model while respecting the\nhierarchy of terms.\n","ec":"drop.scope(terms1, terms2)"},{"p":"stats","o":"summary.aov","f":"hp_summary.aov","d":"Summarize an analysis of variance model.\n","ec":"summary.aov(object, intercept = FALSE, split, expand.split = TRUE, keep.zero.df = TRUE, ...)"},{"p":"stats","o":"optimHess","f":"hp_optimHess","d":"General-purpose optimization based on Nelder<U+2013>Mead, quasi-Newton and\nconjugate-gradient algorithms. It includes an option for\nbox-constrained optimization and simulated annealing.\n","ec":"optimHess(par, fn, gr = NULL, ..., control = list())"},{"p":"stats","o":".lm.fit","f":"hp_.lm.fit","d":"These are the basic computing engines called by lm used\nto fit linear models.  These should usually not be used\ndirectly unless by experienced users.  .lm.fit() is a bare-bones\nwrapper to the innermost QR-based C code, on which\nglm.fit and lsfit are also based, for\neven more experienced users.\n","ec":".lm.fit(x, y, tol = 1e-07)"},{"p":"stats","o":"cooks.distance","f":"hp_cooks.distance","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"cooks.distance(model, ...)"},{"p":"stats","o":"dnorm","f":"hp_dnorm","d":"Density, distribution function, quantile function and random\ngeneration for the normal distribution with mean equal to mean\nand standard deviation equal to sd.\n","ec":"dnorm(x, mean = 0, sd = 1, log = FALSE)"},{"p":"stats","o":"psmirnov","f":"hp_psmirnov","d":"Distribution function, quantile function and random generation for the\ndistribution of the Smirnov statistic.","ec":"psmirnov(q, sizes, z = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), exact = TRUE, simulate = FALSE, B = 2000, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"extractAIC","f":"hp_extractAIC","d":"Computes the (generalized) Akaike An Information\nCriterion for a fitted parametric model.\n","ec":"extractAIC(fit, scale, k = 2, ...)"},{"p":"stats","o":"qbirthday","f":"hp_qbirthday","d":"Computes answers to a generalised birthday paradox problem.\npbirthday computes the probability of a coincidence and\nqbirthday computes the smallest number of observations needed\nto have at least a specified probability of coincidence.\n","ec":"qbirthday(prob = 0.5, classes = 365, coincident = 2)"},{"p":"stats","o":"C","f":"hp_C","d":"Sets the \"contrasts\" attribute for the factor.\n","ec":"C(object, contr, how.many, ...)"},{"p":"stats","o":"sortedXyData","f":"hp_sortedXyData","d":"This is a constructor function for the class of sortedXyData\nobjects.  These objects are mostly used in the initial\nfunction for a self-starting nonlinear regression model, which will be\nof the selfStart class.\n","ec":"sortedXyData(x, y, data)"},{"p":"stats","o":"D","f":"hp_D","d":"Compute derivatives of simple expressions, symbolically and algorithmically.\n","ec":"D(expr, name)"},{"p":"stats","o":"lowess","f":"hp_lowess","d":"This function performs the computations for the\nLOWESS smoother which uses locally-weighted polynomial\nregression (see the references).\n","ec":"lowess(x, y = NULL, f = 2/3, iter = 3L, delta = 0.01 * diff(range(x)))"},{"p":"stats","o":"varimax","f":"hp_varimax","d":"These functions <U+2018>rotate<U+2019> loading matrices in factor analysis.\n","ec":"varimax(x, normalize = TRUE, eps = 1e-05)"},{"p":"stats","o":"optimize","f":"hp_optimize","d":"The function optimize searches the interval from\nlower to upper for a minimum or maximum of\nthe function f with respect to its first argument.\n","ec":"optimize(f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25)"},{"p":"stats","o":"manova","f":"hp_manova","d":"A class for the multivariate analysis of variance.\n","ec":"manova(...)"},{"p":"stats","o":"deviance","f":"hp_deviance","d":"Returns the deviance of a fitted model object.\n","ec":"deviance(object, ...)"},{"p":"stats","o":"optim","f":"hp_optim","d":"General-purpose optimization based on Nelder<U+2013>Mead, quasi-Newton and\nconjugate-gradient algorithms. It includes an option for\nbox-constrained optimization and simulated annealing.\n","ec":"optim(par, fn, gr = NULL, ..., method = c(\"Nelder-Mead\", \"BFGS\", \"CG\", \"L-BFGS-B\", \"SANN\", \"Brent\"), lower = -Inf, upper = Inf, control = list(), hessian = FALSE)"},{"p":"stats","o":"lag.plot","f":"hp_lag.plot","d":"Plot time series against lagged versions of themselves.\nHelps visualizing <U+2018>auto-dependence<U+2019> even when auto-correlations\nvanish.\n","ec":"lag.plot(x, lags = 1, layout = NULL, set.lags = 1L:lags, main = NULL, asp = 1, diag = TRUE, diag.col = \"gray\", type = \"p\", oma = NULL, ask = NULL, do.lines = (n <= 150), labels = do.lines, ...)"},{"p":"stats","o":"constrOptim","f":"hp_constrOptim","d":"Minimise a function subject to linear inequality constraints using an\nadaptive barrier algorithm.\n","ec":"constrOptim(theta, f, grad, ui, ci, mu = 1e-04, control = list(), method = if (is.null(grad)) \"Nelder-Mead\" else \"BFGS\", outer.iterations = 100, outer.eps = 1e-05, ..., hessian = FALSE)"},{"p":"stats","o":"splinefunH","f":"hp_splinefunH","d":"Perform cubic (or Hermite) spline interpolation of given data points,\nreturning either a list of points obtained by the interpolation or a\nfunction performing the interpolation.\n","ec":"splinefunH(x, y, m)"},{"p":"stats","o":"reformulate","f":"hp_reformulate","d":"delete.response returns a terms object for the same\nmodel but with no response variable.\n","ec":"reformulate(termlabels, response = NULL, intercept = TRUE, env = parent.frame())"},{"p":"stats","o":"pacf","f":"hp_pacf","d":"The function acf computes (and by default plots) estimates of\nthe autocovariance or autocorrelation function.  Function pacf\nis the function used for the partial autocorrelations.  Function\nccf computes the cross-correlation or cross-covariance of two\nunivariate series.\n","ec":"pacf(x, lag.max, plot, na.action, ...)"},{"p":"stats","o":"mcnemar.test","f":"hp_mcnemar.test","d":"Performs McNemar's chi-squared test for symmetry of rows and columns\nin a two-dimensional contingency table.\n","ec":"mcnemar.test(x, y = NULL, correct = TRUE)"},{"p":"stats","o":"df","f":"hp_df","d":"Density, distribution function, quantile function and random\ngeneration for the F distribution with df1 and df2\ndegrees of freedom (and optional non-centrality parameter ncp).\n","ec":"df(x, df1, df2, ncp, log = FALSE)"},{"p":"stats","o":"tsSmooth","f":"hp_tsSmooth","d":"Performs fixed-interval smoothing on a univariate time series via a\nstate-space model.  Fixed-interval smoothing gives the best estimate\nof the state at each time point based on the whole observed series.\n","ec":"tsSmooth(object, ...)"},{"p":"stats","o":"make.link","f":"hp_make.link","d":"This function is used with the family functions in\nglm().\nGiven the name of a link, it returns a link function, an inverse link\nfunction, the derivative d\\mu / d\\eta and a function\nfor domain checking.\n","ec":"make.link(link)"},{"p":"stats","o":"glm.control","f":"hp_glm.control","d":"Auxiliary function for glm fitting.\nTypically only used internally by glm.fit, but may be\nused to construct a control argument to either function.\n","ec":"glm.control(epsilon = 1e-08, maxit = 25, trace = FALSE)"},{"p":"stats","o":"hasTsp","f":"hp_hasTsp","d":"tsp returns the tsp attribute (or NULL).\nIt is included for compatibility with S version 2. tsp<-\nsets the tsp attribute. hasTsp ensures x has a\ntsp attribute, by adding one if needed.\n","ec":"hasTsp(x)"},{"p":"stats","o":"pgamma","f":"hp_pgamma","d":"Density, distribution function, quantile function and random\ngeneration for the Gamma distribution with parameters shape and\nscale.\n","ec":"pgamma(q, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"addmargins","f":"hp_addmargins","d":"For a given table one can specify which of the classifying factors to\nexpand by one or more levels to hold margins to be calculated.  One may for\nexample form sums and means over the first dimension and medians over the\nsecond.  The resulting table will then have two extra levels for the first\ndimension and one extra level for the second.  The default is to sum over\nall margins in the table.  Other possibilities may give results that\ndepend on the order in which the margins are computed.  This is flagged\nin the printed output from the function.\n","ec":"addmargins(A, margin = seq_along(dim(A)), FUN = sum, quiet = FALSE)"},{"p":"stats","o":"dexp","f":"hp_dexp","d":"Density, distribution function, quantile function and random\ngeneration for the exponential distribution with rate rate\n(i.e., mean 1/rate).\n","ec":"dexp(x, rate = 1, log = FALSE)"},{"p":"stats","o":"power.anova.test","f":"hp_power.anova.test","d":"Compute power of test or determine parameters to obtain target power.\n","ec":"power.anova.test(groups = NULL, n = NULL, between.var = NULL, within.var = NULL, sig.level = 0.05, power = NULL)"},{"p":"stats","o":"prop.test","f":"hp_prop.test","d":"prop.test can be used for testing the null that the\nproportions (probabilities of success) in several groups are the\nsame, or that they equal certain given values.\n","ec":"prop.test(x, n, p = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95, correct = TRUE)"},{"p":"stats","o":"model.weights","f":"hp_model.weights","d":"Returns the response, offset, subset, weights or other\nspecial components of a model frame passed as optional arguments to\nmodel.frame.\n","ec":"model.weights(x)"},{"p":"stats","o":"ave","f":"hp_ave","d":"Subsets of x[] are averaged, where each subset consist of those\nobservations with the same factor levels.\n","ec":"ave(x, ..., FUN = mean)"},{"p":"stats","o":"is.stepfun","f":"hp_is.stepfun","d":"Given the vectors (x_1, \\ldots, x_n) and\n(y_0,y_1,\\ldots, y_n) (one value\nmore!), stepfun(x, y, ...) returns an interpolating\n<U+2018>step<U+2019> function, say fn. I.e., fn(t) =\n    c_i (constant) for t \\in (x_i, x_{i+1}) and at the abscissa values, if (by default)\nright = FALSE, fn(x_i) = y_i and for\nright = TRUE, fn(x_i) = y_{i-1}, for\ni=1,\\ldots,n.\n","ec":"is.stepfun(x)"},{"p":"stats","o":"heatmap","f":"hp_heatmap","d":"A heat map is a false color image (basically\nimage(t(x))) with a dendrogram added to the left side\nand to the top.  Typically, reordering of the rows and columns\naccording to some set of values (row or column means) within the\nrestrictions imposed by the dendrogram is carried out.\n","ec":"heatmap(x, Rowv = NULL, Colv = if (symm) \"Rowv\" else NULL, distfun = dist, hclustfun = hclust, reorderfun = function(d, w) reorder(d, w), add.expr, symm = FALSE, revC = identical(Colv, \"Rowv\"), scale = c(\"row\", \"column\", \"none\"), na.rm = TRUE, margins = c(5, 5), ColSideColors, RowSideColors, cexRow = 0.2 + 1/log10(nr), cexCol = 0.2 + 1/log10(nc), labRow = NULL, labCol = NULL, main = NULL, xlab = NULL, ylab = NULL, keep.dendro = FALSE, verbose = getOption(\"verbose\"), ...)"},{"p":"stats","o":"stepfun","f":"hp_stepfun","d":"Given the vectors (x_1, \\ldots, x_n) and\n(y_0,y_1,\\ldots, y_n) (one value\nmore!), stepfun(x, y, ...) returns an interpolating\n<U+2018>step<U+2019> function, say fn. I.e., fn(t) =\n    c_i (constant) for t \\in (x_i, x_{i+1}) and at the abscissa values, if (by default)\nright = FALSE, fn(x_i) = y_i and for\nright = TRUE, fn(x_i) = y_{i-1}, for\ni=1,\\ldots,n.\n","ec":"stepfun(x, y, f = as.numeric(right), ties = \"ordered\", right = FALSE)"},{"p":"stats","o":"loess.smooth","f":"hp_loess.smooth","d":"Plot and add a smooth curve computed by loess to a scatter plot.\n","ec":"loess.smooth(x, y, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), evaluation = 50, ...)"},{"p":"stats","o":"window<-","f":"hp_window..","d":"window is a generic function which\nextracts the subset of the object x\nobserved between the times start and end. If a\nfrequency is specified, the series is then re-sampled at the new\nfrequency.\n","ec":"window<-(x, ..., value)"},{"p":"stats","o":"line","f":"hp_line","d":"Fit a line robustly as recommended in Exploratory Data Analysis.\n","ec":"line(x, y = NULL, iter = 1)"},{"p":"stats","o":"qqline","f":"hp_qqline","d":"qqnorm is a generic function the default method of which\nproduces a normal QQ plot of the values in y.\nqqline adds a line to a <U+201C>theoretical<U+201D>, by default\nnormal, quantile-quantile plot which passes through the probs\nquantiles, by default the first and third quartiles.\n","ec":"qqline(y, datax = FALSE, distribution = qnorm, probs = c(0.25, 0.75), qtype = 7, ...)"},{"p":"stats","o":"ar.mle","f":"hp_ar.mle","d":"Fit an autoregressive time series model to the data, by default\nselecting the complexity by AIC.\n","ec":"ar.mle(x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, series = NULL, ...)"},{"p":"stats","o":"residuals","f":"hp_residuals","d":"residuals is a generic function which extracts model residuals\nfrom objects returned by modeling functions.\n","ec":"residuals(object, ...)"},{"p":"stats","o":"lsfit","f":"hp_lsfit","d":"The least squares estimate of \\beta in the model\n","ec":"lsfit(x, y, wt = NULL, intercept = TRUE, tolerance = 1e-07, yname = NULL)"},{"p":"stats","o":"get_all_vars","f":"hp_get_all_vars","d":"model.frame (a generic function) and its methods return a\ndata.frame with the variables needed to use\nformula and any ... arguments.\n","ec":"get_all_vars(formula, data = NULL, ...)"},{"p":"stats","o":"dt","f":"hp_dt","d":"Density, distribution function, quantile function and random\ngeneration for the t distribution with df degrees of freedom\n(and optional non-centrality parameter ncp).\n","ec":"dt(x, df, ncp, log = FALSE)"},{"p":"stats","o":"splinefun","f":"hp_splinefun","d":"Perform cubic (or Hermite) spline interpolation of given data points,\nreturning either a list of points obtained by the interpolation or a\nfunction performing the interpolation.\n","ec":"splinefun(x, y = NULL, method = c(\"fmm\", \"periodic\", \"natural\", \"monoH.FC\", \"hyman\"), ties = mean)"},{"p":"stats","o":"ks.test","f":"hp_ks.test","d":"Perform a one- or two-sample Kolmogorov-Smirnov test.\n","ec":"ks.test(x, ...)"},{"p":"stats","o":"cor","f":"hp_cor","d":"var, cov and cor compute the variance of x\nand the covariance or correlation of x and y if these\nare vectors.   If x and y are matrices then the\ncovariances (or correlations) between the columns of x and the\ncolumns of y are computed.\n","ec":"cor(x, y = NULL, use = \"everything\", method = c(\"pearson\", \"kendall\", \"spearman\"))"},{"p":"stats","o":"add.scope","f":"hp_add.scope","d":"add.scope and drop.scope compute those terms that can be\nindividually added to or dropped from a model while respecting the\nhierarchy of terms.\n","ec":"add.scope(terms1, terms2)"},{"p":"stats","o":"ecdf","f":"hp_ecdf","d":"Compute an empirical cumulative distribution function, with several\nmethods for plotting, printing and computing with such an\n<U+201C>ecdf<U+201D> object.\n","ec":"ecdf(x)"},{"p":"stats","o":"pwilcox","f":"hp_pwilcox","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon rank sum statistic\nobtained from samples with size m and n, respectively.\n","ec":"pwilcox(q, m, n, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"cov","f":"hp_cov","d":"var, cov and cor compute the variance of x\nand the covariance or correlation of x and y if these\nare vectors.   If x and y are matrices then the\ncovariances (or correlations) between the columns of x and the\ncolumns of y are computed.\n","ec":"cov(x, y = NULL, use = \"everything\", method = c(\"pearson\", \"kendall\", \"spearman\"))"},{"p":"stats","o":"dendrapply","f":"hp_dendrapply","d":"Apply function FUN to each node of a dendrogram\nrecursively.  When  y <- dendrapply(x, fn), then y is a\ndendrogram of the same graph structure as x and for each node,\ny.node[j] <- FUN( x.node[j], ...) (where y.node[j] is an\n(invalid!) notation for the j-th node of y).\n","ec":"dendrapply(X, FUN, ...)"},{"p":"stats","o":"rsignrank","f":"hp_rsignrank","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon Signed Rank statistic\nobtained from a sample with size n.\n","ec":"rsignrank(nn, n)"},{"p":"stats","o":"bandwidth.kernel","f":"hp_bandwidth.kernel","d":"The \"tskernel\" class is designed to represent discrete\nsymmetric normalized smoothing kernels.  These kernels can be used to\nsmooth vectors, matrices, or time series objects.\n","ec":"bandwidth.kernel(k)"},{"p":"stats","o":"as.dist","f":"hp_as.dist","d":"This function computes and returns the distance matrix computed by\nusing the specified distance measure to compute the distances between\nthe rows of a data matrix.\n","ec":"as.dist(m, diag = FALSE, upper = FALSE)"},{"p":"stats","o":"SSweibull","f":"hp_SSweibull","d":"This selfStart model evaluates the Weibull model for growth\ncurve data and its gradient.  It has an initial attribute that\nwill evaluate initial estimates of the parameters Asym, Drop,\nlrc, and pwr for a given set of data.\n","ec":"SSweibull(x, Asym, Drop, lrc, pwr)"},{"p":"stats","o":"bw.nrd","f":"hp_bw.nrd","d":"Bandwidth selectors for Gaussian kernels in density.\n","ec":"bw.nrd(x)"},{"p":"stats","o":"start","f":"hp_start","d":"Extract and encode the times the first and last observations were\ntaken. Provided only for compatibility with S version 2.\n","ec":"start(x, ...)"},{"p":"stats","o":"plnorm","f":"hp_plnorm","d":"Density, distribution function, quantile function and random\ngeneration for the log normal distribution whose logarithm has mean\nequal to meanlog and standard deviation equal to sdlog.\n","ec":"plnorm(q, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"ts.union","f":"hp_ts.union","d":"Bind time series which have a common frequency. ts.union pads\nwith NAs to the total time coverage, ts.intersect\nrestricts to the time covered by all the series.\n","ec":"ts.union(..., dframe = FALSE)"},{"p":"stats","o":"mvfft","f":"hp_mvfft","d":"Computes the Discrete Fourier Transform (DFT) of an array with a fast\nalgorithm, the <U+201C>Fast Fourier Transform<U+201D> (FFT).\n","ec":"mvfft(z, inverse = FALSE)"},{"p":"stats","o":"dweibull","f":"hp_dweibull","d":"Density, distribution function, quantile function and random\ngeneration for the Weibull distribution with parameters shape\nand scale.\n","ec":"dweibull(x, shape, scale = 1, log = FALSE)"},{"p":"stats","o":"as.ts","f":"hp_as.ts","d":"The function ts is used to create time-series objects.\n","ec":"as.ts(x, ...)"},{"p":"stats","o":"cor.test","f":"hp_cor.test","d":"Test for association between paired samples, using one of\nPearson's product moment correlation coefficient,\nKendall's \\tau or Spearman's \\rho.\n","ec":"cor.test(x, ...)"},{"p":"stats","o":".checkMFClasses","f":"hp_.checkMFClasses","d":".checkMFClasses checks if the variables used in a predict\nmethod agree in type with those used for fitting.\n","ec":".checkMFClasses(cl, m, ordNotOK = FALSE)"},{"p":"stats","o":"effects","f":"hp_effects","d":"Returns (orthogonal) effects from a fitted model, usually a linear\nmodel. This is a generic function, but currently only has a methods for\nobjects inheriting from classes \"lm\" and \"glm\".\n","ec":"effects(object, ...)"},{"p":"stats","o":"reorder","f":"hp_reorder","d":"reorder is a generic function.  The \"default\" method\ntreats its first argument as a categorical variable, and reorders its\nlevels based on the values of a second variable, usually numeric.\n","ec":"reorder(x, ...)"},{"p":"stats","o":"KalmanForecast","f":"hp_KalmanForecast","d":"Use Kalman Filtering to find the (Gaussian) log-likelihood, or for\nforecasting or smoothing.\n","ec":"KalmanForecast(n.ahead = 10L, mod, update = FALSE)"},{"p":"stats","o":"eff.aovlist","f":"hp_eff.aovlist","d":"Computes the efficiencies of fixed-effect terms in an analysis of\nvariance model with multiple strata.\n","ec":"eff.aovlist(aovlist)"},{"p":"stats","o":"qgamma","f":"hp_qgamma","d":"Density, distribution function, quantile function and random\ngeneration for the Gamma distribution with parameters shape and\nscale.\n","ec":"qgamma(p, shape, rate = 1, scale = 1/rate, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"glm.fit","f":"hp_glm.fit","d":"glm is used to fit generalized linear models, specified by\ngiving a symbolic description of the linear predictor and a\ndescription of the error distribution.\n","ec":"glm.fit(x, y, weights = rep.int(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep.int(0, nobs), family = gaussian(), control = list(), intercept = TRUE, singular.ok = TRUE)"},{"p":"stats","o":"plot.spec.coherency","f":"hp_plot.spec.coherency","d":"Plotting method for objects of class \"spec\".  For multivariate\ntime series it plots the marginal spectra of the series or pairs plots\nof the coherency and phase of the cross-spectra.\n","ec":"plot.spec.coherency(x, ci = 0.95, xlab = \"frequency\", ylab = \"squared coherency\", ylim = c(0, 1), type = \"l\", main = NULL, ci.col = \"blue\", ci.lty = 3, ...)"},{"p":"stats","o":"dgamma","f":"hp_dgamma","d":"Density, distribution function, quantile function and random\ngeneration for the Gamma distribution with parameters shape and\nscale.\n","ec":"dgamma(x, shape, rate = 1, scale = 1/rate, log = FALSE)"},{"p":"stats","o":"cov2cor","f":"hp_cov2cor","d":"var, cov and cor compute the variance of x\nand the covariance or correlation of x and y if these\nare vectors.   If x and y are matrices then the\ncovariances (or correlations) between the columns of x and the\ncolumns of y are computed.\n","ec":"cov2cor(V)"},{"p":"stats","o":"ls.print","f":"hp_ls.print","d":"Computes basic statistics, including standard errors, t- and p-values\nfor the regression coefficients and prints them if print.it is\nTRUE.\n","ec":"ls.print(ls.out, digits = 4L, print.it = TRUE)"},{"p":"stats","o":"setNames","f":"hp_setNames","d":"This is a convenience function that sets the names on an object and\nreturns the object.  It is most useful at the end of a function\ndefinition where one is creating the object to be returned and would\nprefer not to store it under a name just so the names can be assigned.\n","ec":"setNames(object = nm, nm)"},{"p":"stats","o":"acf2AR","f":"hp_acf2AR","d":"Compute an AR process exactly fitting an autocorrelation function.\n","ec":"acf2AR(acf)"},{"p":"stats","o":"add1","f":"hp_add1","d":"Compute all the single terms in the scope argument that can be\nadded to or dropped from the model, fit those models and compute a\ntable of the changes in fit.\n","ec":"add1(object, scope, ...)"},{"p":"stats","o":"rcauchy","f":"hp_rcauchy","d":"Density, distribution function, quantile function and random\ngeneration for the Cauchy distribution with location parameter\nlocation and scale parameter scale.\n","ec":"rcauchy(n, location = 0, scale = 1)"},{"p":"stats","o":"shapiro.test","f":"hp_shapiro.test","d":"Performs the Shapiro-Wilk test of normality.\n","ec":"shapiro.test(x)"},{"p":"stats","o":"deriv3","f":"hp_deriv3","d":"Compute derivatives of simple expressions, symbolically and algorithmically.\n","ec":"deriv3(expr, ...)"},{"p":"stats","o":"window","f":"hp_window","d":"window is a generic function which\nextracts the subset of the object x\nobserved between the times start and end. If a\nfrequency is specified, the series is then re-sampled at the new\nfrequency.\n","ec":"window(x, ...)"},{"p":"stats","o":"model.tables","f":"hp_model.tables","d":"Computes summary tables for model fits, especially complex aov\nfits.\n","ec":"model.tables(x, ...)"},{"p":"stats","o":"model.matrix","f":"hp_model.matrix","d":"model.matrix creates a design (or model) matrix, e.g., by\nexpanding factors to a set of dummy variables (depending on the\ncontrasts) and expanding interactions similarly.\n","ec":"model.matrix(object, ...)"},{"p":"stats","o":".nknots.smspl","f":"hp_.nknots.smspl","d":"Fits a cubic smoothing spline to the supplied data.\n","ec":".nknots.smspl(n)"},{"p":"stats","o":"KalmanLike","f":"hp_KalmanLike","d":"Use Kalman Filtering to find the (Gaussian) log-likelihood, or for\nforecasting or smoothing.\n","ec":"KalmanLike(y, mod, nit = 0L, update = FALSE)"},{"p":"stats","o":"SSasymp","f":"hp_SSasymp","d":"This selfStart model evaluates the asymptotic regression\nfunction and its gradient.  It has an initial attribute that\nwill evaluate initial estimates of the parameters Asym, R0,\nand lrc for a given set of data.\n","ec":"SSasymp(input, Asym, R0, lrc)"},{"p":"stats","o":"predict","f":"hp_predict","d":"predict is a generic function for predictions from the results of\nvarious model fitting functions.  The function invokes particular\nmethods which depend on the class of\nthe first argument.\n","ec":"predict(object, ...)"},{"p":"stats","o":"as.stepfun","f":"hp_as.stepfun","d":"Given the vectors (x_1, \\ldots, x_n) and\n(y_0,y_1,\\ldots, y_n) (one value\nmore!), stepfun(x, y, ...) returns an interpolating\n<U+2018>step<U+2019> function, say fn. I.e., fn(t) =\n    c_i (constant) for t \\in (x_i, x_{i+1}) and at the abscissa values, if (by default)\nright = FALSE, fn(x_i) = y_i and for\nright = TRUE, fn(x_i) = y_{i-1}, for\ni=1,\\ldots,n.\n","ec":"as.stepfun(x, ...)"},{"p":"stats","o":"t.test","f":"hp_t.test","d":"Performs one and two sample t-tests on vectors of data.\n","ec":"t.test(x, ...)"},{"p":"stats","o":"power.prop.test","f":"hp_power.prop.test","d":"Compute the power of the two-sample test for proportions, or determine\nparameters to obtain a target power.\n","ec":"power.prop.test(n = NULL, p1 = NULL, p2 = NULL, sig.level = 0.05, power = NULL, alternative = c(\"two.sided\", \"one.sided\"), strict = FALSE, tol = .Machine$double.eps^0.25)"},{"p":"stats","o":"rstandard","f":"hp_rstandard","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"rstandard(model, ...)"},{"p":"stats","o":"binom.test","f":"hp_binom.test","d":"Performs an exact test of a simple null hypothesis about the\nprobability of success in a Bernoulli experiment.\n","ec":"binom.test(x, n, p = 0.5, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95)"},{"p":"stats","o":"cophenetic","f":"hp_cophenetic","d":"Computes the cophenetic distances for a hierarchical clustering.\n","ec":"cophenetic(x)"},{"p":"stats","o":"pbeta","f":"hp_pbeta","d":"Density, distribution function, quantile function and random\ngeneration for the Beta distribution with parameters shape1 and\nshape2 (and optional non-centrality parameter ncp).\n","ec":"pbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"KalmanRun","f":"hp_KalmanRun","d":"Use Kalman Filtering to find the (Gaussian) log-likelihood, or for\nforecasting or smoothing.\n","ec":"KalmanRun(y, mod, nit = 0L, update = FALSE)"},{"p":"stats","o":"naprint","f":"hp_naprint","d":"Use missing value information to report the effects of an na.action.\n","ec":"naprint(x, ...)"},{"p":"stats","o":"qlnorm","f":"hp_qlnorm","d":"Density, distribution function, quantile function and random\ngeneration for the log normal distribution whose logarithm has mean\nequal to meanlog and standard deviation equal to sdlog.\n","ec":"qlnorm(p, meanlog = 0, sdlog = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"plclust","f":"hp_plclust","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"plclust(tree, hang = 0.1, unit = FALSE, level = FALSE, hmin = 0, square = TRUE, labels = NULL, plot. = TRUE, axes = TRUE, frame.plot = FALSE, ann = TRUE, main = \"\", sub = NULL, xlab = NULL, ylab = \"Height\")"},{"p":"stats","o":"model.response","f":"hp_model.response","d":"Returns the response, offset, subset, weights or other\nspecial components of a model frame passed as optional arguments to\nmodel.frame.\n","ec":"model.response(data, type = \"any\")"},{"p":"stats","o":"dlnorm","f":"hp_dlnorm","d":"Density, distribution function, quantile function and random\ngeneration for the log normal distribution whose logarithm has mean\nequal to meanlog and standard deviation equal to sdlog.\n","ec":"dlnorm(x, meanlog = 0, sdlog = 1, log = FALSE)"},{"p":"stats","o":"lag","f":"hp_lag","d":"Compute a lagged version of a time series, shifting the time base\nback by a given number of observations.\n","ec":"lag(x, ...)"},{"p":"stats","o":"spec.pgram","f":"hp_spec.pgram","d":"spec.pgram calculates the periodogram using a fast Fourier\ntransform, and optionally smooths the result with a series of\nmodified Daniell smoothers (moving averages giving half weight to\nthe end values).\n","ec":"spec.pgram(x, spans = NULL, kernel = NULL, taper = 0.1, pad = 0, fast = TRUE, demean = FALSE, detrend = TRUE, plot = TRUE, na.action = na.fail, ...)"},{"p":"stats","o":"interaction.plot","f":"hp_interaction.plot","d":"Plots the mean (or other summary) of the response for two-way\ncombinations of factors, thereby illustrating possible interactions.\n","ec":"interaction.plot(x.factor, trace.factor, response, fun = mean, type = c(\"l\", \"p\", \"b\", \"o\", \"c\"), legend = TRUE, trace.label = deparse1(substitute(trace.factor)), fixed = FALSE, xlab = deparse1(substitute(x.factor)), ylab = ylabel, ylim = range(cells, na.rm = TRUE), lty = nc:1, col = 1, pch = c(1L:9, 0, letters), xpd = NULL, leg.bg = par(\"bg\"), leg.bty = \"n\", xtick = FALSE, xaxt = par(\"xaxt\"), axes = TRUE, ...)"},{"p":"stats","o":"fitted","f":"hp_fitted","d":"fitted is a generic function which extracts fitted values from\nobjects returned by modeling functions.  fitted.values is an\nalias for it.\n","ec":"fitted(object, ...)"},{"p":"stats","o":"rgeom","f":"hp_rgeom","d":"Density, distribution function, quantile function and random\ngeneration for the geometric distribution with parameter prob.\n","ec":"rgeom(n, prob)"},{"p":"stats","o":"estVar","f":"hp_estVar","d":"Functions to compute matrix of residual sums of squares and products,\nor the estimated variance matrix for multivariate linear models.\n","ec":"estVar(object, ...)"},{"p":"stats","o":"rgamma","f":"hp_rgamma","d":"Density, distribution function, quantile function and random\ngeneration for the Gamma distribution with parameters shape and\nscale.\n","ec":"rgamma(n, shape, rate = 1, scale = 1/rate)"},{"p":"stats","o":"arima0","f":"hp_arima0","d":"Fit an ARIMA model to a univariate time series, and forecast from\nthe fitted model.\n","ec":"arima0(x, order = c(0, 0, 0), seasonal = list(order = c(0, 0, 0), period = NA), xreg = NULL, include.mean = TRUE, delta = 0.01, transform.pars = TRUE, fixed = NULL, init = NULL, method = c(\"ML\", \"CSS\"), n.cond, optim.control = list())"},{"p":"stats","o":"loglin","f":"hp_loglin","d":"loglin is used to fit log-linear models to multidimensional\ncontingency tables by Iterative Proportional Fitting.\n","ec":"loglin(table, margin, start = rep(1, length(table)), fit = FALSE, eps = 0.1, iter = 20L, param = FALSE, print = TRUE)"},{"p":"stats","o":"ar.yw","f":"hp_ar.yw","d":"Fit an autoregressive time series model to the data, by default\nselecting the complexity by AIC.\n","ec":"ar.yw(x, ...)"},{"p":"stats","o":"promax","f":"hp_promax","d":"These functions <U+2018>rotate<U+2019> loading matrices in factor analysis.\n","ec":"promax(x, m = 4)"},{"p":"stats","o":"phyper","f":"hp_phyper","d":"Density, distribution function, quantile function and random\ngeneration for the hypergeometric distribution.\n","ec":"phyper(q, m, n, k, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"drop1","f":"hp_drop1","d":"Compute all the single terms in the scope argument that can be\nadded to or dropped from the model, fit those models and compute a\ntable of the changes in fit.\n","ec":"drop1(object, scope, ...)"},{"p":"stats","o":"SSfol","f":"hp_SSfol","d":"This selfStart model evaluates the first-order compartment\nfunction and its gradient.  It has an initial attribute that\ncreates initial estimates of the parameters lKe, lKa,\nand lCl.\n","ec":"SSfol(Dose, input, lKe, lKa, lCl)"},{"p":"stats","o":"runif","f":"hp_runif","d":"These functions provide information about the uniform distribution\non the interval from min to max.  dunif gives the\ndensity, punif gives the distribution function qunif\ngives the quantile function and runif generates random\ndeviates.\n","ec":"runif(n, min = 0, max = 1)"},{"p":"stats","o":"family","f":"hp_family","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"family(object, ...)"},{"p":"stats","o":"quantile","f":"hp_quantile","d":"The generic function quantile produces sample quantiles\ncorresponding to the given probabilities.\nThe smallest observation corresponds to a probability of 0 and the\nlargest to a probability of 1.\n","ec":"quantile(x, ...)"},{"p":"stats","o":"wilcox.test","f":"hp_wilcox.test","d":"Performs one- and two-sample Wilcoxon tests on vectors of data; the\nlatter is also known as <U+2018>Mann-Whitney<U+2019> test.\n","ec":"wilcox.test(x, ...)"},{"p":"stats","o":"psignrank","f":"hp_psignrank","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon Signed Rank statistic\nobtained from a sample with size n.\n","ec":"psignrank(q, n, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"complete.cases","f":"hp_complete.cases","d":"Return a logical vector indicating which cases are complete, i.e.,\nhave no missing values.\n","ec":"complete.cases(...)"},{"p":"stats","o":"offset","f":"hp_offset","d":"An offset is a term to be added to a linear predictor, such as in a\ngeneralised linear model, with known coefficient 1 rather than an\nestimated coefficient.\n","ec":"offset(object)"},{"p":"stats","o":"scatter.smooth","f":"hp_scatter.smooth","d":"Plot and add a smooth curve computed by loess to a scatter plot.\n","ec":"scatter.smooth(x, y = NULL, span = 2/3, degree = 1, family = c(\"symmetric\", \"gaussian\"), xlab = NULL, ylab = NULL, ylim = range(y, pred$y, na.rm = TRUE), evaluation = 50, ..., lpars = list())"},{"p":"stats","o":"dmultinom","f":"hp_dmultinom","d":"Generate multinomially distributed random number vectors and\ncompute multinomial probabilities.\n","ec":"dmultinom(x, size = NULL, prob, log = FALSE)"},{"p":"stats","o":"rlnorm","f":"hp_rlnorm","d":"Density, distribution function, quantile function and random\ngeneration for the log normal distribution whose logarithm has mean\nequal to meanlog and standard deviation equal to sdlog.\n","ec":"rlnorm(n, meanlog = 0, sdlog = 1)"},{"p":"stats","o":"approx","f":"hp_approx","d":"Return a list of points which linearly interpolate given data points,\nor a function performing the linear (or constant) interpolation.\n","ec":"approx(x, y = NULL, xout, method = \"linear\", n = 50, yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE)"},{"p":"stats","o":"naresid","f":"hp_naresid","d":"Use missing value information to adjust residuals and predictions.\n","ec":"naresid(omit, x, ...)"},{"p":"stats","o":"SSfpl","f":"hp_SSfpl","d":"This selfStart model evaluates the four-parameter logistic\nfunction and its gradient.  It has an initial attribute computing\ninitial estimates of the parameters A, B,\nxmid, and scal for a given set of data.\n","ec":"SSfpl(input, A, B, xmid, scal)"},{"p":"stats","o":"proj","f":"hp_proj","d":"proj returns a matrix or list of matrices giving the projections\nof the data onto the terms of a linear model.  It is most frequently\nused for aov models.\n","ec":"proj(object, ...)"},{"p":"stats","o":"supsmu","f":"hp_supsmu","d":"Smooth the (x, y) values by Friedman's <U+2018>super smoother<U+2019>.\n","ec":"supsmu(x, y, wt = rep(1, n), span = \"cv\", periodic = FALSE, bass = 0, trace = FALSE)"},{"p":"stats","o":"qqnorm","f":"hp_qqnorm","d":"qqnorm is a generic function the default method of which\nproduces a normal QQ plot of the values in y.\nqqline adds a line to a <U+201C>theoretical<U+201D>, by default\nnormal, quantile-quantile plot which passes through the probs\nquantiles, by default the first and third quartiles.\n","ec":"qqnorm(y, ...)"},{"p":"stats","o":"end","f":"hp_end","d":"Extract and encode the times the first and last observations were\ntaken. Provided only for compatibility with S version 2.\n","ec":"end(x, ...)"},{"p":"stats","o":"printCoefmat","f":"hp_printCoefmat","d":"Utility function to be used in higher-level print\nmethods, such as those for summary.lm,\nsummary.glm and anova.  The\ngoal is to provide a flexible interface with smart defaults such\nthat often, only x needs to be specified.\n","ec":"printCoefmat(x, digits = max(3L, getOption(\"digits\") - 2L), signif.stars = getOption(\"show.signif.stars\"), signif.legend = signif.stars, dig.tst = max(1L, min(5L, digits - 1L)), cs.ind = 1:k, tst.ind = k + 1, zap.ind = integer(), P.values = NULL, has.Pvalue = nc >= 4L && length(cn <- colnames(x)) && substr(cn[nc], 1L, 3L) %in% c(\"Pr(\", \"p-v\"), eps.Pvalue = .Machine$double.eps, na.print = \"NA\", quote = FALSE, right = TRUE, ...)"},{"p":"stats","o":"princomp","f":"hp_princomp","d":"princomp performs a principal components analysis on the given\nnumeric data matrix and returns the results as an object of class\nprincomp.\n","ec":"princomp(x, ...)"},{"p":"stats","o":"aggregate.data.frame","f":"hp_aggregate.data.frame","d":"Splits the data into subsets, computes summary statistics for each,\nand returns the result in a convenient form.\n","ec":"aggregate.data.frame(x, by, FUN, ..., simplify = TRUE, drop = TRUE)"},{"p":"stats","o":"dnbinom","f":"hp_dnbinom","d":"Density, distribution function, quantile function and random\ngeneration for the negative binomial distribution with parameters\nsize and prob.\n","ec":"dnbinom(x, size, prob, mu, log = FALSE)"},{"p":"stats","o":"lm.influence","f":"hp_lm.influence","d":"This function provides the basic quantities which are\nused in forming a wide variety of diagnostics for\nchecking the quality of regression fits.\n","ec":"lm.influence(model, do.coef = TRUE)"},{"p":"stats","o":"rect.hclust","f":"hp_rect.hclust","d":"Draws rectangles around the branches of a dendrogram highlighting the\ncorresponding clusters. First the dendrogram is cut at a certain\nlevel, then a rectangle is drawn around selected branches.\n","ec":"rect.hclust(tree, k = NULL, which = NULL, x = NULL, h = NULL, border = 2, cluster = NULL)"},{"p":"stats","o":"convolve","f":"hp_convolve","d":"Use the Fast Fourier Transform to compute the several kinds of\nconvolutions of two sequences.\n","ec":"convolve(x, y, conj = TRUE, type = c(\"circular\", \"open\", \"filter\"))"},{"p":"stats","o":"ansari.test","f":"hp_ansari.test","d":"Performs the Ansari-Bradley two-sample test for a difference in scale\nparameters.\n","ec":"ansari.test(x, ...)"},{"p":"stats","o":"median.default","f":"hp_median.default","d":"Compute the sample median.\n","ec":"median.default(x, na.rm = FALSE, ...)"},{"p":"stats","o":"ARMAacf","f":"hp_ARMAacf","d":"Compute the theoretical autocorrelation function or partial\nautocorrelation function for an ARMA process.\n","ec":"ARMAacf(ar = numeric(), ma = numeric(), lag.max = r, pacf = FALSE)"},{"p":"stats","o":"poly","f":"hp_poly","d":"Returns or evaluates orthogonal polynomials of degree 1 to\ndegree over the specified set of points x: these are all\northogonal to the constant polynomial of degree 0.  Alternatively,\nevaluate raw polynomials.\n","ec":"poly(x, ..., degree = 1, coefs = NULL, raw = FALSE, simple = FALSE)"},{"p":"stats","o":"NLSstRtAsymptote","f":"hp_NLSstRtAsymptote","d":"Provide an initial guess at the horizontal asymptote on the right side\n(i.e., large values of x) of the graph of y versus\nx from the xy object.  Primarily used within\ninitial functions for self-starting nonlinear regression\nmodels.\n","ec":"NLSstRtAsymptote(xy)"},{"p":"stats","o":"power.t.test","f":"hp_power.t.test","d":"Compute the power of the one- or two- sample t test,\nor determine parameters to obtain a target power.\n","ec":"power.t.test(n = NULL, delta = NULL, sd = 1, sig.level = 0.05, power = NULL, type = c(\"two.sample\", \"one.sample\", \"paired\"), alternative = c(\"two.sided\", \"one.sided\"), strict = FALSE, tol = .Machine$double.eps^0.25)"},{"p":"stats","o":"write.ftable","f":"hp_write.ftable","d":"Read, write and coerce <U+2018>flat<U+2019> (contingency) tables, aka\nftables.\n","ec":"write.ftable(x, file = \"\", quote = TRUE, append = FALSE, digits = getOption(\"digits\"), sep = \" \", ...)"},{"p":"stats","o":"qhyper","f":"hp_qhyper","d":"Density, distribution function, quantile function and random\ngeneration for the hypergeometric distribution.\n","ec":"qhyper(p, m, n, k, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"polym","f":"hp_polym","d":"Returns or evaluates orthogonal polynomials of degree 1 to\ndegree over the specified set of points x: these are all\northogonal to the constant polynomial of degree 0.  Alternatively,\nevaluate raw polynomials.\n","ec":"polym(..., degree = 1, coefs = NULL, raw = FALSE)"},{"p":"stats","o":"weights","f":"hp_weights","d":"weights is a generic function which extracts fitting weights from\nobjects returned by modeling functions.\n","ec":"weights(object, ...)"},{"p":"stats","o":"dhyper","f":"hp_dhyper","d":"Density, distribution function, quantile function and random\ngeneration for the hypergeometric distribution.\n","ec":"dhyper(x, m, n, k, log = FALSE)"},{"p":"stats","o":"contrasts<-","f":"hp_contrasts..","d":"Set and view the contrasts associated with a factor.\n","ec":"contrasts<-(x, how.many = NULL, value)"},{"p":"stats","o":"kernel","f":"hp_kernel","d":"The \"tskernel\" class is designed to represent discrete\nsymmetric normalized smoothing kernels.  These kernels can be used to\nsmooth vectors, matrices, or time series objects.\n","ec":"kernel(coef, m = 2, r, name = \"unknown\")"},{"p":"stats","o":"friedman.test","f":"hp_friedman.test","d":"Performs a Friedman rank sum test with unreplicated blocked data.\n","ec":"friedman.test(y, ...)"},{"p":"stats","o":"acf","f":"hp_acf","d":"The function acf computes (and by default plots) estimates of\nthe autocovariance or autocorrelation function.  Function pacf\nis the function used for the partial autocorrelations.  Function\nccf computes the cross-correlation or cross-covariance of two\nunivariate series.\n","ec":"acf(x, lag.max = NULL, type = c(\"correlation\", \"covariance\", \"partial\"), plot = TRUE, na.action = na.fail, demean = TRUE, ...)"},{"p":"stats","o":"qwilcox","f":"hp_qwilcox","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon rank sum statistic\nobtained from samples with size m and n, respectively.\n","ec":"qwilcox(p, m, n, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"filter","f":"hp_filter","d":"Applies linear filtering to a univariate time series or to each series\nseparately of a multivariate time series.\n","ec":"filter(x, filter, method = c(\"convolution\", \"recursive\"), sides = 2L, circular = FALSE, init = NULL)"},{"p":"stats","o":"lm.fit","f":"hp_lm.fit","d":"These are the basic computing engines called by lm used\nto fit linear models.  These should usually not be used\ndirectly unless by experienced users.  .lm.fit() is a bare-bones\nwrapper to the innermost QR-based C code, on which\nglm.fit and lsfit are also based, for\neven more experienced users.\n","ec":"lm.fit(x, y, offset = NULL, method = \"qr\", tol = 1e-07, singular.ok = TRUE, ...)"},{"p":"stats","o":"rpois","f":"hp_rpois","d":"Density, distribution function, quantile function and random\ngeneration for the Poisson distribution with parameter lambda.\n","ec":"rpois(n, lambda)"},{"p":"stats","o":"cmdscale","f":"hp_cmdscale","d":"Classical multidimensional scaling (MDS) of a data matrix.\nAlso known as principal coordinates analysis (Gower, 1966).\n","ec":"cmdscale(d, k = 2, eig = FALSE, add = FALSE, x.ret = FALSE, list. = eig || add || x.ret)"},{"p":"stats","o":"factor.scope","f":"hp_factor.scope","d":"add.scope and drop.scope compute those terms that can be\nindividually added to or dropped from a model while respecting the\nhierarchy of terms.\n","ec":"factor.scope(factor, scope)"},{"p":"stats","o":"Gamma","f":"hp_Gamma","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"Gamma(link = \"inverse\")"},{"p":"stats","o":"pweibull","f":"hp_pweibull","d":"Density, distribution function, quantile function and random\ngeneration for the Weibull distribution with parameters shape\nand scale.\n","ec":"pweibull(q, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"pchisq","f":"hp_pchisq","d":"Density, distribution function, quantile function and random\ngeneration for the chi-squared (\\chi^2) distribution with\ndf degrees of freedom and optional non-centrality parameter\nncp.\n","ec":"pchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"ksmooth","f":"hp_ksmooth","d":"The Nadaraya<U+2013>Watson kernel regression estimate.\n","ec":"ksmooth(x, y, kernel = c(\"box\", \"normal\"), bandwidth = 0.5, range.x = range(x), n.points = max(100L, length(x)), x.points)"},{"p":"stats","o":"symnum","f":"hp_symnum","d":"Symbolically encode a given numeric or logical vector or array.\nParticularly useful for visualization of structured matrices,\ne.g., correlation, sparse, or logical ones.\n","ec":"symnum(x, cutpoints = c(0.3, 0.6, 0.8, 0.9, 0.95), symbols = if (numeric.x) c(\" \", \".\", \",\", \"+\", \"*\", \"B\") else c(\".\", \"|\"), legend = length(symbols) >= 3, na = \"?\", eps = 1e-05, numeric.x = is.numeric(x), corr = missing(cutpoints) && numeric.x, show.max = if (corr) \"1\", show.min = NULL, abbr.colnames = has.colnames, lower.triangular = corr && is.numeric(x) && is.matrix(x), diag.lower.tri = corr && !is.null(show.max))"},{"p":"stats","o":"smooth","f":"hp_smooth","d":"Tukey's smoothers, 3RS3R, 3RSS, 3R, etc.\n","ec":"smooth(x, kind = c(\"3RS3R\", \"3RSS\", \"3RSR\", \"3R\", \"3\", \"S\"), twiceit = FALSE, endrule = c(\"Tukey\", \"copy\"), do.ends = FALSE)"},{"p":"stats","o":"quasipoisson","f":"hp_quasipoisson","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"quasipoisson(link = \"log\")"},{"p":"stats","o":"ppr","f":"hp_ppr","d":"Fit a projection pursuit regression model.\n","ec":"ppr(x, ...)"},{"p":"stats","o":"spec.ar","f":"hp_spec.ar","d":"Fits an AR model to x (or uses the existing fit) and computes\n(and by default plots) the spectral density of the fitted model.\n","ec":"spec.ar(x, n.freq, order = NULL, plot = TRUE, na.action = na.fail, method = \"yule-walker\", ...)"},{"p":"stats","o":"pnbinom","f":"hp_pnbinom","d":"Density, distribution function, quantile function and random\ngeneration for the negative binomial distribution with parameters\nsize and prob.\n","ec":"pnbinom(q, size, prob, mu, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"coefficients","f":"hp_coefficients","d":"coef is a generic function which extracts model coefficients\nfrom objects returned by modeling functions.  coefficients is\nan alias for it.\n","ec":"coefficients(object, ...)"},{"p":"stats","o":"model.offset","f":"hp_model.offset","d":"Returns the response, offset, subset, weights or other\nspecial components of a model frame passed as optional arguments to\nmodel.frame.\n","ec":"model.offset(x)"},{"p":"stats","o":"dbeta","f":"hp_dbeta","d":"Density, distribution function, quantile function and random\ngeneration for the Beta distribution with parameters shape1 and\nshape2 (and optional non-centrality parameter ncp).\n","ec":"dbeta(x, shape1, shape2, ncp = 0, log = FALSE)"},{"p":"stats","o":"SSasympOff","f":"hp_SSasympOff","d":"This selfStart model evaluates an alternative parametrization\nof the asymptotic\nregression function and the gradient with respect to those parameters.\nIt has an initial\nattribute that creates initial estimates of the parameters\nAsym, lrc, and c0.\n","ec":"SSasympOff(input, Asym, lrc, c0)"},{"p":"stats","o":"pbirthday","f":"hp_pbirthday","d":"Computes answers to a generalised birthday paradox problem.\npbirthday computes the probability of a coincidence and\nqbirthday computes the smallest number of observations needed\nto have at least a specified probability of coincidence.\n","ec":"pbirthday(n, classes = 365, coincident = 2)"},{"p":"stats","o":"replications","f":"hp_replications","d":"Returns a vector or a list of the number of replicates for\neach term in the formula.\n","ec":"replications(formula, data = NULL, na.action)"},{"p":"stats","o":"ar.ols","f":"hp_ar.ols","d":"Fit an autoregressive time series model to the data by ordinary\nleast squares, by default selecting the complexity by AIC.\n","ec":"ar.ols(x, aic = TRUE, order.max = NULL, na.action = na.fail, demean = TRUE, intercept = demean, series = NULL, ...)"},{"p":"stats","o":"rhyper","f":"hp_rhyper","d":"Density, distribution function, quantile function and random\ngeneration for the hypergeometric distribution.\n","ec":"rhyper(nn, m, n, k)"},{"p":"stats","o":"spectrum","f":"hp_spectrum","d":"The spectrum function estimates the spectral density of a\ntime series.\n","ec":"spectrum(x, ..., method = c(\"pgram\", \"ar\"))"},{"p":"stats","o":"lm","f":"hp_lm","d":"lm is used to fit linear models, including multivariate ones.\nIt can be used to carry out regression,\nsingle stratum analysis of variance and\nanalysis of covariance (although aov may provide a more\nconvenient interface for these).\n","ec":"lm(formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...)"},{"p":"stats","o":"expand.model.frame","f":"hp_expand.model.frame","d":"Evaluates new variables as if they had been part of the formula of the\nspecified model.  This ensures that the same na.action and\nsubset arguments are applied and allows, for example, x\nto be recovered for a model using sin(x) as a predictor.\n","ec":"expand.model.frame(model, extras, envir = environment(formula(model)), na.expand = FALSE)"},{"p":"stats","o":"kernapply","f":"hp_kernapply","d":"kernapply computes the convolution between an input sequence\nand a specific kernel.\n","ec":"kernapply(x, ...)"},{"p":"stats","o":"bw.nrd0","f":"hp_bw.nrd0","d":"Bandwidth selectors for Gaussian kernels in density.\n","ec":"bw.nrd0(x)"},{"p":"stats","o":"stl","f":"hp_stl","d":"Decompose a time series into seasonal, trend and irregular components\nusing loess, acronym STL.\n","ec":"stl(x, s.window, s.degree = 0, t.window = NULL, t.degree = 1, l.window = nextodd(period), l.degree = t.degree, s.jump = ceiling(s.window/10), t.jump = ceiling(t.window/10), l.jump = ceiling(l.window/10), robust = FALSE, inner = if (robust) 1 else 2, outer = if (robust) 15 else 0, na.action = na.fail)"},{"p":"stats","o":"loess","f":"hp_loess","d":"Fit a locally polynomial surface determined by one or more numerical\npredictors, using local fitting.\n","ec":"loess(formula, data, weights, subset, na.action, model = FALSE, span = 0.75, enp.target, degree = 2L, parametric = FALSE, drop.square = FALSE, normalize = TRUE, family = c(\"gaussian\", \"symmetric\"), method = c(\"loess\", \"model.frame\"), control = loess.control(...), ...)"},{"p":"stats","o":"IQR","f":"hp_IQR","d":"computes interquartile range of the x values.","ec":"IQR(x, na.rm = FALSE, type = 7)"},{"p":"stats","o":"qgeom","f":"hp_qgeom","d":"Density, distribution function, quantile function and random\ngeneration for the geometric distribution with parameter prob.\n","ec":"qgeom(p, prob, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"contr.helmert","f":"hp_contr.helmert","d":"Return a matrix of contrasts.\n","ec":"contr.helmert(n, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"na.pass","f":"hp_na.pass","d":"These generic functions are useful for dealing with NAs\nin e.g., data frames.\nna.fail returns the object if it does not contain any\nmissing values, and signals an error otherwise.\nna.omit returns the object with incomplete cases removed.\nna.pass returns the object unchanged.\n","ec":"na.pass(object, ...)"},{"p":"stats","o":"toeplitz","f":"hp_toeplitz","d":"In its simplest use, toeplitz() forms a symmetric Toeplitz matrix\ngiven its first column (or row).  For the general case, asymmetric and\nnon-square Toeplitz matrices are formed either by specifying the first\ncolumn and row separately,\n","ec":"toeplitz(x, r = NULL, symmetric = is.null(r))"},{"p":"stats","o":"pairwise.t.test","f":"hp_pairwise.t.test","d":"Calculate pairwise comparisons between group levels with corrections\nfor multiple testing\n","ec":"pairwise.t.test(x, g, p.adjust.method = p.adjust.methods, pool.sd = !paired, paired = FALSE, alternative = c(\"two.sided\", \"less\", \"greater\"), ...)"},{"p":"stats","o":"dist","f":"hp_dist","d":"This function computes and returns the distance matrix computed by\nusing the specified distance measure to compute the distances between\nthe rows of a data matrix.\n","ec":"dist(x, method = \"euclidean\", diag = FALSE, upper = FALSE, p = 2)"},{"p":"stats","o":".getXlevels","f":"hp_.getXlevels","d":".checkMFClasses checks if the variables used in a predict\nmethod agree in type with those used for fitting.\n","ec":".getXlevels(Terms, m)"},{"p":"stats","o":"NLSstClosestX","f":"hp_NLSstClosestX","d":"Use inverse linear interpolation to approximate the x value at\nwhich the function represented by xy is equal to yval.\n","ec":"NLSstClosestX(xy, yval)"},{"p":"stats","o":"getInitial","f":"hp_getInitial","d":"This function evaluates initial parameter estimates for a nonlinear\nregression model.  If data is a parameterized data frame or\npframe object, its parameters attribute is returned.\nOtherwise the object is examined to see if it contains a call to a\nselfStart object whose initial attribute can be\nevaluated.\n","ec":"getInitial(object, data, ...)"},{"p":"stats","o":"sigma","f":"hp_sigma","d":"Extract the estimated standard deviation of the errors, the\n<U+201C>residual standard deviation<U+201D> (misnamed also\n<U+201C>residual standard error<U+201D>, e.g., in\nsummary.lm()'s output, from a fitted model).\n","ec":"sigma(object, ...)"},{"p":"stats","o":"qchisq","f":"hp_qchisq","d":"Density, distribution function, quantile function and random\ngeneration for the chi-squared (\\chi^2) distribution with\ndf degrees of freedom and optional non-centrality parameter\nncp.\n","ec":"qchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"contr.poly","f":"hp_contr.poly","d":"Return a matrix of contrasts.\n","ec":"contr.poly(n, scores = 1:n, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"dchisq","f":"hp_dchisq","d":"Density, distribution function, quantile function and random\ngeneration for the chi-squared (\\chi^2) distribution with\ndf degrees of freedom and optional non-centrality parameter\nncp.\n","ec":"dchisq(x, df, ncp = 0, log = FALSE)"},{"p":"stats","o":"spline","f":"hp_spline","d":"Perform cubic (or Hermite) spline interpolation of given data points,\nreturning either a list of points obtained by the interpolation or a\nfunction performing the interpolation.\n","ec":"spline(x, y = NULL, n = 3 * length(x), method = \"fmm\", xmin = min(x), xmax = max(x), xout, ties = mean)"},{"p":"stats","o":"qunif","f":"hp_qunif","d":"These functions provide information about the uniform distribution\non the interval from min to max.  dunif gives the\ndensity, punif gives the distribution function qunif\ngives the quantile function and runif generates random\ndeviates.\n","ec":"qunif(p, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"confint","f":"hp_confint","d":"Computes confidence intervals for one or more parameters in a fitted\nmodel.  There is a default and a method for objects inheriting from class\n\"lm\".\n","ec":"confint(object, parm, level = 0.95, ...)"},{"p":"stats","o":"pairwise.table","f":"hp_pairwise.table","d":"Creates  table of p values for pairwise comparisons\nwith corrections for multiple testing.\n","ec":"pairwise.table(compare.levels, level.names, p.adjust.method)"},{"p":"stats","o":"SSasympOrig","f":"hp_SSasympOrig","d":"This selfStart model evaluates the asymptotic regression\nfunction through the origin and its gradient.  It has an\ninitial attribute that will evaluate initial estimates of the\nparameters Asym and lrc for a given set of data.\n","ec":"SSasympOrig(input, Asym, lrc)"},{"p":"stats","o":"pexp","f":"hp_pexp","d":"Density, distribution function, quantile function and random\ngeneration for the exponential distribution with rate rate\n(i.e., mean 1/rate).\n","ec":"pexp(q, rate = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"plot.spec.phase","f":"hp_plot.spec.phase","d":"Plotting method for objects of class \"spec\".  For multivariate\ntime series it plots the marginal spectra of the series or pairs plots\nof the coherency and phase of the cross-spectra.\n","ec":"plot.spec.phase(x, ci = 0.95, xlab = \"frequency\", ylab = \"phase\", ylim = c(-pi, pi), type = \"l\", main = NULL, ci.col = \"blue\", ci.lty = 3, ...)"},{"p":"stats","o":"density.default","f":"hp_density.default","d":"The (S3) generic function density computes kernel density\nestimates.  Its default method does so with the given kernel and\nbandwidth for univariate observations.\n","ec":"density.default(x, bw = \"nrd0\", adjust = 1, kernel = c(\"gaussian\", \"epanechnikov\", \"rectangular\", \"triangular\", \"biweight\", \"cosine\", \"optcosine\"), weights = NULL, window = kernel, width, give.Rkern = FALSE, subdensity = FALSE, warnWbw = var(weights) > 0, n = 512, from, to, cut = 3, ext = 4, old.coords = FALSE, na.rm = FALSE, ...)"},{"p":"stats","o":"medpolish","f":"hp_medpolish","d":"Fits an additive model (two-way decomposition) using Tukey's\nmedian polish procedure.\n","ec":"medpolish(x, eps = 0.01, maxiter = 10L, trace.iter = TRUE, na.rm = FALSE)"},{"p":"stats","o":"ptukey","f":"hp_ptukey","d":"Functions of the distribution of the studentized range, R/s,\nwhere R is the range of a standard normal sample and\ndf \\times s^2 is independently distributed as\nchi-squared with df degrees of freedom, see pchisq.\n","ec":"ptukey(q, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"cancor","f":"hp_cancor","d":"Compute the canonical correlations between two data matrices.\n","ec":"cancor(x, y, xcenter = TRUE, ycenter = TRUE)"},{"p":"stats","o":"Box.test","f":"hp_Box.test","d":"Compute the Box<U+2013>Pierce or Ljung<U+2013>Box test statistic for examining the\nnull hypothesis of independence in a given time series.  These are\nsometimes known as <U+2018>portmanteau<U+2019> tests.\n","ec":"Box.test(x, lag = 1, type = c(\"Box-Pierce\", \"Ljung-Box\"), fitdf = 0)"},{"p":"stats","o":"TukeyHSD","f":"hp_TukeyHSD","d":"Create a set of confidence intervals on the differences between the\nmeans of the levels of a factor with the specified family-wise\nprobability of coverage.  The intervals are based on the Studentized\nrange statistic, Tukey's <U+2018>Honest Significant Difference<U+2019>\nmethod.\n","ec":"TukeyHSD(x, which, ordered = FALSE, conf.level = 0.95, ...)"},{"p":"stats","o":"rnorm","f":"hp_rnorm","d":"Density, distribution function, quantile function and random\ngeneration for the normal distribution with mean equal to mean\nand standard deviation equal to sd.\n","ec":"rnorm(n, mean = 0, sd = 1)"},{"p":"stats","o":"var.test","f":"hp_var.test","d":"Performs an F test to compare the variances of two samples from normal\npopulations.\n","ec":"var.test(x, ...)"},{"p":"stats","o":"poisson","f":"hp_poisson","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"poisson(link = \"log\")"},{"p":"stats","o":"bartlett.test","f":"hp_bartlett.test","d":"Performs Bartlett's test of the null that the variances in each of the\ngroups (samples) are the same.\n","ec":"bartlett.test(x, ...)"},{"p":"stats","o":"summary.stepfun","f":"hp_summary.stepfun","d":"Given the vectors (x_1, \\ldots, x_n) and\n(y_0,y_1,\\ldots, y_n) (one value\nmore!), stepfun(x, y, ...) returns an interpolating\n<U+2018>step<U+2019> function, say fn. I.e., fn(t) =\n    c_i (constant) for t \\in (x_i, x_{i+1}) and at the abscissa values, if (by default)\nright = FALSE, fn(x_i) = y_i and for\nright = TRUE, fn(x_i) = y_{i-1}, for\ni=1,\\ldots,n.\n","ec":"summary.stepfun(object, ...)"},{"p":"stats","o":"na.fail","f":"hp_na.fail","d":"These generic functions are useful for dealing with NAs\nin e.g., data frames.\nna.fail returns the object if it does not contain any\nmissing values, and signals an error otherwise.\nna.omit returns the object with incomplete cases removed.\nna.pass returns the object unchanged.\n","ec":"na.fail(object, ...)"},{"p":"stats","o":"model.frame","f":"hp_model.frame","d":"model.frame (a generic function) and its methods return a\ndata.frame with the variables needed to use\nformula and any ... arguments.\n","ec":"model.frame(formula, ...)"},{"p":"stats","o":"covratio","f":"hp_covratio","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"covratio(model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model))"},{"p":"stats","o":"contrasts","f":"hp_contrasts","d":"Set and view the contrasts associated with a factor.\n","ec":"contrasts(x, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"ar.burg","f":"hp_ar.burg","d":"Fit an autoregressive time series model to the data, by default\nselecting the complexity by AIC.\n","ec":"ar.burg(x, ...)"},{"p":"stats","o":"residuals.lm","f":"hp_residuals.lm","d":"All these functions are methods for class \"lm\"  objects.\n","ec":"residuals.lm(object, type = c(\"working\", \"response\", \"deviance\", \"pearson\", \"partial\"), ...)"},{"p":"stats","o":"df.residual","f":"hp_df.residual","d":"Returns the residual degrees-of-freedom extracted from a fitted model\nobject.\n","ec":"df.residual(object, ...)"},{"p":"stats","o":"ts.intersect","f":"hp_ts.intersect","d":"Bind time series which have a common frequency. ts.union pads\nwith NAs to the total time coverage, ts.intersect\nrestricts to the time covered by all the series.\n","ec":"ts.intersect(..., dframe = FALSE)"},{"p":"stats","o":"power","f":"hp_power","d":"Creates a link object based on the link function\n\\eta = \\mu ^ \\lambda.\n","ec":"power(lambda = 1)"},{"p":"stats","o":"SSlogis","f":"hp_SSlogis","d":"This selfStart model evaluates the logistic\nfunction and its gradient.  It has an initial attribute that\ncreates initial estimates of the parameters Asym,\nxmid, and scal.   In R 3.4.2 and earlier, that\ninit function failed when min(input) was exactly zero.\n","ec":"SSlogis(input, Asym, xmid, scal)"},{"p":"stats","o":"glm","f":"hp_glm","d":"glm is used to fit generalized linear models, specified by\ngiving a symbolic description of the linear predictor and a\ndescription of the error distribution.\n","ec":"glm(formula, family = gaussian, data, weights, subset, na.action, start = NULL, etastart, mustart, offset, control = list(...), model = TRUE, method = \"glm.fit\", x = FALSE, y = TRUE, singular.ok = TRUE, contrasts = NULL, ...)"},{"p":"stats","o":"rchisq","f":"hp_rchisq","d":"Density, distribution function, quantile function and random\ngeneration for the chi-squared (\\chi^2) distribution with\ndf degrees of freedom and optional non-centrality parameter\nncp.\n","ec":"rchisq(n, df, ncp = 0)"},{"p":"stats","o":"getCall","f":"hp_getCall","d":"update will update and (by default) re-fit a model.  It does this\nby extracting the call stored in the object, updating the call and (by\ndefault) evaluating that call.  Sometimes it is useful to call\nupdate with only one argument, for example if the data frame has\nbeen corrected.\n","ec":"getCall(x, ...)"},{"p":"stats","o":"model.matrix.lm","f":"hp_model.matrix.lm","d":"model.matrix creates a design (or model) matrix, e.g., by\nexpanding factors to a set of dummy variables (depending on the\ncontrasts) and expanding interactions similarly.\n","ec":"model.matrix.lm(object, ...)"},{"p":"stats","o":"chisq.test","f":"hp_chisq.test","d":"chisq.test performs chi-squared contingency table tests\nand goodness-of-fit tests.\n","ec":"chisq.test(x, y = NULL, correct = TRUE, p = rep(1/length(x), length(x)), rescale.p = FALSE, simulate.p.value = FALSE, B = 2000)"},{"p":"stats","o":"coef","f":"hp_coef","d":"coef is a generic function which extracts model coefficients\nfrom objects returned by modeling functions.  coefficients is\nan alias for it.\n","ec":"coef(object, ...)"},{"p":"stats","o":"step","f":"hp_step","d":"Select a formula-based model by AIC.\n","ec":"step(object, scope, scale = 0, direction = c(\"both\", \"backward\", \"forward\"), trace = 1, keep = NULL, steps = 1000, k = 2, ...)"},{"p":"stats","o":"ppoints","f":"hp_ppoints","d":"Generates the sequence of probability points\n(1:m - a)/(m + (1-a)-a)\nwhere m is either n, if length(n)==1, or\nlength(n).\n","ec":"ppoints(n, a = if (n <= 10) 3/8 else 1/2)"},{"p":"stats","o":"vcov","f":"hp_vcov","d":"Returns the variance-covariance matrix of the main parameters of\na fitted model object.  The <U+201C>main<U+201D> parameters of model\ncorrespond to those returned by coef, and typically do\nnot contain a nuisance scale parameter (sigma).\n","ec":"vcov(object, ...)"},{"p":"stats","o":".preformat.ts","f":"hp_.preformat.ts","d":"Notably for calendar related time series objects,  \nformat and print methods showing years,\nmonths and or quarters respectively.\n","ec":".preformat.ts(x, calendar, ...)"},{"p":"stats","o":"qqplot","f":"hp_qqplot","d":"qqnorm is a generic function the default method of which\nproduces a normal QQ plot of the values in y.\nqqline adds a line to a <U+201C>theoretical<U+201D>, by default\nnormal, quantile-quantile plot which passes through the probs\nquantiles, by default the first and third quartiles.\n","ec":"qqplot(x, y, plot.it = TRUE, xlab = deparse1(substitute(x)), ylab = deparse1(substitute(y)), ..., conf.level = NULL, conf.args = list(exact = NULL, simulate.p.value = FALSE, B = 2000, col = NA, border = NULL))"},{"p":"stats","o":"DF2formula","f":"hp_DF2formula","d":"The generic function formula and its specific methods provide a\nway of extracting formulae which have been included in other objects.\n","ec":"DF2formula(x, env = parent.frame())"},{"p":"stats","o":"update.default","f":"hp_update.default","d":"update will update and (by default) re-fit a model.  It does this\nby extracting the call stored in the object, updating the call and (by\ndefault) evaluating that call.  Sometimes it is useful to call\nupdate with only one argument, for example if the data frame has\nbeen corrected.\n","ec":"update.default(object, formula., ..., evaluate = TRUE)"},{"p":"stats","o":"qtukey","f":"hp_qtukey","d":"Functions of the distribution of the studentized range, R/s,\nwhere R is the range of a standard normal sample and\ndf \\times s^2 is independently distributed as\nchi-squared with df degrees of freedom, see pchisq.\n","ec":"qtukey(p, nmeans, df, nranges = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"quade.test","f":"hp_quade.test","d":"Performs a Quade test with unreplicated blocked data.\n","ec":"quade.test(y, ...)"},{"p":"stats","o":"qpois","f":"hp_qpois","d":"Density, distribution function, quantile function and random\ngeneration for the Poisson distribution with parameter lambda.\n","ec":"qpois(p, lambda, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"df.kernel","f":"hp_df.kernel","d":"The \"tskernel\" class is designed to represent discrete\nsymmetric normalized smoothing kernels.  These kernels can be used to\nsmooth vectors, matrices, or time series objects.\n","ec":"df.kernel(k)"},{"p":"stats","o":"influence","f":"hp_influence","d":"This function provides the basic quantities which are\nused in forming a wide variety of diagnostics for\nchecking the quality of regression fits.\n","ec":"influence(model, ...)"},{"p":"stats","o":"qsmirnov","f":"hp_qsmirnov","d":"Distribution function, quantile function and random generation for the\ndistribution of the Smirnov statistic.","ec":"qsmirnov(p, sizes, z = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"), exact = TRUE, simulate = FALSE, B = 2000)"},{"p":"stats","o":"cutree","f":"hp_cutree","d":"Cuts a tree, e.g., as resulting from hclust, into several\ngroups either by specifying the desired number(s) of groups or the cut\nheight(s).\n","ec":"cutree(tree, k = NULL, h = NULL)"},{"p":"stats","o":"poisson.test","f":"hp_poisson.test","d":"Performs an exact test of a simple null hypothesis about the\nrate parameter in Poisson distribution, or for the\nratio between two rate parameters.\n","ec":"poisson.test(x, T = 1, r = 1, alternative = c(\"two.sided\", \"less\", \"greater\"), conf.level = 0.95)"},{"p":"stats","o":"pf","f":"hp_pf","d":"Density, distribution function, quantile function and random\ngeneration for the F distribution with df1 and df2\ndegrees of freedom (and optional non-centrality parameter ncp).\n","ec":"pf(q, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"case.names","f":"hp_case.names","d":"Simple utilities returning (non-missing) case names, and\n(non-eliminated) variable names.\n","ec":"case.names(object, ...)"},{"p":"stats","o":"frequency","f":"hp_frequency","d":"time creates the vector of times at which a time series was sampled.\n","ec":"frequency(x, ...)"},{"p":"stats","o":"tsdiag","f":"hp_tsdiag","d":"A generic function to plot time-series diagnostics.\n","ec":"tsdiag(object, gof.lag, ...)"},{"p":"stats","o":"qweibull","f":"hp_qweibull","d":"Density, distribution function, quantile function and random\ngeneration for the Weibull distribution with parameters shape\nand scale.\n","ec":"qweibull(p, shape, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"NLSstLfAsymptote","f":"hp_NLSstLfAsymptote","d":"Provide an initial guess at the horizontal asymptote on the left side\n(i.e., small values of x) of the graph of y versus\nx from the xy object.  Primarily used within\ninitial functions for self-starting nonlinear regression\nmodels.\n","ec":"NLSstLfAsymptote(xy)"},{"p":"stats","o":"kmeans","f":"hp_kmeans","d":"Perform k-means clustering on a data matrix.\n","ec":"kmeans(x, centers, iter.max = 10L, nstart = 1L, algorithm = c(\"Hartigan-Wong\", \"Lloyd\", \"Forgy\", \"MacQueen\"), trace = FALSE)"},{"p":"stats","o":"weighted.residuals","f":"hp_weighted.residuals","d":"Computed weighted residuals from a linear model fit.\n","ec":"weighted.residuals(obj, drop0 = TRUE)"},{"p":"stats","o":"mauchly.test","f":"hp_mauchly.test","d":"Tests whether a Wishart-distributed covariance matrix (or\ntransformation thereof) is proportional to a given matrix.\n","ec":"mauchly.test(object, ...)"},{"p":"stats","o":"napredict","f":"hp_napredict","d":"Use missing value information to adjust residuals and predictions.\n","ec":"napredict(omit, x, ...)"},{"p":"stats","o":"qexp","f":"hp_qexp","d":"Density, distribution function, quantile function and random\ngeneration for the exponential distribution with rate rate\n(i.e., mean 1/rate).\n","ec":"qexp(p, rate = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"deriv","f":"hp_deriv","d":"Compute derivatives of simple expressions, symbolically and algorithmically.\n","ec":"deriv(expr, ...)"},{"p":"stats","o":"var","f":"hp_var","d":"var, cov and cor compute the variance of x\nand the covariance or correlation of x and y if these\nare vectors.   If x and y are matrices then the\ncovariances (or correlations) between the columns of x and the\ncolumns of y are computed.\n","ec":"var(x, y = NULL, na.rm = FALSE, use)"},{"p":"stats","o":"aggregate.ts","f":"hp_aggregate.ts","d":"Splits the data into subsets, computes summary statistics for each,\nand returns the result in a convenient form.\n","ec":"aggregate.ts(x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption(\"ts.eps\"), ...)"},{"p":"stats","o":"rwilcox","f":"hp_rwilcox","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon rank sum statistic\nobtained from samples with size m and n, respectively.\n","ec":"rwilcox(nn, m, n)"},{"p":"stats","o":"SSbiexp","f":"hp_SSbiexp","d":"This selfStart model evaluates the biexponential model function\nand its gradient.  It has an initial attribute that\ncreates initial estimates of the parameters A1, lrc1,\nA2, and lrc2.\n","ec":"SSbiexp(input, A1, lrc1, A2, lrc2)"},{"p":"stats","o":"pt","f":"hp_pt","d":"Density, distribution function, quantile function and random\ngeneration for the t distribution with df degrees of freedom\n(and optional non-centrality parameter ncp).\n","ec":"pt(q, df, ncp, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"rsmirnov","f":"hp_rsmirnov","d":"Distribution function, quantile function and random generation for the\ndistribution of the Smirnov statistic.","ec":"rsmirnov(n, sizes, z = NULL, alternative = c(\"two.sided\", \"less\", \"greater\"))"},{"p":"stats","o":"qf","f":"hp_qf","d":"Density, distribution function, quantile function and random\ngeneration for the F distribution with df1 and df2\ndegrees of freedom (and optional non-centrality parameter ncp).\n","ec":"qf(p, df1, df2, ncp, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"xtabs","f":"hp_xtabs","d":"Create a contingency table (optionally a sparse matrix) from\ncross-classifying factors, usually contained in a data frame,\nusing a formula interface.\n","ec":"xtabs(formula = ~., data = parent.frame(), subset, sparse = FALSE, na.action, na.rm = FALSE, addNA = FALSE, exclude = if (!addNA) c(NA, NaN), drop.unused.levels = FALSE)"},{"p":"stats","o":"kruskal.test","f":"hp_kruskal.test","d":"Performs a Kruskal-Wallis rank sum test.\n","ec":"kruskal.test(x, ...)"},{"p":"stats","o":"median","f":"hp_median","d":"Compute the sample median.\n","ec":"median(x, na.rm = FALSE, ...)"},{"p":"stats","o":"as.hclust","f":"hp_as.hclust","d":"Converts objects from other hierarchical clustering functions to\nclass \"hclust\".\n","ec":"as.hclust(x, ...)"},{"p":"stats","o":"termplot","f":"hp_termplot","d":"Plots regression terms against their predictors, optionally with\nstandard errors and partial residuals added.\n","ec":"termplot(model, data = NULL, envir = environment(formula(model)), partial.resid = FALSE, rug = FALSE, terms = NULL, se = FALSE, xlabs = NULL, ylabs = NULL, main = NULL, col.term = 2, lwd.term = 1.5, col.se = \"orange\", lty.se = 2, lwd.se = 1, col.res = \"gray\", cex = 1, pch = par(\"pch\"), col.smth = \"darkred\", lty.smth = 2, span.smth = 2/3, ask = dev.interactive() && nb.fig < n.tms, use.factor.levels = TRUE, smooth = NULL, ylim = \"common\", plot = TRUE, transform.x = FALSE, ...)"},{"p":"stats","o":"rweibull","f":"hp_rweibull","d":"Density, distribution function, quantile function and random\ngeneration for the Weibull distribution with parameters shape\nand scale.\n","ec":"rweibull(n, shape, scale = 1)"},{"p":"stats","o":"resid","f":"hp_resid","d":"residuals is a generic function which extracts model residuals\nfrom objects returned by modeling functions.\n","ec":"resid(object, ...)"},{"p":"stats","o":"pgeom","f":"hp_pgeom","d":"Density, distribution function, quantile function and random\ngeneration for the geometric distribution with parameter prob.\n","ec":"pgeom(q, prob, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"qnbinom","f":"hp_qnbinom","d":"Density, distribution function, quantile function and random\ngeneration for the negative binomial distribution with parameters\nsize and prob.\n","ec":"qnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"se.contrast","f":"hp_se.contrast","d":"Returns the standard errors for one or more contrasts in an aov\nobject.\n","ec":"se.contrast(object, ...)"},{"p":"stats","o":"summary.manova","f":"hp_summary.manova","d":"A summary method for class \"manova\".\n","ec":"summary.manova(object, test = c(\"Pillai\", \"Wilks\", \"Hotelling-Lawley\", \"Roy\"), intercept = FALSE, tol = 1e-07, ...)"},{"p":"stats","o":"prcomp","f":"hp_prcomp","d":"Performs a principal components analysis on the given data matrix\nand returns the results as an object of class prcomp.","ec":"prcomp(x, ...)"},{"p":"stats","o":"preplot","f":"hp_preplot","d":"Compute an object to be used for plots relating to the given model object.\n","ec":"preplot(object, ...)"},{"p":"stats","o":"plot.ecdf","f":"hp_plot.ecdf","d":"Compute an empirical cumulative distribution function, with several\nmethods for plotting, printing and computing with such an\n<U+201C>ecdf<U+201D> object.\n","ec":"plot.ecdf(x, ..., ylab = \"Fn(x)\", verticals = FALSE, col.01line = \"gray70\", pch = 19)"},{"p":"stats","o":"arima.sim","f":"hp_arima.sim","d":"Simulate from an ARIMA model.\n","ec":"arima.sim(model, n, rand.gen = rnorm, innov = rand.gen(n, ...), n.start = NA, start.innov = rand.gen(n.start, ...), ...)"},{"p":"stats","o":"lm.wfit","f":"hp_lm.wfit","d":"These are the basic computing engines called by lm used\nto fit linear models.  These should usually not be used\ndirectly unless by experienced users.  .lm.fit() is a bare-bones\nwrapper to the innermost QR-based C code, on which\nglm.fit and lsfit are also based, for\neven more experienced users.\n","ec":"lm.wfit(x, y, w, offset = NULL, method = \"qr\", tol = 1e-07, singular.ok = TRUE, ...)"},{"p":"stats","o":"ccf","f":"hp_ccf","d":"The function acf computes (and by default plots) estimates of\nthe autocovariance or autocorrelation function.  Function pacf\nis the function used for the partial autocorrelations.  Function\nccf computes the cross-correlation or cross-covariance of two\nunivariate series.\n","ec":"ccf(x, y, lag.max = NULL, type = c(\"correlation\", \"covariance\"), plot = TRUE, na.action = na.fail, ...)"},{"p":"stats","o":"is.leaf","f":"hp_is.leaf","d":"Class \"dendrogram\" provides general functions for handling\ntree-like structures.  It is intended as a replacement for similar\nfunctions in hierarchical clustering and classification/regression\ntrees, such that all of these can use the same engine for plotting or\ncutting trees.\n","ec":"is.leaf(object)"},{"p":"stats","o":"na.action","f":"hp_na.action","d":"Extract information on the NA action used to create an object.\n","ec":"na.action(object, ...)"},{"p":"stats","o":"screeplot","f":"hp_screeplot","d":"screeplot.default plots the variances against the number of the\nprincipal component. This is also the plot method for classes\n\"princomp\" and \"prcomp\".\n","ec":"screeplot(x, ...)"},{"p":"stats","o":"approxfun","f":"hp_approxfun","d":"Return a list of points which linearly interpolate given data points,\nor a function performing the linear (or constant) interpolation.\n","ec":"approxfun(x, y = NULL, method = \"linear\", yleft, yright, rule = 1, f = 0, ties = mean, na.rm = TRUE)"},{"p":"stats","o":"NLSstAsymptotic","f":"hp_NLSstAsymptotic","d":"Fits the asymptotic regression model, in the form b0 +\n      b1*(1-exp(-exp(lrc) * x)) to the xy data.\nThis can be used as a building block in determining starting estimates\nfor more complicated models.\n","ec":"NLSstAsymptotic(xy)"},{"p":"stats","o":"order.dendrogram","f":"hp_order.dendrogram","d":"Theses functions return the order (index) or the \"label\"\nattribute for the leaves in a\ndendrogram.  These indices can then be used to access the appropriate\ncomponents of any additional data.\n","ec":"order.dendrogram(x)"},{"p":"stats","o":"cycle","f":"hp_cycle","d":"time creates the vector of times at which a time series was sampled.\n","ec":"cycle(x, ...)"},{"p":"stats","o":"qt","f":"hp_qt","d":"Density, distribution function, quantile function and random\ngeneration for the t distribution with df degrees of freedom\n(and optional non-centrality parameter ncp).\n","ec":"qt(p, df, ncp, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"rf","f":"hp_rf","d":"Density, distribution function, quantile function and random\ngeneration for the F distribution with df1 and df2\ndegrees of freedom (and optional non-centrality parameter ncp).\n","ec":"rf(n, df1, df2, ncp)"},{"p":"stats","o":"punif","f":"hp_punif","d":"These functions provide information about the uniform distribution\non the interval from min to max.  dunif gives the\ndensity, punif gives the distribution function qunif\ngives the quantile function and runif generates random\ndeviates.\n","ec":"punif(q, min = 0, max = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"quasi","f":"hp_quasi","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"quasi(link = \"identity\", variance = \"constant\")"},{"p":"stats","o":"ts.plot","f":"hp_ts.plot","d":"Plot several time series on a common plot. Unlike\nplot.ts the series can have a different time bases,\nbut they should have the same frequency.\n","ec":"ts.plot(..., gpars = list())"},{"p":"stats","o":"cov.wt","f":"hp_cov.wt","d":"Returns a list containing estimates of the weighted covariance matrix\nand the mean of the data, and optionally of the (weighted) correlation\nmatrix.","ec":"cov.wt(x, wt = rep(1/nrow(x), nrow(x)), cor = FALSE, center = TRUE, method = c(\"unbiased\", \"ML\"))"},{"p":"stats","o":"mood.test","f":"hp_mood.test","d":"Performs Mood's two-sample test for a difference in scale parameters.\n","ec":"mood.test(x, ...)"},{"p":"stats","o":"PP.test","f":"hp_PP.test","d":"Computes the Phillips-Perron test for the null hypothesis that\nx has a unit root against a stationary alternative.\n","ec":"PP.test(x, lshort = TRUE)"},{"p":"stats","o":"is.empty.model","f":"hp_is.empty.model","d":"R's formula notation allows models with no intercept and no\npredictors. These require special handling internally.\nis.empty.model() checks whether an object describes an empty\nmodel.\n","ec":"is.empty.model(x)"},{"p":"stats","o":"loess.control","f":"hp_loess.control","d":"Set control parameters for loess fits.\n","ec":"loess.control(surface = c(\"interpolate\", \"direct\"), statistics = c(\"approximate\", \"exact\", \"none\"), trace.hat = c(\"exact\", \"approximate\"), cell = 0.2, iterations = 4L, iterTrace = FALSE, ...)"},{"p":"stats","o":"decompose","f":"hp_decompose","d":"Decompose a time series into seasonal, trend and irregular components\nusing moving averages.  Deals with additive or multiplicative\nseasonal component.\n","ec":"decompose(x, type = c(\"additive\", \"multiplicative\"), filter = NULL)"},{"p":"stats","o":"aggregate","f":"hp_aggregate","d":"Splits the data into subsets, computes summary statistics for each,\nand returns the result in a convenient form.\n","ec":"aggregate(x, ...)"},{"p":"stats","o":"BIC","f":"hp_BIC","d":"Generic function calculating Akaike's <U+2018>An Information Criterion<U+2019> for\none or several fitted model objects for which a log-likelihood value\ncan be obtained, according to the formula\n-2 \\mbox{log-likelihood} + k n_{par},\nwhere n_{par} represents the number of parameters in the\nfitted model, and k = 2 for the usual AIC, or\nk = \\log(n)\n(n being the number of observations) for the so-called BIC or SBC\n(Schwarz's Bayesian criterion).\n","ec":"BIC(object, ...)"},{"p":"stats","o":"reshape","f":"hp_reshape","d":"This function reshapes a data frame between <U+2018>wide<U+2019> format (with\nrepeated measurements in separate columns of the same row) and\n<U+2018>long<U+2019> format (with the repeated measurements in separate\nrows).\n","ec":"reshape(data, varying = NULL, v.names = NULL, timevar = \"time\", idvar = \"id\", ids = 1L:NROW(data), times = seq_along(varying[[1L]]), drop = NULL, direction, new.row.names = NULL, sep = \".\", split = if (sep == \"\") { list(regexp = \"[A-Za-z][0-9]\", include = TRUE) } else { list(regexp = sep, include = FALSE, fixed = TRUE) })"},{"p":"stats","o":"makeARIMA","f":"hp_makeARIMA","d":"Use Kalman Filtering to find the (Gaussian) log-likelihood, or for\nforecasting or smoothing.\n","ec":"makeARIMA(phi, theta, Delta, kappa = 1e+06, SSinit = c(\"Gardner1980\", \"Rossignol2011\"), tol = .Machine$double.eps)"},{"p":"stats","o":"ARMAtoMA","f":"hp_ARMAtoMA","d":"Convert ARMA process to infinite MA process.\n","ec":"ARMAtoMA(ar = numeric(), ma = numeric(), lag.max)"},{"p":"stats","o":"weighted.mean","f":"hp_weighted.mean","d":"Compute a weighted mean.\n","ec":"weighted.mean(x, w, ...)"},{"p":"stats","o":"pbinom","f":"hp_pbinom","d":"Density, distribution function, quantile function and random\ngeneration for the binomial distribution with parameters size\nand prob.\n","ec":"pbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"selfStart","f":"hp_selfStart","d":"Construct self-starting nonlinear models to be used in\nnls, etc.  Via function initial to compute\napproximate parameter values from data, such models are\n<U+201C>self-starting<U+201D>, i.e., do not need a start argument in,\ne.g., nls().\n","ec":"selfStart(model, initial, parameters, template)"},{"p":"stats","o":"SSgompertz","f":"hp_SSgompertz","d":"This selfStart model evaluates the Gompertz growth model\nand its gradient.  It has an initial attribute that\ncreates initial estimates of the parameters Asym,\nb2, and b3.\n","ec":"SSgompertz(x, Asym, b2, b3)"},{"p":"stats","o":"qnorm","f":"hp_qnorm","d":"Density, distribution function, quantile function and random\ngeneration for the normal distribution with mean equal to mean\nand standard deviation equal to sd.\n","ec":"qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"inverse.gaussian","f":"hp_inverse.gaussian","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"inverse.gaussian(link = \"1/mu^2\")"},{"p":"stats","o":"na.omit","f":"hp_na.omit","d":"These generic functions are useful for dealing with NAs\nin e.g., data frames.\nna.fail returns the object if it does not contain any\nmissing values, and signals an error otherwise.\nna.omit returns the object with incomplete cases removed.\nna.pass returns the object unchanged.\n","ec":"na.omit(object, ...)"},{"p":"stats","o":"sd","f":"hp_sd","d":"This function computes the standard deviation of the values in\nx.\nIf na.rm is TRUE then missing values are removed before\ncomputation proceeds.\n","ec":"sd(x, na.rm = FALSE)"},{"p":"stats","o":"rt","f":"hp_rt","d":"Density, distribution function, quantile function and random\ngeneration for the t distribution with df degrees of freedom\n(and optional non-centrality parameter ncp).\n","ec":"rt(n, df, ncp)"},{"p":"stats","o":"fft","f":"hp_fft","d":"Computes the Discrete Fourier Transform (DFT) of an array with a fast\nalgorithm, the <U+201C>Fast Fourier Transform<U+201D> (FFT).\n","ec":"fft(z, inverse = FALSE)"},{"p":"stats","o":"dcauchy","f":"hp_dcauchy","d":"Density, distribution function, quantile function and random\ngeneration for the Cauchy distribution with location parameter\nlocation and scale parameter scale.\n","ec":"dcauchy(x, location = 0, scale = 1, log = FALSE)"},{"p":"stats","o":"fivenum","f":"hp_fivenum","d":"Returns Tukey's five number summary (minimum, lower-hinge, median,\nupper-hinge, maximum) for the input data.\n","ec":"fivenum(x, na.rm = TRUE)"},{"p":"stats","o":"toeplitz2","f":"hp_toeplitz2","d":"In its simplest use, toeplitz() forms a symmetric Toeplitz matrix\ngiven its first column (or row).  For the general case, asymmetric and\nnon-square Toeplitz matrices are formed either by specifying the first\ncolumn and row separately,\n","ec":"toeplitz2(x, nrow = length(x) + 1L - ncol, ncol = length(x) + 1L - nrow)"},{"p":"stats","o":"relevel","f":"hp_relevel","d":"The levels of a factor are re-ordered so that the level specified by\nref is first and the others are moved down. This is useful\nfor contr.treatment contrasts which take the first level as\nthe reference.\n","ec":"relevel(x, ref, ...)"},{"p":"stats","o":"summary.glm","f":"hp_summary.glm","d":"These functions are all methods for class glm or\nsummary.glm objects.\n","ec":"summary.glm(object, dispersion = NULL, correlation = FALSE, symbolic.cor = FALSE, ...)"},{"p":"stats","o":"rexp","f":"hp_rexp","d":"Density, distribution function, quantile function and random\ngeneration for the exponential distribution with rate rate\n(i.e., mean 1/rate).\n","ec":"rexp(n, rate = 1)"},{"p":"stats","o":"monthplot","f":"hp_monthplot","d":"These functions plot seasonal (or other) subseries of a time series.\nFor each season (or other category), a time series is plotted.\n","ec":"monthplot(x, ...)"},{"p":"stats","o":"dfbeta","f":"hp_dfbeta","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"dfbeta(model, ...)"},{"p":"stats","o":"diffinv","f":"hp_diffinv","d":"Computes the inverse function of the lagged differences function\ndiff.\n","ec":"diffinv(x, ...)"},{"p":"stats","o":"nobs","f":"hp_nobs","d":"Extract the number of <U+2018>observations<U+2019> from a model fit.  This is\nprincipally intended to be used in computing BIC (see AIC).\n","ec":"nobs(object, ...)"},{"p":"stats","o":"SSmicmen","f":"hp_SSmicmen","d":"This selfStart model evaluates the Michaelis-Menten model and\nits gradient.  It has an initial attribute that\nwill evaluate initial estimates of the parameters Vm and K\n","ec":"SSmicmen(input, Vm, K)"},{"p":"stats","o":"is.ts","f":"hp_is.ts","d":"The function ts is used to create time-series objects.\n","ec":"is.ts(x)"},{"p":"stats","o":"dummy.coef.lm","f":"hp_dummy.coef.lm","d":"This extracts coefficients in terms of the original levels of the\ncoefficients rather than the coded variables.\n","ec":"dummy.coef.lm(object, use.na = FALSE, ...)"},{"p":"stats","o":"hatvalues","f":"hp_hatvalues","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"hatvalues(model, ...)"},{"p":"stats","o":"variable.names","f":"hp_variable.names","d":"Simple utilities returning (non-missing) case names, and\n(non-eliminated) variable names.\n","ec":"variable.names(object, ...)"},{"p":"stats","o":"Pair","f":"hp_Pair","d":"Combines two vectors into an object of class \"Pair\".\n","ec":"Pair(x, y)"},{"p":"stats","o":"model.frame.default","f":"hp_model.frame.default","d":"model.frame (a generic function) and its methods return a\ndata.frame with the variables needed to use\nformula and any ... arguments.\n","ec":"model.frame.default(formula, data = NULL, subset = NULL, na.action, drop.unused.levels = FALSE, xlev = NULL, ...)"},{"p":"stats","o":"anova","f":"hp_anova","d":"Compute analysis of variance (or deviance) tables for one or more\nfitted model objects.\n","ec":"anova(object, ...)"},{"p":"stats","o":"simulate","f":"hp_simulate","d":"Simulate one or more responses from the distribution\ncorresponding to a fitted model object.\n","ec":"simulate(object, nsim = 1, seed = NULL, ...)"},{"p":"stats","o":"dffits","f":"hp_dffits","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"dffits(model, infl = lm.influence(model, do.coef = FALSE), res = weighted.residuals(model))"},{"p":"stats","o":"model.matrix.default","f":"hp_model.matrix.default","d":"model.matrix creates a design (or model) matrix, e.g., by\nexpanding factors to a set of dummy variables (depending on the\ncontrasts) and expanding interactions similarly.\n","ec":"model.matrix.default(object, data = environment(object), contrasts.arg = NULL, xlev = NULL, ...)"},{"p":"stats","o":"contr.SAS","f":"hp_contr.SAS","d":"Return a matrix of contrasts.\n","ec":"contr.SAS(n, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"contr.treatment","f":"hp_contr.treatment","d":"Return a matrix of contrasts.\n","ec":"contr.treatment(n, base = 1, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"predict.lm","f":"hp_predict.lm","d":"Predicted values based on linear model object.\n","ec":"predict.lm(object, newdata, se.fit = FALSE, scale = NULL, df = Inf, interval = c(\"none\", \"confidence\", \"prediction\"), level = 0.95, type = c(\"response\", \"terms\"), terms = NULL, na.action = na.pass, pred.var = res.var/weights, weights = 1, rankdeficient = c(\"warnif\", \"simple\", \"non-estim\", \"NA\", \"NAwarn\"), tol = 1e-06, verbose = FALSE, ...)"},{"p":"stats","o":"prop.trend.test","f":"hp_prop.trend.test","d":"Performs chi-squared test for trend in proportions, i.e., a test\nasymptotically optimal for local alternatives where the log odds vary\nin proportion with score.  By default, score is chosen\nas the group numbers.\n","ec":"prop.trend.test(x, n, score = seq_along(x))"},{"p":"stats","o":"as.dendrogram","f":"hp_as.dendrogram","d":"Class \"dendrogram\" provides general functions for handling\ntree-like structures.  It is intended as a replacement for similar\nfunctions in hierarchical clustering and classification/regression\ntrees, such that all of these can use the same engine for plotting or\ncutting trees.\n","ec":"as.dendrogram(object, ...)"},{"p":"stats","o":"ppois","f":"hp_ppois","d":"Density, distribution function, quantile function and random\ngeneration for the Poisson distribution with parameter lambda.\n","ec":"ppois(q, lambda, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"pcauchy","f":"hp_pcauchy","d":"Density, distribution function, quantile function and random\ngeneration for the Cauchy distribution with location parameter\nlocation and scale parameter scale.\n","ec":"pcauchy(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"smoothEnds","f":"hp_smoothEnds","d":"Smooth end points of a vector y using subsequently smaller\nmedians and Tukey's end point rule at the very end. (of odd span),\n","ec":"smoothEnds(y, k = 3)"},{"p":"stats","o":"qbinom","f":"hp_qbinom","d":"Density, distribution function, quantile function and random\ngeneration for the binomial distribution with parameters size\nand prob.\n","ec":"qbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"hat","f":"hp_hat","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"hat(x, intercept = TRUE)"},{"p":"stats","o":"p.adjust","f":"hp_p.adjust","d":"Given a set of p-values, returns p-values adjusted using\none of several methods.","ec":"p.adjust(p, method = p.adjust.methods, n = length(p))"},{"p":"stats","o":".MFclass","f":"hp_.MFclass","d":".checkMFClasses checks if the variables used in a predict\nmethod agree in type with those used for fitting.\n","ec":".MFclass(x)"},{"p":"stats","o":"dbinom","f":"hp_dbinom","d":"Density, distribution function, quantile function and random\ngeneration for the binomial distribution with parameters size\nand prob.\n","ec":"dbinom(x, size, prob, log = FALSE)"},{"p":"stats","o":"terms.formula","f":"hp_terms.formula","d":"This function takes a formula and some optional arguments and\nconstructs a terms object. The terms object can then be used to\nconstruct a model.matrix.\n","ec":"terms.formula(x, specials = NULL, abb = NULL, data = NULL, neg.out = TRUE, keep.order = FALSE, simplify = FALSE, ..., allowDotAsName = FALSE)"},{"p":"stats","o":"spec.taper","f":"hp_spec.taper","d":"Apply a cosine-bell taper to a time series.\n","ec":"spec.taper(x, p = 0.1)"},{"p":"stats","o":"HoltWinters","f":"hp_HoltWinters","d":"Computes Holt-Winters Filtering of a given time series.\nUnknown parameters are determined by minimizing the squared\nprediction error.\n","ec":"HoltWinters(x, alpha = NULL, beta = NULL, gamma = NULL, seasonal = c(\"additive\", \"multiplicative\"), start.periods = 2, l.start = NULL, b.start = NULL, s.start = NULL, optim.start = c(alpha = 0.3, beta = 0.1, gamma = 0.1), optim.control = list())"},{"p":"stats","o":"ts","f":"hp_ts","d":"The function ts is used to create time-series objects.\n","ec":"ts(data = NA, start = 1, end = numeric(), frequency = 1, deltat = 1, ts.eps = getOption(\"ts.eps\"), class = if (nseries > 1) c(\"mts\", \"ts\", \"matrix\", \"array\") else \"ts\", names = if (!is.null(dimnames(data))) colnames(data) else paste(\"Series\", seq(nseries)))"},{"p":"stats","o":"na.exclude","f":"hp_na.exclude","d":"These generic functions are useful for dealing with NAs\nin e.g., data frames.\nna.fail returns the object if it does not contain any\nmissing values, and signals an error otherwise.\nna.omit returns the object with incomplete cases removed.\nna.pass returns the object unchanged.\n","ec":"na.exclude(object, ...)"},{"p":"stats","o":"dsignrank","f":"hp_dsignrank","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon Signed Rank statistic\nobtained from a sample with size n.\n","ec":"dsignrank(x, n, log = FALSE)"},{"p":"stats","o":"is.tskernel","f":"hp_is.tskernel","d":"The \"tskernel\" class is designed to represent discrete\nsymmetric normalized smoothing kernels.  These kernels can be used to\nsmooth vectors, matrices, or time series objects.\n","ec":"is.tskernel(k)"},{"p":"stats","o":"fitted.values","f":"hp_fitted.values","d":"fitted is a generic function which extracts fitted values from\nobjects returned by modeling functions.  fitted.values is an\nalias for it.\n","ec":"fitted.values(object, ...)"},{"p":"stats","o":"qsignrank","f":"hp_qsignrank","d":"Density, distribution function, quantile function and random\ngeneration for the distribution of the Wilcoxon Signed Rank statistic\nobtained from a sample with size n.\n","ec":"qsignrank(p, n, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"integrate","f":"hp_integrate","d":"Adaptive quadrature of functions of one variable over a finite or\ninfinite interval.\n","ec":"integrate(f, lower, upper, ..., subdivisions = 100L, rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol, stop.on.error = TRUE, keep.xy = FALSE, aux = NULL)"},{"p":"stats","o":"optimise","f":"hp_optimise","d":"The function optimize searches the interval from\nlower to upper for a minimum or maximum of\nthe function f with respect to its first argument.\n","ec":"optimise(f, interval, ..., lower = min(interval), upper = max(interval), maximum = FALSE, tol = .Machine$double.eps^0.25)"},{"p":"stats","o":"binomial","f":"hp_binomial","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"binomial(link = \"logit\")"},{"p":"stats","o":"KalmanSmooth","f":"hp_KalmanSmooth","d":"Use Kalman Filtering to find the (Gaussian) log-likelihood, or for\nforecasting or smoothing.\n","ec":"KalmanSmooth(y, mod, nit = 0L)"},{"p":"stats","o":".vcov.aliased","f":"hp_.vcov.aliased","d":"Returns the variance-covariance matrix of the main parameters of\na fitted model object.  The <U+201C>main<U+201D> parameters of model\ncorrespond to those returned by coef, and typically do\nnot contain a nuisance scale parameter (sigma).\n","ec":".vcov.aliased(aliased, vc, complete = TRUE)"},{"p":"stats","o":"deltat","f":"hp_deltat","d":"time creates the vector of times at which a time series was sampled.\n","ec":"deltat(x, ...)"},{"p":"stats","o":"p.adjust.methods","f":"hp_p.adjust.methods","d":"Given a set of p-values, returns p-values adjusted using\none of several methods.","ec":""},{"p":"stats","o":"SSD","f":"hp_SSD","d":"Functions to compute matrix of residual sums of squares and products,\nor the estimated variance matrix for multivariate linear models.\n","ec":"SSD(object, ...)"},{"p":"stats","o":"summary.lm","f":"hp_summary.lm","d":"summary method for class \"lm\".\n","ec":"summary.lm(object, correlation = FALSE, symbolic.cor = FALSE, ...)"},{"p":"stats","o":"smooth.spline","f":"hp_smooth.spline","d":"Fits a cubic smoothing spline to the supplied data.\n","ec":"smooth.spline(x, y = NULL, w = NULL, df, spar = NULL, lambda = NULL, cv = FALSE, all.knots = FALSE, nknots = .nknots.smspl, keep.data = TRUE, df.offset = 0, penalty = 1, control.spar = list(), tol = 1e-06 * IQR(x), keep.stuff = FALSE)"},{"p":"stats","o":"rstudent","f":"hp_rstudent","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"rstudent(model, ...)"},{"p":"stats","o":"hclust","f":"hp_hclust","d":"Hierarchical cluster analysis on a set of dissimilarities and\nmethods for analyzing it.\n","ec":"hclust(d, method = \"complete\", members = NULL)"},{"p":"stats","o":"density","f":"hp_density","d":"The (S3) generic function density computes kernel density\nestimates.  Its default method does so with the given kernel and\nbandwidth for univariate observations.\n","ec":"density(x, ...)"},{"p":"stats","o":"dgeom","f":"hp_dgeom","d":"Density, distribution function, quantile function and random\ngeneration for the geometric distribution with parameter prob.\n","ec":"dgeom(x, prob, log = FALSE)"},{"p":"stats","o":"terms","f":"hp_terms","d":"The function terms is a generic function\nwhich can be used to extract terms objects\nfrom various kinds of R data objects.\n","ec":"terms(x, ...)"},{"p":"stats","o":"fisher.test","f":"hp_fisher.test","d":"Performs Fisher's exact test for testing the null of independence of\nrows and columns in a contingency table with fixed marginals.\n","ec":"fisher.test(x, y = NULL, workspace = 2e+05, hybrid = FALSE, hybridPars = c(expect = 5, percent = 80, Emin = 1), control = list(), or = 1, alternative = \"two.sided\", conf.int = TRUE, conf.level = 0.95, simulate.p.value = FALSE, B = 2000)"},{"p":"stats","o":"rbinom","f":"hp_rbinom","d":"Density, distribution function, quantile function and random\ngeneration for the binomial distribution with parameters size\nand prob.\n","ec":"rbinom(n, size, prob)"},{"p":"stats","o":"formula","f":"hp_formula","d":"The generic function formula and its specific methods provide a\nway of extracting formulae which have been included in other objects.\n","ec":"formula(x, ...)"},{"p":"stats","o":"nls.control","f":"hp_nls.control","d":"Allow the user to set some characteristics of the nls\nnonlinear least squares algorithm.\n","ec":"nls.control(maxiter = 50, tol = 1e-05, minFactor = 1/1024, printEval = FALSE, warnOnly = FALSE, scaleOffset = 0, nDcentral = FALSE)"},{"p":"stats","o":"isoreg","f":"hp_isoreg","d":"Compute the isotonic (monotonically increasing nonparametric) least\nsquares regression which is piecewise constant.\n","ec":"isoreg(x, y = NULL)"},{"p":"stats","o":"contr.sum","f":"hp_contr.sum","d":"Return a matrix of contrasts.\n","ec":"contr.sum(n, contrasts = TRUE, sparse = FALSE)"},{"p":"stats","o":"uniroot","f":"hp_uniroot","d":"The function uniroot searches the interval from lower\nto upper for a root (i.e., zero) of the function f with\nrespect to its first argument.\n","ec":"uniroot(f, interval, ..., lower = min(interval), upper = max(interval), f.lower = f(lower, ...), f.upper = f(upper, ...), extendInt = c(\"no\", \"yes\", \"downX\", \"upX\"), check.conv = FALSE, tol = .Machine$double.eps^0.25, maxiter = 1000, trace = 0)"},{"p":"stats","o":"quasibinomial","f":"hp_quasibinomial","d":"Family objects provide a convenient way to specify the details of the\nmodels used by functions such as glm.  See the\ndocumentation for glm for the details on how such model\nfitting takes place.\n","ec":"quasibinomial(link = \"logit\")"},{"p":"stats","o":"dunif","f":"hp_dunif","d":"These functions provide information about the uniform distribution\non the interval from min to max.  dunif gives the\ndensity, punif gives the distribution function qunif\ngives the quantile function and runif generates random\ndeviates.\n","ec":"dunif(x, min = 0, max = 1, log = FALSE)"},{"p":"stats","o":"influence.measures","f":"hp_influence.measures","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"influence.measures(model, infl = influence(model))"},{"p":"stats","o":"na.contiguous","f":"hp_na.contiguous","d":"Find the longest consecutive stretch of non-missing values in a time\nseries object.  (In the event of a tie, the first such stretch.)\n","ec":"na.contiguous(object, ...)"},{"p":"stats","o":"dfbetas","f":"hp_dfbetas","d":"This suite of functions can be used to compute some of the regression\n(leave-one-out deletion) diagnostics for linear and generalized linear\nmodels discussed in Belsley, Kuh and Welsch (1980),\nCook and Weisberg (1982), etc.\n","ec":"dfbetas(model, ...)"},{"p":"stats","o":"pairwise.prop.test","f":"hp_pairwise.prop.test","d":"Calculate pairwise comparisons between pairs of proportions with\ncorrection for multiple testing\n","ec":"pairwise.prop.test(x, n, p.adjust.method = p.adjust.methods, ...)"},{"p":"stats","o":"rnbinom","f":"hp_rnbinom","d":"Density, distribution function, quantile function and random\ngeneration for the negative binomial distribution with parameters\nsize and prob.\n","ec":"rnbinom(n, size, prob, mu)"},{"p":"stats","o":"pnorm","f":"hp_pnorm","d":"Density, distribution function, quantile function and random\ngeneration for the normal distribution with mean equal to mean\nand standard deviation equal to sd.\n","ec":"pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"rbeta","f":"hp_rbeta","d":"Density, distribution function, quantile function and random\ngeneration for the Beta distribution with parameters shape1 and\nshape2 (and optional non-centrality parameter ncp).\n","ec":"rbeta(n, shape1, shape2, ncp = 0)"},{"p":"stats","o":"cpgram","f":"hp_cpgram","d":"Plots a cumulative periodogram.\n","ec":"cpgram(ts, taper = 0.1, main = paste(\"Series: \", deparse1(substitute(ts))), ci.col = \"blue\")"},{"p":"stats","o":"knots","f":"hp_knots","d":"Given the vectors (x_1, \\ldots, x_n) and\n(y_0,y_1,\\ldots, y_n) (one value\nmore!), stepfun(x, y, ...) returns an interpolating\n<U+2018>step<U+2019> function, say fn. I.e., fn(t) =\n    c_i (constant) for t \\in (x_i, x_{i+1}) and at the abscissa values, if (by default)\nright = FALSE, fn(x_i) = y_i and for\nright = TRUE, fn(x_i) = y_{i-1}, for\ni=1,\\ldots,n.\n","ec":"knots(Fn, ...)"},{"p":"stats","o":"biplot","f":"hp_biplot","d":"Plot a biplot on the current graphics device.\n","ec":"biplot(x, ...)"},{"p":"stats","o":"runmed","f":"hp_runmed","d":"Compute running medians of odd span.  This is the <U+2018>most robust<U+2019>\nscatter plot smoothing possible.  For efficiency (and historical\nreason), you can use one of two different algorithms giving identical\nresults.\n","ec":"runmed(x, k, endrule = c(\"median\", \"keep\", \"constant\"), algorithm = NULL, na.action = c(\"+Big_alternate\", \"-Big_alternate\", \"na.omit\", \"fail\"), print.level = 0)"},{"p":"stats","o":"mad","f":"hp_mad","d":"Compute the median absolute deviation, i.e., the (lo-/hi-) median of\nthe absolute deviations from the median, and (by default) adjust by a\nfactor for asymptotically normal consistency.\n","ec":"mad(x, center = median(x), constant = 1.4826, na.rm = FALSE, low = FALSE, high = FALSE)"},{"p":"stats","o":"delete.response","f":"hp_delete.response","d":"delete.response returns a terms object for the same\nmodel but with no response variable.\n","ec":"delete.response(termobj)"},{"p":"stats","o":"plogis","f":"hp_plogis","d":"Density, distribution function, quantile function and random\ngeneration for the logistic distribution with parameters\nlocation and scale.\n","ec":"plogis(q, location = 0, scale = 1, lower.tail = TRUE, log.p = FALSE)"},{"p":"stats","o":"read.ftable","f":"hp_read.ftable","d":"Read, write and coerce <U+2018>flat<U+2019> (contingency) tables, aka\nftables.\n","ec":"read.ftable(file, sep = \"\", quote = \"\\\"\", row.var.names, col.vars, skip = 0)"},{"p":"stats","o":"aov","f":"hp_aov","d":"Fit an analysis of variance model by a call to lm (for each\nstratum if an Error(.) is used).\n","ec":"aov(formula, data = NULL, projections = FALSE, qr = TRUE, contrasts = NULL, ...)"},{"p":"stats","o":"update","f":"hp_update","d":"update will update and (by default) re-fit a model.  It does this\nby extracting the call stored in the object, updating the call and (by\ndefault) evaluating that call.  Sometimes it is useful to call\nupdate with only one argument, for example if the data frame has\nbeen corrected.\n","ec":"update(object, ...)"},{"p":"stats","o":"StructTS","f":"hp_StructTS","d":"Fit a structural model for a time series by maximum likelihood.\n","ec":"StructTS(x, type = c(\"level\", \"trend\", \"BSM\"), init = NULL, fixed = NULL, optim.control = NULL)"},{"p":"stats4","o":"BIC","f":"hp_BIC","d":"-NA-","ec":"BIC(object, ...)"},{"p":"stats4","o":".__T__logLik:stats","f":"hp_.__T__logLik.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__T__vcov:stats","f":"hp_.__T__vcov.stats","d":"-NA-","ec":""},{"p":"stats4","o":"nobs","f":"hp_nobs","d":"-NA-","ec":"nobs(object, ...)"},{"p":"stats4","o":"profile","f":"hp_profile","d":"-NA-","ec":"profile(fitted, ...)"},{"p":"stats4","o":"summary","f":"hp_summary","d":"-NA-","ec":"summary(object, ...)"},{"p":"stats4","o":".__T__plot:base","f":"hp_.__T__plot.base","d":"-NA-","ec":""},{"p":"stats4","o":"plot","f":"hp_plot","d":"-NA-","ec":"plot(x, y, ...)"},{"p":"stats4","o":"update","f":"hp_update","d":"-NA-","ec":"update(object, ...)"},{"p":"stats4","o":".__T__nobs:stats","f":"hp_.__T__nobs.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__C__mle","f":"hp_.__C__mle","d":"-NA-","ec":""},{"p":"stats4","o":".__T__BIC:stats","f":"hp_.__T__BIC.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__C__profile.mle","f":"hp_.__C__profile.mle","d":"-NA-","ec":""},{"p":"stats4","o":".__T__coef:stats","f":"hp_.__T__coef.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__T__summary:base","f":"hp_.__T__summary.base","d":"-NA-","ec":""},{"p":"stats4","o":"mle","f":"hp_mle","d":"Estimate parameters by the method of maximum likelihood.\n","ec":"mle(minuslogl, start, optim = stats::optim, method = if (!useLim) \"BFGS\" else \"L-BFGS-B\", fixed = list(), nobs, lower, upper, ...)"},{"p":"stats4","o":".__T__update:stats","f":"hp_.__T__update.stats","d":"-NA-","ec":""},{"p":"stats4","o":"logLik","f":"hp_logLik","d":"-NA-","ec":"logLik(object, ...)"},{"p":"stats4","o":"vcov","f":"hp_vcov","d":"-NA-","ec":"vcov(object, ...)"},{"p":"stats4","o":"AIC","f":"hp_AIC","d":"-NA-","ec":"AIC(object, ..., k = 2)"},{"p":"stats4","o":"coef","f":"hp_coef","d":"-NA-","ec":"coef(object, ...)"},{"p":"stats4","o":"confint","f":"hp_confint","d":"-NA-","ec":"confint(object, parm, level = 0.95, ...)"},{"p":"stats4","o":".__T__show:methods","f":"hp_.__T__show.methods","d":"-NA-","ec":""},{"p":"stats4","o":".__T__confint:stats","f":"hp_.__T__confint.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__T__profile:stats","f":"hp_.__T__profile.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__T__AIC:stats","f":"hp_.__T__AIC.stats","d":"-NA-","ec":""},{"p":"stats4","o":".__C__summary.mle","f":"hp_.__C__summary.mle","d":"-NA-","ec":""},{"p":"stringi","o":"stri_startswith","f":"hp_stri_startswith","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_startswith(str, ..., fixed, coll, charclass)"},{"p":"stringi","o":"stri_locate_first","f":"hp_stri_locate_first","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_first(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"%s==%","f":"hp_X.s...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s==%(e1, e2)"},{"p":"stringi","o":"stri_subset_regex","f":"hp_stri_subset_regex","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_regex(str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_locate_all_boundaries","f":"hp_stri_locate_all_boundaries","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_all_boundaries(str, omit_no_match = FALSE, get_length = FALSE, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_width","f":"hp_stri_width","d":"Approximates the number of text columns the 'cat()' function\nmight use to print a string using a mono-spaced font.\n","ec":"stri_width(str)"},{"p":"stringi","o":"stri_datetime_add<-","f":"hp_stri_datetime_add..","d":"Modifies a date-time object by adding a specific amount of time units.\n","ec":"stri_datetime_add<-(time, units = \"seconds\", tz = NULL, locale = NULL, value)"},{"p":"stringi","o":"stri_datetime_parse","f":"hp_stri_datetime_parse","d":"These functions convert a given date/time object\nto a character vector, or vice versa.\n","ec":"stri_datetime_parse(str, format = \"uuuu-MM-dd HH:mm:ss\", lenient = FALSE, tz = NULL, locale = NULL)"},{"p":"stringi","o":"stri_join_list","f":"hp_stri_join_list","d":"These functions concatenate all the strings in each character vector\nin a given list.\nstri_c_list and stri_paste_list are aliases for\nstri_join_list.\n","ec":"stri_join_list(x, sep = \"\", collapse = NULL)"},{"p":"stringi","o":"stri_extract_all_regex","f":"hp_stri_extract_all_regex","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_all_regex(str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_extract_first_fixed","f":"hp_stri_extract_first_fixed","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_first_fixed(str, pattern, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_detect_regex","f":"hp_stri_detect_regex","d":"These functions determine, for each string in str,\nif there is at least one match to a corresponding pattern.\n","ec":"stri_detect_regex(str, pattern, negate = FALSE, max_count = -1, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_trim_right","f":"hp_stri_trim_right","d":"These functions may be used, e.g., to remove unnecessary\nwhite-spaces from strings. Trimming ends at the first or\nstarts at the last pattern match.\n","ec":"stri_trim_right(str, pattern = \"\\\\P{Wspace}\", negate = FALSE)"},{"p":"stringi","o":"stri_order","f":"hp_stri_order","d":"This function finds a permutation which rearranges the\nstrings in a given character vector into the ascending or descending\nlocale-dependent lexicographic order.\n","ec":"stri_order(str, decreasing = FALSE, na_last = TRUE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_locale_info","f":"hp_stri_locale_info","d":"Provides some basic information on a given locale identifier.\n","ec":"stri_locale_info(locale = NULL)"},{"p":"stringi","o":"stri_extract_last_charclass","f":"hp_stri_extract_last_charclass","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_last_charclass(str, pattern)"},{"p":"stringi","o":"stri_datetime_add","f":"hp_stri_datetime_add","d":"Modifies a date-time object by adding a specific amount of time units.\n","ec":"stri_datetime_add(time, value = 1L, units = \"seconds\", tz = NULL, locale = NULL)"},{"p":"stringi","o":"%s<%","f":"hp_X.s..","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s<%(e1, e2)"},{"p":"stringi","o":"stri_trans_isnfkc","f":"hp_stri_trans_isnfkc","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_isnfkc(str)"},{"p":"stringi","o":"stri_subset_fixed","f":"hp_stri_subset_fixed","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_fixed(str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_trans_isnfkd","f":"hp_stri_trans_isnfkd","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_isnfkd(str)"},{"p":"stringi","o":"stri_extract_last_coll","f":"hp_stri_extract_last_coll","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_last_coll(str, pattern, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_replace_first_regex","f":"hp_stri_replace_first_regex","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_first_regex(str, pattern, replacement, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_reverse","f":"hp_stri_reverse","d":"Reverses the order of the code points in every string.\n","ec":"stri_reverse(str)"},{"p":"stringi","o":"stri_enc_fromutf32","f":"hp_stri_enc_fromutf32","d":"This function converts integer vectors,\nrepresenting sequences of UTF-32 code points, to UTF-8 strings.\n","ec":"stri_enc_fromutf32(vec)"},{"p":"stringi","o":"stri_opts_fixed","f":"hp_stri_opts_fixed","d":"A convenience function used to tune up the behavior of stri_*_fixed\nfunctions, see stringi-search-fixed.\n","ec":"stri_opts_fixed(case_insensitive = FALSE, overlap = FALSE)"},{"p":"stringi","o":"stri_datetime_fields","f":"hp_stri_datetime_fields","d":"Computes and returns values for all date and time fields.\n","ec":"stri_datetime_fields(time, tz = attr(time, \"tzone\"), locale = NULL)"},{"p":"stringi","o":"%s>=%","f":"hp_X.s...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s>=%(e1, e2)"},{"p":"stringi","o":"stri_locate_first_boundaries","f":"hp_stri_locate_first_boundaries","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_first_boundaries(str, get_length = FALSE, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_enc_toascii","f":"hp_stri_enc_toascii","d":"This function converts input strings to ASCII,\ni.e., to character strings consisting of bytes not greater than 127.\n","ec":"stri_enc_toascii(str)"},{"p":"stringi","o":"stri_locate_all_fixed","f":"hp_stri_locate_all_fixed","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_all_fixed(str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_trans_toupper","f":"hp_stri_trans_toupper","d":"These functions transform strings either to lower case,\nUPPER CASE, or Title Case or perform case folding.\n","ec":"stri_trans_toupper(str, locale = NULL)"},{"p":"stringi","o":"stri_sub_all<-","f":"hp_stri_sub_all..","d":"stri_sub_all extracts multiple substrings from each string.\nIts replacement version substitutes (in-place) multiple substrings with the\ncorresponding replacement strings.\nstri_sub_replace_all (alias stri_sub_all_replace)\nis its forward pipe operator-friendly variant, returning\na copy of the input vector.\n","ec":"stri_sub_all<-(str, from = list(1L), to = list(-1L), length, omit_na = FALSE, use_matrix = TRUE, value)"},{"p":"stringi","o":"stri_sort_key","f":"hp_stri_sort_key","d":"This function computes a locale-dependent sort key, which is an alternative\ncharacter representation of the string that, when ordered in the C locale\n(which orders using the underlying bytes directly), will give an equivalent\nordering to the original string. It is useful for enhancing algorithms\nthat sort only in the C locale (e.g., the strcmp function in libc)\nwith the ability to be locale-aware.\n","ec":"stri_sort_key(str, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_locate_first_words","f":"hp_stri_locate_first_words","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_first_words(str, locale = NULL, get_length = FALSE)"},{"p":"stringi","o":"%stri!=%","f":"hp_X.stri...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri!=%(e1, e2)"},{"p":"stringi","o":"stri_info","f":"hp_stri_info","d":"Gives the current default settings used by the ICU library.\n","ec":"stri_info(short = FALSE)"},{"p":"stringi","o":"stri_replace_last_charclass","f":"hp_stri_replace_last_charclass","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_last_charclass(str, pattern, replacement)"},{"p":"stringi","o":"stri_enc_isutf16le","f":"hp_stri_enc_isutf16le","d":"These functions detect whether a given byte stream is\nvalid UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE.\n","ec":"stri_enc_isutf16le(str)"},{"p":"stringi","o":"stri_length","f":"hp_stri_length","d":"This function returns the number of code points\nin each string.\n","ec":"stri_length(str)"},{"p":"stringi","o":"stri_replace_first_coll","f":"hp_stri_replace_first_coll","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_first_coll(str, pattern, replacement, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_extract_last_boundaries","f":"hp_stri_extract_last_boundaries","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_last_boundaries(str, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_split_lines1","f":"hp_stri_split_lines1","d":"These functions split each character string in a given vector\ninto text lines.\n","ec":"stri_split_lines1(str)"},{"p":"stringi","o":"stri_trans_nfkc_casefold","f":"hp_stri_trans_nfkc_casefold","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_nfkc_casefold(str)"},{"p":"stringi","o":"stri_trans_tolower","f":"hp_stri_trans_tolower","d":"These functions transform strings either to lower case,\nUPPER CASE, or Title Case or perform case folding.\n","ec":"stri_trans_tolower(str, locale = NULL)"},{"p":"stringi","o":"stri_na2empty","f":"hp_stri_na2empty","d":"This function replaces all missing values with empty strings.\nSee stri_replace_na for a generalization.\n","ec":"stri_na2empty(x)"},{"p":"stringi","o":"stri_sub<-","f":"hp_stri_sub..","d":"stri_sub extracts particular substrings at code point-based\nindex ranges provided. Its replacement version allows to substitute\n(in-place) parts of\na string with given replacement strings. stri_sub_replace\nis its forward pipe operator-friendly variant that returns\na copy of the input vector.\n","ec":"stri_sub<-(str, from = 1L, to = -1L, length, omit_na = FALSE, use_matrix = TRUE, value)"},{"p":"stringi","o":"stri_read_lines","f":"hp_stri_read_lines","d":"Reads a text file in ins entirety, re-encodes it, and splits it into text lines.\n","ec":"stri_read_lines(con, encoding = NULL, fname = con)"},{"p":"stringi","o":"stri_detect","f":"hp_stri_detect","d":"These functions determine, for each string in str,\nif there is at least one match to a corresponding pattern.\n","ec":"stri_detect(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_locate_last_coll","f":"hp_stri_locate_last_coll","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_last_coll(str, pattern, get_length = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_trans_casefold","f":"hp_stri_trans_casefold","d":"These functions transform strings either to lower case,\nUPPER CASE, or Title Case or perform case folding.\n","ec":"stri_trans_casefold(str)"},{"p":"stringi","o":"stri_split_fixed","f":"hp_stri_split_fixed","d":"These functions split each element in str into substrings.\npattern defines the delimiters that separate the inputs into tokens.\nThe input data between the matches become the fields themselves.\n","ec":"stri_split_fixed(str, pattern, n = -1L, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"%s>%","f":"hp_X.s..","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s>%(e1, e2)"},{"p":"stringi","o":"stri_extract_all_words","f":"hp_stri_extract_all_words","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_all_words(str, simplify = FALSE, omit_no_match = FALSE, locale = NULL)"},{"p":"stringi","o":"stri_rand_strings","f":"hp_stri_rand_strings","d":"Generates (pseudo)random strings of desired lengths.\n","ec":"stri_rand_strings(n, length, pattern = \"[A-Za-z0-9]\")"},{"p":"stringi","o":"stri_trans_isnfc","f":"hp_stri_trans_isnfc","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_isnfc(str)"},{"p":"stringi","o":"stri_endswith_fixed","f":"hp_stri_endswith_fixed","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_endswith_fixed(str, pattern, to = -1L, negate = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_trans_isnfd","f":"hp_stri_trans_isnfd","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_isnfd(str)"},{"p":"stringi","o":"stri_split_coll","f":"hp_stri_split_coll","d":"These functions split each element in str into substrings.\npattern defines the delimiters that separate the inputs into tokens.\nThe input data between the matches become the fields themselves.\n","ec":"stri_split_coll(str, pattern, n = -1L, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_locate_all_charclass","f":"hp_stri_locate_all_charclass","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_all_charclass(str, pattern, merge = TRUE, omit_no_match = FALSE, get_length = FALSE)"},{"p":"stringi","o":"%s!=%","f":"hp_X.s...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s!=%(e1, e2)"},{"p":"stringi","o":"stri_c","f":"hp_stri_c","d":"These are the stringi's equivalents of the built-in\npaste function.\nstri_c and stri_paste are aliases for stri_join.\n","ec":"stri_c(..., sep = \"\", collapse = NULL, ignore_null = FALSE)"},{"p":"stringi","o":"stri_subset<-","f":"hp_stri_subset..","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset<-(str, ..., regex, fixed, coll, charclass, value)"},{"p":"stringi","o":"stri_locate_first_coll","f":"hp_stri_locate_first_coll","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_first_coll(str, pattern, get_length = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_locate_first_charclass","f":"hp_stri_locate_first_charclass","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_first_charclass(str, pattern, get_length = FALSE)"},{"p":"stringi","o":"stri_conv","f":"hp_stri_conv","d":"These functions convert strings between encodings.\nThey aim to serve as a more portable and faster replacement\nfor R's own iconv.\n","ec":"stri_conv(str, from = NULL, to = NULL, to_raw = FALSE)"},{"p":"stringi","o":"stri_sub_replace_all","f":"hp_stri_sub_replace_all","d":"stri_sub_all extracts multiple substrings from each string.\nIts replacement version substitutes (in-place) multiple substrings with the\ncorresponding replacement strings.\nstri_sub_replace_all (alias stri_sub_all_replace)\nis its forward pipe operator-friendly variant, returning\na copy of the input vector.\n","ec":"stri_sub_replace_all(..., replacement, value = replacement)"},{"p":"stringi","o":"stri_enc_list","f":"hp_stri_enc_list","d":"Gives the list of encodings that are supported by ICU.\n","ec":"stri_enc_list(simplify = TRUE)"},{"p":"stringi","o":"stri_string_format","f":"hp_stri_string_format","d":"stri_sprintf (synonym: stri_string_format)\nis a Unicode-aware replacement for and enhancement of\nthe built-in sprintf function.\nMoreover, stri_printf prints formatted strings.\n","ec":"stri_string_format(format, ..., na_string = NA_character_, inf_string = \"Inf\", nan_string = \"NaN\", use_length = FALSE)"},{"p":"stringi","o":"stri_sub_replace","f":"hp_stri_sub_replace","d":"stri_sub extracts particular substrings at code point-based\nindex ranges provided. Its replacement version allows to substitute\n(in-place) parts of\na string with given replacement strings. stri_sub_replace\nis its forward pipe operator-friendly variant that returns\na copy of the input vector.\n","ec":"stri_sub_replace(..., replacement, value = replacement)"},{"p":"stringi","o":"stri_pad_left","f":"hp_stri_pad_left","d":"Add multiple pad characters at the given side(s) of each string\nso that each output string is of total width of at least width.\nThese functions may be used to center or left/right-align each string.\n","ec":"stri_pad_left(str, width = floor(0.9 * getOption(\"width\")), pad = \" \", use_length = FALSE)"},{"p":"stringi","o":"stri_locate_all_coll","f":"hp_stri_locate_all_coll","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_all_coll(str, pattern, omit_no_match = FALSE, get_length = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_subset_regex<-","f":"hp_stri_subset_regex..","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_regex<-(str, pattern, negate = FALSE, ..., opts_regex = NULL, value)"},{"p":"stringi","o":"stri_detect_fixed","f":"hp_stri_detect_fixed","d":"These functions determine, for each string in str,\nif there is at least one match to a corresponding pattern.\n","ec":"stri_detect_fixed(str, pattern, negate = FALSE, max_count = -1, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_unique","f":"hp_stri_unique","d":"This function returns a character vector like str,\nbut with duplicate elements removed.\n","ec":"stri_unique(str, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_omit_na","f":"hp_stri_omit_na","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_omit_na(x)"},{"p":"stringi","o":"stri_locale_list","f":"hp_stri_locale_list","d":"Creates a character vector with all available locale identifies.\n","ec":"stri_locale_list()"},{"p":"stringi","o":"stri_trans_isnfkc_casefold","f":"hp_stri_trans_isnfkc_casefold","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_isnfkc_casefold(str)"},{"p":"stringi","o":"stri_locate_last_regex","f":"hp_stri_locate_last_regex","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_last_regex(str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_escape_unicode","f":"hp_stri_escape_unicode","d":"Generates an ASCII string where all non-printable characters\nand non-ASCII characters are converted to escape sequences.\n","ec":"stri_escape_unicode(str)"},{"p":"stringi","o":"stri_duplicated","f":"hp_stri_duplicated","d":"stri_duplicated() determines which strings in a character vector\nare duplicates of other elements.\n","ec":"stri_duplicated(str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_sort","f":"hp_stri_sort","d":"This function sorts a character vector according to a locale-dependent\nlexicographic order.\n","ec":"stri_sort(str, decreasing = FALSE, na_last = NA, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_split_lines","f":"hp_stri_split_lines","d":"These functions split each character string in a given vector\ninto text lines.\n","ec":"stri_split_lines(str, omit_empty = FALSE)"},{"p":"stringi","o":"stri_flatten","f":"hp_stri_flatten","d":"Joins the elements of a character vector into one string.\n","ec":"stri_flatten(str, collapse = \"\", na_empty = FALSE, omit_empty = FALSE)"},{"p":"stringi","o":"stri_extract_last_regex","f":"hp_stri_extract_last_regex","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_last_regex(str, pattern, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_subset_coll","f":"hp_stri_subset_coll","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_coll(str, pattern, omit_na = FALSE, negate = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_subset","f":"hp_stri_subset","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_datetime_format","f":"hp_stri_datetime_format","d":"These functions convert a given date/time object\nto a character vector, or vice versa.\n","ec":"stri_datetime_format(time, format = \"uuuu-MM-dd HH:mm:ss\", tz = NULL, locale = NULL)"},{"p":"stringi","o":"stri_replace_last_regex","f":"hp_stri_replace_last_regex","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_last_regex(str, pattern, replacement, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_split_boundaries","f":"hp_stri_split_boundaries","d":"This function locates text boundaries\n(like character, word, line, or sentence boundaries)\nand splits strings at the indicated positions.\n","ec":"stri_split_boundaries(str, n = -1L, tokens_only = FALSE, simplify = FALSE, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_extract_all_coll","f":"hp_stri_extract_all_coll","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_all_coll(str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_trans_nfc","f":"hp_stri_trans_nfc","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_nfc(str)"},{"p":"stringi","o":"stri_trans_nfd","f":"hp_stri_trans_nfd","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_nfd(str)"},{"p":"stringi","o":"stri_cmp_equiv","f":"hp_stri_cmp_equiv","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_equiv(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_endswith","f":"hp_stri_endswith","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_endswith(str, ..., fixed, coll, charclass)"},{"p":"stringi","o":"stri_replace_first","f":"hp_stri_replace_first","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_first(str, replacement, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_split_regex","f":"hp_stri_split_regex","d":"These functions split each element in str into substrings.\npattern defines the delimiters that separate the inputs into tokens.\nThe input data between the matches become the fields themselves.\n","ec":"stri_split_regex(str, pattern, n = -1L, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_locate_last_charclass","f":"hp_stri_locate_last_charclass","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_last_charclass(str, pattern, get_length = FALSE)"},{"p":"stringi","o":"stri_count_boundaries","f":"hp_stri_count_boundaries","d":"These functions determine the number of text boundaries\n(like character, word, line, or sentence boundaries) in a string.\n","ec":"stri_count_boundaries(str, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_endswith_coll","f":"hp_stri_endswith_coll","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_endswith_coll(str, pattern, to = -1L, negate = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_endswith_charclass","f":"hp_stri_endswith_charclass","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_endswith_charclass(str, pattern, to = -1L, negate = FALSE)"},{"p":"stringi","o":"stri_sprintf","f":"hp_stri_sprintf","d":"stri_sprintf (synonym: stri_string_format)\nis a Unicode-aware replacement for and enhancement of\nthe built-in sprintf function.\nMoreover, stri_printf prints formatted strings.\n","ec":"stri_sprintf(format, ..., na_string = NA_character_, inf_string = \"Inf\", nan_string = \"NaN\", use_length = FALSE)"},{"p":"stringi","o":"stri_enc_isutf32le","f":"hp_stri_enc_isutf32le","d":"These functions detect whether a given byte stream is\nvalid UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE.\n","ec":"stri_enc_isutf32le(str)"},{"p":"stringi","o":"stri_detect_coll","f":"hp_stri_detect_coll","d":"These functions determine, for each string in str,\nif there is at least one match to a corresponding pattern.\n","ec":"stri_detect_coll(str, pattern, negate = FALSE, max_count = -1, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_remove_na","f":"hp_stri_remove_na","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_remove_na(x)"},{"p":"stringi","o":"stri_locate_all_words","f":"hp_stri_locate_all_words","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_all_words(str, omit_no_match = FALSE, locale = NULL, get_length = FALSE)"},{"p":"stringi","o":"stri_locale_set","f":"hp_stri_locale_set","d":"stri_locale_set changes the default locale for all the functions\nin the stringi package,\ni.e., establishes the meaning of the <U+201C>NULL locale<U+201D> argument\nof locale-sensitive functions.\nstri_locale_get\ngives the current default locale.\n","ec":"stri_locale_set(locale)"},{"p":"stringi","o":"stri_printf","f":"hp_stri_printf","d":"stri_sprintf (synonym: stri_string_format)\nis a Unicode-aware replacement for and enhancement of\nthe built-in sprintf function.\nMoreover, stri_printf prints formatted strings.\n","ec":"stri_printf(format, ..., file = \"\", sep = \"\\n\", append = FALSE, na_string = \"NA\", inf_string = \"Inf\", nan_string = \"NaN\", use_length = FALSE)"},{"p":"stringi","o":"%stri<=%","f":"hp_X.stri...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri<=%(e1, e2)"},{"p":"stringi","o":"stri_cmp","f":"hp_stri_cmp","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_rank","f":"hp_stri_rank","d":"This function ranks each string in a character vector according to a\nlocale-dependent lexicographic order.\nIt is a portable replacement for the base xtfrm function.\n","ec":"stri_rank(str, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_replace_na","f":"hp_stri_replace_na","d":"This function gives a convenient way to replace each missing (NA)\nvalue with a given string.\n","ec":"stri_replace_na(str, replacement = \"NA\")"},{"p":"stringi","o":"%s$%","f":"hp_X.s..","d":"Provides access to stri_sprintf in form of a binary\noperator in a way similar to Python's % overloaded for strings.\n","ec":"%s$%(e1, e2)"},{"p":"stringi","o":"stri_count_coll","f":"hp_stri_count_coll","d":"These functions count the number of occurrences\nof a pattern in a string.\n","ec":"stri_count_coll(str, pattern, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_count_words","f":"hp_stri_count_words","d":"These functions determine the number of text boundaries\n(like character, word, line, or sentence boundaries) in a string.\n","ec":"stri_count_words(str, locale = NULL)"},{"p":"stringi","o":"stri_sub_all","f":"hp_stri_sub_all","d":"stri_sub_all extracts multiple substrings from each string.\nIts replacement version substitutes (in-place) multiple substrings with the\ncorresponding replacement strings.\nstri_sub_replace_all (alias stri_sub_all_replace)\nis its forward pipe operator-friendly variant, returning\na copy of the input vector.\n","ec":"stri_sub_all(str, from = list(1L), to = list(-1L), length, use_matrix = TRUE, ignore_negative_length = TRUE)"},{"p":"stringi","o":"stri_extract_all","f":"hp_stri_extract_all","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_all(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_numbytes","f":"hp_stri_numbytes","d":"Counts the number of bytes needed to store\neach string in the computer's memory.\n","ec":"stri_numbytes(str)"},{"p":"stringi","o":"stri_enc_detect","f":"hp_stri_enc_detect","d":"This function uses the ICU engine to determine the character set,\nor encoding, of character data in an unknown format.\n","ec":"stri_enc_detect(str, filter_angle_brackets = FALSE)"},{"p":"stringi","o":"stri_datetime_symbols","f":"hp_stri_datetime_symbols","d":"Returns a list of all localizable date-time formatting data,\nincluding month and weekday names, localized AM/PM strings, etc.\n","ec":"stri_datetime_symbols(locale = NULL, context = \"standalone\", width = \"wide\")"},{"p":"stringi","o":"stri_isempty","f":"hp_stri_isempty","d":"This is the fastest way to find out\nwhether the elements of a character vector are empty strings.\n","ec":"stri_isempty(str)"},{"p":"stringi","o":"stri_replace_first_fixed","f":"hp_stri_replace_first_fixed","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_first_fixed(str, pattern, replacement, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_count_fixed","f":"hp_stri_count_fixed","d":"These functions count the number of occurrences\nof a pattern in a string.\n","ec":"stri_count_fixed(str, pattern, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_rand_lipsum","f":"hp_stri_rand_lipsum","d":"Generates (pseudo)random lorem ipsum text consisting\nof a given number of text paragraphs.\n","ec":"stri_rand_lipsum(n_paragraphs, start_lipsum = TRUE, nparagraphs = n_paragraphs)"},{"p":"stringi","o":"stri_trans_nfkc","f":"hp_stri_trans_nfkc","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_nfkc(str)"},{"p":"stringi","o":"stri_trans_nfkd","f":"hp_stri_trans_nfkd","d":"These functions convert strings to NFC, NFKC, NFD, NFKD, or NFKC_Casefold\nUnicode Normalization Form or check whether strings are normalized.\n","ec":"stri_trans_nfkd(str)"},{"p":"stringi","o":"stri_replace_all_coll","f":"hp_stri_replace_all_coll","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_all_coll(str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_encode","f":"hp_stri_encode","d":"These functions convert strings between encodings.\nThey aim to serve as a more portable and faster replacement\nfor R's own iconv.\n","ec":"stri_encode(str, from = NULL, to = NULL, to_raw = FALSE)"},{"p":"stringi","o":"stri_replace_rstr","f":"hp_stri_replace_rstr","d":"Converts a gsub-style replacement strings\nto those which can be used in stri_replace.\nIn particular, $ becomes \\$ and \\1 becomes $1.\n","ec":"stri_replace_rstr(x)"},{"p":"stringi","o":"stri_match_last","f":"hp_stri_match_last","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_last(str, ..., regex)"},{"p":"stringi","o":"%stri<%","f":"hp_X.stri..","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri<%(e1, e2)"},{"p":"stringi","o":"stri_duplicated_any","f":"hp_stri_duplicated_any","d":"stri_duplicated() determines which strings in a character vector\nare duplicates of other elements.\n","ec":"stri_duplicated_any(str, from_last = FALSE, fromLast = from_last, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_timezone_info","f":"hp_stri_timezone_info","d":"Provides some basic information on a given time zone identifier.\n","ec":"stri_timezone_info(tz = NULL, locale = NULL, display_type = \"long\")"},{"p":"stringi","o":"stri_match_first_regex","f":"hp_stri_match_first_regex","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_first_regex(str, pattern, cg_missing = NA_character_, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_match_all","f":"hp_stri_match_all","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_all(str, ..., regex)"},{"p":"stringi","o":"stri_extract_first_charclass","f":"hp_stri_extract_first_charclass","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_first_charclass(str, pattern)"},{"p":"stringi","o":"stri_extract_first_boundaries","f":"hp_stri_extract_first_boundaries","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_first_boundaries(str, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_enc_tonative","f":"hp_stri_enc_tonative","d":"Converts character strings with declared encodings\nto the current native encoding.\n","ec":"stri_enc_tonative(str)"},{"p":"stringi","o":"stri_startswith_fixed","f":"hp_stri_startswith_fixed","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_startswith_fixed(str, pattern, from = 1L, negate = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_pad","f":"hp_stri_pad","d":"Add multiple pad characters at the given side(s) of each string\nso that each output string is of total width of at least width.\nThese functions may be used to center or left/right-align each string.\n","ec":"stri_pad(str, width = floor(0.9 * getOption(\"width\")), side = c(\"left\", \"right\", \"both\"), pad = \" \", use_length = FALSE)"},{"p":"stringi","o":"%stri*%","f":"hp_X.stri..","d":"Duplicates each str(e1) string times(e2) times\nand concatenates the results.\n","ec":"%stri*%(e1, e2)"},{"p":"stringi","o":"stri_dup","f":"hp_stri_dup","d":"Duplicates each str(e1) string times(e2) times\nand concatenates the results.\n","ec":"stri_dup(str, times)"},{"p":"stringi","o":"stri_opts_brkiter","f":"hp_stri_opts_brkiter","d":"A convenience function to tune the ICU BreakIterator's behavior\nin some text boundary analysis functions, see\nstringi-search-boundaries.\n","ec":"stri_opts_brkiter(type, locale, skip_word_none, skip_word_number, skip_word_letter, skip_word_kana, skip_word_ideo, skip_line_soft, skip_line_hard, skip_sentence_term, skip_sentence_sep)"},{"p":"stringi","o":"stri_omit_empty_na","f":"hp_stri_omit_empty_na","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_omit_empty_na(x)"},{"p":"stringi","o":"stri_write_lines","f":"hp_stri_write_lines","d":"Writes a text file is such a way that each element of a given\ncharacter vector becomes a separate text line.\n","ec":"stri_write_lines(str, con, encoding = \"UTF-8\", sep = ifelse(.Platform$OS.type == \"windows\", \"\\r\\n\", \"\\n\"), fname = con)"},{"p":"stringi","o":"stri_match_last_regex","f":"hp_stri_match_last_regex","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_last_regex(str, pattern, cg_missing = NA_character_, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_c_list","f":"hp_stri_c_list","d":"These functions concatenate all the strings in each character vector\nin a given list.\nstri_c_list and stri_paste_list are aliases for\nstri_join_list.\n","ec":"stri_c_list(x, sep = \"\", collapse = NULL)"},{"p":"stringi","o":"stri_replace_all","f":"hp_stri_replace_all","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_all(str, replacement, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_opts_regex","f":"hp_stri_opts_regex","d":"A convenience function to tune the ICU regular expressions\nmatcher's behavior, e.g., in stri_count_regex\nand other stringi-search-regex functions.\n","ec":"stri_opts_regex(case_insensitive, comments, dotall, dot_all = dotall, literal, multiline, multi_line = multiline, unix_lines, uword, error_on_unknown_escapes, time_limit = 0L, stack_limit = 0L)"},{"p":"stringi","o":"%stri!==%","f":"hp_X.stri....","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri!==%(e1, e2)"},{"p":"stringi","o":"stri_subset_charclass<-","f":"hp_stri_subset_charclass..","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_charclass<-(str, pattern, negate = FALSE, value)"},{"p":"stringi","o":"stri_replace_all_regex","f":"hp_stri_replace_all_regex","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_all_regex(str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_locate_last_boundaries","f":"hp_stri_locate_last_boundaries","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_last_boundaries(str, get_length = FALSE, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_subset_fixed<-","f":"hp_stri_subset_fixed..","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_fixed<-(str, pattern, negate = FALSE, ..., opts_fixed = NULL, value)"},{"p":"stringi","o":"stri_locate_first_fixed","f":"hp_stri_locate_first_fixed","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_first_fixed(str, pattern, get_length = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_extract_last_words","f":"hp_stri_extract_last_words","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_last_words(str, locale = NULL)"},{"p":"stringi","o":"stri_replace_last","f":"hp_stri_replace_last","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_last(str, replacement, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_enc_isutf16be","f":"hp_stri_enc_isutf16be","d":"These functions detect whether a given byte stream is\nvalid UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE.\n","ec":"stri_enc_isutf16be(str)"},{"p":"stringi","o":"stri_extract_first","f":"hp_stri_extract_first","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_first(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_rand_shuffle","f":"hp_stri_rand_shuffle","d":"Generates a (pseudo)random permutation of the code points\nin each string.\n","ec":"stri_rand_shuffle(str)"},{"p":"stringi","o":"%stri+%","f":"hp_X.stri..","d":"Binary operators for joining (concatenating) two character vectors,\nwith a typical R look-and-feel.\n","ec":"%stri+%(e1, e2)"},{"p":"stringi","o":"stri_extract_last","f":"hp_stri_extract_last","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_last(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_locate_last","f":"hp_stri_locate_last","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_last(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_datetime_now","f":"hp_stri_datetime_now","d":"Returns the current date and time.\n","ec":"stri_datetime_now()"},{"p":"stringi","o":"stri_startswith_coll","f":"hp_stri_startswith_coll","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_startswith_coll(str, pattern, from = 1L, negate = FALSE, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_trim_both","f":"hp_stri_trim_both","d":"These functions may be used, e.g., to remove unnecessary\nwhite-spaces from strings. Trimming ends at the first or\nstarts at the last pattern match.\n","ec":"stri_trim_both(str, pattern = \"\\\\P{Wspace}\", negate = FALSE)"},{"p":"stringi","o":"%s!==%","f":"hp_X.s....","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s!==%(e1, e2)"},{"p":"stringi","o":"stri_replace","f":"hp_stri_replace","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace(str, replacement, ..., regex, fixed, coll, charclass, mode = c(\"first\", \"all\", \"last\"))"},{"p":"stringi","o":"stri_extract_last_fixed","f":"hp_stri_extract_last_fixed","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_last_fixed(str, pattern, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_replace_all_charclass","f":"hp_stri_replace_all_charclass","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_all_charclass(str, pattern, replacement, merge = FALSE, vectorize_all = TRUE, vectorise_all = vectorize_all)"},{"p":"stringi","o":"stri_pad_right","f":"hp_stri_pad_right","d":"Add multiple pad characters at the given side(s) of each string\nso that each output string is of total width of at least width.\nThese functions may be used to center or left/right-align each string.\n","ec":"stri_pad_right(str, width = floor(0.9 * getOption(\"width\")), pad = \" \", use_length = FALSE)"},{"p":"stringi","o":"stri_match","f":"hp_stri_match","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match(str, ..., regex, mode = c(\"first\", \"all\", \"last\"))"},{"p":"stringi","o":"stri_replace_last_coll","f":"hp_stri_replace_last_coll","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_last_coll(str, pattern, replacement, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_opts_collator","f":"hp_stri_opts_collator","d":"A convenience function to tune the ICU Collator's behavior,\ne.g., in stri_compare, stri_order,\nstri_unique, stri_duplicated,\nas well as stri_detect_coll\nand other stringi-search-coll functions.\n","ec":"stri_opts_collator(locale = NULL, strength = 3L, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE)"},{"p":"stringi","o":"stri_cmp_lt","f":"hp_stri_cmp_lt","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_lt(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_subset_coll<-","f":"hp_stri_subset_coll..","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_coll<-(str, pattern, negate = FALSE, ..., opts_collator = NULL, value)"},{"p":"stringi","o":"stri_enc_info","f":"hp_stri_enc_info","d":"Gets basic information on a character encoding.\n","ec":"stri_enc_info(enc = NULL)"},{"p":"stringi","o":"stri_trans_char","f":"hp_stri_trans_char","d":"Translates Unicode code points in each input string.\n","ec":"stri_trans_char(str, pattern, replacement)"},{"p":"stringi","o":"stri_stats_latex","f":"hp_stri_stats_latex","d":"This function gives LaTeX-oriented statistics for a character vector,\ne.g., obtained by loading a text file with the\nreadLines function, where each text line\nis represented by a separate string.\n","ec":"stri_stats_latex(str)"},{"p":"stringi","o":"stri_trim_left","f":"hp_stri_trim_left","d":"These functions may be used, e.g., to remove unnecessary\nwhite-spaces from strings. Trimming ends at the first or\nstarts at the last pattern match.\n","ec":"stri_trim_left(str, pattern = \"\\\\P{Wspace}\", negate = FALSE)"},{"p":"stringi","o":"stri_replace_all_fixed","f":"hp_stri_replace_all_fixed","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_all_fixed(str, pattern, replacement, vectorize_all = TRUE, vectorise_all = vectorize_all, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_replace_last_fixed","f":"hp_stri_replace_last_fixed","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_last_fixed(str, pattern, replacement, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_join","f":"hp_stri_join","d":"These are the stringi's equivalents of the built-in\npaste function.\nstri_c and stri_paste are aliases for stri_join.\n","ec":"stri_join(..., sep = \"\", collapse = NULL, ignore_null = FALSE)"},{"p":"stringi","o":"stri_enc_toutf32","f":"hp_stri_enc_toutf32","d":"UTF-32 is a 32-bit encoding where each Unicode code point\ncorresponds to exactly one integer value.\nThis function converts a character vector to a list\nof integer vectors so that, e.g.,\nindividual code points may be easily accessed, changed, etc.\n","ec":"stri_enc_toutf32(str)"},{"p":"stringi","o":"stri_cmp_neq","f":"hp_stri_cmp_neq","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_neq(e1, e2)"},{"p":"stringi","o":"stri_locate_all_regex","f":"hp_stri_locate_all_regex","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_all_regex(str, pattern, omit_no_match = FALSE, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_replace_first_charclass","f":"hp_stri_replace_first_charclass","d":"These functions replace, with the given replacement string, every/first/last\nsubstring of the input that matches the specified pattern.\n","ec":"stri_replace_first_charclass(str, pattern, replacement)"},{"p":"stringi","o":"stri_enc_toutf8","f":"hp_stri_enc_toutf8","d":"Converts character strings with declared marked encodings\nto UTF-8 strings.\n","ec":"stri_enc_toutf8(str, is_unknown_8bit = FALSE, validate = FALSE)"},{"p":"stringi","o":"stri_locale_get","f":"hp_stri_locale_get","d":"stri_locale_set changes the default locale for all the functions\nin the stringi package,\ni.e., establishes the meaning of the <U+201C>NULL locale<U+201D> argument\nof locale-sensitive functions.\nstri_locale_get\ngives the current default locale.\n","ec":"stri_locale_get()"},{"p":"stringi","o":"stri_trim","f":"hp_stri_trim","d":"These functions may be used, e.g., to remove unnecessary\nwhite-spaces from strings. Trimming ends at the first or\nstarts at the last pattern match.\n","ec":"stri_trim(str, side = c(\"both\", \"left\", \"right\"), pattern = \"\\\\P{Wspace}\", negate = FALSE)"},{"p":"stringi","o":"stri_count_regex","f":"hp_stri_count_regex","d":"These functions count the number of occurrences\nof a pattern in a string.\n","ec":"stri_count_regex(str, pattern, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_cmp_le","f":"hp_stri_cmp_le","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_le(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_timezone_set","f":"hp_stri_timezone_set","d":"stri_timezone_set changes the current default time zone for all functions\nin the stringi package, i.e., establishes the meaning of the\n<U+201C>NULL time zone<U+201D> argument to date/time processing functions.\n","ec":"stri_timezone_set(tz)"},{"p":"stringi","o":"stri_count_charclass","f":"hp_stri_count_charclass","d":"These functions count the number of occurrences\nof a pattern in a string.\n","ec":"stri_count_charclass(str, pattern)"},{"p":"stringi","o":"stri_pad_both","f":"hp_stri_pad_both","d":"Add multiple pad characters at the given side(s) of each string\nso that each output string is of total width of at least width.\nThese functions may be used to center or left/right-align each string.\n","ec":"stri_pad_both(str, width = floor(0.9 * getOption(\"width\")), pad = \" \", use_length = FALSE)"},{"p":"stringi","o":"stri_paste_list","f":"hp_stri_paste_list","d":"These functions concatenate all the strings in each character vector\nin a given list.\nstri_c_list and stri_paste_list are aliases for\nstri_join_list.\n","ec":"stri_paste_list(x, sep = \"\", collapse = NULL)"},{"p":"stringi","o":"stri_sub_all_replace","f":"hp_stri_sub_all_replace","d":"stri_sub_all extracts multiple substrings from each string.\nIts replacement version substitutes (in-place) multiple substrings with the\ncorresponding replacement strings.\nstri_sub_replace_all (alias stri_sub_all_replace)\nis its forward pipe operator-friendly variant, returning\na copy of the input vector.\n","ec":"stri_sub_all_replace(..., replacement, value = replacement)"},{"p":"stringi","o":"stri_datetime_create","f":"hp_stri_datetime_create","d":"Constructs date-time objects from numeric representations.\n","ec":"stri_datetime_create(year = NULL, month = NULL, day = NULL, hour = 0L, minute = 0L, second = 0, lenient = FALSE, tz = NULL, locale = NULL)"},{"p":"stringi","o":"stri_extract_first_coll","f":"hp_stri_extract_first_coll","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_first_coll(str, pattern, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_read_raw","f":"hp_stri_read_raw","d":"Reads a text file as-is, with no conversion or text line splitting.\n","ec":"stri_read_raw(con, fname = con)"},{"p":"stringi","o":"stri_enc_mark","f":"hp_stri_enc_mark","d":"Reads declared encodings for each string in a character vector\nas seen by stringi.\n","ec":"stri_enc_mark(str)"},{"p":"stringi","o":"stri_timezone_get","f":"hp_stri_timezone_get","d":"stri_timezone_set changes the current default time zone for all functions\nin the stringi package, i.e., establishes the meaning of the\n<U+201C>NULL time zone<U+201D> argument to date/time processing functions.\n","ec":"stri_timezone_get()"},{"p":"stringi","o":"stri_datetime_fstr","f":"hp_stri_datetime_fstr","d":"This function converts strptime or\nstrftime-style\nformat strings to ICU format strings that may be used\nin stri_datetime_parse and stri_datetime_format\nfunctions.\n","ec":"stri_datetime_fstr(x, ignore_special = TRUE)"},{"p":"stringi","o":"stri_locate_last_words","f":"hp_stri_locate_last_words","d":"These functions locate text boundaries\n(like character, word, line, or sentence boundaries).\nUse stri_locate_all_* to locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first or the last matches, respectively.\n","ec":"stri_locate_last_words(str, locale = NULL, get_length = FALSE)"},{"p":"stringi","o":"stri_match_first","f":"hp_stri_match_first","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_first(str, ..., regex)"},{"p":"stringi","o":"stri_cmp_nequiv","f":"hp_stri_cmp_nequiv","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_nequiv(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_extract_all_charclass","f":"hp_stri_extract_all_charclass","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_all_charclass(str, pattern, merge = TRUE, simplify = FALSE, omit_no_match = FALSE)"},{"p":"stringi","o":"stri_list2matrix","f":"hp_stri_list2matrix","d":"This function converts a given list of atomic vectors to\na character matrix.\n","ec":"stri_list2matrix(x, byrow = FALSE, fill = NA_character_, n_min = 0, by_row = byrow)"},{"p":"stringi","o":"stri_startswith_charclass","f":"hp_stri_startswith_charclass","d":"These functions check if a string starts or ends with a match\nto a given pattern. Also, it is possible to check if there is a match\nat a specific position.\n","ec":"stri_startswith_charclass(str, pattern, from = 1L, negate = FALSE)"},{"p":"stringi","o":"stri_remove_empty_na","f":"hp_stri_remove_empty_na","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_remove_empty_na(x)"},{"p":"stringi","o":"stri_subset_charclass","f":"hp_stri_subset_charclass","d":"These functions return or modify a sub-vector where there is a match to\na given pattern. In other words, they\nare roughly equivalent (but faster and easier to use) to a call to\nstr[stri_detect(str, ...)] or\nstr[stri_detect(str, ...)] <- value.\n","ec":"stri_subset_charclass(str, pattern, omit_na = FALSE, negate = FALSE)"},{"p":"stringi","o":"stri_locate_first_regex","f":"hp_stri_locate_first_regex","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_first_regex(str, pattern, capture_groups = FALSE, get_length = FALSE, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_remove_empty","f":"hp_stri_remove_empty","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_remove_empty(x, na_empty = FALSE)"},{"p":"stringi","o":"%stri===%","f":"hp_X.stri....","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri===%(e1, e2)"},{"p":"stringi","o":"stri_trans_general","f":"hp_stri_trans_general","d":"ICU General transforms provide different ways\nfor processing Unicode text. They are useful in handling a variety\nof different tasks, including:\n","ec":"stri_trans_general(str, id, rules = FALSE, forward = TRUE)"},{"p":"stringi","o":"stri_stats_general","f":"hp_stri_stats_general","d":"This function gives general statistics for a character vector,\ne.g., obtained by loading a text file with the\nreadLines or stri_read_lines function,\nwhere each text line' is represented by a separate string.\n","ec":"stri_stats_general(str)"},{"p":"stringi","o":"stri_locate_all","f":"hp_stri_locate_all","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_all(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"%s*%","f":"hp_X.s..","d":"Duplicates each str(e1) string times(e2) times\nand concatenates the results.\n","ec":"%s*%(e1, e2)"},{"p":"stringi","o":"stri_enc_set","f":"hp_stri_enc_set","d":"stri_enc_set sets the encoding used to re-encode strings\ninternally (i.e., by R) declared to be in native encoding,\nsee stringi-encoding and stri_enc_mark.\nstri_enc_get returns the currently used default encoding.\n","ec":"stri_enc_set(enc)"},{"p":"stringi","o":"stri_cmp_gt","f":"hp_stri_cmp_gt","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_gt(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_detect_charclass","f":"hp_stri_detect_charclass","d":"These functions determine, for each string in str,\nif there is at least one match to a corresponding pattern.\n","ec":"stri_detect_charclass(str, pattern, negate = FALSE, max_count = -1)"},{"p":"stringi","o":"stri_split","f":"hp_stri_split","d":"These functions split each element in str into substrings.\npattern defines the delimiters that separate the inputs into tokens.\nThe input data between the matches become the fields themselves.\n","ec":"stri_split(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_compare","f":"hp_stri_compare","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_compare(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_extract_all_boundaries","f":"hp_stri_extract_all_boundaries","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_all_boundaries(str, simplify = FALSE, omit_no_match = FALSE, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_unescape_unicode","f":"hp_stri_unescape_unicode","d":"Un-escapes all known escape sequences.\n","ec":"stri_unescape_unicode(str)"},{"p":"stringi","o":"stri_locate","f":"hp_stri_locate","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate(str, ..., regex, fixed, coll, charclass, mode = c(\"first\", \"all\", \"last\"))"},{"p":"stringi","o":"stri_enc_get","f":"hp_stri_enc_get","d":"stri_enc_set sets the encoding used to re-encode strings\ninternally (i.e., by R) declared to be in native encoding,\nsee stringi-encoding and stri_enc_mark.\nstri_enc_get returns the currently used default encoding.\n","ec":"stri_enc_get()"},{"p":"stringi","o":"stri_omit_empty","f":"hp_stri_omit_empty","d":"stri_remove_empty (alias stri_omit_empty)\nremoves all empty strings from a character vector,\nand, if na_empty is TRUE, also gets rid of all missing\nvalues.\n","ec":"stri_omit_empty(x, na_empty = FALSE)"},{"p":"stringi","o":"stri_enc_isutf32be","f":"hp_stri_enc_isutf32be","d":"These functions detect whether a given byte stream is\nvalid UTF-16LE, UTF-16BE, UTF-32LE, or UTF-32BE.\n","ec":"stri_enc_isutf32be(str)"},{"p":"stringi","o":"stri_timezone_list","f":"hp_stri_timezone_list","d":"Returns a list of available time zone identifiers.\n","ec":"stri_timezone_list(region = NA_character_, offset = NA_integer_)"},{"p":"stringi","o":"%s===%","f":"hp_X.s....","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s===%(e1, e2)"},{"p":"stringi","o":"stri_extract","f":"hp_stri_extract","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract(str, ..., regex, fixed, coll, charclass, mode = c(\"first\", \"all\", \"last\"))"},{"p":"stringi","o":"%stri$%","f":"hp_X.stri..","d":"Provides access to stri_sprintf in form of a binary\noperator in a way similar to Python's % overloaded for strings.\n","ec":"%stri$%(e1, e2)"},{"p":"stringi","o":"stri_wrap","f":"hp_stri_wrap","d":"This function breaks text paragraphs into lines,\nof total width (if it is possible) at most given width.\n","ec":"stri_wrap(str, width = floor(0.9 * getOption(\"width\")), cost_exponent = 2, simplify = TRUE, normalize = TRUE, normalise = normalize, indent = 0, exdent = 0, prefix = \"\", initial = prefix, whitespace_only = FALSE, use_length = FALSE, locale = NULL)"},{"p":"stringi","o":"stri_split_charclass","f":"hp_stri_split_charclass","d":"These functions split each element in str into substrings.\npattern defines the delimiters that separate the inputs into tokens.\nThe input data between the matches become the fields themselves.\n","ec":"stri_split_charclass(str, pattern, n = -1L, omit_empty = FALSE, tokens_only = FALSE, simplify = FALSE)"},{"p":"stringi","o":"stri_enc_detect2","f":"hp_stri_enc_detect2","d":"This function tries to detect character encoding\nin case the language of text is known.\n","ec":"stri_enc_detect2(str, locale = NULL)"},{"p":"stringi","o":"%stri==%","f":"hp_X.stri...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri==%(e1, e2)"},{"p":"stringi","o":"stri_locate_last_fixed","f":"hp_stri_locate_last_fixed","d":"These functions find the indexes (positions) where\nthere is a match to some pattern.\nThe functions stri_locate_all_* locate all the matches.\nstri_locate_first_* and stri_locate_last_*\ngive the first and the last matches, respectively.\n","ec":"stri_locate_last_fixed(str, pattern, get_length = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"%s+%","f":"hp_X.s..","d":"Binary operators for joining (concatenating) two character vectors,\nwith a typical R look-and-feel.\n","ec":"%s+%(e1, e2)"},{"p":"stringi","o":"%s<=%","f":"hp_X.s...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%s<=%(e1, e2)"},{"p":"stringi","o":"stri_cmp_ge","f":"hp_stri_cmp_ge","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_ge(e1, e2, ..., opts_collator = NULL)"},{"p":"stringi","o":"stri_sub","f":"hp_stri_sub","d":"stri_sub extracts particular substrings at code point-based\nindex ranges provided. Its replacement version allows to substitute\n(in-place) parts of\na string with given replacement strings. stri_sub_replace\nis its forward pipe operator-friendly variant that returns\na copy of the input vector.\n","ec":"stri_sub(str, from = 1L, to = -1L, length, use_matrix = TRUE, ignore_negative_length = FALSE)"},{"p":"stringi","o":"stri_enc_isutf8","f":"hp_stri_enc_isutf8","d":"The function checks whether given sequences of bytes forms\na proper UTF-8 string.\n","ec":"stri_enc_isutf8(str)"},{"p":"stringi","o":"stri_trans_list","f":"hp_stri_trans_list","d":"Returns a list of available text transform identifiers.\nEach of them may be used in stri_trans_general\ntasks.\n","ec":"stri_trans_list()"},{"p":"stringi","o":"stri_match_all_regex","f":"hp_stri_match_all_regex","d":"These functions extract substrings in str that\nmatch a given regex pattern. Additionally, they extract matches\nto every capture group, i.e., to all the sub-patterns given\nin round parentheses.\n","ec":"stri_match_all_regex(str, pattern, omit_no_match = FALSE, cg_missing = NA_character_, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_extract_first_regex","f":"hp_stri_extract_first_regex","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_first_regex(str, pattern, ..., opts_regex = NULL)"},{"p":"stringi","o":"stri_paste","f":"hp_stri_paste","d":"These are the stringi's equivalents of the built-in\npaste function.\nstri_c and stri_paste are aliases for stri_join.\n","ec":"stri_paste(..., sep = \"\", collapse = NULL, ignore_null = FALSE)"},{"p":"stringi","o":"stri_count","f":"hp_stri_count","d":"These functions count the number of occurrences\nof a pattern in a string.\n","ec":"stri_count(str, ..., regex, fixed, coll, charclass)"},{"p":"stringi","o":"stri_extract_all_fixed","f":"hp_stri_extract_all_fixed","d":"These functions extract all substrings matching a given pattern.\n","ec":"stri_extract_all_fixed(str, pattern, simplify = FALSE, omit_no_match = FALSE, ..., opts_fixed = NULL)"},{"p":"stringi","o":"stri_coll","f":"hp_stri_coll","d":"A convenience function to tune the ICU Collator's behavior,\ne.g., in stri_compare, stri_order,\nstri_unique, stri_duplicated,\nas well as stri_detect_coll\nand other stringi-search-coll functions.\n","ec":"stri_coll(locale = NULL, strength = 3L, alternate_shifted = FALSE, french = FALSE, uppercase_first = NA, case_level = FALSE, normalization = FALSE, normalisation = normalization, numeric = FALSE)"},{"p":"stringi","o":"%stri>%","f":"hp_X.stri..","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri>%(e1, e2)"},{"p":"stringi","o":"stri_cmp_eq","f":"hp_stri_cmp_eq","d":"These functions may be used to determine if two strings\nare equal, canonically equivalent (this is performed in a much more clever\nfashion than when testing for equality), or to check whether they are in\na specific lexicographic order.\n","ec":"stri_cmp_eq(e1, e2)"},{"p":"stringi","o":"stri_extract_first_words","f":"hp_stri_extract_first_words","d":"These functions extract data between text boundaries.\n","ec":"stri_extract_first_words(str, locale = NULL)"},{"p":"stringi","o":"stri_trans_totitle","f":"hp_stri_trans_totitle","d":"These functions transform strings either to lower case,\nUPPER CASE, or Title Case or perform case folding.\n","ec":"stri_trans_totitle(str, ..., opts_brkiter = NULL)"},{"p":"stringi","o":"stri_enc_isascii","f":"hp_stri_enc_isascii","d":"The function checks whether all bytes in a string are <= 127.\n","ec":"stri_enc_isascii(str)"},{"p":"stringi","o":"%stri>=%","f":"hp_X.stri...","d":"Relational operators for comparing corresponding strings in\ntwo character vectors, with a typical R look-and-feel.\n","ec":"%stri>=%(e1, e2)"},{"p":"stringr","o":"word","f":"hp_word","d":"Extract words from a sentence\n","ec":"word(string, start = 1L, end = start, sep = fixed(\" \"))"},{"p":"stringr","o":"str_which","f":"hp_str_which","d":"str_which() returns the indices of string where there's at least\none match to pattern. It's a wrapper around\nwhich(str_detect(x, pattern)), and is equivalent to grep(pattern, x).\n","ec":"str_which(string, pattern, negate = FALSE)"},{"p":"stringr","o":"str_subset","f":"hp_str_subset","d":"str_subset() returns all elements of string where there's at least\none match to pattern. It's a wrapper around x[str_detect(x, pattern)],\nand is equivalent to grep(pattern, x, value = TRUE).\n","ec":"str_subset(string, pattern, negate = FALSE)"},{"p":"stringr","o":"str_interp","f":"hp_str_interp","d":"\n","ec":"str_interp(string, env = parent.frame())"},{"p":"stringr","o":"str_glue_data","f":"hp_str_glue_data","d":"These functions are wrappers around glue::glue() and glue::glue_data(),\nwhich provide a powerful and elegant syntax for interpolating strings\nwith {}.\n","ec":"str_glue_data(.x, ..., .sep = \"\", .envir = parent.frame(), .na = \"NA\")"},{"p":"stringr","o":"str_like","f":"hp_str_like","d":"str_like() follows the conventions of the SQL LIKE operator:\n","ec":"str_like(string, pattern, ignore_case = TRUE)"},{"p":"stringr","o":"str_remove","f":"hp_str_remove","d":"Remove matches, i.e. replace them with \"\".\n","ec":"str_remove(string, pattern)"},{"p":"stringr","o":"str_to_upper","f":"hp_str_to_upper","d":"A character vector the same length as string.\n","ec":"str_to_upper(string, locale = \"en\")"},{"p":"stringr","o":"str_to_lower","f":"hp_str_to_lower","d":"A character vector the same length as string.\n","ec":"str_to_lower(string, locale = \"en\")"},{"p":"stringr","o":"str_sub_all","f":"hp_str_sub_all","d":"str_sub() extracts or replaces the elements at a single position in each\nstring. str_sub_all() allows you to extract strings at multiple elements\nin every string.\n","ec":"str_sub_all(string, start = 1L, end = -1L)"},{"p":"stringr","o":"str_split","f":"hp_str_split","d":"This family of functions provides various ways of splitting a string up\ninto pieces. These two functions return a character vector:\n","ec":"str_split(string, pattern, n = Inf, simplify = FALSE)"},{"p":"stringr","o":"str_detect","f":"hp_str_detect","d":"str_detect() returns a logical vector with TRUE for each element of\nstring that matches pattern and FALSE otherwise. It's equivalent to\ngrepl(pattern, string).\n","ec":"str_detect(string, pattern, negate = FALSE)"},{"p":"stringr","o":"str_starts","f":"hp_str_starts","d":"str_starts() and str_ends() are special cases of str_detect() that\nonly match at the beginning or end of a string, respectively.\n","ec":"str_starts(string, pattern, negate = FALSE)"},{"p":"stringr","o":"str_width","f":"hp_str_width","d":"str_length() returns the number of codepoints in a string. These are\nthe individual elements (which are often, but not always letters) that\ncan be extracted with str_sub().\n","ec":"str_width(string)"},{"p":"stringr","o":"str_extract_all","f":"hp_str_extract_all","d":"str_extract() extracts the first complete match from each string,\nstr_extract_all()extracts all matches from each string.\n","ec":"str_extract_all(string, pattern, simplify = FALSE)"},{"p":"stringr","o":"regex","f":"hp_regex","d":"Modifier functions control the meaning of the pattern argument to\nstringr functions:\n","ec":"regex(pattern, ignore_case = FALSE, multiline = FALSE, comments = FALSE, dotall = FALSE, ...)"},{"p":"stringr","o":"str_glue","f":"hp_str_glue","d":"These functions are wrappers around glue::glue() and glue::glue_data(),\nwhich provide a powerful and elegant syntax for interpolating strings\nwith {}.\n","ec":"str_glue(..., .sep = \"\", .envir = parent.frame())"},{"p":"stringr","o":"str_order","f":"hp_str_order","d":"A character vector the same length as string.\n","ec":"str_order(x, decreasing = FALSE, na_last = TRUE, locale = \"en\", numeric = FALSE, ...)"},{"p":"stringr","o":"str_view","f":"hp_str_view","d":"str_view() is used to print the underlying representation of a string and\nto see how a pattern matches.\n","ec":"str_view(string, pattern = NULL, match = TRUE, html = FALSE, use_escapes = FALSE)"},{"p":"stringr","o":"str_rank","f":"hp_str_rank","d":"A character vector the same length as string.\n","ec":"str_rank(x, locale = \"en\", numeric = FALSE, ...)"},{"p":"stringr","o":"str_sort","f":"hp_str_sort","d":"A character vector the same length as string.\n","ec":"str_sort(x, decreasing = FALSE, na_last = TRUE, locale = \"en\", numeric = FALSE, ...)"},{"p":"stringr","o":"str_to_sentence","f":"hp_str_to_sentence","d":"A character vector the same length as string.\n","ec":"str_to_sentence(string, locale = \"en\")"},{"p":"stringr","o":"str_replace_na","f":"hp_str_replace_na","d":"Turn NA into \"NA\"\n","ec":"str_replace_na(string, replacement = \"NA\")"},{"p":"stringr","o":"str_trunc","f":"hp_str_trunc","d":"Truncate a string to a fixed of characters, so that\nstr_length(str_trunc(x, n)) is always less than or equal to n.\n","ec":"str_trunc(string, width, side = c(\"right\", \"left\", \"center\"), ellipsis = \"...\")"},{"p":"stringr","o":"str_unique","f":"hp_str_unique","d":"str_unique() removes duplicated values, with optional control over\nhow duplication is measured.\n","ec":"str_unique(string, locale = \"en\", ignore_case = FALSE, ...)"},{"p":"stringr","o":"str_flatten_comma","f":"hp_str_flatten_comma","d":"str_flatten() reduces a character vector to a single string. This is a\nsummary function because regardless of the length of the input x, it\nalways returns a single string.\n","ec":"str_flatten_comma(string, last = NULL, na.rm = FALSE)"},{"p":"stringr","o":"str_view_all","f":"hp_str_view_all","d":"str_view() is used to print the underlying representation of a string and\nto see how a pattern matches.\n","ec":"str_view_all(string, pattern = NULL, match = NA, html = FALSE, use_escapes = FALSE)"},{"p":"stringr","o":"str_remove_all","f":"hp_str_remove_all","d":"Remove matches, i.e. replace them with \"\".\n","ec":"str_remove_all(string, pattern)"},{"p":"stringr","o":"str_pad","f":"hp_str_pad","d":"Pad a string to a fixed width, so that\nstr_length(str_pad(x, n)) is always greater than or equal to n.\n","ec":"str_pad(string, width, side = c(\"left\", \"right\", \"both\"), pad = \" \", use_width = TRUE)"},{"p":"stringr","o":"str_split_fixed","f":"hp_str_split_fixed","d":"This family of functions provides various ways of splitting a string up\ninto pieces. These two functions return a character vector:\n","ec":"str_split_fixed(string, pattern, n)"},{"p":"stringr","o":"str_conv","f":"hp_str_conv","d":"This is a convenient way to override the current encoding of a string.\n","ec":"str_conv(string, encoding)"},{"p":"stringr","o":"str_squish","f":"hp_str_squish","d":"str_trim() removes whitespace from start and end of string; str_squish()\nremoves whitespace at the start and end, and replaces all internal whitespace\nwith a single space.\n","ec":"str_squish(string)"},{"p":"stringr","o":"str_length","f":"hp_str_length","d":"str_length() returns the number of codepoints in a string. These are\nthe individual elements (which are often, but not always letters) that\ncan be extracted with str_sub().\n","ec":"str_length(string)"},{"p":"stringr","o":"str_sub<-","f":"hp_str_sub..","d":"str_sub() extracts or replaces the elements at a single position in each\nstring. str_sub_all() allows you to extract strings at multiple elements\nin every string.\n","ec":"str_sub<-(string, start = 1L, end = -1L, omit_na = FALSE, value)"},{"p":"stringr","o":"str_flatten","f":"hp_str_flatten","d":"str_flatten() reduces a character vector to a single string. This is a\nsummary function because regardless of the length of the input x, it\nalways returns a single string.\n","ec":"str_flatten(string, collapse = \"\", last = NULL, na.rm = FALSE)"},{"p":"stringr","o":"invert_match","f":"hp_invert_match","d":"Invert a matrix of match locations to match the opposite of what was\npreviously matched.\n","ec":"invert_match(loc)"},{"p":"stringr","o":"str_dup","f":"hp_str_dup","d":"str_dup() duplicates the characters within a string, e.g.\nstr_dup(\"xy\", 3) returns \"xyxyxy\".\n","ec":"str_dup(string, times)"},{"p":"stringr","o":"boundary","f":"hp_boundary","d":"Modifier functions control the meaning of the pattern argument to\nstringr functions:\n","ec":"boundary(type = c(\"character\", \"line_break\", \"sentence\", \"word\"), skip_word_none = NA, ...)"},{"p":"stringr","o":"str_escape","f":"hp_str_escape","d":"This function escapes metacharacter, the characters that have special\nmeaning to the regular expression engine. In most cases you are better\noff using fixed() since it is faster, but str_escape() is useful\nif you are composing user provided strings into a pattern.\n","ec":"str_escape(string)"},{"p":"stringr","o":"str_split_i","f":"hp_str_split_i","d":"This family of functions provides various ways of splitting a string up\ninto pieces. These two functions return a character vector:\n","ec":"str_split_i(string, pattern, i)"},{"p":"stringr","o":"str_ends","f":"hp_str_ends","d":"str_starts() and str_ends() are special cases of str_detect() that\nonly match at the beginning or end of a string, respectively.\n","ec":"str_ends(string, pattern, negate = FALSE)"},{"p":"stringr","o":"str_extract","f":"hp_str_extract","d":"str_extract() extracts the first complete match from each string,\nstr_extract_all()extracts all matches from each string.\n","ec":"str_extract(string, pattern, group = NULL)"},{"p":"stringr","o":"str_trim","f":"hp_str_trim","d":"str_trim() removes whitespace from start and end of string; str_squish()\nremoves whitespace at the start and end, and replaces all internal whitespace\nwith a single space.\n","ec":"str_trim(string, side = c(\"both\", \"left\", \"right\"))"},{"p":"stringr","o":"str_to_title","f":"hp_str_to_title","d":"A character vector the same length as string.\n","ec":"str_to_title(string, locale = \"en\")"},{"p":"stringr","o":"str_replace","f":"hp_str_replace","d":"str_replace() replaces the first match; str_replace_all() replaces\nall matches.\n","ec":"str_replace(string, pattern, replacement)"},{"p":"stringr","o":"str_locate","f":"hp_str_locate","d":"str_locate() returns the start and end position of the first match;\nstr_locate_all() returns the start and end position of each match.\n","ec":"str_locate(string, pattern)"},{"p":"stringr","o":"str_equal","f":"hp_str_equal","d":"This uses Unicode canonicalisation rules, and optionally ignores case.\n","ec":"str_equal(x, y, locale = \"en\", ignore_case = FALSE, ...)"},{"p":"stringr","o":"str_locate_all","f":"hp_str_locate_all","d":"str_locate() returns the start and end position of the first match;\nstr_locate_all() returns the start and end position of each match.\n","ec":"str_locate_all(string, pattern)"},{"p":"stringr","o":"str_count","f":"hp_str_count","d":"Counts the number of times pattern is found within each element\nof string.\n","ec":"str_count(string, pattern = \"\")"},{"p":"stringr","o":"str_replace_all","f":"hp_str_replace_all","d":"str_replace() replaces the first match; str_replace_all() replaces\nall matches.\n","ec":"str_replace_all(string, pattern, replacement)"},{"p":"stringr","o":"str_match_all","f":"hp_str_match_all","d":"Extract any number of matches defined by unnamed, (pattern), and\nnamed, <U+2060>(?<name>pattern)<U+2060> capture groups.\n","ec":"str_match_all(string, pattern)"},{"p":"stringr","o":"str_split_1","f":"hp_str_split_1","d":"This family of functions provides various ways of splitting a string up\ninto pieces. These two functions return a character vector:\n","ec":"str_split_1(string, pattern)"},{"p":"stringr","o":"str_sub","f":"hp_str_sub","d":"str_sub() extracts or replaces the elements at a single position in each\nstring. str_sub_all() allows you to extract strings at multiple elements\nin every string.\n","ec":"str_sub(string, start = 1L, end = -1L)"},{"p":"stringr","o":"str_wrap","f":"hp_str_wrap","d":"Wrap words into paragraphs, minimizing the \"raggedness\" of the lines\n(i.e. the variation in length line) using the Knuth-Plass algorithm.\n","ec":"str_wrap(string, width = 80, indent = 0, exdent = 0, whitespace_only = TRUE)"},{"p":"stringr","o":"coll","f":"hp_coll","d":"Modifier functions control the meaning of the pattern argument to\nstringr functions:\n","ec":"coll(pattern, ignore_case = FALSE, locale = \"en\", ...)"},{"p":"stringr","o":"fixed","f":"hp_fixed","d":"Modifier functions control the meaning of the pattern argument to\nstringr functions:\n","ec":"fixed(pattern, ignore_case = FALSE)"},{"p":"stringr","o":"str_match","f":"hp_str_match","d":"Extract any number of matches defined by unnamed, (pattern), and\nnamed, <U+2060>(?<name>pattern)<U+2060> capture groups.\n","ec":"str_match(string, pattern)"},{"p":"stringr","o":"str_c","f":"hp_str_c","d":"str_c() combines multiple character vectors into a single character\nvector. It's very similar to paste0() but uses tidyverse recycling and\nNA rules.\n","ec":"str_c(..., sep = \"\", collapse = NULL)"},{"p":"testthat","o":"testthat_print","f":"hp_testthat_print","d":"Evaluates code in a special context in which all output is captured,\nsimilar to capture.output().\n","ec":"testthat_print(x)"},{"p":"testthat","o":"ListReporter","f":"hp_ListReporter","d":"This reporter gathers all results, adding additional information such as\ntest elapsed time, and test filename if available. Very useful for reporting.\n","ec":""},{"p":"testthat","o":"is.expectation","f":"hp_is.expectation","d":"For advanced use only. If you are creating your own expectation, you should\ncall expect() instead. See vignette(\"custom-expectation\") for more\ndetails.\n","ec":"is.expectation(x)"},{"p":"testthat","o":"MinimalReporter","f":"hp_MinimalReporter","d":"The minimal test reporter provides the absolutely minimum amount of\ninformation: whether each expectation has succeeded, failed or experienced\nan error.  If you want to find out what the failures and errors actually\nwere, you'll need to run a more informative test reporter.\n","ec":""},{"p":"testthat","o":"expect_output","f":"hp_expect_output","d":"Test for output produced by print() or cat(). This is best used for\nvery simple output; for more complex cases use expect_snapshot().\n","ec":"expect_output(object, regexp = NULL, ..., info = NULL, label = NULL, width = 80)"},{"p":"testthat","o":"expect_no_message","f":"hp_expect_no_message","d":"These expectations are the opposite of expect_error(),\nexpect_warning(), expect_message(), and expect_condition(). They\nassert the absence of an error, warning, or message, respectively.\n","ec":"expect_no_message(object, ..., message = NULL, class = NULL)"},{"p":"testthat","o":"skip_on_bioc","f":"hp_skip_on_bioc","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_on_bioc()"},{"p":"testthat","o":"set_state_inspector","f":"hp_set_state_inspector","d":"One of the most pernicious challenges to debug is when a test runs fine\nin your test suite, but fails when you run it interactively (or similarly,\nit fails randomly when running your tests in parallel). One of the most\ncommon causes of this problem is accidentally changing global state in a\nprevious test (e.g. changing an option, an environment variable, or the\nworking directory). This is hard to debug, because it's very hard to figure\nout which test made the change.\n","ec":"set_state_inspector(callback)"},{"p":"testthat","o":"expect_snapshot","f":"hp_expect_snapshot","d":"Snapshot tests (aka golden tests) are similar to unit tests except that the\nexpected result is stored in a separate file that is managed by testthat.\nSnapshot tests are useful for when the expected value is large, or when\nthe intent of the code is something that can only be verified by a human\n(e.g. this is a useful error message). Learn more in\nvignette(\"snapshotting\").\n","ec":"expect_snapshot(x, cran = FALSE, error = FALSE, transform = NULL, variant = NULL, cnd_class = FALSE)"},{"p":"testthat","o":"find_test_scripts","f":"hp_find_test_scripts","d":"Find test files\n","ec":"find_test_scripts(path, filter = NULL, invert = FALSE, ..., full.names = TRUE, start_first = NULL)"},{"p":"testthat","o":"capture_message","f":"hp_capture_message","d":"\n","ec":"capture_message(code, entrace = FALSE)"},{"p":"testthat","o":"StopReporter","f":"hp_StopReporter","d":"The default reporter used when expect_that() is run interactively.\nIt responds by stop()ping on failures and doing nothing otherwise. This\nwill ensure that a failing test will raise an error.\n","ec":""},{"p":"testthat","o":"with_reporter","f":"hp_with_reporter","d":"get_reporter() and set_reporter() access and modify the current \"active\"\nreporter. Generally, these functions should not be called directly; instead\nuse with_reporter() to temporarily change, then reset, the active reporter.\n","ec":"with_reporter(reporter, code, start_end_reporter = TRUE)"},{"p":"testthat","o":"TeamcityReporter","f":"hp_TeamcityReporter","d":"This reporter will output results in the Teamcity message format.\nFor more information about Teamcity messages, see\nhttp://confluence.jetbrains.com/display/TCD7/Build+Script+Interaction+with+TeamCity\n","ec":""},{"p":"testthat","o":"expect_gte","f":"hp_expect_gte","d":"Does code return a number greater/less than the expected value?\n","ec":"expect_gte(object, expected, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"expect_type","f":"hp_expect_type","d":"See https://adv-r.hadley.nz/oo.html for an overview of R's OO systems, and\nthe vocabulary used here.\n","ec":"expect_type(object, type)"},{"p":"testthat","o":"local_test_directory","f":"hp_local_test_directory","d":"For expert use only.\n","ec":"local_test_directory(path, package = NULL, .env = parent.frame())"},{"p":"testthat","o":"expect_false","f":"hp_expect_false","d":"These are fall-back expectations that you can use when none of the other\nmore specific expectations apply. The disadvantage is that you may get\na less informative error message.\n","ec":"expect_false(object, info = NULL, label = NULL)"},{"p":"testthat","o":"expect_snapshot_error","f":"hp_expect_snapshot_error","d":"\n","ec":"expect_snapshot_error(x, class = \"error\", cran = FALSE, variant = NULL)"},{"p":"testthat","o":"testthat_tolerance","f":"hp_testthat_tolerance","d":"testthat's default numeric tolerance is 1.4901161 <97> 10-8.\n","ec":"testthat_tolerance()"},{"p":"testthat","o":"set_reporter","f":"hp_set_reporter","d":"get_reporter() and set_reporter() access and modify the current \"active\"\nreporter. Generally, these functions should not be called directly; instead\nuse with_reporter() to temporarily change, then reset, the active reporter.\n","ec":"set_reporter(reporter)"},{"p":"testthat","o":"expect_silent","f":"hp_expect_silent","d":"Checks that the code produces no output, messages, or warnings.\n","ec":"expect_silent(object)"},{"p":"testthat","o":"show_failure","f":"hp_show_failure","d":"Use these expectations to test other expectations.\nUse show_failure() in examples to print the failure message without\nthrowing an error.\n","ec":"show_failure(expr)"},{"p":"testthat","o":"expect_length","f":"hp_expect_length","d":"Does code return a vector with the specified length?\n","ec":"expect_length(object, n)"},{"p":"testthat","o":"succeed","f":"hp_succeed","d":"These allow you to manually trigger success or failure. Failure is\nparticularly useful to a pre-condition or mark a test as not yet\nimplemented.\n","ec":"succeed(message = \"Success has been forced\", info = NULL)"},{"p":"testthat","o":"capture_error","f":"hp_capture_error","d":"\n","ec":"capture_error(code, entrace = FALSE)"},{"p":"testthat","o":"skip_on_cran","f":"hp_skip_on_cran","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_on_cran()"},{"p":"testthat","o":"compare_file_binary","f":"hp_compare_file_binary","d":"Whole file snapshot testing is designed for testing objects that don't have\na convenient textual representation, with initial support for images\n(.png, .jpg, .svg), data frames (.csv), and text files\n(.R, .txt, .json, ...).\n","ec":"compare_file_binary(old, new)"},{"p":"testthat","o":"expect_snapshot_output","f":"hp_expect_snapshot_output","d":"\n","ec":"expect_snapshot_output(x, cran = FALSE, variant = NULL)"},{"p":"testthat","o":"test_file","f":"hp_test_file","d":"Helper, setup, and teardown files located in the same directory as the\ntest will also be run. See vignette(\"special-files\") for details.\n","ec":"test_file(path, reporter = default_compact_reporter(), desc = NULL, package = NULL, ...)"},{"p":"testthat","o":"skip_on_os","f":"hp_skip_on_os","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_on_os(os, arch = NULL)"},{"p":"testthat","o":"local_test_context","f":"hp_local_test_context","d":"local_test_context() is run automatically by test_that() but you may\nwant to run it yourself if you want to replicate test results interactively.\nIf run inside a function, the effects are automatically reversed when the\nfunction exits; if running in the global environment, use\nwithr::deferred_run() to undo.\n","ec":"local_test_context(.env = parent.frame())"},{"p":"testthat","o":"testthat_example","f":"hp_testthat_example","d":"testthat_examples() retrieves path to directory of test files,\ntestthat_example() retrieves path to a single test file.\n","ec":"testthat_example(filename)"},{"p":"testthat","o":"it","f":"hp_it","d":"A simple BDD DSL for writing tests. The language is similar to RSpec for\nRuby or Mocha for JavaScript. BDD tests read like sentences and it should\nthus be easier to understand what the specification of a function/component\nis.\n","ec":"it(description, code = NULL)"},{"p":"testthat","o":"LocationReporter","f":"hp_LocationReporter","d":"This reporter simply prints the location of every expectation and error.\nThis is useful if you're trying to figure out the source of a segfault,\nor you want to figure out which code triggers a C/C++ breakpoint\n","ec":""},{"p":"testthat","o":"context","f":"hp_context","d":"\n","ec":"context(desc)"},{"p":"testthat","o":"expect_named","f":"hp_expect_named","d":"You can either check for the presence of names (leaving expected\nblank), specific names (by supplying a vector of names), or absence of\nnames (with NULL).\n","ec":"expect_named(object, expected, ignore.order = FALSE, ignore.case = FALSE, info = NULL, label = NULL)"},{"p":"testthat","o":"context_start_file","f":"hp_context_start_file","d":"For use in external reporters\n","ec":"context_start_file(name)"},{"p":"testthat","o":"is_a","f":"hp_is_a","d":"\n","ec":"is_a(class)"},{"p":"testthat","o":"prints_text","f":"hp_prints_text","d":"\n","ec":"prints_text(regexp = NULL, ...)"},{"p":"testthat","o":"get_reporter","f":"hp_get_reporter","d":"get_reporter() and set_reporter() access and modify the current \"active\"\nreporter. Generally, these functions should not be called directly; instead\nuse with_reporter() to temporarily change, then reset, the active reporter.\n","ec":"get_reporter()"},{"p":"testthat","o":"testthat_examples","f":"hp_testthat_examples","d":"testthat_examples() retrieves path to directory of test files,\ntestthat_example() retrieves path to a single test file.\n","ec":"testthat_examples()"},{"p":"testthat","o":"equals_reference","f":"hp_equals_reference","d":"\n","ec":"equals_reference(file, label = NULL, ...)"},{"p":"testthat","o":"local_edition","f":"hp_local_edition","d":"local_edition() allows you to temporarily (within a single test or\na single test file) change the active edition of testthat.\nedition_get() allows you to retrieve the currently active edition.\n","ec":"local_edition(x, .env = parent.frame())"},{"p":"testthat","o":"expect_that","f":"hp_expect_that","d":"\n","ec":"expect_that(object, condition, info = NULL, label = NULL)"},{"p":"testthat","o":"shows_message","f":"hp_shows_message","d":"\n","ec":"shows_message(regexp = NULL, all = FALSE, ...)"},{"p":"testthat","o":"test_example","f":"hp_test_example","d":"These helper functions make it easier to test the examples in a package.\nEach example counts as one test, and it succeeds if the code runs without\nan error. Generally, this is redundant with R CMD check, and is not\nrecommended in routine practice.\n","ec":"test_example(path, title = path)"},{"p":"testthat","o":"expect_snapshot_file","f":"hp_expect_snapshot_file","d":"Whole file snapshot testing is designed for testing objects that don't have\na convenient textual representation, with initial support for images\n(.png, .jpg, .svg), data frames (.csv), and text files\n(.R, .txt, .json, ...).\n","ec":"expect_snapshot_file(path, name = basename(path), binary = lifecycle::deprecated(), cran = FALSE, compare = NULL, transform = NULL, variant = NULL)"},{"p":"testthat","o":"ProgressReporter","f":"hp_ProgressReporter","d":"ProgressReporter is designed for interactive use. Its goal is to\ngive you actionable insights to help you understand the status of your\ncode. This reporter also praises you from time-to-time if all your tests\npass. It's the default reporter for test_dir().\n","ec":""},{"p":"testthat","o":"is_null","f":"hp_is_null","d":"\n","ec":"is_null()"},{"p":"testthat","o":"teardown","f":"hp_teardown","d":"\n","ec":"teardown(code, env = parent.frame())"},{"p":"testthat","o":"new_expectation","f":"hp_new_expectation","d":"For advanced use only. If you are creating your own expectation, you should\ncall expect() instead. See vignette(\"custom-expectation\") for more\ndetails.\n","ec":"new_expectation(type, message, ..., srcref = NULL, trace = NULL, .subclass = NULL)"},{"p":"testthat","o":"expect_contains","f":"hp_expect_contains","d":"Note that expect_setequal() ignores names, and you will be warned if both\nobject and expected have them.\n","ec":"expect_contains(object, expected)"},{"p":"testthat","o":"expect_equal_to_reference","f":"hp_expect_equal_to_reference","d":"For complex printed output and objects, it is often challenging to describe\nexactly what you expect to see. expect_known_value() and\nexpect_known_output() provide a slightly weaker guarantee, simply\nasserting that the values have not changed since the last time that you ran\nthem.\n","ec":"expect_equal_to_reference(..., update = FALSE)"},{"p":"testthat","o":"set_max_fails","f":"hp_set_max_fails","d":"This sets the TESTTHAT_MAX_FAILS env var which will affect both the\ncurrent R process and any processes launched from it.\n","ec":"set_max_fails(n)"},{"p":"testthat","o":"expect_condition","f":"hp_expect_condition","d":"expect_error(), expect_warning(), expect_message(), and\nexpect_condition() check that code throws an error, warning, message,\nor condition with a message that matches regexp, or a class that inherits\nfrom class. See below for more details.\n","ec":"expect_condition(object, regexp = NULL, class = NULL, ..., inherit = TRUE, info = NULL, label = NULL)"},{"p":"testthat","o":"local_mocked_bindings","f":"hp_local_mocked_bindings","d":"with_mocked_bindings() and local_mocked_bindings() provide tools for\n\"mocking\", temporarily redefining a function so that it behaves differently\nduring tests. This is helpful for testing functions that depend on external\nstate (i.e. reading a value from a file or a website, or pretending a package\nis or isn't installed).\n","ec":"local_mocked_bindings(..., .package = NULL, .env = caller_env())"},{"p":"testthat","o":"expect_success","f":"hp_expect_success","d":"Use these expectations to test other expectations.\nUse show_failure() in examples to print the failure message without\nthrowing an error.\n","ec":"expect_success(expr)"},{"p":"testthat","o":"snapshot_accept","f":"hp_snapshot_accept","ec":"snapshot_accept(files = NULL, path = \"tests/testthat\")"},{"p":"testthat","o":"capture_output_lines","f":"hp_capture_output_lines","d":"Evaluates code in a special context in which all output is captured,\nsimilar to capture.output().\n","ec":"capture_output_lines(code, print = FALSE, width = 80)"},{"p":"testthat","o":"make_expectation","f":"hp_make_expectation","d":"This a convenience function to make a expectation that checks that\ninput stays the same.\n","ec":"make_expectation(x, expectation = \"equals\")"},{"p":"testthat","o":"expect_no_warning","f":"hp_expect_no_warning","d":"These expectations are the opposite of expect_error(),\nexpect_warning(), expect_message(), and expect_condition(). They\nassert the absence of an error, warning, or message, respectively.\n","ec":"expect_no_warning(object, ..., message = NULL, class = NULL)"},{"p":"testthat","o":"fail","f":"hp_fail","d":"These allow you to manually trigger success or failure. Failure is\nparticularly useful to a pre-condition or mark a test as not yet\nimplemented.\n","ec":"fail(message = \"Failure has been forced\", info = NULL, trace_env = caller_env())"},{"p":"testthat","o":"skip_if","f":"hp_skip_if","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_if(condition, message = NULL)"},{"p":"testthat","o":"skip_if_not","f":"hp_skip_if_not","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_if_not(condition, message = NULL)"},{"p":"testthat","o":"test_examples","f":"hp_test_examples","d":"These helper functions make it easier to test the examples in a package.\nEach example counts as one test, and it succeeds if the code runs without\nan error. Generally, this is redundant with R CMD check, and is not\nrecommended in routine practice.\n","ec":"test_examples(path = \"../..\")"},{"p":"testthat","o":"throws_error","f":"hp_throws_error","d":"\n","ec":"throws_error(regexp = NULL, ...)"},{"p":"testthat","o":"is_testing","f":"hp_is_testing","d":"These functions help you determine if you code is running in a particular\ntesting context:\n","ec":"is_testing()"},{"p":"testthat","o":"has_names","f":"hp_has_names","d":"\n","ec":"has_names(expected, ignore.order = FALSE, ignore.case = FALSE)"},{"p":"testthat","o":"expect_cpp_tests_pass","f":"hp_expect_cpp_tests_pass","d":"Test compiled code in the package package. A call to this function will\nautomatically be generated for you in tests/testthat/test-cpp.R after\ncalling use_catch(); you should not need to manually call this expectation\nyourself.\n","ec":"expect_cpp_tests_pass(package)"},{"p":"testthat","o":"watch","f":"hp_watch","d":"This is used to power the auto_test() and\nauto_test_package() functions which are used to rerun tests\nwhenever source code changes.\n","ec":"watch(path, callback, pattern = NULL, hash = TRUE)"},{"p":"testthat","o":"is_parallel","f":"hp_is_parallel","d":"These functions help you determine if you code is running in a particular\ntesting context:\n","ec":"is_parallel()"},{"p":"testthat","o":"expect_less_than","f":"hp_expect_less_than","d":"These functions have been deprecated in favour of the more concise\nexpect_gt() and expect_lt().\n","ec":"expect_less_than(...)"},{"p":"testthat","o":"expect_snapshot_value","f":"hp_expect_snapshot_value","d":"Captures the result of function, flexibly serializing it into a text\nrepresentation that's stored in a snapshot file. See expect_snapshot()\nfor more details on snapshot testing.\n","ec":"expect_snapshot_value(x, style = c(\"json\", \"json2\", \"deparse\", \"serialize\"), cran = FALSE, tolerance = testthat_tolerance(), ..., variant = NULL)"},{"p":"testthat","o":"expect_equivalent","f":"hp_expect_equivalent","d":"Compares object and expected using all.equal() and\ncheck.attributes = FALSE.\n","ec":"expect_equivalent(object, expected, ..., info = NULL, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"CompactProgressReporter","f":"hp_CompactProgressReporter","d":"ProgressReporter is designed for interactive use. Its goal is to\ngive you actionable insights to help you understand the status of your\ncode. This reporter also praises you from time-to-time if all your tests\npass. It's the default reporter for test_dir().\n","ec":""},{"p":"testthat","o":"MultiReporter","f":"hp_MultiReporter","d":"This reporter is useful to use several reporters at the same time, e.g.\nadding a custom reporter without removing the current one.\n","ec":""},{"p":"testthat","o":"describe","f":"hp_describe","d":"A simple BDD DSL for writing tests. The language is similar to RSpec for\nRuby or Mocha for JavaScript. BDD tests read like sentences and it should\nthus be easier to understand what the specification of a function/component\nis.\n","ec":"describe(description, code)"},{"p":"testthat","o":"skip_on_appveyor","f":"hp_skip_on_appveyor","d":"\n","ec":"skip_on_appveyor()"},{"p":"testthat","o":"expect_lt","f":"hp_expect_lt","d":"Does code return a number greater/less than the expected value?\n","ec":"expect_lt(object, expected, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"expect_known_output","f":"hp_expect_known_output","d":"For complex printed output and objects, it is often challenging to describe\nexactly what you expect to see. expect_known_value() and\nexpect_known_output() provide a slightly weaker guarantee, simply\nasserting that the values have not changed since the last time that you ran\nthem.\n","ec":"expect_known_output(object, file, update = TRUE, ..., info = NULL, label = NULL, print = FALSE, width = 80)"},{"p":"testthat","o":"gives_warning","f":"hp_gives_warning","d":"\n","ec":"gives_warning(regexp = NULL, all = FALSE, ...)"},{"p":"testthat","o":"expect_message","f":"hp_expect_message","d":"expect_error(), expect_warning(), expect_message(), and\nexpect_condition() check that code throws an error, warning, message,\nor condition with a message that matches regexp, or a class that inherits\nfrom class. See below for more details.\n","ec":"expect_message(object, regexp = NULL, class = NULL, ..., inherit = TRUE, all = FALSE, info = NULL, label = NULL)"},{"p":"testthat","o":"quasi_label","f":"hp_quasi_label","d":"The first argument to every expect_ function can use unquoting to\nconstruct better labels. This makes it easy to create informative labels when\nexpectations are used inside a function or a for loop. quasi_label() wraps\nup the details, returning the expression and label.\n","ec":"quasi_label(quo, label = NULL, arg = \"quo\")"},{"p":"testthat","o":"is_less_than","f":"hp_is_less_than","d":"\n","ec":"is_less_than(expected, label = NULL, ...)"},{"p":"testthat","o":"compare","f":"hp_compare","d":"\n","ec":"compare(x, y, ...)"},{"p":"testthat","o":"expect_output_file","f":"hp_expect_output_file","d":"expect_output_file() behaves identically to expect_known_output().\n","ec":"expect_output_file(object, file, update = TRUE, ..., info = NULL, label = NULL, print = FALSE, width = 80)"},{"p":"testthat","o":"auto_test_package","f":"hp_auto_test_package","d":"Watches a package for changes, rerunning tests as appropriate.\n","ec":"auto_test_package(pkg = \".\", reporter = default_reporter(), hash = TRUE)"},{"p":"testthat","o":"skip_on_travis","f":"hp_skip_on_travis","d":"\n","ec":"skip_on_travis()"},{"p":"testthat","o":"teardown_env","f":"hp_teardown_env","d":"This environment has no purpose other than as a handle for withr::defer():\nuse it when you want to run code after all tests have been run.\nTypically, you'll use withr::defer(cleanup(), teardown_env())\nimmediately after you've made a mess in a <U+2060>setup-*.R<U+2060> file.\n","ec":"teardown_env()"},{"p":"testthat","o":"auto_test","f":"hp_auto_test","d":"The idea behind auto_test() is that you just leave it running while\nyou develop your code.  Every time you save a file it will be automatically\ntested and you can easily see if your changes have caused any test\nfailures.\n","ec":"auto_test(code_path, test_path, reporter = default_reporter(), env = test_env(), hash = TRUE)"},{"p":"testthat","o":"expect_error","f":"hp_expect_error","d":"expect_error(), expect_warning(), expect_message(), and\nexpect_condition() check that code throws an error, warning, message,\nor condition with a message that matches regexp, or a class that inherits\nfrom class. See below for more details.\n","ec":"expect_error(object, regexp = NULL, class = NULL, ..., inherit = TRUE, info = NULL, label = NULL)"},{"p":"testthat","o":"expect_invisible","f":"hp_expect_invisible","d":"Use this to test whether a function returns a visible or invisible\noutput. Typically you'll use this to check that functions called primarily\nfor their side-effects return their data argument invisibly.\n","ec":"expect_invisible(call, label = NULL)"},{"p":"testthat","o":"announce_snapshot_file","f":"hp_announce_snapshot_file","d":"Whole file snapshot testing is designed for testing objects that don't have\na convenient textual representation, with initial support for images\n(.png, .jpg, .svg), data frames (.csv), and text files\n(.R, .txt, .json, ...).\n","ec":"announce_snapshot_file(path, name = basename(path))"},{"p":"testthat","o":"expect_identical","f":"hp_expect_identical","d":"These functions provide two levels of strictness when comparing a\ncomputation to a reference value. expect_identical() is the baseline;\nexpect_equal() relaxes the test to ignore small numeric differences.\n","ec":"expect_identical(object, expected, info = NULL, label = NULL, expected.label = NULL, ...)"},{"p":"testthat","o":"is_equivalent_to","f":"hp_is_equivalent_to","d":"\n","ec":"is_equivalent_to(expected, label = NULL)"},{"p":"testthat","o":"default_compact_reporter","f":"hp_default_compact_reporter","d":"The defaults are:\n","ec":"default_compact_reporter()"},{"p":"testthat","o":"check_reporter","f":"hp_check_reporter","d":"The defaults are:\n","ec":"check_reporter()"},{"p":"testthat","o":"Reporter","f":"hp_Reporter","d":"The job of a reporter is to aggregate the results from files, tests, and\nexpectations and display them in an informative way. Every testtthat function\nthat runs multiple tests provides a reporter argument which you can\nuse to override the default (which is selected by default_reporter()).\n","ec":""},{"p":"testthat","o":"verify_output","f":"hp_verify_output","d":"\n","ec":"verify_output(path, code, width = 80, crayon = FALSE, unicode = FALSE, env = caller_env())"},{"p":"testthat","o":"CheckReporter","f":"hp_CheckReporter","d":"<U+2060>R CMD check<U+2060> displays only the last 13 lines of the result, so this\nreport is designed to ensure that you see something useful there.\n","ec":""},{"p":"testthat","o":"capture_warnings","f":"hp_capture_warnings","d":"\n","ec":"capture_warnings(code, ignore_deprecation = FALSE)"},{"p":"testthat","o":"capture_expectation","f":"hp_capture_expectation","d":"\n","ec":"capture_expectation(code, entrace = FALSE)"},{"p":"testthat","o":"is_snapshot","f":"hp_is_snapshot","d":"These functions help you determine if you code is running in a particular\ntesting context:\n","ec":"is_snapshot()"},{"p":"testthat","o":"expect","f":"hp_expect","d":"Call expect() when writing your own expectations. See\nvignette(\"custom-expectation\") for details.\n","ec":"expect(ok, failure_message, info = NULL, srcref = NULL, trace = NULL, trace_env = caller_env())"},{"p":"testthat","o":"expect_no_error","f":"hp_expect_no_error","d":"These expectations are the opposite of expect_error(),\nexpect_warning(), expect_message(), and expect_condition(). They\nassert the absence of an error, warning, or message, respectively.\n","ec":"expect_no_error(object, ..., message = NULL, class = NULL)"},{"p":"testthat","o":"use_catch","f":"hp_use_catch","d":"Add the necessary infrastructure to enable C++ unit testing\nin R packages with Catch and\ntestthat.\n","ec":"use_catch(dir = getwd())"},{"p":"testthat","o":"capture_warning","f":"hp_capture_warning","d":"\n","ec":"capture_warning(code, entrace = FALSE)"},{"p":"testthat","o":"expect_no_condition","f":"hp_expect_no_condition","d":"These expectations are the opposite of expect_error(),\nexpect_warning(), expect_message(), and expect_condition(). They\nassert the absence of an error, warning, or message, respectively.\n","ec":"expect_no_condition(object, ..., message = NULL, class = NULL)"},{"p":"testthat","o":"source_test_helpers","f":"hp_source_test_helpers","d":"These are used by test_dir() and friends\n","ec":"source_test_helpers(path = \"tests/testthat\", env = test_env())"},{"p":"testthat","o":"expect_more_than","f":"hp_expect_more_than","d":"These functions have been deprecated in favour of the more concise\nexpect_gt() and expect_lt().\n","ec":"expect_more_than(...)"},{"p":"testthat","o":"skip_if_translated","f":"hp_skip_if_translated","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_if_translated(msgid = \"'%s' not found\")"},{"p":"testthat","o":"expect_null","f":"hp_expect_null","d":"This is a special case because NULL is a singleton so it's possible\ncheck for it either with expect_equal(x, NULL) or expect_type(x, \"NULL\").\n","ec":"expect_null(object, info = NULL, label = NULL)"},{"p":"testthat","o":"with_mock","f":"hp_with_mock","d":"\n","ec":"with_mock(..., .env = topenv())"},{"p":"testthat","o":"expect_true","f":"hp_expect_true","d":"These are fall-back expectations that you can use when none of the other\nmore specific expectations apply. The disadvantage is that you may get\na less informative error message.\n","ec":"expect_true(object, info = NULL, label = NULL)"},{"p":"testthat","o":"takes_less_than","f":"hp_takes_less_than","d":"This is useful for performance regression testing.\n","ec":"takes_less_than(amount)"},{"p":"testthat","o":"expect_visible","f":"hp_expect_visible","d":"Use this to test whether a function returns a visible or invisible\noutput. Typically you'll use this to check that functions called primarily\nfor their side-effects return their data argument invisibly.\n","ec":"expect_visible(call, label = NULL)"},{"p":"testthat","o":"test_check","f":"hp_test_check","d":"See vignette(\"special-files\") to learn about the various files that\ntestthat works with.\n","ec":"test_check(package, reporter = check_reporter(), ...)"},{"p":"testthat","o":"source_test_teardown","f":"hp_source_test_teardown","d":"These are used by test_dir() and friends\n","ec":"source_test_teardown(path = \"tests/testthat\", env = test_env())"},{"p":"testthat","o":"testing_package","f":"hp_testing_package","d":"These functions help you determine if you code is running in a particular\ntesting context:\n","ec":"testing_package()"},{"p":"testthat","o":"expect_match","f":"hp_expect_match","d":"Does a string match a regular expression?\n","ec":"expect_match(object, regexp, perl = FALSE, fixed = FALSE, ..., all = TRUE, info = NULL, label = NULL)"},{"p":"testthat","o":"source_test_setup","f":"hp_source_test_setup","d":"These are used by test_dir() and friends\n","ec":"source_test_setup(path = \"tests/testthat\", env = test_env())"},{"p":"testthat","o":"test_env","f":"hp_test_env","d":"We use a new environment which inherits from globalenv() or a package\nnamespace. In an ideal world, we'd avoid putting the global environment on\nthe search path for tests, but it's not currently possible without losing\nthe ability to load packages in tests.\n","ec":"test_env(package = NULL)"},{"p":"testthat","o":"expectation","f":"hp_expectation","d":"For advanced use only. If you are creating your own expectation, you should\ncall expect() instead. See vignette(\"custom-expectation\") for more\ndetails.\n","ec":"expectation(type, message, srcref = NULL, trace = NULL)"},{"p":"testthat","o":"edition_get","f":"hp_edition_get","d":"local_edition() allows you to temporarily (within a single test or\na single test file) change the active edition of testthat.\nedition_get() allows you to retrieve the currently active edition.\n","ec":"edition_get()"},{"p":"testthat","o":"test_path","f":"hp_test_path","d":"Many tests require some external file (e.g. a .csv if you're testing a\ndata import function) but the working directory varies depending on the way\nthat you're running the test (e.g. interactively, with devtools::test(),\nor with <U+2060>R CMD check<U+2060>). test_path() understands these variations and\nautomatically generates a path relative to tests/testthat, regardless of\nwhere that directory might reside relative to the current working directory.\n","ec":"test_path(...)"},{"p":"testthat","o":"expect_mapequal","f":"hp_expect_mapequal","d":"Note that expect_setequal() ignores names, and you will be warned if both\nobject and expected have them.\n","ec":"expect_mapequal(object, expected)"},{"p":"testthat","o":"expect_equal","f":"hp_expect_equal","d":"These functions provide two levels of strictness when comparing a\ncomputation to a reference value. expect_identical() is the baseline;\nexpect_equal() relaxes the test to ignore small numeric differences.\n","ec":"expect_equal(object, expected, ..., tolerance = if (edition_get() >= 3) testthat_tolerance(), info = NULL, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"not","f":"hp_not","d":"This negates an expectation, making it possible to express that you\nwant the opposite of a standard expectation. This function is deprecated\nand will be removed in a future version.\n","ec":"not(f)"},{"p":"testthat","o":"DebugReporter","f":"hp_DebugReporter","d":"This reporter will call a modified version of recover() on all\nbroken expectations.\n","ec":""},{"p":"testthat","o":"local_snapshotter","f":"hp_local_snapshotter","d":"Needed if you want to run snapshot tests outside of the usual testthat\nframework For expert use only.\n","ec":"local_snapshotter(snap_dir = NULL, cleanup = FALSE, fail_on_new = FALSE, .env = parent.frame())"},{"p":"testthat","o":"with_mocked_bindings","f":"hp_with_mocked_bindings","d":"with_mocked_bindings() and local_mocked_bindings() provide tools for\n\"mocking\", temporarily redefining a function so that it behaves differently\nduring tests. This is helpful for testing functions that depend on external\nstate (i.e. reading a value from a file or a website, or pretending a package\nis or isn't installed).\n","ec":"with_mocked_bindings(code, ..., .package = NULL)"},{"p":"testthat","o":"TapReporter","f":"hp_TapReporter","d":"This reporter will output results in the Test Anything Protocol (TAP),\na simple text-based interface between testing modules in a test harness.\nFor more information about TAP, see http://testanything.org\n","ec":""},{"p":"testthat","o":"expect_setequal","f":"hp_expect_setequal","d":"Note that expect_setequal() ignores names, and you will be warned if both\nobject and expected have them.\n","ec":"expect_setequal(object, expected)"},{"p":"testthat","o":"try_again","f":"hp_try_again","d":"Try evaluating an expressing multiple times until it succeeds.\n","ec":"try_again(times, code)"},{"p":"testthat","o":"expect_snapshot_warning","f":"hp_expect_snapshot_warning","d":"\n","ec":"expect_snapshot_warning(x, class = \"warning\", cran = FALSE, variant = NULL)"},{"p":"testthat","o":"test_dir","f":"hp_test_dir","d":"This function is the low-level workhorse that powers test_local() and\ntest_package(). Generally, you should not call this function directly.\nIn particular, you are responsible for ensuring that the functions to test\nare available in the test env (e.g. via load_package).\n","ec":"test_dir(path, filter = NULL, reporter = NULL, env = NULL, ..., load_helpers = TRUE, stop_on_failure = TRUE, stop_on_warning = FALSE, wrap = lifecycle::deprecated(), package = NULL, load_package = c(\"none\", \"installed\", \"source\"))"},{"p":"testthat","o":"snapshot_review","f":"hp_snapshot_review","ec":"snapshot_review(files = NULL, path = \"tests/testthat\")"},{"p":"testthat","o":"is_more_than","f":"hp_is_more_than","d":"\n","ec":"is_more_than(expected, label = NULL, ...)"},{"p":"testthat","o":"expect_in","f":"hp_expect_in","d":"Note that expect_setequal() ignores names, and you will be warned if both\nobject and expected have them.\n","ec":"expect_in(object, expected)"},{"p":"testthat","o":"expect_s3_class","f":"hp_expect_s3_class","d":"See https://adv-r.hadley.nz/oo.html for an overview of R's OO systems, and\nthe vocabulary used here.\n","ec":"expect_s3_class(object, class, exact = FALSE)"},{"p":"testthat","o":"expect_is","f":"hp_expect_is","d":"\n","ec":"expect_is(object, class, info = NULL, label = NULL)"},{"p":"testthat","o":"test_local","f":"hp_test_local","d":"See vignette(\"special-files\") to learn about the various files that\ntestthat works with.\n","ec":"test_local(path = \".\", reporter = NULL, ..., load_package = \"source\")"},{"p":"testthat","o":"setup","f":"hp_setup","d":"\n","ec":"setup(code, env = parent.frame())"},{"p":"testthat","o":"expect_vector","f":"hp_expect_vector","d":"expect_vector() is a thin wrapper around vctrs::vec_assert(), converting\nthe results of that function in to the expectations used by testthat. This\nmeans that it used the vctrs of ptype (prototype) and size. See\ndetails in https://vctrs.r-lib.org/articles/type-size.html\n","ec":"expect_vector(object, ptype = NULL, size = NULL)"},{"p":"testthat","o":"is_identical_to","f":"hp_is_identical_to","d":"\n","ec":"is_identical_to(expected, label = NULL)"},{"p":"testthat","o":"expect_gt","f":"hp_expect_gt","d":"Does code return a number greater/less than the expected value?\n","ec":"expect_gt(object, expected, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"is_false","f":"hp_is_false","d":"\n","ec":"is_false()"},{"p":"testthat","o":"expect_s4_class","f":"hp_expect_s4_class","d":"See https://adv-r.hadley.nz/oo.html for an overview of R's OO systems, and\nthe vocabulary used here.\n","ec":"expect_s4_class(object, class)"},{"p":"testthat","o":"is_true","f":"hp_is_true","d":"\n","ec":"is_true()"},{"p":"testthat","o":"skip_on_covr","f":"hp_skip_on_covr","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_on_covr()"},{"p":"testthat","o":"source_dir","f":"hp_source_dir","d":"These are used by test_dir() and friends\n","ec":"source_dir(path, pattern = \"\\\\.[rR]$\", env = test_env(), chdir = TRUE, wrap = TRUE)"},{"p":"testthat","o":"compare_file_text","f":"hp_compare_file_text","d":"Whole file snapshot testing is designed for testing objects that don't have\na convenient textual representation, with initial support for images\n(.png, .jpg, .svg), data frames (.csv), and text files\n(.R, .txt, .json, ...).\n","ec":"compare_file_text(old, new)"},{"p":"testthat","o":"is_informative_error","f":"hp_is_informative_error","d":"\n","ec":"is_informative_error(x, ...)"},{"p":"testthat","o":"expect_known_value","f":"hp_expect_known_value","d":"For complex printed output and objects, it is often challenging to describe\nexactly what you expect to see. expect_known_value() and\nexpect_known_output() provide a slightly weaker guarantee, simply\nasserting that the values have not changed since the last time that you ran\nthem.\n","ec":"expect_known_value(object, file, update = TRUE, ..., info = NULL, label = NULL, version = 2)"},{"p":"testthat","o":"capture_messages","f":"hp_capture_messages","d":"\n","ec":"capture_messages(code)"},{"p":"testthat","o":"run_cpp_tests","f":"hp_run_cpp_tests","d":"Test compiled code in the package package. A call to this function will\nautomatically be generated for you in tests/testthat/test-cpp.R after\ncalling use_catch(); you should not need to manually call this expectation\nyourself.\n","ec":"run_cpp_tests(package)"},{"p":"testthat","o":"expect_failure","f":"hp_expect_failure","d":"Use these expectations to test other expectations.\nUse show_failure() in examples to print the failure message without\nthrowing an error.\n","ec":"expect_failure(expr, message = NULL, ...)"},{"p":"testthat","o":"capture_output","f":"hp_capture_output","d":"Evaluates code in a special context in which all output is captured,\nsimilar to capture.output().\n","ec":"capture_output(code, print = FALSE, width = 80)"},{"p":"testthat","o":"expect_warning","f":"hp_expect_warning","d":"expect_error(), expect_warning(), expect_message(), and\nexpect_condition() check that code throws an error, warning, message,\nor condition with a message that matches regexp, or a class that inherits\nfrom class. See below for more details.\n","ec":"expect_warning(object, regexp = NULL, class = NULL, ..., inherit = TRUE, all = FALSE, info = NULL, label = NULL)"},{"p":"testthat","o":"test_rd","f":"hp_test_rd","d":"These helper functions make it easier to test the examples in a package.\nEach example counts as one test, and it succeeds if the code runs without\nan error. Generally, this is redundant with R CMD check, and is not\nrecommended in routine practice.\n","ec":"test_rd(rd, title = attr(rd, \"Rdfile\"))"},{"p":"testthat","o":"default_parallel_reporter","f":"hp_default_parallel_reporter","d":"The defaults are:\n","ec":"default_parallel_reporter()"},{"p":"testthat","o":"expect_no_match","f":"hp_expect_no_match","d":"Does a string match a regular expression?\n","ec":"expect_no_match(object, regexp, perl = FALSE, fixed = FALSE, ..., all = TRUE, info = NULL, label = NULL)"},{"p":"testthat","o":"ParallelProgressReporter","f":"hp_ParallelProgressReporter","d":"ProgressReporter is designed for interactive use. Its goal is to\ngive you actionable insights to help you understand the status of your\ncode. This reporter also praises you from time-to-time if all your tests\npass. It's the default reporter for test_dir().\n","ec":""},{"p":"testthat","o":"skip_on_ci","f":"hp_skip_on_ci","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_on_ci()"},{"p":"testthat","o":"local_reproducible_output","f":"hp_local_reproducible_output","d":"local_test_context() is run automatically by test_that() but you may\nwant to run it yourself if you want to replicate test results interactively.\nIf run inside a function, the effects are automatically reversed when the\nfunction exits; if running in the global environment, use\nwithr::deferred_run() to undo.\n","ec":"local_reproducible_output(width = 80, crayon = FALSE, unicode = FALSE, rstudio = FALSE, hyperlinks = FALSE, lang = \"en\", .env = parent.frame())"},{"p":"testthat","o":"JunitReporter","f":"hp_JunitReporter","d":"This reporter includes detailed results about each test and summaries,\nwritten to a file (or stdout) in jUnit XML format. This can be read by\nthe Jenkins Continuous Integration System to report on a dashboard etc.\nRequires the xml2 package.\n","ec":""},{"p":"testthat","o":"test_that","f":"hp_test_that","d":"A test encapsulates a series of expectations about a small, self-contained\nunit of functionality. Each test contains one or more expectations, such as\nexpect_equal() or expect_error(), and lives in a <U+2060>test/testhat/test*<U+2060>\nfile, often together with other tests that relate to the same function or set\nof functions.\n","ec":"test_that(desc, code)"},{"p":"testthat","o":"SummaryReporter","f":"hp_SummaryReporter","d":"This is a reporter designed for interactive usage: it lets you know which\ntests have run successfully and as well as fully reporting information about\nfailures and errors.\n","ec":""},{"p":"testthat","o":"test_package","f":"hp_test_package","d":"See vignette(\"special-files\") to learn about the various files that\ntestthat works with.\n","ec":"test_package(package, reporter = check_reporter(), ...)"},{"p":"testthat","o":"default_reporter","f":"hp_default_reporter","d":"The defaults are:\n","ec":"default_reporter()"},{"p":"testthat","o":"equals","f":"hp_equals","d":"\n","ec":"equals(expected, label = NULL, ...)"},{"p":"testthat","o":"capture_condition","f":"hp_capture_condition","d":"\n","ec":"capture_condition(code, entrace = FALSE)"},{"p":"testthat","o":"source_file","f":"hp_source_file","d":"These are used by test_dir() and friends\n","ec":"source_file(path, env = test_env(), chdir = TRUE, desc = NULL, wrap = TRUE, error_call = caller_env())"},{"p":"testthat","o":"local_mock","f":"hp_local_mock","d":"\n","ec":"local_mock(..., .env = topenv(), .local_envir = parent.frame())"},{"p":"testthat","o":"skip_if_offline","f":"hp_skip_if_offline","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_if_offline(host = \"captive.apple.com\")"},{"p":"testthat","o":"exp_signal","f":"hp_exp_signal","d":"For advanced use only. If you are creating your own expectation, you should\ncall expect() instead. See vignette(\"custom-expectation\") for more\ndetails.\n","ec":"exp_signal(exp)"},{"p":"testthat","o":"RStudioReporter","f":"hp_RStudioReporter","d":"This reporter is designed for output to RStudio. It produces results in\nany easily parsed form.\n","ec":""},{"p":"testthat","o":"expect_reference","f":"hp_expect_reference","d":"expect_reference() compares the underlying memory addresses of\ntwo symbols. It is for expert use only.\n","ec":"expect_reference(object, expected, info = NULL, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"expect_known_hash","f":"hp_expect_known_hash","d":"For complex printed output and objects, it is often challenging to describe\nexactly what you expect to see. expect_known_value() and\nexpect_known_output() provide a slightly weaker guarantee, simply\nasserting that the values have not changed since the last time that you ran\nthem.\n","ec":"expect_known_hash(object, hash = NULL)"},{"p":"testthat","o":"expect_lte","f":"hp_expect_lte","d":"Does code return a number greater/less than the expected value?\n","ec":"expect_lte(object, expected, label = NULL, expected.label = NULL)"},{"p":"testthat","o":"FailReporter","f":"hp_FailReporter","d":"This reporter will simply throw an error if any of the tests failed. It is\nbest combined with another reporter, such as the\nSummaryReporter.\n","ec":""},{"p":"testthat","o":"skip_if_not_installed","f":"hp_skip_if_not_installed","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip_if_not_installed(pkg, minimum_version = NULL)"},{"p":"testthat","o":"skip","f":"hp_skip","d":"skip_if() and skip_if_not() allow you to skip tests, immediately\nconcluding a test_that() block without executing any further expectations.\nThis allows you to skip a test without failure, if for some reason it\ncan't be run (e.g. it depends on the feature of a specific operating system,\nor it requires a specific version of a package).\n","ec":"skip(message = \"Skipping\")"},{"p":"testthat","o":"matches","f":"hp_matches","d":"\n","ec":"matches(regexp, all = TRUE, ...)"},{"p":"testthat","o":"SilentReporter","f":"hp_SilentReporter","d":"This reporter quietly runs all tests, simply gathering all expectations.\nThis is helpful for programmatically inspecting errors after a test run.\nYou can retrieve the results with the expectations()\nmethod.\n","ec":""},{"p":"testthat","o":"evaluate_promise","f":"hp_evaluate_promise","d":"Evaluate a promise, capturing all types of output.\n","ec":"evaluate_promise(code, print = FALSE)"},{"p":"testthat","o":"is_checking","f":"hp_is_checking","d":"These functions help you determine if you code is running in a particular\ntesting context:\n","ec":"is_checking()"},{"p":"tibble","o":"new_tibble","f":"hp_new_tibble","d":"Creates or validates a subclass of a tibble.\nThese function is mostly useful for package authors that implement subclasses\nof a tibble, like sf or tsibble.\n","ec":"new_tibble(x, ..., nrow = NULL, class = NULL, subclass = NULL)"},{"p":"tibble","o":"set_char_opts","f":"hp_set_char_opts","d":"\n","ec":"set_char_opts(x, ..., min_chars = NULL, shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"))"},{"p":"tibble","o":"tidy_names","f":"hp_tidy_names","d":"\n","ec":"tidy_names(name, syntactic = FALSE, quiet = FALSE)"},{"p":"tibble","o":".__C__tbl_df","f":"hp_.__C__tbl_df","d":"-NA-","ec":""},{"p":"tibble","o":"as_tibble_row","f":"hp_as_tibble_row","d":"as_tibble() turns an existing object, such as a data frame or\nmatrix, into a so-called tibble, a data frame with class tbl_df. This is\nin contrast with tibble(), which builds a tibble from individual columns.\nas_tibble() is to tibble() as base::as.data.frame() is to\nbase::data.frame().\n","ec":"as_tibble_row(x, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))"},{"p":"tibble","o":"char","f":"hp_char","d":"\n","ec":"char(x, ..., min_chars = NULL, shorten = c(\"back\", \"front\", \"mid\", \"abbreviate\"))"},{"p":"tibble","o":"as_data_frame","f":"hp_as_data_frame","d":"\n","ec":"as_data_frame(x, ...)"},{"p":"tibble","o":"as_tibble_col","f":"hp_as_tibble_col","d":"as_tibble() turns an existing object, such as a data frame or\nmatrix, into a so-called tibble, a data frame with class tbl_df. This is\nin contrast with tibble(), which builds a tibble from individual columns.\nas_tibble() is to tibble() as base::as.data.frame() is to\nbase::data.frame().\n","ec":"as_tibble_col(x, column_name = \"value\")"},{"p":"tibble","o":"rownames_to_column","f":"hp_rownames_to_column","d":"While a tibble can have row names (e.g., when converting from a regular data\nframe), they are removed when subsetting with the [ operator.\nA warning will be raised when attempting to assign non-NULL row names\nto a tibble.\nGenerally, it is best to avoid row names, because they are basically a\ncharacter column with different semantics than every other column.\n","ec":"rownames_to_column(.data, var = \"rowname\")"},{"p":"tibble","o":"deframe","f":"hp_deframe","d":"enframe() converts named atomic vectors or lists to one- or two-column\ndata frames.\nFor a list, the result will be a nested tibble with a column of type list.\nFor unnamed vectors, the natural sequence is used as name column.\n","ec":"deframe(x)"},{"p":"tibble","o":"is.tibble","f":"hp_is.tibble","d":"\n","ec":"is.tibble(x)"},{"p":"tibble","o":"data_frame","f":"hp_data_frame","d":"\n","ec":"data_frame(...)"},{"p":"tibble","o":"trunc_mat","f":"hp_trunc_mat","d":"\nAs of tibble 3.1.0, printing is handled entirely by the pillar package.\nDo not use this function.\nIf you implement a package that extend tibble,\nthe printed output can be customized in various ways.\nSee vignette(\"extending\", package = \"pillar\") for details.\n","ec":"trunc_mat(x, n = NULL, width = NULL, n_extra = NULL)"},{"p":"tibble","o":"add_case","f":"hp_add_case","d":"This is a convenient way to add one or more rows of data to an existing data\nframe. See tribble() for an easy way to create an complete\ndata frame row-by-row. Use tibble_row() to ensure that the new data\nhas only one row.\n","ec":"add_case(.data, ..., .before = NULL, .after = NULL)"},{"p":"tibble","o":"lst","f":"hp_lst","d":"lst() constructs a list, similar to base::list(), but with some of the\nsame features as tibble(). lst() builds components sequentially. When\ndefining a component, you can refer to components created earlier in the\ncall. lst() also generates missing names automatically.\n","ec":"lst(...)"},{"p":"tibble","o":"tibble","f":"hp_tibble","d":"tibble() constructs a data frame. It is used like base::data.frame(), but\nwith a couple notable differences:\n","ec":"tibble(..., .rows = NULL, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))"},{"p":"tibble","o":"as.tibble","f":"hp_as.tibble","d":"\n","ec":"as.tibble(x, ...)"},{"p":"tibble","o":"data_frame_","f":"hp_data_frame_","d":"\n","ec":"data_frame_(xs)"},{"p":"tibble","o":"rowid_to_column","f":"hp_rowid_to_column","d":"While a tibble can have row names (e.g., when converting from a regular data\nframe), they are removed when subsetting with the [ operator.\nA warning will be raised when attempting to assign non-NULL row names\nto a tibble.\nGenerally, it is best to avoid row names, because they are basically a\ncharacter column with different semantics than every other column.\n","ec":"rowid_to_column(.data, var = \"rowid\")"},{"p":"tibble","o":"enframe","f":"hp_enframe","d":"enframe() converts named atomic vectors or lists to one- or two-column\ndata frames.\nFor a list, the result will be a nested tibble with a column of type list.\nFor unnamed vectors, the natural sequence is used as name column.\n","ec":"enframe(x, name = \"name\", value = \"value\")"},{"p":"tibble","o":"frame_matrix","f":"hp_frame_matrix","d":"Create matrices laying out the data in rows, similar to\nmatrix(..., byrow = TRUE), with a nicer-to-read syntax.\nThis is useful for small matrices, e.g. covariance matrices, where readability\nis important. The syntax is inspired by tribble().\n","ec":"frame_matrix(...)"},{"p":"tibble","o":"tibble_","f":"hp_tibble_","d":"\n","ec":"tibble_(xs)"},{"p":"tibble","o":"has_rownames","f":"hp_has_rownames","d":"While a tibble can have row names (e.g., when converting from a regular data\nframe), they are removed when subsetting with the [ operator.\nA warning will be raised when attempting to assign non-NULL row names\nto a tibble.\nGenerally, it is best to avoid row names, because they are basically a\ncharacter column with different semantics than every other column.\n","ec":"has_rownames(.data)"},{"p":"tibble","o":"remove_rownames","f":"hp_remove_rownames","d":"While a tibble can have row names (e.g., when converting from a regular data\nframe), they are removed when subsetting with the [ operator.\nA warning will be raised when attempting to assign non-NULL row names\nto a tibble.\nGenerally, it is best to avoid row names, because they are basically a\ncharacter column with different semantics than every other column.\n","ec":"remove_rownames(.data)"},{"p":"tibble","o":"view","f":"hp_view","d":"\n","ec":"view(x, title = NULL, ..., n = NULL)"},{"p":"tibble","o":"lst_","f":"hp_lst_","d":"\n","ec":"lst_(xs)"},{"p":"tibble","o":"frame_data","f":"hp_frame_data","d":"\n","ec":"frame_data(...)"},{"p":"tibble","o":"tibble_row","f":"hp_tibble_row","d":"tibble() constructs a data frame. It is used like base::data.frame(), but\nwith a couple notable differences:\n","ec":"tibble_row(..., .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))"},{"p":"tibble","o":"set_num_opts","f":"hp_set_num_opts","d":"\n","ec":"set_num_opts(x, ..., sigfig = NULL, digits = NULL, label = NULL, scale = NULL, notation = c(\"fit\", \"dec\", \"sci\", \"eng\", \"si\"), fixed_exponent = NULL, extra_sigfig = NULL)"},{"p":"tibble","o":"validate_tibble","f":"hp_validate_tibble","d":"Creates or validates a subclass of a tibble.\nThese function is mostly useful for package authors that implement subclasses\nof a tibble, like sf or tsibble.\n","ec":"validate_tibble(x)"},{"p":"tibble","o":"is_tibble","f":"hp_is_tibble","d":"This function returns TRUE for tibbles or subclasses thereof,\nand FALSE for all other objects, including regular data frames.\n","ec":"is_tibble(x)"},{"p":"tibble","o":"set_tidy_names","f":"hp_set_tidy_names","d":"\n","ec":"set_tidy_names(x, syntactic = FALSE, quiet = FALSE)"},{"p":"tibble","o":"add_row","f":"hp_add_row","d":"This is a convenient way to add one or more rows of data to an existing data\nframe. See tribble() for an easy way to create an complete\ndata frame row-by-row. Use tibble_row() to ensure that the new data\nhas only one row.\n","ec":"add_row(.data, ..., .before = NULL, .after = NULL)"},{"p":"tibble","o":"tribble","f":"hp_tribble","d":"Create tibbles using an easier to read row-by-row layout.\nThis is useful for small tables of data where readability is\nimportant.  Please see tibble-package for a general introduction.\n","ec":"tribble(...)"},{"p":"tibble","o":"as_tibble","f":"hp_as_tibble","d":"as_tibble() turns an existing object, such as a data frame or\nmatrix, into a so-called tibble, a data frame with class tbl_df. This is\nin contrast with tibble(), which builds a tibble from individual columns.\nas_tibble() is to tibble() as base::as.data.frame() is to\nbase::data.frame().\n","ec":"as_tibble(x, ..., .rows = NULL, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"), rownames = pkgconfig::get_config(\"tibble::rownames\", NULL))"},{"p":"tibble","o":"column_to_rownames","f":"hp_column_to_rownames","d":"While a tibble can have row names (e.g., when converting from a regular data\nframe), they are removed when subsetting with the [ operator.\nA warning will be raised when attempting to assign non-NULL row names\nto a tibble.\nGenerally, it is best to avoid row names, because they are basically a\ncharacter column with different semantics than every other column.\n","ec":"column_to_rownames(.data, var = \"rowname\")"},{"p":"tibble","o":"add_column","f":"hp_add_column","d":"This is a convenient way to add one or more columns to an existing data\nframe.\n","ec":"add_column(.data, ..., .before = NULL, .after = NULL, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\"))"},{"p":"tibble","o":"repair_names","f":"hp_repair_names","d":"\n","ec":"repair_names(x, prefix = \"V\", sep = \"\")"},{"p":"tibble","o":"num","f":"hp_num","d":"\n","ec":"num(x, ..., sigfig = NULL, digits = NULL, label = NULL, scale = NULL, notation = c(\"fit\", \"dec\", \"sci\", \"eng\", \"si\"), fixed_exponent = NULL, extra_sigfig = NULL)"},{"p":"tidyr","o":"separate_wider_delim","f":"hp_separate_wider_delim","d":"\n","ec":"separate_wider_delim(data, cols, delim, ..., names = NULL, names_sep = NULL, names_repair = \"check_unique\", too_few = c(\"error\", \"debug\", \"align_start\", \"align_end\"), too_many = c(\"error\", \"debug\", \"drop\", \"merge\"), cols_remove = TRUE)"},{"p":"tidyr","o":"unnest_wider","f":"hp_unnest_wider","d":"unnest_wider() turns each element of a list-column into a column. It\nis most naturally suited to list-columns where every element is named,\nand the names are consistent from row-to-row.\nunnest_wider() preserves the rows of x while modifying the columns.\n","ec":"unnest_wider(data, col, names_sep = NULL, simplify = TRUE, strict = FALSE, names_repair = \"check_unique\", ptype = NULL, transform = NULL)"},{"p":"tidyr","o":"pivot_wider","f":"hp_pivot_wider","d":"pivot_wider() \"widens\" data, increasing the number of columns and\ndecreasing the number of rows. The inverse transformation is\npivot_longer().\n","ec":"pivot_wider(data, ..., id_cols = NULL, id_expand = FALSE, names_from = name, names_prefix = \"\", names_sep = \"_\", names_glue = NULL, names_sort = FALSE, names_vary = \"fastest\", names_expand = FALSE, names_repair = \"check_unique\", values_from = value, values_fill = NULL, values_fn = NULL, unused_fn = NULL)"},{"p":"tidyr","o":"check_pivot_spec","f":"hp_check_pivot_spec","d":"check_pivot_spec() is a developer facing helper function for validating\nthe pivot spec used in pivot_longer_spec() or pivot_wider_spec(). It is\nonly useful if you are extending pivot_longer() or pivot_wider() with\nnew S3 methods.\n","ec":"check_pivot_spec(spec, call = caller_env())"},{"p":"tidyr","o":"spread_","f":"hp_spread_","d":"\n","ec":"spread_(data, key_col, value_col, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)"},{"p":"tidyr","o":"build_longer_spec","f":"hp_build_longer_spec","d":"This is a low level interface to pivoting, inspired by the cdata package,\nthat allows you to describe pivoting with a data frame.\n","ec":"build_longer_spec(data, cols, ..., names_to = \"name\", values_to = \"value\", names_prefix = NULL, names_sep = NULL, names_pattern = NULL, names_ptypes = NULL, names_transform = NULL, error_call = current_env())"},{"p":"tidyr","o":"gather","f":"hp_gather","d":"\n","ec":"gather(data, key = \"key\", value = \"value\", ..., na.rm = FALSE, convert = FALSE, factor_key = FALSE)"},{"p":"tidyr","o":"nesting_","f":"hp_nesting_","d":"\n","ec":"nesting_(x)"},{"p":"tidyr","o":"expand_","f":"hp_expand_","d":"\n","ec":"expand_(data, dots, ...)"},{"p":"tidyr","o":"expand_grid","f":"hp_expand_grid","d":"expand_grid() is heavily motivated by expand.grid().\nCompared to expand.grid(), it:\n","ec":"expand_grid(..., .name_repair = \"check_unique\")"},{"p":"tidyr","o":"unpack","f":"hp_unpack","d":"Packing and unpacking preserve the length of a data frame, changing its\nwidth. pack() makes df narrow by collapsing a set of columns into a\nsingle df-column. unpack() makes data wider by expanding df-columns\nback out into individual columns.\n","ec":"unpack(data, cols, ..., names_sep = NULL, names_repair = \"check_unique\", error_call = current_env())"},{"p":"tidyr","o":"chop","f":"hp_chop","d":"Chopping and unchopping preserve the width of a data frame, changing its\nlength. chop() makes df shorter by converting rows within each group\ninto list-columns. unchop() makes df longer by expanding list-columns\nso that each element of the list-column gets its own row in the output.\nchop() and unchop() are building blocks for more complicated functions\n(like unnest(), unnest_longer(), and unnest_wider()) and are generally\nmore suitable for programming than interactive data analysis.\n","ec":"chop(data, cols, ..., error_call = current_env())"},{"p":"tidyr","o":"unnest_","f":"hp_unnest_","d":"\n","ec":"unnest_(...)"},{"p":"tidyr","o":"spread","f":"hp_spread","d":"\n","ec":"spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE, sep = NULL)"},{"p":"tidyr","o":"separate_longer_position","f":"hp_separate_longer_position","d":"\n","ec":"separate_longer_position(data, cols, width, ..., keep_empty = FALSE)"},{"p":"tidyr","o":"unite","f":"hp_unite","d":"Convenience function to paste together multiple columns into one.\n","ec":"unite(data, col, ..., sep = \"_\", remove = TRUE, na.rm = FALSE)"},{"p":"tidyr","o":"nest_legacy","f":"hp_nest_legacy","d":"\n","ec":"nest_legacy(data, ..., .key = \"data\")"},{"p":"tidyr","o":"nest","f":"hp_nest","d":"Nesting creates a list-column of data frames; unnesting flattens it back out\ninto regular columns. Nesting is implicitly a summarising operation: you\nget one row for each group defined by the non-nested columns. This is useful\nin conjunction with other summaries that work with whole datasets, most\nnotably models.\n","ec":"nest(.data, ..., .by = NULL, .key = NULL, .names_sep = NULL)"},{"p":"tidyr","o":"full_seq","f":"hp_full_seq","d":"This is useful if you want to fill in missing values that should have\nbeen observed but weren't. For example, full_seq(c(1, 2, 4, 6), 1)\nwill return 1:6.\n","ec":"full_seq(x, period, tol = 1e-06)"},{"p":"tidyr","o":"drop_na","f":"hp_drop_na","d":"drop_na() drops rows where any column specified by ... contains a\nmissing value.\n","ec":"drop_na(data, ...)"},{"p":"tidyr","o":"separate_wider_regex","f":"hp_separate_wider_regex","d":"\n","ec":"separate_wider_regex(data, cols, patterns, ..., names_sep = NULL, names_repair = \"check_unique\", too_few = c(\"error\", \"debug\", \"align_start\"), cols_remove = TRUE)"},{"p":"tidyr","o":"pivot_longer","f":"hp_pivot_longer","d":"pivot_longer() \"lengthens\" data, increasing the number of rows and\ndecreasing the number of columns. The inverse transformation is\npivot_wider()\n","ec":"pivot_longer(data, cols, ..., cols_vary = \"fastest\", names_to = \"name\", names_prefix = NULL, names_sep = NULL, names_pattern = NULL, names_ptypes = NULL, names_transform = NULL, names_repair = \"check_unique\", values_to = \"value\", values_drop_na = FALSE, values_ptypes = NULL, values_transform = NULL)"},{"p":"tidyr","o":"expand","f":"hp_expand","d":"expand() generates all combination of variables found in a dataset.\nIt is paired with nesting() and crossing() helpers. crossing()\nis a wrapper around expand_grid() that de-duplicates and sorts its inputs;\nnesting() is a helper that only finds combinations already present in the\ndata.\n","ec":"expand(data, ..., .name_repair = \"check_unique\")"},{"p":"tidyr","o":"extract_","f":"hp_extract_","d":"\n","ec":"extract_(data, col, into, regex = \"([[:alnum:]]+)\", remove = TRUE, convert = FALSE, ...)"},{"p":"tidyr","o":"fill_","f":"hp_fill_","d":"\n","ec":"fill_(data, fill_cols, .direction = c(\"down\", \"up\"))"},{"p":"tidyr","o":"nesting","f":"hp_nesting","d":"expand() generates all combination of variables found in a dataset.\nIt is paired with nesting() and crossing() helpers. crossing()\nis a wrapper around expand_grid() that de-duplicates and sorts its inputs;\nnesting() is a helper that only finds combinations already present in the\ndata.\n","ec":"nesting(..., .name_repair = \"check_unique\")"},{"p":"tidyr","o":"uncount","f":"hp_uncount","d":"Performs the opposite operation to dplyr::count(), duplicating rows\naccording to a weighting variable (or expression).\n","ec":"uncount(data, weights, ..., .remove = TRUE, .id = NULL)"},{"p":"tidyr","o":"fill","f":"hp_fill","d":"Fills missing values in selected columns using the next or previous entry.\nThis is useful in the common output format where values are not repeated,\nand are only recorded when they change.\n","ec":"fill(data, ..., .direction = c(\"down\", \"up\", \"downup\", \"updown\"))"},{"p":"tidyr","o":"extract_numeric","f":"hp_extract_numeric","d":"DEPRECATED: please use readr::parse_number() instead.\n","ec":"extract_numeric(x)"},{"p":"tidyr","o":"complete_","f":"hp_complete_","d":"\n","ec":"complete_(data, cols, fill = list(), ...)"},{"p":"tidyr","o":"build_wider_spec","f":"hp_build_wider_spec","d":"This is a low level interface to pivoting, inspired by the cdata package,\nthat allows you to describe pivoting with a data frame.\n","ec":"build_wider_spec(data, ..., names_from = name, values_from = value, names_prefix = \"\", names_sep = \"_\", names_glue = NULL, names_sort = FALSE, names_vary = \"fastest\", names_expand = FALSE, error_call = current_env())"},{"p":"tidyr","o":"pivot_wider_spec","f":"hp_pivot_wider_spec","d":"This is a low level interface to pivoting, inspired by the cdata package,\nthat allows you to describe pivoting with a data frame.\n","ec":"pivot_wider_spec(data, spec, ..., names_repair = \"check_unique\", id_cols = NULL, id_expand = FALSE, values_fill = NULL, values_fn = NULL, unused_fn = NULL, error_call = current_env())"},{"p":"tidyr","o":"replace_na","f":"hp_replace_na","d":"Replace NAs with specified values\n","ec":"replace_na(data, replace, ...)"},{"p":"tidyr","o":"unchop","f":"hp_unchop","d":"Chopping and unchopping preserve the width of a data frame, changing its\nlength. chop() makes df shorter by converting rows within each group\ninto list-columns. unchop() makes df longer by expanding list-columns\nso that each element of the list-column gets its own row in the output.\nchop() and unchop() are building blocks for more complicated functions\n(like unnest(), unnest_longer(), and unnest_wider()) and are generally\nmore suitable for programming than interactive data analysis.\n","ec":"unchop(data, cols, ..., keep_empty = FALSE, ptype = NULL, error_call = current_env())"},{"p":"tidyr","o":"crossing","f":"hp_crossing","d":"expand() generates all combination of variables found in a dataset.\nIt is paired with nesting() and crossing() helpers. crossing()\nis a wrapper around expand_grid() that de-duplicates and sorts its inputs;\nnesting() is a helper that only finds combinations already present in the\ndata.\n","ec":"crossing(..., .name_repair = \"check_unique\")"},{"p":"tidyr","o":"separate","f":"hp_separate","d":"\n","ec":"separate(data, col, into, sep = \"[^[:alnum:]]+\", remove = TRUE, convert = FALSE, extra = \"warn\", fill = \"warn\", ...)"},{"p":"tidyr","o":"unnest_longer","f":"hp_unnest_longer","d":"unnest_longer() turns each element of a list-column into a row. It\nis most naturally suited to list-columns where the elements are unnamed\nand the length of each element varies from row to row.\n","ec":"unnest_longer(data, col, values_to = NULL, indices_to = NULL, indices_include = NULL, keep_empty = FALSE, names_repair = \"check_unique\", simplify = TRUE, ptype = NULL, transform = NULL)"},{"p":"tidyr","o":"unite_","f":"hp_unite_","d":"\n","ec":"unite_(data, col, from, sep = \"_\", remove = TRUE)"},{"p":"tidyr","o":"unnest","f":"hp_unnest","d":"Unnest expands a list-column containing data frames into rows and columns.\n","ec":"unnest(data, cols, ..., keep_empty = FALSE, ptype = NULL, names_sep = NULL, names_repair = \"check_unique\", .drop = deprecated(), .id = deprecated(), .sep = deprecated(), .preserve = deprecated())"},{"p":"tidyr","o":"crossing_","f":"hp_crossing_","d":"\n","ec":"crossing_(x)"},{"p":"tidyr","o":"pivot_longer_spec","f":"hp_pivot_longer_spec","d":"This is a low level interface to pivoting, inspired by the cdata package,\nthat allows you to describe pivoting with a data frame.\n","ec":"pivot_longer_spec(data, spec, ..., cols_vary = \"fastest\", names_repair = \"check_unique\", values_drop_na = FALSE, values_ptypes = NULL, values_transform = NULL, error_call = current_env())"},{"p":"tidyr","o":"extract","f":"hp_extract","d":"\n","ec":"extract(data, col, into, regex = \"([[:alnum:]]+)\", remove = TRUE, convert = FALSE, ...)"},{"p":"tidyr","o":"unnest_legacy","f":"hp_unnest_legacy","d":"\n","ec":"unnest_legacy(data, ..., .drop = NA, .id = NULL, .sep = NULL, .preserve = NULL)"},{"p":"tidyr","o":"tidyr_legacy","f":"hp_tidyr_legacy","d":"Ensures all column names are unique using the approach found in\ntidyr 0.8.3 and earlier. Only use this function if you want to preserve\nthe naming strategy, otherwise you're better off adopting the new\ntidyverse standard with name_repair = \"universal\"\n","ec":"tidyr_legacy(nms, prefix = \"V\", sep = \"\")"},{"p":"tidyr","o":"separate_rows_","f":"hp_separate_rows_","d":"\n","ec":"separate_rows_(data, cols, sep = \"[^[:alnum:].]+\", convert = FALSE)"},{"p":"tidyr","o":"separate_rows","f":"hp_separate_rows","d":"\n","ec":"separate_rows(data, ..., sep = \"[^[:alnum:].]+\", convert = FALSE)"},{"p":"tidyr","o":"gather_","f":"hp_gather_","d":"\n","ec":"gather_(data, key_col, value_col, gather_cols, na.rm = FALSE, convert = FALSE, factor_key = FALSE)"},{"p":"tidyr","o":"pack","f":"hp_pack","d":"Packing and unpacking preserve the length of a data frame, changing its\nwidth. pack() makes df narrow by collapsing a set of columns into a\nsingle df-column. unpack() makes data wider by expanding df-columns\nback out into individual columns.\n","ec":"pack(.data, ..., .names_sep = NULL, .error_call = current_env())"},{"p":"tidyr","o":"nest_","f":"hp_nest_","d":"\n","ec":"nest_(...)"},{"p":"tidyr","o":"drop_na_","f":"hp_drop_na_","d":"\n","ec":"drop_na_(data, vars)"},{"p":"tidyr","o":"separate_","f":"hp_separate_","d":"\n","ec":"separate_(data, col, into, sep = \"[^[:alnum:]]+\", remove = TRUE, convert = FALSE, extra = \"warn\", fill = \"warn\", ...)"},{"p":"tidyr","o":"unnest_auto","f":"hp_unnest_auto","d":"unnest_auto() picks between unnest_wider() or unnest_longer()\nby inspecting the inner names of the list-col:\n","ec":"unnest_auto(data, col)"},{"p":"tidyr","o":"complete","f":"hp_complete","d":"Turns implicit missing values into explicit missing values. This is a wrapper\naround expand(), dplyr::full_join() and replace_na() that's useful for\ncompleting missing combinations of data.\n","ec":"complete(data, ..., fill = list(), explicit = TRUE)"},{"p":"tidyr","o":"hoist","f":"hp_hoist","d":"hoist() allows you to selectively pull components of a list-column\ninto their own top-level columns, using the same syntax as purrr::pluck().\n","ec":"hoist(.data, .col, ..., .remove = TRUE, .simplify = TRUE, .ptype = NULL, .transform = NULL)"},{"p":"tidyr","o":"separate_wider_position","f":"hp_separate_wider_position","d":"\n","ec":"separate_wider_position(data, cols, widths, ..., names_sep = NULL, names_repair = \"check_unique\", too_few = c(\"error\", \"debug\", \"align_start\"), too_many = c(\"error\", \"debug\", \"drop\"), cols_remove = TRUE)"},{"p":"tidyr","o":"separate_longer_delim","f":"hp_separate_longer_delim","d":"\n","ec":"separate_longer_delim(data, cols, delim, ...)"},{"p":"tidyselect","o":"vars_select_helpers","f":"hp_vars_select_helpers","d":"This list contains all selection helpers exported in tidyselect. It\nwas useful when you wanted to embed the helpers in your API without\nhaving to track addition of new helpers in tidyselect. However the\nselection helpers are now always embedded in the DSL.\n","ec":""},{"p":"tidyselect","o":"eval_rename","f":"hp_eval_rename","d":"eval_select() and eval_rename() evaluate defused R code\n(i.e. quoted expressions) according to the special rules of the\ntidyselect syntax. They\npower functions like dplyr::select(), dplyr::rename(), or\ntidyr::pivot_longer().\n","ec":"eval_rename(expr, data, env = caller_env(), ..., strict = TRUE, name_spec = NULL, allow_predicates = TRUE, error_call = caller_env())"},{"p":"tidyselect","o":"where","f":"hp_where","d":"This selection helper selects the variables for which a\nfunction returns TRUE.\n","ec":"where(fn)"},{"p":"tidyselect","o":"peek_vars","f":"hp_peek_vars","d":"Read the Get started for\nexamples of how to create selection helpers with peek_vars().\n","ec":"peek_vars(..., fn = NULL)"},{"p":"tidyselect","o":"starts_with","f":"hp_starts_with","d":"These selection helpers match variables according\nto a given pattern.\n","ec":"starts_with(match, ignore.case = TRUE, vars = NULL)"},{"p":"tidyselect","o":"peek_data","f":"hp_peek_data","d":"Read the Get started for\nexamples of how to create selection helpers with peek_vars().\n","ec":"peek_data(..., fn = NULL)"},{"p":"tidyselect","o":"poke_vars","f":"hp_poke_vars","d":"Variables are made available to select helpers by\nregistering them in a special placeholder.\n","ec":"poke_vars(vars)"},{"p":"tidyselect","o":"vars_pull","f":"hp_vars_pull","d":"This function powers dplyr::pull() and various functions of the\ntidyr package. It is similar to vars_select() but returns only\none column name and has slightly different semantics: it allows\nnegative numbers to select columns from the end.\n","ec":"vars_pull(vars, var = -1, error_call = caller_env(), error_arg = caller_arg(var))"},{"p":"tidyselect","o":"vars_rename","f":"hp_vars_rename","d":"\n","ec":"vars_rename(.vars, ..., .strict = TRUE)"},{"p":"tidyselect","o":"last_col","f":"hp_last_col","d":"These functions are selection helpers.\n","ec":"last_col(offset = 0L, vars = NULL)"},{"p":"tidyselect","o":"tidyselect_data_has_predicates","f":"hp_tidyselect_data_has_predicates","d":"If your doesn't support predicate functions, return a 0-row data frame\nfrom tidyselect_data_proxy() and FALSE from\ntidyselect_data_has_predicates().\n","ec":"tidyselect_data_has_predicates(x)"},{"p":"tidyselect","o":"scoped_vars","f":"hp_scoped_vars","d":"Variables are made available to select helpers by\nregistering them in a special placeholder.\n","ec":"scoped_vars(vars, frame = caller_env())"},{"p":"tidyselect","o":"all_of","f":"hp_all_of","d":"These selection helpers select variables\ncontained in a character vector. They are especially useful for\nprogramming with selecting functions.\n","ec":"all_of(x)"},{"p":"tidyselect","o":"one_of","f":"hp_one_of","d":"one_of() is superseded in favour of the more precise any_of() and\nall_of() selectors.\n","ec":"one_of(..., .vars = NULL)"},{"p":"tidyselect","o":"num_range","f":"hp_num_range","d":"These selection helpers match variables according\nto a given pattern.\n","ec":"num_range(prefix, range, suffix = \"\", width = NULL, vars = NULL)"},{"p":"tidyselect","o":"eval_relocate","f":"hp_eval_relocate","d":"eval_relocate() is a variant of eval_select() that moves a selection to\na new location. Either before or after can be provided to specify where\nto move the selection to. This powers dplyr::relocate().\n","ec":"eval_relocate(expr, data, ..., before = NULL, after = NULL, strict = TRUE, name_spec = NULL, allow_rename = TRUE, allow_empty = TRUE, allow_predicates = TRUE, before_arg = \"before\", after_arg = \"after\", env = caller_env(), error_call = caller_env())"},{"p":"tidyselect","o":"contains","f":"hp_contains","d":"These selection helpers match variables according\nto a given pattern.\n","ec":"contains(match, ignore.case = TRUE, vars = NULL)"},{"p":"tidyselect","o":"vars_select","f":"hp_vars_select","d":"\n","ec":"vars_select(.vars, ..., .include = character(), .exclude = character(), .strict = TRUE)"},{"p":"tidyselect","o":"ends_with","f":"hp_ends_with","d":"These selection helpers match variables according\nto a given pattern.\n","ec":"ends_with(match, ignore.case = TRUE, vars = NULL)"},{"p":"tidyselect","o":"eval_select","f":"hp_eval_select","d":"eval_select() and eval_rename() evaluate defused R code\n(i.e. quoted expressions) according to the special rules of the\ntidyselect syntax. They\npower functions like dplyr::select(), dplyr::rename(), or\ntidyr::pivot_longer().\n","ec":"eval_select(expr, data, env = caller_env(), ..., include = NULL, exclude = NULL, strict = TRUE, name_spec = NULL, allow_rename = TRUE, allow_empty = TRUE, allow_predicates = TRUE, error_call = caller_env())"},{"p":"tidyselect","o":"any_of","f":"hp_any_of","d":"These selection helpers select variables\ncontained in a character vector. They are especially useful for\nprogramming with selecting functions.\n","ec":"any_of(x, ..., vars = NULL)"},{"p":"tidyselect","o":"with_vars","f":"hp_with_vars","d":"Variables are made available to select helpers by\nregistering them in a special placeholder.\n","ec":"with_vars(vars, expr)"},{"p":"tidyselect","o":"tidyselect_data_proxy","f":"hp_tidyselect_data_proxy","d":"If your doesn't support predicate functions, return a 0-row data frame\nfrom tidyselect_data_proxy() and FALSE from\ntidyselect_data_has_predicates().\n","ec":"tidyselect_data_proxy(x)"},{"p":"tidyselect","o":"matches","f":"hp_matches","d":"These selection helpers match variables according\nto a given pattern.\n","ec":"matches(match, ignore.case = TRUE, perl = FALSE, vars = NULL)"},{"p":"tidyselect","o":"everything","f":"hp_everything","d":"These functions are selection helpers.\n","ec":"everything(vars = NULL)"},{"p":"tools","o":"md5sum","f":"hp_md5sum","d":"Compute the 32-byte MD5 hashes of one or more files.\n","ec":"md5sum(files)"},{"p":"tools","o":"parse_Rd","f":"hp_parse_Rd","d":"This function reads an R documentation (Rd) file and parses it, for\nprocessing by other functions.\n","ec":"parse_Rd(file, srcfile = NULL, encoding = \"unknown\", verbose = FALSE, fragment = FALSE, warningCalls = TRUE, macros = file.path(R.home(\"share\"), \"Rd\", \"macros\", \"system.Rd\"), permissive = FALSE)"},{"p":"tools","o":"SIGKILL","f":"hp_SIGKILL","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"Rd2ex","f":"hp_Rd2ex","d":"These functions take the output of parse_Rd(), an\nRd object, and produce a help page from it.  As they are mainly\nintended for internal use, their interfaces are subject to change.\n","ec":"Rd2ex(Rd, out = \"\", defines = .Platform$OS.type, stages = \"render\", outputEncoding = \"UTF-8\", commentDontrun = TRUE, commentDonttest = FALSE, ...)"},{"p":"tools","o":"compactPDF","f":"hp_compactPDF","d":"Re-save PDF files (especially vignettes) more compactly.\nSupport function for R CMD build --compact-vignettes.\n","ec":"compactPDF(paths, qpdf = Sys.which(Sys.getenv(\"R_QPDF\", \"qpdf\")), gs_cmd = Sys.getenv(\"R_GSCMD\", \"\"), gs_quality = Sys.getenv(\"GS_QUALITY\", \"none\"), gs_extras = character(), verbose = FALSE)"},{"p":"tools","o":"installFoundDepends","f":"hp_installFoundDepends","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"installFoundDepends(depPkgList, ...)"},{"p":"tools","o":"startDynamicHelp","f":"hp_startDynamicHelp","d":"This function starts the internal help server, so that HTML help pages\nare rendered when requested.\n","ec":"startDynamicHelp(start = TRUE)"},{"p":"tools","o":"checkRdContents","f":"hp_checkRdContents","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"checkRdContents(package, dir, lib.loc = NULL, chkInternal = NULL)"},{"p":"tools","o":"R_user_dir","f":"hp_R_user_dir","d":"Directories for storing R-related user-specific data, configuration\nand cache files.\n","ec":"R_user_dir(package, which = c(\"data\", \"config\", \"cache\"))"},{"p":"tools","o":"assertError","f":"hp_assertError","d":"When testing code, it is not sufficient to check that results are correct,\nbut also that errors or warnings are signalled in appropriate\nsituations.  The functions described here provide a convenient\nfacility for doing so.  The three functions check that evaluating the\nsupplied expression produces an error, a warning or one of a\nspecified list of conditions, respectively.  If the assertion fails,\nan error is signalled.\n","ec":"assertError(expr, classes = \"error\", verbose = FALSE)"},{"p":"tools","o":"Rd2txt","f":"hp_Rd2txt","d":"These functions take the output of parse_Rd(), an\nRd object, and produce a help page from it.  As they are mainly\nintended for internal use, their interfaces are subject to change.\n","ec":"Rd2txt(Rd, out = \"\", package = \"\", defines = .Platform$OS.type, stages = \"render\", outputEncoding = \"\", fragment = FALSE, options, ...)"},{"p":"tools","o":"CRAN_package_db","f":"hp_CRAN_package_db","d":"Tools for obtaining information about current packages in the\nCRAN package repository, and their check status.\n","ec":"CRAN_package_db()"},{"p":"tools","o":"SIGTSTP","f":"hp_SIGTSTP","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"checkS3methods","f":"hp_checkS3methods","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"checkS3methods(package, dir, lib.loc = NULL)"},{"p":"tools","o":"undoc","f":"hp_undoc","d":"Finds the objects in a package which are undocumented, in the sense\nthat they are visible to the user (or data objects or S4 classes\nprovided by the package), but no documentation entry exists.\n","ec":"undoc(package, dir, lib.loc = NULL)"},{"p":"tools","o":"find_gs_cmd","f":"hp_find_gs_cmd","d":"Find a GhostScript executable in a cross-platform way.\n","ec":"find_gs_cmd(gs_cmd = \"\")"},{"p":"tools","o":"encoded_text_to_latex","f":"hp_encoded_text_to_latex","d":"Translate non-ASCII characters in text to LaTeX escape sequences.\n","ec":"encoded_text_to_latex(x, encoding = c(\"latin1\", \"latin2\", \"latin9\", \"UTF-8\", \"utf8\"))"},{"p":"tools","o":"checkDocFiles","f":"hp_checkDocFiles","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"checkDocFiles(package, dir, lib.loc = NULL, chkInternal = NULL)"},{"p":"tools","o":"getDepList","f":"hp_getDepList","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"getDepList(depMtrx, instPkgs, recursive = TRUE, local = TRUE, reduce = TRUE, lib.loc = NULL)"},{"p":"tools","o":"summarize_check_packages_in_dir_timings","f":"hp_summarize_check_packages_in_dir_timings","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"summarize_check_packages_in_dir_timings(dir, all = FALSE, full = FALSE)"},{"p":"tools","o":"as.Rconcordance","f":"hp_as.Rconcordance","d":"The Rd parser records locations in <U+2018>.Rd<U+2019> files from\nwhich components of the file are read.  Output generators\nRd2HTML and Rd2latex can output\ninformation about these locations as <U+201C>concordances<U+201D> between\nsource and output lines.  \n","ec":"as.Rconcordance(x, ...)"},{"p":"tools","o":"Adobe_glyphs","f":"hp_Adobe_glyphs","d":"charset_to_Unicode is a matrix of Unicode code points with\ncolumns for the common 8-bit encodings.\n","ec":""},{"p":"tools","o":"pkgDepends","f":"hp_pkgDepends","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"pkgDepends(pkg, recursive = TRUE, local = TRUE, reduce = TRUE, lib.loc = NULL)"},{"p":"tools","o":"langElts","f":"hp_langElts","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":""},{"p":"tools","o":"HTMLheader","f":"hp_HTMLheader","d":"This function generates the standard HTML header used on R help pages.\n","ec":"HTMLheader(title = \"R\", logo = TRUE, up = NULL, top = file.path(Rhome, \"doc/html/index.html\"), Rhome = \"\", css = file.path(Rhome, \"doc/html/R.css\"), headerTitle = paste(\"R:\", title), outputEncoding = \"UTF-8\")"},{"p":"tools","o":"package_native_routine_registration_skeleton","f":"hp_package_native_routine_registration_skeleton","d":"Write a skeleton for adding native routine registration to a package.\n","ec":"package_native_routine_registration_skeleton(dir, con = stdout(), align = TRUE, character_only = TRUE, include_declarations = TRUE)"},{"p":"tools","o":"parseLatex","f":"hp_parseLatex","d":"The parseLatex function parses LaTeX source, producing a\nstructured object; deparseLatex reverses the process.  The\nlatexToUtf8 function takes a LaTeX object, and processes a number\nof different macros to convert them into the corresponding UTF-8\ncharacters.\n","ec":"parseLatex(text, filename = deparse1(substitute(text)), verbose = FALSE, verbatim = c(\"verbatim\", \"verbatim*\", \"Sinput\", \"Soutput\"), verb = \"\\\\Sexpr\")"},{"p":"tools","o":"matchConcordance","f":"hp_matchConcordance","d":"The Rd parser records locations in <U+2018>.Rd<U+2019> files from\nwhich components of the file are read.  Output generators\nRd2HTML and Rd2latex can output\ninformation about these locations as <U+201C>concordances<U+201D> between\nsource and output lines.  \n","ec":"matchConcordance(linenum, concordance)"},{"p":"tools","o":"followConcordance","f":"hp_followConcordance","d":"The Rd parser records locations in <U+2018>.Rd<U+2019> files from\nwhich components of the file are read.  Output generators\nRd2HTML and Rd2latex can output\ninformation about these locations as <U+201C>concordances<U+201D> between\nsource and output lines.  \n","ec":"followConcordance(concordance, prevConcordance)"},{"p":"tools","o":"toRd","f":"hp_toRd","d":"Methods for this function render their associated classes as a fragment of Rd\ncode, which can then be rendered into text, HTML, or LaTeX.\n","ec":"toRd(obj, ...)"},{"p":"tools","o":"file_path_sans_ext","f":"hp_file_path_sans_ext","d":"Utilities for listing files, and manipulating file paths.\n","ec":"file_path_sans_ext(x, compression = FALSE)"},{"p":"tools","o":"CRAN_check_results","f":"hp_CRAN_check_results","d":"Tools for obtaining information about current packages in the\nCRAN package repository, and their check status.\n","ec":"CRAN_check_results(flavors = NULL)"},{"p":"tools","o":"list_files_with_type","f":"hp_list_files_with_type","d":"Utilities for listing files, and manipulating file paths.\n","ec":"list_files_with_type(dir, type, all.files = FALSE, full.names = TRUE, OS_subdirs = .OStype())"},{"p":"tools","o":"checkRd","f":"hp_checkRd","d":"Check an help file or the output of the parse_Rd function.\n","ec":"checkRd(Rd, defines = .Platform$OS.type, stages = \"render\", unknownOK = TRUE, listOK = TRUE, ..., def_enc = FALSE)"},{"p":"tools","o":"SIGUSR1","f":"hp_SIGUSR1","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"vignetteDepends","f":"hp_vignetteDepends","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"vignetteDepends(vignette, recursive = TRUE, reduce = TRUE, local = TRUE, lib.loc = NULL)"},{"p":"tools","o":"makevars_site","f":"hp_makevars_site","d":"Determine the location of the user and site specific <U+2018>Makevars<U+2019>\nfiles for customizing package compilation.\n","ec":"makevars_site()"},{"p":"tools","o":"SIGUSR2","f":"hp_SIGUSR2","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"SweaveTeXFilter","f":"hp_SweaveTeXFilter","d":"This function blanks out code chunks and Noweb markup in an Sweave\ninput file, for spell checking or other uses.\n","ec":"SweaveTeXFilter(ifile, encoding = \"unknown\")"},{"p":"tools","o":"vignetteInfo","f":"hp_vignetteInfo","d":"Extract metadata from a vignette source file.\n","ec":"vignetteInfo(file)"},{"p":"tools","o":"checkPoFile","f":"hp_checkPoFile","d":"These functions compare formats embedded in English messages\nwith translated strings to check for consistency.  checkPoFile\nchecks one file, while checkPoFiles checks all files for specified\nor all languages.\n","ec":"checkPoFile(f, strictPlural = FALSE)"},{"p":"tools","o":"xgettext2pot","f":"hp_xgettext2pot","d":"For each file in the <U+2018>R<U+2019> directory (including system-specific\nsubdirectories) of a source package, extract the unique arguments passed\nto these <U+201C>message generating<U+201D> calls;\n","ec":"xgettext2pot(dir, potFile, name = \"R\", version, bugs)"},{"p":"tools","o":"loadRdMacros","f":"hp_loadRdMacros","d":"Loads macros from an <U+2018>.Rd<U+2019> file, or from several <U+2018>.Rd<U+2019>\nfiles contained in a package.\n","ec":"loadRdMacros(file, macros = TRUE)"},{"p":"tools","o":"texi2pdf","f":"hp_texi2pdf","d":"Run latex/pdflatex, makeindex and bibtex\nuntil all cross-references are resolved to create a DVI or a PDF file.\n","ec":"texi2pdf(file, clean = FALSE, quiet = TRUE, texi2dvi = getOption(\"texi2dvi\"), texinputs = NULL, index = TRUE)"},{"p":"tools","o":"summarize_check_packages_in_dir_results","f":"hp_summarize_check_packages_in_dir_results","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"summarize_check_packages_in_dir_results(dir, all = TRUE, full = FALSE, ...)"},{"p":"tools","o":"summarize_check_packages_in_dir_depends","f":"hp_summarize_check_packages_in_dir_depends","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"summarize_check_packages_in_dir_depends(dir, all = FALSE, which = c(\"Depends\", \"Imports\", \"LinkingTo\"))"},{"p":"tools","o":"pskill","f":"hp_pskill","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":"pskill(pid, signal = SIGTERM)"},{"p":"tools","o":"checkMD5sums","f":"hp_checkMD5sums","d":"checkMD5sums checks the files against a file <U+2018>MD5<U+2019>.\n","ec":"checkMD5sums(package, dir)"},{"p":"tools","o":".print.via.format","f":"hp_.print.via.format","d":".print.via.format is a <U+201C>prototype<U+201D> print()\nmethod, useful, at least as a start, by a simple\n","ec":".print.via.format(x, ...)"},{"p":"tools","o":"makevars_user","f":"hp_makevars_user","d":"Determine the location of the user and site specific <U+2018>Makevars<U+2019>\nfiles for customizing package compilation.\n","ec":"makevars_user()"},{"p":"tools","o":"file_path_as_absolute","f":"hp_file_path_as_absolute","d":"Utilities for listing files, and manipulating file paths.\n","ec":"file_path_as_absolute(x)"},{"p":"tools","o":"standard_package_names","f":"hp_standard_package_names","d":"These functions allow an installed package to be tested, or all base\nand recommended packages.\n","ec":"standard_package_names()"},{"p":"tools","o":"testInstalledPackages","f":"hp_testInstalledPackages","d":"These functions allow an installed package to be tested, or all base\nand recommended packages.\n","ec":"testInstalledPackages(outDir = \".\", errorsAreFatal = TRUE, scope = c(\"both\", \"base\", \"recommended\"), types = c(\"examples\", \"tests\", \"vignettes\"), srcdir = NULL, Ropts = \"\", ...)"},{"p":"tools","o":"SIGCHLD","f":"hp_SIGCHLD","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"checkRdaFiles","f":"hp_checkRdaFiles","d":"This reports for each of the files produced by save the size,\nif it was saved in ASCII or XDR binary format, and if it was\ncompressed (and if so in what format).\n","ec":"checkRdaFiles(paths)"},{"p":"tools","o":"showNonASCII","f":"hp_showNonASCII","d":"This function prints elements of a character vector which contain\nnon-ASCII bytes, printing such bytes as a escape like <U+2018><U+2060><fc><U+2060><U+2019>.\n","ec":"showNonASCII(x)"},{"p":"tools","o":"Rd_db","f":"hp_Rd_db","d":"Utilities for computing on the information in Rd objects.","ec":"Rd_db(package, dir, lib.loc = NULL, stages = \"build\")"},{"p":"tools","o":"pkg2HTML","f":"hp_pkg2HTML","d":"Generate a single-page HTML reference manual from the Rd sources\ncontained in an installed or source R package.\n","ec":"pkg2HTML(package, dir = NULL, lib.loc = NULL, outputEncoding = \"UTF-8\", stylesheet = file.path(R.home(\"doc\"), \"html\", \"R-nav.css\"), hooks = list(pkg_href = function(pkg) sprintf(\"%s.html\", pkg)), texmath = getOption(\"help.htmlmath\"), prism = TRUE, out = NULL, toc_entry = c(\"title\", \"name\"), ..., Rhtml = FALSE, mathjax_config = file.path(R.home(\"doc\"), \"html\", \"mathjax-config.js\"), include_description = TRUE)"},{"p":"tools","o":"delimMatch","f":"hp_delimMatch","d":"Match delimited substrings in a character vector, with proper nesting.\n","ec":"delimMatch(x, delim = c(\"{\", \"}\"), syntax = \"Rd\")"},{"p":"tools","o":"testInstalledBasic","f":"hp_testInstalledBasic","d":"These functions allow an installed package to be tested, or all base\nand recommended packages.\n","ec":"testInstalledBasic(scope = c(\"basic\", \"devel\", \"both\", \"internet\", \"all\"), outDir = file.path(R.home(), \"tests\"), testSrcdir = getTestSrcdir(outDir))"},{"p":"tools","o":"toHTML","f":"hp_toHTML","d":"This generic function generates a complete HTML page from an object.\n","ec":"toHTML(x, ...)"},{"p":"tools","o":"assertWarning","f":"hp_assertWarning","d":"When testing code, it is not sufficient to check that results are correct,\nbut also that errors or warnings are signalled in appropriate\nsituations.  The functions described here provide a convenient\nfacility for doing so.  The three functions check that evaluating the\nsupplied expression produces an error, a warning or one of a\nspecified list of conditions, respectively.  If the assertion fails,\nan error is signalled.\n","ec":"assertWarning(expr, classes = \"warning\", verbose = FALSE)"},{"p":"tools","o":"dependsOnPkgs","f":"hp_dependsOnPkgs","d":"Find <U+2018>reverse<U+2019> dependencies of packages, that is those packages\nwhich depend on this one, and (optionally) so on recursively.\n","ec":"dependsOnPkgs(pkgs, dependencies = \"strong\", recursive = TRUE, lib.loc = NULL, installed = utils::installed.packages(lib.loc, fields = \"Enhances\"))"},{"p":"tools","o":"codoc","f":"hp_codoc","d":"Find inconsistencies between actual and documented <U+2018>structure<U+2019>\nof R objects in a package.  codoc compares names and\noptionally also corresponding positions and default values of the\narguments of functions.  codocClasses and codocData\ncompare slot names of S4 classes and variable names of data sets,\nrespectively.\n","ec":"codoc(package, dir, lib.loc = NULL, use.values = NULL, verbose = getOption(\"verbose\"))"},{"p":"tools","o":"xngettext","f":"hp_xngettext","d":"For each file in the <U+2018>R<U+2019> directory (including system-specific\nsubdirectories) of a source package, extract the unique arguments passed\nto these <U+201C>message generating<U+201D> calls;\n","ec":"xngettext(dir, verbose = FALSE)"},{"p":"tools","o":"CRAN_check_issues","f":"hp_CRAN_check_issues","d":"Tools for obtaining information about current packages in the\nCRAN package repository, and their check status.\n","ec":"CRAN_check_issues()"},{"p":"tools","o":"update_pkg_po","f":"hp_update_pkg_po","d":"Prepare the <U+2018>po<U+2019> directory of a package and optionally compile and install\nthe translations.\n","ec":"update_pkg_po(pkgdir, pkg = NULL, version = NULL, pot_make = TRUE, mo_make = TRUE, verbose = getOption(\"verbose\"), mergeOpts = \"\", copyright, bugs)"},{"p":"tools","o":"charset_to_Unicode","f":"hp_charset_to_Unicode","d":"charset_to_Unicode is a matrix of Unicode code points with\ncolumns for the common 8-bit encodings.\n","ec":""},{"p":"tools","o":"SIGQUIT","f":"hp_SIGQUIT","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"Rd2latex","f":"hp_Rd2latex","d":"These functions take the output of parse_Rd(), an\nRd object, and produce a help page from it.  As they are mainly\nintended for internal use, their interfaces are subject to change.\n","ec":"Rd2latex(Rd, out = \"\", defines = .Platform$OS.type, stages = \"render\", outputEncoding = \"UTF-8\", fragment = FALSE, ..., writeEncoding = TRUE, concordance = FALSE)"},{"p":"tools","o":"SIGHUP","f":"hp_SIGHUP","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"checkDocStyle","f":"hp_checkDocStyle","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"checkDocStyle(package, dir, lib.loc = NULL)"},{"p":"tools","o":"Rd2txt_options","f":"hp_Rd2txt_options","d":"This function sets various options for displaying text help.\n","ec":"Rd2txt_options(...)"},{"p":"tools","o":"codocClasses","f":"hp_codocClasses","d":"Find inconsistencies between actual and documented <U+2018>structure<U+2019>\nof R objects in a package.  codoc compares names and\noptionally also corresponding positions and default values of the\narguments of functions.  codocClasses and codocData\ncompare slot names of S4 classes and variable names of data sets,\nrespectively.\n","ec":"codocClasses(package, lib.loc = NULL)"},{"p":"tools","o":"SIGTERM","f":"hp_SIGTERM","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"read.00Index","f":"hp_read.00Index","d":"Read item/description information from <U+2018>00Index<U+2019>-like files.  Such\nfiles are description lists rendered in tabular form, and currently\nused for the <U+2018>INDEX<U+2019> and <U+2018>demo/00Index<U+2019> files of add-on\npackages.\n","ec":"read.00Index(file)"},{"p":"tools","o":"checkReplaceFuns","f":"hp_checkReplaceFuns","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"checkReplaceFuns(package, dir, lib.loc = NULL)"},{"p":"tools","o":"bibstyle","f":"hp_bibstyle","d":"This function defines and registers styles for rendering\nbibentry objects into <U+2018>Rd<U+2019> format, for later\nconversion to text, HTML, etc.\n","ec":"bibstyle(style, envir, ..., .init = FALSE, .default = TRUE)"},{"p":"tools","o":"list_files_with_exts","f":"hp_list_files_with_exts","d":"Utilities for listing files, and manipulating file paths.\n","ec":"list_files_with_exts(dir, exts, all.files = FALSE, full.names = TRUE)"},{"p":"tools","o":"codocData","f":"hp_codocData","d":"Find inconsistencies between actual and documented <U+2018>structure<U+2019>\nof R objects in a package.  codoc compares names and\noptionally also corresponding positions and default values of the\narguments of functions.  codocClasses and codocData\ncompare slot names of S4 classes and variable names of data sets,\nrespectively.\n","ec":"codocData(package, lib.loc = NULL)"},{"p":"tools","o":"write_PACKAGES","f":"hp_write_PACKAGES","d":"Generate <U+2018>PACKAGES<U+2019>, <U+2018>PACKAGES.gz<U+2019> and <U+2018>PACKAGES.rds<U+2019>\nfiles for a repository of source or Mac/Windows binary packages.\n","ec":"write_PACKAGES(dir = \".\", fields = NULL, type = c(\"source\", \"mac.binary\", \"win.binary\"), verbose = FALSE, unpacked = FALSE, subdirs = FALSE, latestOnly = TRUE, addFiles = FALSE, rds_compress = \"xz\", validate = FALSE)"},{"p":"tools","o":"checkFF","f":"hp_checkFF","d":"Performs checks on calls to compiled code from R code.  Currently only\nchecks whether the interface functions such as .C and\n.Fortran are called with a \"NativeSymbolInfo\"\nfirst argument or with argument PACKAGE specified, which is\nhighly recommended to avoid name clashes in foreign function calls.\n","ec":"checkFF(package, dir, file, lib.loc = NULL, registration = FALSE, check_DUP = FALSE, verbose = getOption(\"verbose\"))"},{"p":"tools","o":"checkVignettes","f":"hp_checkVignettes","d":"Check all vignettes of a package by running\nSweave (or other custom weave function) and/or\nStangle (or other custom tangle function) on them.\nAll R source code files found after the tangling step are\nsourceed to check whether all code can be\nexecuted without errors.\n","ec":"checkVignettes(package, dir, lib.loc = NULL, tangle = TRUE, weave = TRUE, latex = FALSE, workdir = c(\"tmp\", \"src\", \"cur\"), keepfiles = FALSE)"},{"p":"tools","o":"check_packages_in_dir_changes","f":"hp_check_packages_in_dir_changes","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"check_packages_in_dir_changes(dir, old, outputs = FALSE, sources = FALSE, ...)"},{"p":"tools","o":"deparseLatex","f":"hp_deparseLatex","d":"The parseLatex function parses LaTeX source, producing a\nstructured object; deparseLatex reverses the process.  The\nlatexToUtf8 function takes a LaTeX object, and processes a number\nof different macros to convert them into the corresponding UTF-8\ncharacters.\n","ec":"deparseLatex(x, dropBraces = FALSE)"},{"p":"tools","o":"Rdindex","f":"hp_Rdindex","d":"Print a 2-column index table with names and titles from given\nR documentation files to a given output file or connection.  The\ntitles are nicely formatted between two column positions (typically 25\nand 72, respectively).\n","ec":"Rdindex(RdFiles, outFile = \"\", type = NULL, width = 0.9 * getOption(\"width\"), indent = NULL)"},{"p":"tools","o":"file_ext","f":"hp_file_ext","d":"Utilities for listing files, and manipulating file paths.\n","ec":"file_ext(x)"},{"p":"tools","o":"texi2dvi","f":"hp_texi2dvi","d":"Run latex/pdflatex, makeindex and bibtex\nuntil all cross-references are resolved to create a DVI or a PDF file.\n","ec":"texi2dvi(file, pdf = FALSE, clean = FALSE, quiet = TRUE, texi2dvi = getOption(\"texi2dvi\"), texinputs = NULL, index = TRUE)"},{"p":"tools","o":"nonS3methods","f":"hp_nonS3methods","d":"Functions for performing various quality control (QC) checks on R code\nand documentation, notably on R packages.\n","ec":"nonS3methods(package)"},{"p":"tools","o":"SIGCONT","f":"hp_SIGCONT","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"findHTMLlinks","f":"hp_findHTMLlinks","d":"Compute relative file paths for URLs to other package's installed HTML\ndocumentation.\n","ec":"findHTMLlinks(pkgDir = \"\", lib.loc = NULL, level = 0:2)"},{"p":"tools","o":"resaveRdaFiles","f":"hp_resaveRdaFiles","d":"This reports for each of the files produced by save the size,\nif it was saved in ASCII or XDR binary format, and if it was\ncompressed (and if so in what format).\n","ec":"resaveRdaFiles(paths, compress = c(\"auto\", \"gzip\", \"bzip2\", \"xz\"), compression_level, version = NULL)"},{"p":"tools","o":"CRAN_check_details","f":"hp_CRAN_check_details","d":"Tools for obtaining information about current packages in the\nCRAN package repository, and their check status.\n","ec":"CRAN_check_details(flavors = NULL)"},{"p":"tools","o":"buildVignette","f":"hp_buildVignette","d":"Run Sweave (or other custom weave function),\ntexi2pdf, and/or Stangle \n(or other custom tangle function) on one vignette.\n","ec":"buildVignette(file, dir = \".\", weave = TRUE, latex = TRUE, tangle = TRUE, quiet = TRUE, clean = TRUE, keep = character(), engine = NULL, buildPkg = NULL, encoding = getVignetteEncoding(file), ...)"},{"p":"tools","o":"psnice","f":"hp_psnice","d":"Get or set the <U+2018>niceness<U+2019> of the current process, or one or\nmore other processes.\n","ec":"psnice(pid = Sys.getpid(), value = NA_integer_)"},{"p":"tools","o":"assertCondition","f":"hp_assertCondition","d":"When testing code, it is not sufficient to check that results are correct,\nbut also that errors or warnings are signalled in appropriate\nsituations.  The functions described here provide a convenient\nfacility for doing so.  The three functions check that evaluating the\nsupplied expression produces an error, a warning or one of a\nspecified list of conditions, respectively.  If the assertion fails,\nan error is signalled.\n","ec":"assertCondition(expr, ..., .exprString = .deparseTrim(substitute(expr), cutoff = 30L), verbose = FALSE)"},{"p":"tools","o":"loadPkgRdMacros","f":"hp_loadPkgRdMacros","d":"Loads macros from an <U+2018>.Rd<U+2019> file, or from several <U+2018>.Rd<U+2019>\nfiles contained in a package.\n","ec":"loadPkgRdMacros(pkgdir, macros = NULL)"},{"p":"tools","o":"check_packages_in_dir","f":"hp_check_packages_in_dir","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"check_packages_in_dir(dir, pfiles = Sys.glob(\"*.tar.gz\"), check_args = character(), check_args_db = list(), reverse = NULL, check_env = character(), xvfb = FALSE, Ncpus = getOption(\"Ncpus\", 1L), clean = TRUE, install_args = list(), parallel_args = list(), ...)"},{"p":"tools","o":"package.dependencies","f":"hp_package.dependencies","d":"The functions or variables listed here are no longer part of R as\nthey are not needed (any more).\n","ec":"package.dependencies(x, check = FALSE, depLevel = c(\"Depends\", \"Imports\", \"Suggests\"))"},{"p":"tools","o":"testInstalledPackage","f":"hp_testInstalledPackage","d":"These functions allow an installed package to be tested, or all base\nand recommended packages.\n","ec":"testInstalledPackage(pkg, lib.loc = NULL, outDir = \".\", types = c(\"examples\", \"tests\", \"vignettes\"), srcdir = NULL, Ropts = \"\", ...)"},{"p":"tools","o":"Rd2HTML","f":"hp_Rd2HTML","d":"These functions take the output of parse_Rd(), an\nRd object, and produce a help page from it.  As they are mainly\nintended for internal use, their interfaces are subject to change.\n","ec":"Rd2HTML(Rd, out = \"\", package = \"\", defines = .Platform$OS.type, Links = NULL, Links2 = NULL, stages = \"render\", outputEncoding = \"UTF-8\", dynamic = FALSE, no_links = FALSE, fragment = FALSE, stylesheet = if (dynamic) \"/doc/html/R.css\" else \"R.css\", texmath = getOption(\"help.htmlmath\"), concordance = FALSE, standalone = TRUE, hooks = list(), toc = isTRUE(getOption(\"help.htmltoc\")), Rhtml = FALSE, ...)"},{"p":"tools","o":"buildVignettes","f":"hp_buildVignettes","d":"Run Sweave (or other custom weave function)\nand texi2pdf on all vignettes\nof a package, or list the vignettes.\n","ec":"buildVignettes(package, dir, lib.loc = NULL, quiet = TRUE, clean = TRUE, tangle = FALSE, skip = NULL, ser_elibs = NULL)"},{"p":"tools","o":"vignetteEngine","f":"hp_vignetteEngine","d":"Vignettes are normally processed by Sweave, but package\nwriters may choose to use a different engine (e.g., one provided by the\nknitr, noweb or R.rsp packages).  This function\nis used by those packages to register their engines, and internally by\nR to retrieve them.\n","ec":"vignetteEngine(name, weave, tangle, pattern = NULL, package = NULL, aspell = list())"},{"p":"tools","o":"Rcmd","f":"hp_Rcmd","d":"Invoke R CMD tools from within R.\n","ec":"Rcmd(args, ...)"},{"p":"tools","o":"summarize_CRAN_check_status","f":"hp_summarize_CRAN_check_status","d":"Tools for obtaining information about current packages in the\nCRAN package repository, and their check status.\n","ec":"summarize_CRAN_check_status(packages, results = NULL, details = NULL, issues = NULL)"},{"p":"tools","o":"check_packages_in_dir_details","f":"hp_check_packages_in_dir_details","d":"Check source packages in a given directory, optionally with their\nreverse dependencies.\n","ec":"check_packages_in_dir_details(dir, logs = NULL, drop_ok = TRUE, ...)"},{"p":"tools","o":"Rdiff","f":"hp_Rdiff","d":"Given two R output files, compute differences ignoring headers,\nfooters and some other differences.\n","ec":"Rdiff(from, to, useDiff = FALSE, forEx = FALSE, nullPointers = TRUE, Log = FALSE)"},{"p":"tools","o":"xgettext","f":"hp_xgettext","d":"For each file in the <U+2018>R<U+2019> directory (including system-specific\nsubdirectories) of a source package, extract the unique arguments passed\nto these <U+201C>message generating<U+201D> calls;\n","ec":"xgettext(dir, verbose = FALSE, asCall = TRUE)"},{"p":"tools","o":"pkgVignettes","f":"hp_pkgVignettes","d":"Run Sweave (or other custom weave function)\nand texi2pdf on all vignettes\nof a package, or list the vignettes.\n","ec":"pkgVignettes(package, dir, subdirs = NULL, lib.loc = NULL, output = FALSE, source = FALSE, check = FALSE)"},{"p":"tools","o":"latexToUtf8","f":"hp_latexToUtf8","d":"The parseLatex function parses LaTeX source, producing a\nstructured object; deparseLatex reverses the process.  The\nlatexToUtf8 function takes a LaTeX object, and processes a number\nof different macros to convert them into the corresponding UTF-8\ncharacters.\n","ec":"latexToUtf8(x)"},{"p":"tools","o":"update_PACKAGES","f":"hp_update_PACKAGES","d":"Update an existing repository by reading the PACKAGES\nfile, retaining entries which are still valid, removing entries which\nare no longer valid, and only processing built package tarballs which do not\nmatch existing entries.\n","ec":"update_PACKAGES(dir = \".\", fields = NULL, type = c(\"source\", \"mac.binary\", \"win.binary\"), verbose.level = as.integer(dryrun), latestOnly = TRUE, addFiles = FALSE, rds_compress = \"xz\", strict = TRUE, dryrun = FALSE)"},{"p":"tools","o":"getVignetteInfo","f":"hp_getVignetteInfo","d":"This function gets information on installed vignettes.\n","ec":"getVignetteInfo(package = NULL, lib.loc = NULL, all = TRUE)"},{"p":"tools","o":"SIGSTOP","f":"hp_SIGSTOP","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"SIGINT","f":"hp_SIGINT","d":"pskill sends a signal to a process, usually to terminate it.\n","ec":""},{"p":"tools","o":"showNonASCIIfile","f":"hp_showNonASCIIfile","d":"This function prints elements of a character vector which contain\nnon-ASCII bytes, printing such bytes as a escape like <U+2018><U+2060><fc><U+2060><U+2019>.\n","ec":"showNonASCIIfile(file)"},{"p":"tools","o":"add_datalist","f":"hp_add_datalist","d":"The data() command with no arguments lists all the\ndatasets available via data in attached packages, and to do so a\nper-package list is installed.  Creating that list at install time can\nbe slow for packages with huge datasets, and can be expedited by a\nsupplying <U+2018>data/datalist<U+2019> file.\n","ec":"add_datalist(pkgpath, force = FALSE, small.size = 1024^2)"},{"p":"tools","o":"checkPoFiles","f":"hp_checkPoFiles","d":"These functions compare formats embedded in English messages\nwith translated strings to check for consistency.  checkPoFile\nchecks one file, while checkPoFiles checks all files for specified\nor all languages.\n","ec":"checkPoFiles(language, dir = \".\")"},{"p":"tools","o":"toTitleCase","f":"hp_toTitleCase","d":"Convert a character vector to title case, especially package titles.\n","ec":"toTitleCase(text)"},{"p":"tools","o":"package_dependencies","f":"hp_package_dependencies","d":"Find (recursively) dependencies or reverse dependencies of packages.\n","ec":"package_dependencies(packages = NULL, db = NULL, which = \"strong\", recursive = FALSE, reverse = FALSE, verbose = getOption(\"verbose\"))"},{"p":"tools","o":"getBibstyle","f":"hp_getBibstyle","d":"This function defines and registers styles for rendering\nbibentry objects into <U+2018>Rd<U+2019> format, for later\nconversion to text, HTML, etc.\n","ec":"getBibstyle(all = FALSE)"},{"p":"tools","o":"checkTnF","f":"hp_checkTnF","d":"Checks the specified R package or code file for occurrences of\nT or F, and gathers the expression containing these.\nThis is useful as in R T and F are just variables which\nare set to the logicals TRUE and FALSE by default, but\nare not reserved words and hence can be overwritten by the user.\nHence, one should always use TRUE and FALSE for the\nlogicals.\n","ec":"checkTnF(package, dir, file, lib.loc = NULL)"},{"p":"tools","o":"make_translations_pkg","f":"hp_make_translations_pkg","d":"A utility for R Core members to prepare a package of updated translations.\n","ec":"make_translations_pkg(srcdir, outDir = \".\", append = \"-1\")"},{"p":"tools","o":"RdTextFilter","f":"hp_RdTextFilter","d":"This function blanks out all non-text in an Rd file,\nfor spell checking or other uses.\n","ec":"RdTextFilter(ifile, encoding = \"unknown\", keepSpacing = TRUE, drop = character(), keep = character(), macros = file.path(R.home(\"share\"), \"Rd\", \"macros\", \"system.Rd\"))"},{"p":"tzdb","o":"tzdb_initialize","f":"hp_tzdb_initialize","d":"tzdb_initialize() is intended to be called from a client package's\n.onLoad() as tzdb::tzdb_initialize() to ensure that the tzdb package\nhas been loaded.\n","ec":"tzdb_initialize()"},{"p":"tzdb","o":"tzdb_names","f":"hp_tzdb_names","d":"tzdb_names() returns the time zone names found in the database.\n","ec":"tzdb_names()"},{"p":"tzdb","o":"tzdb_path","f":"hp_tzdb_path","d":"Retrieve the path to the time zone database\n","ec":"tzdb_path(type)"},{"p":"tzdb","o":"tzdb_version","f":"hp_tzdb_version","d":"tzdb_version() returns the version of the time zone database currently in\nuse.\n","ec":"tzdb_version()"},{"p":"utf8","o":"output_utf8","f":"hp_output_utf8","d":"Test whether the output connection has ANSI style escape support\nor UTF-8 support.\n","ec":"output_utf8()"},{"p":"utf8","o":"utf8_format","f":"hp_utf8_format","d":"Format a character object for UTF-8 printing.\n","ec":"utf8_format(x, trim = FALSE, chars = NULL, justify = \"left\", width = NULL, na.encode = TRUE, quote = FALSE, na.print = NULL, print.gap = NULL, utf8 = NULL, ...)"},{"p":"utf8","o":"utf8_print","f":"hp_utf8_print","d":"Print a UTF-8 character object.\n","ec":"utf8_print(x, chars = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, right = FALSE, max = NULL, names = NULL, rownames = NULL, escapes = NULL, display = TRUE, style = TRUE, utf8 = NULL, ...)"},{"p":"utf8","o":"output_ansi","f":"hp_output_ansi","d":"Test whether the output connection has ANSI style escape support\nor UTF-8 support.\n","ec":"output_ansi()"},{"p":"utf8","o":"utf8_width","f":"hp_utf8_width","d":"Compute the display widths of the elements of a character object.\n","ec":"utf8_width(x, encode = TRUE, quote = FALSE, utf8 = NULL)"},{"p":"utf8","o":"as_utf8","f":"hp_as_utf8","d":"UTF-8 text encoding and validation.\n","ec":"as_utf8(x, normalize = FALSE)"},{"p":"utf8","o":"utf8_normalize","f":"hp_utf8_normalize","d":"Transform text to normalized form, optionally mapping to lowercase\nand applying compatibility maps.\n","ec":"utf8_normalize(x, map_case = FALSE, map_compat = FALSE, map_quote = FALSE, remove_ignorable = FALSE)"},{"p":"utf8","o":"utf8_valid","f":"hp_utf8_valid","d":"UTF-8 text encoding and validation.\n","ec":"utf8_valid(x)"},{"p":"utf8","o":"utf8_encode","f":"hp_utf8_encode","d":"Escape the strings in a character object, optionally adding\nquotes or spaces, adjusting the width for display.\n","ec":"utf8_encode(x, width = 0L, quote = FALSE, justify = \"left\", escapes = NULL, display = FALSE, utf8 = NULL)"},{"p":"utils","o":"write.socket","f":"hp_write.socket","d":"read.socket reads a string from the specified socket,\nwrite.socket writes to the specified socket.  There is very\nlittle error checking done by either.\n","ec":"write.socket(socket, string)"},{"p":"utils","o":"fixInNamespace","f":"hp_fixInNamespace","d":"Utility functions to access and replace the non-exported functions in\na namespace, for use in developing packages with namespaces.\n","ec":"fixInNamespace(x, ns, pos = -1, envir = as.environment(pos), ...)"},{"p":"utils","o":"changedFiles","f":"hp_changedFiles","d":"fileSnapshot takes a snapshot of a selection of files,\nrecording summary information about each.  changedFiles\ncompares two snapshots, or compares one snapshot to the current state\nof the file system.  The snapshots need not be the same directory;\nthis could be used to compare two directories.\n","ec":"changedFiles(before, after, path = before$path, timestamp = before$timestamp, check.file.info = c(\"size\", \"isdir\", \"mode\", \"mtime\"), md5sum = before$md5sum, digest = before$digest, full.names = before$full.names, ...)"},{"p":"utils","o":"history","f":"hp_history","d":"Load or save or display the commands history.\n","ec":"history(max.show = 25, reverse = FALSE, pattern, ...)"},{"p":"utils","o":"SweaveHooks","f":"hp_SweaveHooks","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"SweaveHooks(options, run = FALSE, envir = .GlobalEnv)"},{"p":"utils","o":"packageDate","f":"hp_packageDate","d":"Parses and returns the <U+2018>DESCRIPTION<U+2019> file of a package as a\n\"packageDescription\".\n","ec":"packageDate(pkg, lib.loc = NULL, date.fields = c(\"Date\", \"Packaged\", \"Date/Publication\", \"Built\"), tryFormats = c(\"%Y-%m-%d\", \"%Y/%m/%d\", \"%D\", \"%m/%d/%y\"), desc = packageDescription(pkg, lib.loc = lib.loc, fields = date.fields))"},{"p":"utils","o":"installed.packages","f":"hp_installed.packages","d":"Find (or retrieve) details of all packages installed in the specified\nlibraries.\n","ec":"installed.packages(lib.loc = NULL, priority = NULL, noCache = FALSE, fields = NULL, subarch = .Platform$r_arch, ...)"},{"p":"utils","o":"citEntry","f":"hp_citEntry","d":"Old interface providing functionality for specifying bibliographic \ninformation in enhanced BibTeX style.  Since R 2.14.0 this has been \nsuperseded by bibentry.\n","ec":"citEntry(entry, textVersion = NULL, header = NULL, footer = NULL, ...)"},{"p":"utils","o":"as.roman","f":"hp_as.roman","d":"Simple manipulation of (a small set of) integer numbers as roman numerals.\n","ec":"as.roman(x)"},{"p":"utils","o":".romans","f":"hp_.romans","d":"Simple manipulation of (a small set of) integer numbers as roman numerals.\n","ec":""},{"p":"utils","o":"suppressForeignCheck","f":"hp_suppressForeignCheck","d":"For globalVariables, the names supplied are of functions or\nother objects that should be regarded as defined globally when the\ncheck tool is applied to this package.  The call to\nglobalVariables will be included in the package's source.\nRepeated calls in the same package accumulate the names of the\nglobal variables.\n","ec":"suppressForeignCheck(names, package, add = TRUE)"},{"p":"utils","o":"aregexec","f":"hp_aregexec","d":"Determine positions of approximate string matches.\n","ec":"aregexec(pattern, text, max.distance = 0.1, costs = NULL, ignore.case = FALSE, fixed = FALSE, useBytes = FALSE)"},{"p":"utils","o":"txtProgressBar","f":"hp_txtProgressBar","d":"Text progress bar in the R console.\n","ec":"txtProgressBar(min = 0, max = 1, initial = 0, char = \"=\", width = NA, title, label, style = 1, file = \"\")"},{"p":"utils","o":"strcapture","f":"hp_strcapture","d":"Given a character vector and a regular expression containing capture\nexpressions, strcapture will extract the captured tokens into a\ntabular data structure, such as a data.frame, the type and structure of\nwhich is specified by a prototype object. The assumption is that the\nsame number of tokens are captured from every input string. \n","ec":"strcapture(pattern, x, proto, perl = FALSE, useBytes = FALSE)"},{"p":"utils","o":"xemacs","f":"hp_xemacs","d":"Invoke a text editor on an R object.\n","ec":"xemacs(name = NULL, file = \"\")"},{"p":"utils","o":"rtags","f":"hp_rtags","d":"rtags provides etags-like indexing capabilities for R code,\nusing R's own parser.\n","ec":"rtags(path = \".\", pattern = \"\\\\.[RrSs]$\", recursive = FALSE, src = list.files(path = path, pattern = pattern, full.names = TRUE, recursive = recursive), keep.re = NULL, ofile = \"\", append = FALSE, verbose = getOption(\"verbose\"), type = c(\"etags\", \"ctags\"))"},{"p":"utils","o":"as.person","f":"hp_as.person","d":"A class and utility methods for holding information about persons\nlike name and email address.\n","ec":"as.person(x)"},{"p":"utils","o":"maintainer","f":"hp_maintainer","d":"Show the name and email address of the maintainer of an installed package.\n","ec":"maintainer(pkg)"},{"p":"utils","o":"aspell","f":"hp_aspell","d":"Spell check given files via Aspell, Hunspell or Ispell.\n","ec":"aspell(files, filter, control = list(), encoding = \"unknown\", program = NULL, dictionaries = character())"},{"p":"utils","o":"bug.report","f":"hp_bug.report","d":"Invokes an editor or email program to write a bug report or opens a\nweb page for bug submission.  Some standard information on the current\nversion and configuration of R are included automatically.\n","ec":"bug.report(subject = \"\", address, file = \"R.bug.report\", package = NULL, lib.loc = NULL, ...)"},{"p":"utils","o":"capture.output","f":"hp_capture.output","d":"Evaluates its arguments with the output being returned as a character\nstring or sent to a file.  Related to sink similarly to how\nwith is related to attach.\n","ec":"capture.output(..., file = NULL, append = FALSE, type = c(\"output\", \"message\"), split = FALSE)"},{"p":"utils","o":"remhash","f":"hp_remhash","d":"Create and manipulate mutable hash tables.\n","ec":"remhash(h, key)"},{"p":"utils","o":"assignInMyNamespace","f":"hp_assignInMyNamespace","d":"Utility functions to access and replace the non-exported functions in\na namespace, for use in developing packages with namespaces.\n","ec":"assignInMyNamespace(x, value)"},{"p":"utils","o":"aspell_package_vignettes","f":"hp_aspell_package_vignettes","d":"Utilities for spell checking packages via Aspell, Hunspell or Ispell.\n","ec":"aspell_package_vignettes(dir, control = list(), program = NULL, dictionaries = character())"},{"p":"utils","o":"memory.limit","f":"hp_memory.limit","d":"These functions are currently stubs which report infinity\n(Inf) with a warning on all platforms.  OS's own facilities\ncan be used on some systems to limit memory allocation.\n\n","ec":"memory.limit(size = NA)"},{"p":"utils","o":"person","f":"hp_person","d":"A class and utility methods for holding information about persons\nlike name and email address.\n","ec":"person(given = NULL, family = NULL, middle = NULL, email = NULL, role = NULL, comment = NULL, first = NULL, last = NULL)"},{"p":"utils","o":"ls.str","f":"hp_ls.str","d":"ls.str and lsf.str are variations of ls\napplying str() to each matched name: see section Value.\n","ec":"ls.str(pos = -1, name, envir, all.names = FALSE, pattern, mode = \"any\")"},{"p":"utils","o":"read.delim2","f":"hp_read.delim2","d":"Reads a file in table format and creates a data frame from it, with\ncases corresponding to lines and variables to fields in the file.\n","ec":"read.delim2(file, header = TRUE, sep = \"\\t\", quote = \"\\\"\", dec = \",\", fill = TRUE, comment.char = \"\", ...)"},{"p":"utils","o":"RweaveLatexWritedoc","f":"hp_RweaveLatexWritedoc","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveLatexWritedoc(object, chunk)"},{"p":"utils","o":"hasName","f":"hp_hasName","d":"hasName is a convenient way to test for one or more names\nin an R object.\n","ec":"hasName(x, name)"},{"p":"utils","o":"getTxtProgressBar","f":"hp_getTxtProgressBar","d":"Text progress bar in the R console.\n","ec":"getTxtProgressBar(pb)"},{"p":"utils","o":"news","f":"hp_news","d":"Build and query the news data base for R or add-on packages.\n","ec":"news(query, package = \"R\", lib.loc = NULL, format = NULL, reader = NULL, db = NULL)"},{"p":"utils","o":"typhash","f":"hp_typhash","d":"Create and manipulate mutable hash tables.\n","ec":"typhash(h)"},{"p":"utils","o":"read.csv","f":"hp_read.csv","d":"Reads a file in table format and creates a data frame from it, with\ncases corresponding to lines and variables to fields in the file.\n","ec":"read.csv(file, header = TRUE, sep = \",\", quote = \"\\\"\", dec = \".\", fill = TRUE, comment.char = \"\", ...)"},{"p":"utils","o":"RSiteSearch","f":"hp_RSiteSearch","d":"Search for key words or phrases in various documentation, such as\nR manuals, help pages of base and CRAN packages, vignettes, task views and others, using the search engine\nat https://search.r-project.org and view them in a web browser.\n","ec":"RSiteSearch(string, restrict = c(\"functions\", \"descriptions\", \"news\", \"Rfunctions\", \"Rmanuals\", \"READMEs\", \"views\", \"vignettes\"), format, sortby = c(\"score\", \"date:late\", \"date:early\", \"subject\", \"subject:descending\", \"size\", \"size:descending\"), matchesPerPage = 20, words = c(\"all\", \"any\"))"},{"p":"utils","o":"debugger","f":"hp_debugger","d":"Functions to dump the evaluation environments (frames) and to examine\ndumped frames.\n","ec":"debugger(dump = last.dump)"},{"p":"utils","o":"demo","f":"hp_demo","d":"demo is a user-friendly interface to running some demonstration\nR scripts.  demo() gives the list of available topics.\n","ec":"demo(topic, package = NULL, lib.loc = NULL, character.only = FALSE, verbose = getOption(\"verbose\"), type = c(\"console\", \"html\"), echo = TRUE, ask = getOption(\"demo.ask\"), encoding = getOption(\"encoding\"))"},{"p":"utils","o":"isS3stdGeneric","f":"hp_isS3stdGeneric","d":"Determines whether f acts as a standard S3-style generic\nfunction.\n","ec":"isS3stdGeneric(f)"},{"p":"utils","o":"Sweave","f":"hp_Sweave","d":"Sweave provides a flexible framework for mixing text and R/S code\nfor automatic report generation.  The basic idea is to replace the\ncode with its output, such that the final document only contains the\ntext and the output of the statistical analysis: however, the source\ncode can also be included.\n","ec":"Sweave(file, driver = RweaveLatex(), syntax = getOption(\"SweaveSyntax\"), encoding = \"\", ...)"},{"p":"utils","o":"nsl","f":"hp_nsl","d":"Interface to the system gethostbyname, currently available\nonly on unix-alikes, i.e., not on Windows.\n","ec":"nsl(hostname)"},{"p":"utils","o":"modifyList","f":"hp_modifyList","d":"Modifies a possibly nested list recursively by changing a subset of\nelements at each level to match a second list.\n","ec":"modifyList(x, val, keep.null = FALSE)"},{"p":"utils","o":"promptData","f":"hp_promptData","d":"Generates a shell of documentation for a data set.\n","ec":"promptData(object, filename = NULL, name = NULL)"},{"p":"utils","o":"help.request","f":"hp_help.request","d":"Prompts the user to check they have done all that is expected of them\nbefore sending a post to the R-help mailing list, provides a template\nfor the post with session information included and optionally sends\nthe email (on Unix systems).\n","ec":"help.request(subject = \"\", address = \"r-help@R-project.org\", file = \"R.help.request\", ...)"},{"p":"utils","o":"alarm","f":"hp_alarm","d":"Gives an audible or visual signal to the user.\n","ec":"alarm()"},{"p":"utils","o":".DollarNames","f":"hp_.DollarNames","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":".DollarNames(x, pattern)"},{"p":"utils","o":"promptImport","f":"hp_promptImport","d":"Facilitate the constructing of files documenting R objects.\n","ec":"promptImport(object, filename = NULL, name = NULL, importedFrom = NULL, importPage = name, ...)"},{"p":"utils","o":"close.socket","f":"hp_close.socket","d":"Closes the socket and frees the space in the file descriptor table.  The\nport may not be freed immediately.\n","ec":"close.socket(socket, ...)"},{"p":"utils","o":"read.csv2","f":"hp_read.csv2","d":"Reads a file in table format and creates a data frame from it, with\ncases corresponding to lines and variables to fields in the file.\n","ec":"read.csv2(file, header = TRUE, sep = \";\", quote = \"\\\"\", dec = \",\", fill = TRUE, comment.char = \"\", ...)"},{"p":"utils","o":"zip","f":"hp_zip","d":"A wrapper for an external zip command to create zip archives.\n","ec":"zip(zipfile, files, flags = \"-r9X\", extras = \"\", zip = Sys.getenv(\"R_ZIPCMD\", \"zip\"))"},{"p":"utils","o":"hsearch_db_concepts","f":"hp_hsearch_db_concepts","d":"Utilities for searching the help system.\n","ec":"hsearch_db_concepts(db = hsearch_db())"},{"p":"utils","o":"assignInNamespace","f":"hp_assignInNamespace","d":"Utility functions to access and replace the non-exported functions in\na namespace, for use in developing packages with namespaces.\n","ec":"assignInNamespace(x, value, ns, pos = -1, envir = as.environment(pos))"},{"p":"utils","o":"askYesNo","f":"hp_askYesNo","d":"askYesNo provides a standard way to ask the user a yes/no question.  \nIt provides a way for front-ends to substitute their own dialogs.\n","ec":"askYesNo(msg, default = TRUE, prompts = getOption(\"askYesNo\", gettext(c(\"Yes\", \"No\", \"Cancel\"))), ...)"},{"p":"utils","o":"read.delim","f":"hp_read.delim","d":"Reads a file in table format and creates a data frame from it, with\ncases corresponding to lines and variables to fields in the file.\n","ec":"read.delim(file, header = TRUE, sep = \"\\t\", quote = \"\\\"\", dec = \".\", fill = TRUE, comment.char = \"\", ...)"},{"p":"utils","o":"limitedLabels","f":"hp_limitedLabels","d":"Functions to dump the evaluation environments (frames) and to examine\ndumped frames.\n","ec":"limitedLabels(value, maxwidth = getOption(\"width\") - 5L)"},{"p":"utils","o":"is.relistable","f":"hp_is.relistable","d":"relist() is an S3 generic function with a few methods in order\nto allow easy inversion of unlist(obj) when that is used\nwith an object obj of (S3) class \"relistable\".\n","ec":"is.relistable(x)"},{"p":"utils","o":"toLatex","f":"hp_toLatex","d":"These methods convert R objects to character vectors with\nBibTeX or LaTeX markup.\n","ec":"toLatex(object, ...)"},{"p":"utils","o":"citFooter","f":"hp_citFooter","d":"How to cite R and R packages in publications.\n","ec":"citFooter(...)"},{"p":"utils","o":"head.matrix","f":"hp_head.matrix","d":"Returns the first or last parts of a vector, matrix, table, data frame\nor function.  Since head() and tail() are generic\nfunctions, they may also have been extended to other classes.\n","ec":"head.matrix(x, n = 6L, ...)"},{"p":"utils","o":"View","f":"hp_View","d":"Invoke a spreadsheet-style data viewer on a matrix-like R object.\n","ec":"View(x, title)"},{"p":"utils","o":"findMatches","f":"hp_findMatches","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":"findMatches(pattern, values, fuzzy, backtick)"},{"p":"utils","o":"create.post","f":"hp_create.post","d":"An ancillary function used by bug.report and\nhelp.request to prepare emails for submission to package\nmaintainers or to R mailing lists.\n","ec":"create.post(instructions = character(), description = \"post\", subject = \"\", method = getOption(\"mailer\"), address = \"the relevant mailing list\", ccaddress = getOption(\"ccaddress\", \"\"), filename = \"R.post\", info = character())"},{"p":"utils","o":"globalVariables","f":"hp_globalVariables","d":"For globalVariables, the names supplied are of functions or\nother objects that should be regarded as defined globally when the\ncheck tool is applied to this package.  The call to\nglobalVariables will be included in the package's source.\nRepeated calls in the same package accumulate the names of the\nglobal variables.\n","ec":"globalVariables(names, package, add = TRUE)"},{"p":"utils","o":"vi","f":"hp_vi","d":"Invoke a text editor on an R object.\n","ec":"vi(name = NULL, file = \"\")"},{"p":"utils","o":"bibentry","f":"hp_bibentry","d":"Functionality for representing and manipulating bibliographic\ninformation in enhanced BibTeX style.\n","ec":"bibentry(bibtype, textVersion = NULL, header = NULL, footer = NULL, key = NULL, ..., other = list(), mheader = NULL, mfooter = NULL)"},{"p":"utils","o":"checkCRAN","f":"hp_checkCRAN","d":"Functions helping to maintain CRAN, some of them may also be useful\nfor administrators of other repository networks.\n","ec":"checkCRAN(method)"},{"p":"utils","o":"Stangle","f":"hp_Stangle","d":"Sweave provides a flexible framework for mixing text and R/S code\nfor automatic report generation.  The basic idea is to replace the\ncode with its output, such that the final document only contains the\ntext and the output of the statistical analysis: however, the source\ncode can also be included.\n","ec":"Stangle(file, driver = Rtangle(), syntax = getOption(\"SweaveSyntax\"), encoding = \"\", ...)"},{"p":"utils","o":"methods","f":"hp_methods","d":"List all available methods for a S3 and S4 generic function, or all\nmethods for an S3 or S4 class.\n","ec":"methods(generic.function, class, all.names = FALSE, dropPath = FALSE)"},{"p":"utils","o":"sethash","f":"hp_sethash","d":"Create and manipulate mutable hash tables.\n","ec":"sethash(h, key, value)"},{"p":"utils","o":"type.convert","f":"hp_type.convert","d":"Convert a data object to logical, integer, numeric, complex, character\nor factor as appropriate.\n","ec":"type.convert(x, ...)"},{"p":"utils","o":"findLineNum","f":"hp_findLineNum","d":"These functions locate objects containing particular lines of source\ncode, using the information saved when the code was parsed with\nkeep.source = TRUE.\n","ec":"findLineNum(srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv)"},{"p":"utils","o":"menu","f":"hp_menu","d":"menu presents the user with a menu of choices labelled from 1\nto the number of choices.  To exit without choosing an item one can\nselect <U+2018><U+2060>0<U+2060><U+2019>.\n","ec":"menu(choices, graphics = FALSE, title = NULL)"},{"p":"utils","o":"?","f":"hp_X.","d":"These functions provide access to documentation.\nDocumentation on a topic with name name (typically, an R\nobject or a data set) can be displayed by either help(\"name\") or\n?name.\n","ec":"?(e1, e2)"},{"p":"utils","o":"aspell_package_C_files","f":"hp_aspell_package_C_files","d":"Utilities for spell checking packages via Aspell, Hunspell or Ispell.\n","ec":"aspell_package_C_files(dir, ignore = character(), control = list(), program = NULL, dictionaries = character())"},{"p":"utils","o":"old.packages","f":"hp_old.packages","d":"old.packages indicates packages which have a (suitable) later\nversion on the repositories whereas update.packages offers to\ndownload and install such packages.\n","ec":"old.packages(lib.loc = NULL, repos = getOption(\"repos\"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, checkBuilt = FALSE, ..., type = getOption(\"pkgType\"))"},{"p":"utils","o":"hsearch_db_keywords","f":"hp_hsearch_db_keywords","d":"Utilities for searching the help system.\n","ec":"hsearch_db_keywords(db = hsearch_db())"},{"p":"utils","o":"RShowDoc","f":"hp_RShowDoc","d":"Utility function to find and display R documentation.\n","ec":"RShowDoc(what, type = c(\"pdf\", \"html\", \"txt\"), package)"},{"p":"utils","o":"browseURL","f":"hp_browseURL","d":"Load a given URL into an HTML browser.\n","ec":"browseURL(url, browser = getOption(\"browser\"), encodeIfNeeded = FALSE)"},{"p":"utils","o":"debugcall","f":"hp_debugcall","d":"Set or unset debugging flags based on a call to a function. Takes into\naccount S3/S4 method dispatch based on the classes of the arguments in\nthe call.\n","ec":"debugcall(call, once = FALSE)"},{"p":"utils","o":"is.hashtab","f":"hp_is.hashtab","d":"Create and manipulate mutable hash tables.\n","ec":"is.hashtab(x)"},{"p":"utils","o":"gethash","f":"hp_gethash","d":"Create and manipulate mutable hash tables.\n","ec":"gethash(h, key, nomatch = NULL)"},{"p":"utils","o":"setTxtProgressBar","f":"hp_setTxtProgressBar","d":"Text progress bar in the R console.\n","ec":"setTxtProgressBar(pb, value, title = NULL, label = NULL)"},{"p":"utils","o":"tail","f":"hp_tail","d":"Returns the first or last parts of a vector, matrix, table, data frame\nor function.  Since head() and tail() are generic\nfunctions, they may also have been extended to other classes.\n","ec":"tail(x, ...)"},{"p":"utils","o":"emacs","f":"hp_emacs","d":"Invoke a text editor on an R object.\n","ec":"emacs(name = NULL, file = \"\")"},{"p":"utils","o":"object.size","f":"hp_object.size","d":"Provides an estimate of the memory that is being used to store an R object.\n","ec":"object.size(x)"},{"p":"utils","o":"RweaveTryStop","f":"hp_RweaveTryStop","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveTryStop(err, options)"},{"p":"utils","o":"undebugcall","f":"hp_undebugcall","d":"Set or unset debugging flags based on a call to a function. Takes into\naccount S3/S4 method dispatch based on the classes of the arguments in\nthe call.\n","ec":"undebugcall(call)"},{"p":"utils","o":"download.file","f":"hp_download.file","d":"This function can be used to download a file from the Internet.\n","ec":"download.file(url, destfile, method, quiet = FALSE, mode = \"w\", cacheOK = TRUE, extra = getOption(\"download.file.extra\"), headers = NULL, ...)"},{"p":"utils","o":"loadhistory","f":"hp_loadhistory","d":"Load or save or display the commands history.\n","ec":"loadhistory(file = \".Rhistory\")"},{"p":"utils","o":"RweaveChunkPrefix","f":"hp_RweaveChunkPrefix","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveChunkPrefix(options)"},{"p":"utils","o":"summaryRprof","f":"hp_summaryRprof","d":"Summarise the output of the Rprof function to show the\namount of time used by different R functions.\n","ec":"summaryRprof(filename = \"Rprof.out\", chunksize = 5000, memory = c(\"none\", \"both\", \"tseries\", \"stats\"), lines = c(\"hide\", \"show\", \"both\"), index = 2, diff = TRUE, exclude = NULL, basenames = 1)"},{"p":"utils","o":"make.socket","f":"hp_make.socket","d":"With server = FALSE attempts to open a client socket to the\nspecified port and host.  With server = TRUE the R process\nlistens on the specified port for a connection and then returns a\nserver socket.  It is a good idea to use on.exit to\nensure that a socket is closed, as you only get 64 of them.\n","ec":"make.socket(host = \"localhost\", port, fail = TRUE, server = FALSE)"},{"p":"utils","o":"xedit","f":"hp_xedit","d":"Invoke a text editor on an R object.\n","ec":"xedit(name = NULL, file = \"\")"},{"p":"utils","o":"data","f":"hp_data","d":"Loads specified data sets, or list the available data sets.\n","ec":"data(..., list = character(), package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"), envir = .GlobalEnv, overwrite = TRUE)"},{"p":"utils","o":"charClass","f":"hp_charClass","d":"An interface to the (C99) wide character classification functions in use.\n","ec":"charClass(x, class)"},{"p":"utils","o":"RtangleSetup","f":"hp_RtangleSetup","d":"A driver for Stangle that extracts R code chunks.\nNotably all RtangleSetup() arguments may be used as arguments\nin the Stangle() call.\n","ec":"RtangleSetup(file, syntax, output = NULL, annotate = TRUE, split = FALSE, quiet = FALSE, drop.evalFALSE = FALSE, ...)"},{"p":"utils","o":"browseEnv","f":"hp_browseEnv","d":"The browseEnv function opens a browser with list of objects\ncurrently in sys.frame() environment.\n","ec":"browseEnv(envir = .GlobalEnv, pattern, excludepatt = \"^last\\\\.warning\", html = .Platform$GUI != \"AQUA\", expanded = TRUE, properties = NULL, main = NULL, debugMe = FALSE)"},{"p":"utils","o":"update.packages","f":"hp_update.packages","d":"old.packages indicates packages which have a (suitable) later\nversion on the repositories whereas update.packages offers to\ndownload and install such packages.\n","ec":"update.packages(lib.loc = NULL, repos = getOption(\"repos\"), contriburl = contrib.url(repos, type), method, instlib = NULL, ask = TRUE, available = NULL, oldPkgs = NULL, ..., checkBuilt = FALSE, type = getOption(\"pkgType\"))"},{"p":"utils","o":"untar","f":"hp_untar","d":"Extract files from or list the contents of a tar archive.\n","ec":"untar(tarfile, files = NULL, list = FALSE, exdir = \".\", compressed = NA, extras = NULL, verbose = FALSE, restore_times = TRUE, support_old_tars = Sys.getenv(\"R_SUPPORT_OLD_TARS\", FALSE), tar = Sys.getenv(\"TAR\"))"},{"p":"utils","o":"tail.matrix","f":"hp_tail.matrix","d":"Returns the first or last parts of a vector, matrix, table, data frame\nor function.  Since head() and tail() are generic\nfunctions, they may also have been extended to other classes.\n","ec":"tail.matrix(x, n = 6L, keepnums = TRUE, addrownums, ...)"},{"p":"utils","o":"getS3method","f":"hp_getS3method","d":"Get a method for an S3 generic, possibly from a namespace or the\ngeneric's registry.\n","ec":"getS3method(f, class, optional = FALSE, envir = parent.frame())"},{"p":"utils","o":"write.table","f":"hp_write.table","d":"write.table prints its required argument x (after\nconverting it to a data frame if it is not one nor a matrix) to\na file or connection.\n","ec":"write.table(x, file = \"\", append = FALSE, quote = TRUE, sep = \" \", eol = \"\\n\", na = \"NA\", dec = \".\", row.names = TRUE, col.names = TRUE, qmethod = c(\"escape\", \"double\"), fileEncoding = \"\")"},{"p":"utils","o":"strOptions","f":"hp_strOptions","d":"Compactly display the internal structure of an R object, a\ndiagnostic function and an alternative to summary\n(and to some extent, dput).  Ideally, only one line for\neach <U+2018>basic<U+2019> structure is displayed.  It is especially well suited\nto compactly display the (abbreviated) contents of (possibly nested)\nlists.  The idea is to give reasonable output for any R\nobject.  It calls args for (non-primitive) function objects.\n","ec":"strOptions(strict.width = \"no\", digits.d = 3L, vec.len = 4L, list.len = 99L, deparse.lines = NULL, drop.deparse.attr = TRUE, formatNum = function(x, ...) format(x, trim = TRUE, drop0trailing = TRUE, ...))"},{"p":"utils","o":"rc.status","f":"hp_rc.status","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":"rc.status()"},{"p":"utils","o":"asDateBuilt","f":"hp_asDateBuilt","d":"Parses and returns the <U+2018>DESCRIPTION<U+2019> file of a package as a\n\"packageDescription\".\n","ec":"asDateBuilt(built)"},{"p":"utils","o":"Rprofmem","f":"hp_Rprofmem","d":"Enable or disable reporting of memory allocation in R.\n","ec":"Rprofmem(filename = \"Rprofmem.out\", append = FALSE, threshold = 0)"},{"p":"utils","o":"apropos","f":"hp_apropos","d":"apropos() returns a character vector giving the names of\nobjects in the search list matching (as a regular expression)\nwhat.\n","ec":"apropos(what, where = FALSE, ignore.case = TRUE, dot_internals = FALSE, mode = \"any\")"},{"p":"utils","o":"getSrcDirectory","f":"hp_getSrcDirectory","d":"These functions extract information from source references.\n","ec":"getSrcDirectory(x, unique = TRUE)"},{"p":"utils","o":"as.relistable","f":"hp_as.relistable","d":"relist() is an S3 generic function with a few methods in order\nto allow easy inversion of unlist(obj) when that is used\nwith an object obj of (S3) class \"relistable\".\n","ec":"as.relistable(x)"},{"p":"utils","o":"SweaveSyntaxNoweb","f":"hp_SweaveSyntaxNoweb","d":"Sweave provides a flexible framework for mixing text and R/S code\nfor automatic report generation.  The basic idea is to replace the\ncode with its output, such that the final document only contains the\ntext and the output of the statistical analysis: however, the source\ncode can also be included.\n","ec":""},{"p":"utils","o":"SweaveSyntaxLatex","f":"hp_SweaveSyntaxLatex","d":"Sweave provides a flexible framework for mixing text and R/S code\nfor automatic report generation.  The basic idea is to replace the\ncode with its output, such that the final document only contains the\ntext and the output of the statistical analysis: however, the source\ncode can also be included.\n","ec":""},{"p":"utils","o":"citeNatbib","f":"hp_citeNatbib","d":"Cite a bibentry object in text.  The cite() function\nuses the cite() function from the default\nbibstyle if present, or citeNatbib() if not.\nciteNatbib() uses a style similar to that used by the LaTeX\npackage natbib.\n","ec":"citeNatbib(keys, bib, textual = FALSE, before = NULL, after = NULL, mode = c(\"authoryear\", \"numbers\", \"super\"), abbreviate = TRUE, longnamesfirst = TRUE, bibpunct = c(\"(\", \")\", \";\", \"a\", \"\", \",\"), previous)"},{"p":"utils","o":"read.fwf","f":"hp_read.fwf","d":"Read a table of fixed width formatted\ndata into a data.frame.\n","ec":"read.fwf(file, widths, header = FALSE, sep = \"\\t\", skip = 0L, row.names, col.names, n = -1L, buffersize = 2000, fileEncoding = \"\", ...)"},{"p":"utils","o":"de.setup","f":"hp_de.setup","d":"Internal utils functions\n","ec":"de.setup(ilist, list.names, incols)"},{"p":"utils","o":"removeSource","f":"hp_removeSource","d":"When options(\"keep.source\") is TRUE, a copy of the\noriginal source code to a function is stored with it.  Similarly,\nparse() may keep formatted source for an expression.\nSuch source reference attributes are removed from the object by\nremoveSource().\n","ec":"removeSource(fn)"},{"p":"utils","o":"data.entry","f":"hp_data.entry","d":"A spreadsheet-like editor for entering or editing data.\n","ec":"data.entry(..., Modes = NULL, Names = NULL)"},{"p":"utils","o":"packageVersion","f":"hp_packageVersion","d":"Parses and returns the <U+2018>DESCRIPTION<U+2019> file of a package as a\n\"packageDescription\".\n","ec":"packageVersion(pkg, lib.loc = NULL)"},{"p":"utils","o":"as.personList","f":"hp_as.personList","d":"Old interface providing functionality for information about\ncollections of persons.  Since R 2.14.0 person objects\ncan be combined with the corresponding c method which\nsupersedes the personList function.\n","ec":"as.personList(x)"},{"p":"utils","o":"citation","f":"hp_citation","d":"How to cite R and R packages in publications.\n","ec":"citation(package = \"base\", lib.loc = NULL, auto = NULL)"},{"p":"utils","o":"citHeader","f":"hp_citHeader","d":"How to cite R and R packages in publications.\n","ec":"citHeader(...)"},{"p":"utils","o":"read.fortran","f":"hp_read.fortran","d":"Read fixed-format data files using Fortran-style format specifications.\n","ec":"read.fortran(file, format, ..., as.is = TRUE, colClasses = NA)"},{"p":"utils","o":"findCRANmirror","f":"hp_findCRANmirror","d":"Find out if a CRAN mirror has been selected for the current session.\n","ec":"findCRANmirror(type = c(\"src\", \"web\"))"},{"p":"utils","o":"aspell_package_R_files","f":"hp_aspell_package_R_files","d":"Utilities for spell checking packages via Aspell, Hunspell or Ispell.\n","ec":"aspell_package_R_files(dir, ignore = character(), control = list(), program = NULL, dictionaries = character())"},{"p":"utils","o":"RtangleFinish","f":"hp_RtangleFinish","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RtangleFinish(object, error = FALSE)"},{"p":"utils","o":"hashtab","f":"hp_hashtab","d":"Create and manipulate mutable hash tables.\n","ec":"hashtab(type = c(\"identical\", \"address\"), size)"},{"p":"utils","o":"rc.getOption","f":"hp_rc.getOption","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":"rc.getOption(name)"},{"p":"utils","o":"RtangleWritedoc","f":"hp_RtangleWritedoc","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RtangleWritedoc(object, chunk)"},{"p":"utils","o":"readCitationFile","f":"hp_readCitationFile","d":"How to cite R and R packages in publications.\n","ec":"readCitationFile(file, meta = NULL)"},{"p":"utils","o":"stack","f":"hp_stack","d":"Stacking vectors concatenates multiple vectors into a single vector\nalong with a factor indicating where each observation originated.\nUnstacking reverses this operation.\n","ec":"stack(x, ...)"},{"p":"utils","o":"package.skeleton","f":"hp_package.skeleton","d":"package.skeleton automates some of the setup for a new source\npackage.  It creates directories, saves functions, data, and R code files to\nappropriate places, and creates skeleton help files and a\n<U+2018>Read-and-delete-me<U+2019> file describing further steps in packaging.\n","ec":"package.skeleton(name = \"anRpackage\", list = character(), environment = .GlobalEnv, path = \".\", force = FALSE, code_files = character(), encoding = \"unknown\")"},{"p":"utils","o":"memory.size","f":"hp_memory.size","d":"These functions are currently stubs which report infinity\n(Inf) with a warning on all platforms.  OS's own facilities\ncan be used on some systems to limit memory allocation.\n\n","ec":"memory.size(max = FALSE)"},{"p":"utils","o":"de.ncols","f":"hp_de.ncols","d":"Internal utils functions\n","ec":"de.ncols(inlist)"},{"p":"utils","o":"file.edit","f":"hp_file.edit","d":"Edit one or more files in a text editor.","ec":"file.edit(..., title = file, editor = getOption(\"editor\"), fileEncoding = \"\")"},{"p":"utils","o":"sessionInfo","f":"hp_sessionInfo","d":"Get and report version information about R, the OS and attached or\nloaded packages.\n","ec":"sessionInfo(package = NULL)"},{"p":"utils","o":"SweaveSyntConv","f":"hp_SweaveSyntConv","d":"This function converts the syntax of files in Sweave\nformat to another Sweave syntax definition.\n","ec":"SweaveSyntConv(file, syntax, output = NULL)"},{"p":"utils","o":"RweaveLatex","f":"hp_RweaveLatex","d":"A driver for Sweave that translates R code chunks in\nLaTeX files by <U+201C>running them<U+201D>, i.e., parse() and\neval() each.\n","ec":"RweaveLatex()"},{"p":"utils","o":"help","f":"hp_help","d":"help is the primary interface to the help systems.\n","ec":"help(topic, package = NULL, lib.loc = NULL, verbose = getOption(\"verbose\"), try.all.packages = getOption(\"help.try.all.packages\"), help_type = getOption(\"help_type\"))"},{"p":"utils","o":"prompt","f":"hp_prompt","d":"Facilitate the constructing of files documenting R objects.\n","ec":"prompt(object, filename = NULL, name = NULL, ...)"},{"p":"utils","o":"getParseText","f":"hp_getParseText","d":"If the \"keep.source\" option is TRUE, R's parser\nwill attach detailed information on the object it has parsed.  These\nfunctions retrieve that information.\n","ec":"getParseText(parseData, id)"},{"p":"utils","o":"osVersion","f":"hp_osVersion","d":"-NA-","ec":"-NA-"},{"p":"utils","o":".AtNames","f":"hp_.AtNames","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":".AtNames(x, pattern)"},{"p":"utils","o":"url.show","f":"hp_url.show","d":"Extension of file.show to display text files from a remote\nserver.\n","ec":"url.show(url, title = url, file = tempfile(), delete.file = TRUE, method, ...)"},{"p":"utils","o":"getCRANmirrors","f":"hp_getCRANmirrors","d":"Interact with the user to choose a CRAN mirror.\n","ec":"getCRANmirrors(all = FALSE, local.only = FALSE)"},{"p":"utils","o":"head","f":"hp_head","d":"Returns the first or last parts of a vector, matrix, table, data frame\nor function.  Since head() and tail() are generic\nfunctions, they may also have been extended to other classes.\n","ec":"head(x, ...)"},{"p":"utils","o":"localeToCharset","f":"hp_localeToCharset","d":"This functions aims to find a suitable coding for the locale named, by\ndefault the current locale, and if it is a UTF-8 locale a suitable\nsingle-byte encoding.\n","ec":"localeToCharset(locale = Sys.getlocale(\"LC_CTYPE\"))"},{"p":"utils","o":"Rprof","f":"hp_Rprof","d":"Enable or disable profiling of the execution of R expressions.\n","ec":"Rprof(filename = \"Rprof.out\", append = FALSE, interval = 0.02, memory.profiling = FALSE, gc.profiling = FALSE, line.profiling = FALSE, filter.callframes = FALSE, numfiles = 100L, bufsize = 10000L, event = c(\"default\", \"cpu\", \"elapsed\"))"},{"p":"utils","o":"getParseData","f":"hp_getParseData","d":"If the \"keep.source\" option is TRUE, R's parser\nwill attach detailed information on the object it has parsed.  These\nfunctions retrieve that information.\n","ec":"getParseData(x, includeText = NA)"},{"p":"utils","o":"RweaveLatexSetup","f":"hp_RweaveLatexSetup","d":"A driver for Sweave that translates R code chunks in\nLaTeX files by <U+201C>running them<U+201D>, i.e., parse() and\neval() each.\n","ec":"RweaveLatexSetup(file, syntax, output = NULL, quiet = FALSE, debug = FALSE, stylepath, ...)"},{"p":"utils","o":"formatOL","f":"hp_formatOL","d":"Format unordered (itemize) and ordered (enumerate) lists.\n","ec":"formatOL(x, type = \"arabic\", offset = 0, start = 1, width = 0.9 * getOption(\"width\"))"},{"p":"utils","o":"dump.frames","f":"hp_dump.frames","d":"Functions to dump the evaluation environments (frames) and to examine\ndumped frames.\n","ec":"dump.frames(dumpto = \"last.dump\", to.file = FALSE, include.GlobalEnv = FALSE)"},{"p":"utils","o":"read.table","f":"hp_read.table","d":"Reads a file in table format and creates a data frame from it, with\ncases corresponding to lines and variables to fields in the file.\n","ec":"read.table(file, header = FALSE, sep = \"\", quote = \"\\\"'\", dec = \".\", numerals = c(\"allow.loss\", \"warn.loss\", \"no.loss\"), row.names, col.names, as.is = !stringsAsFactors, tryLogical = TRUE, na.strings = \"NA\", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE, comment.char = \"#\", allowEscapes = FALSE, flush = FALSE, stringsAsFactors = FALSE, fileEncoding = \"\", encoding = \"unknown\", text, skipNul = FALSE)"},{"p":"utils","o":"URLdecode","f":"hp_URLdecode","d":"Functions to percent-encode or decode characters in URLs.\n","ec":"URLdecode(URL)"},{"p":"utils","o":"numhash","f":"hp_numhash","d":"Create and manipulate mutable hash tables.\n","ec":"numhash(h)"},{"p":"utils","o":"isS3method","f":"hp_isS3method","d":"Checks if method is the name of a valid / registered S3\nmethod.  Alternatively, when f and class are specified,\nit is checked if f is the name of an S3 generic function and\npaste(f, class, sep=\".\") is a valid S3 method.\n","ec":"isS3method(method, f, class, envir = parent.frame())"},{"p":"utils","o":"compareVersion","f":"hp_compareVersion","d":"Compare two package version numbers to see which is later.\n","ec":"compareVersion(a, b)"},{"p":"utils","o":"count.fields","f":"hp_count.fields","d":"count.fields counts the number of fields, as separated by\nsep, in each of the lines of file read.\n","ec":"count.fields(file, sep = \"\", quote = \"\\\"'\", skip = 0, blank.lines.skip = TRUE, comment.char = \"#\")"},{"p":"utils","o":"tar","f":"hp_tar","d":"Create a tar archive.\n","ec":"tar(tarfile, files = NULL, compression = c(\"none\", \"gzip\", \"bzip2\", \"xz\"), compression_level = 6, tar = Sys.getenv(\"tar\"), extra_flags = \"\")"},{"p":"utils","o":"setRepositories","f":"hp_setRepositories","d":"Interact with the user to choose the package repositories to be used.\n","ec":"setRepositories(graphics = getOption(\"menu.graphics\"), ind = NULL, addURLs = character(), name = NULL)"},{"p":"utils","o":"edit","f":"hp_edit","d":"Invoke a text editor on an R object.\n","ec":"edit(name, ...)"},{"p":"utils","o":"mirror2html","f":"hp_mirror2html","d":"Functions helping to maintain CRAN, some of them may also be useful\nfor administrators of other repository networks.\n","ec":"mirror2html(mirrors = NULL, file = \"mirrors.html\", head = \"mirrors-head.html\", foot = \"mirrors-foot.html\")"},{"p":"utils","o":"relist","f":"hp_relist","d":"relist() is an S3 generic function with a few methods in order\nto allow easy inversion of unlist(obj) when that is used\nwith an object obj of (S3) class \"relistable\".\n","ec":"relist(flesh, skeleton = attr(flesh, \"skeleton\"))"},{"p":"utils","o":"chooseBioCmirror","f":"hp_chooseBioCmirror","d":"Interact with the user to choose a Bioconductor mirror.\n","ec":"chooseBioCmirror(graphics = getOption(\"menu.graphics\"), ind = NULL, local.only = FALSE)"},{"p":"utils","o":"available.packages","f":"hp_available.packages","d":"available.packages returns a matrix of details corresponding to\npackages currently available at one or more repositories. The\ncurrent list of packages is downloaded over the internet (or copied\nfrom a local mirror).\n","ec":"available.packages(contriburl = contrib.url(repos, type), method, fields = NULL, type = getOption(\"pkgType\"), filters = NULL, repos = getOption(\"repos\"), ignore_repo_cache = FALSE, max_repo_cache_age, quiet = TRUE, ...)"},{"p":"utils","o":"aspell_write_personal_dictionary_file","f":"hp_aspell_write_personal_dictionary_file","d":"Utilities for spell checking packages via Aspell, Hunspell or Ispell.\n","ec":"aspell_write_personal_dictionary_file(x, out, language = \"en\", program = NULL)"},{"p":"utils","o":"getAnywhere","f":"hp_getAnywhere","d":"These functions locate all objects with name matching their argument,\nwhether visible on the search path, registered as an S3 method or in a\nnamespace but not exported.  getAnywhere() returns the objects\nand argsAnywhere() returns the arguments of any objects that\nare functions.\n","ec":"getAnywhere(x)"},{"p":"utils","o":"hsearch_db","f":"hp_hsearch_db","d":"Utilities for searching the help system.\n","ec":"hsearch_db(package = NULL, lib.loc = NULL, types = getOption(\"help.search.types\"), verbose = getOption(\"verbose\"), rebuild = FALSE, use_UTF8 = FALSE)"},{"p":"utils","o":"personList","f":"hp_personList","d":"Old interface providing functionality for information about\ncollections of persons.  Since R 2.14.0 person objects\ncan be combined with the corresponding c method which\nsupersedes the personList function.\n","ec":"personList(...)"},{"p":"utils","o":"fileSnapshot","f":"hp_fileSnapshot","d":"fileSnapshot takes a snapshot of a selection of files,\nrecording summary information about each.  changedFiles\ncompares two snapshots, or compares one snapshot to the current state\nof the file system.  The snapshots need not be the same directory;\nthis could be used to compare two directories.\n","ec":"fileSnapshot(path = \".\", file.info = TRUE, timestamp = NULL, md5sum = FALSE, digest = NULL, full.names = length(path) > 1, ...)"},{"p":"utils","o":"combn","f":"hp_combn","d":"Generate all combinations of the elements of x taken m\nat a time.  If x is a positive integer, returns all\ncombinations of the elements of seq(x) taken m at a\ntime.  If argument FUN is not NULL, applies a function given\nby the argument to each point.  If simplify is FALSE,  returns\na list; otherwise returns an array, typically a\nmatrix.  ... are passed unchanged to the\nFUN function, if specified.\n","ec":"combn(x, m, FUN = NULL, simplify = TRUE, ...)"},{"p":"utils","o":"packageStatus","f":"hp_packageStatus","d":"Summarize information about installed packages and packages\navailable at various repositories, and automatically upgrade outdated\npackages.\n","ec":"packageStatus(lib.loc = NULL, repositories = NULL, method, type = getOption(\"pkgType\"), ...)"},{"p":"utils","o":"read.socket","f":"hp_read.socket","d":"read.socket reads a string from the specified socket,\nwrite.socket writes to the specified socket.  There is very\nlittle error checking done by either.\n","ec":"read.socket(socket, maxlen = 256L, loop = FALSE)"},{"p":"utils","o":"find","f":"hp_find","d":"apropos() returns a character vector giving the names of\nobjects in the search list matching (as a regular expression)\nwhat.\n","ec":"find(what, mode = \"any\", numeric = FALSE, simple.words = TRUE)"},{"p":"utils","o":"RweaveLatexOptions","f":"hp_RweaveLatexOptions","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveLatexOptions(options)"},{"p":"utils","o":"page","f":"hp_page","d":"Displays a representation of the object named by x in a pager\nvia file.show.\n","ec":"page(x, method = c(\"dput\", \"print\"), ...)"},{"p":"utils","o":"write.csv","f":"hp_write.csv","d":"write.table prints its required argument x (after\nconverting it to a data frame if it is not one nor a matrix) to\na file or connection.\n","ec":"write.csv(...)"},{"p":"utils","o":"dataentry","f":"hp_dataentry","d":"A spreadsheet-like editor for entering or editing data.\n","ec":"dataentry(data, modes)"},{"p":"utils","o":"getSrcFilename","f":"hp_getSrcFilename","d":"These functions extract information from source references.\n","ec":"getSrcFilename(x, full.names = FALSE, unique = TRUE)"},{"p":"utils","o":"packageDescription","f":"hp_packageDescription","d":"Parses and returns the <U+2018>DESCRIPTION<U+2019> file of a package as a\n\"packageDescription\".\n","ec":"packageDescription(pkg, lib.loc = NULL, fields = NULL, drop = TRUE, encoding = \"\")"},{"p":"utils","o":"file_test","f":"hp_file_test","d":"Utility for shell-style file tests.\n","ec":"file_test(op, x, y)"},{"p":"utils","o":"toBibtex","f":"hp_toBibtex","d":"These methods convert R objects to character vectors with\nBibTeX or LaTeX markup.\n","ec":"toBibtex(object, ...)"},{"p":"utils","o":"browseVignettes","f":"hp_browseVignettes","d":"List available vignettes in an HTML browser with links to PDF,\nLaTeX/Noweb source, and (tangled) R code (if available).\n","ec":"browseVignettes(package = NULL, lib.loc = NULL, all = TRUE)"},{"p":"utils","o":"setBreakpoint","f":"hp_setBreakpoint","d":"These functions locate objects containing particular lines of source\ncode, using the information saved when the code was parsed with\nkeep.source = TRUE.\n","ec":"setBreakpoint(srcfile, line, nameonly = TRUE, envir = parent.frame(), lastenv, verbose = TRUE, tracer, print = FALSE, clear = FALSE, ...)"},{"p":"utils","o":"download.packages","f":"hp_download.packages","d":"These functions can be used to automatically compare the version\nnumbers of installed packages with the newest available version on\nthe repositories and update outdated packages on the fly.\n","ec":"download.packages(pkgs, destdir, available = NULL, repos = getOption(\"repos\"), contriburl = contrib.url(repos, type), method, type = getOption(\"pkgType\"), ...)"},{"p":"utils","o":"remove.packages","f":"hp_remove.packages","d":"Removes installed packages/bundles and updates index information\nas necessary.\n","ec":"remove.packages(pkgs, lib)"},{"p":"utils","o":"RweaveLatexFinish","f":"hp_RweaveLatexFinish","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveLatexFinish(object, error = FALSE)"},{"p":"utils","o":"chooseCRANmirror","f":"hp_chooseCRANmirror","d":"Interact with the user to choose a CRAN mirror.\n","ec":"chooseCRANmirror(graphics = getOption(\"menu.graphics\"), ind = NULL, local.only = FALSE)"},{"p":"utils","o":"upgrade","f":"hp_upgrade","d":"Upgrade objects.","ec":"upgrade(object, ...)"},{"p":"utils","o":"de","f":"hp_de","d":"A spreadsheet-like editor for entering or editing data.\n","ec":"de(..., Modes = list(), Names = NULL)"},{"p":"utils","o":".RtangleCodeLabel","f":"hp_.RtangleCodeLabel","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":".RtangleCodeLabel(chunk)"},{"p":"utils","o":"formatUL","f":"hp_formatUL","d":"Format unordered (itemize) and ordered (enumerate) lists.\n","ec":"formatUL(x, label = \"*\", offset = 0, width = 0.9 * getOption(\"width\"))"},{"p":"utils","o":"de.restore","f":"hp_de.restore","d":"Internal utils functions\n","ec":"de.restore(inlist, ncols, coltypes, argnames, args)"},{"p":"utils","o":"promptPackage","f":"hp_promptPackage","d":"Generates a prototype of a package overview help page\nusing Rd macros that dynamically extract information\nfrom package metadata when building the package.\n","ec":"promptPackage(package, lib.loc = NULL, filename = NULL, name = NULL, final = FALSE)"},{"p":"utils","o":"write.csv2","f":"hp_write.csv2","d":"write.table prints its required argument x (after\nconverting it to a data frame if it is not one nor a matrix) to\na file or connection.\n","ec":"write.csv2(...)"},{"p":"utils","o":"Rtangle","f":"hp_Rtangle","d":"A driver for Stangle that extracts R code chunks.\nNotably all RtangleSetup() arguments may be used as arguments\nin the Stangle() call.\n","ec":"Rtangle()"},{"p":"utils","o":"packageName","f":"hp_packageName","d":"Many environments are associated with a package; this function\nattempts to determine that package.\n","ec":"packageName(env = parent.frame())"},{"p":"utils","o":"glob2rx","f":"hp_glob2rx","d":"Change wildcard aka globbing patterns into the\ncorresponding regular expressions (regexp).\n","ec":"glob2rx(pattern, trim.head = FALSE, trim.tail = TRUE)"},{"p":"utils","o":"unstack","f":"hp_unstack","d":"Stacking vectors concatenates multiple vectors into a single vector\nalong with a factor indicating where each observation originated.\nUnstacking reverses this operation.\n","ec":"unstack(x, ...)"},{"p":"utils","o":"read.DIF","f":"hp_read.DIF","d":"Reads a file in Data Interchange Format (DIF) and creates a\ndata frame from it.  DIF is a format for data matrices such as\nsingle spreadsheets. \n","ec":"read.DIF(file, header = FALSE, dec = \".\", numerals = c(\"allow.loss\", \"warn.loss\", \"no.loss\"), row.names, col.names, as.is = !stringsAsFactors, na.strings = \"NA\", colClasses = NA, nrows = -1, skip = 0, check.names = TRUE, blank.lines.skip = TRUE, stringsAsFactors = FALSE, transpose = FALSE, fileEncoding = \"\")"},{"p":"utils","o":"savehistory","f":"hp_savehistory","d":"Load or save or display the commands history.\n","ec":"savehistory(file = \".Rhistory\")"},{"p":"utils","o":"vignette","f":"hp_vignette","d":"View a specified package vignette, or list the available ones;\ndisplay it rendered in a viewer, and get or edit its R source file.\n","ec":"vignette(topic, package = NULL, lib.loc = NULL, all = TRUE)"},{"p":"utils","o":"install.packages","f":"hp_install.packages","d":"Download and install packages from CRAN-like repositories or from\nlocal files.\n","ec":"install.packages(pkgs, lib, repos = getOption(\"repos\"), contriburl = contrib.url(repos, type), method, available = NULL, destdir = NULL, dependencies = NA, type = getOption(\"pkgType\"), configure.args = getOption(\"configure.args\"), configure.vars = getOption(\"configure.vars\"), clean = FALSE, Ncpus = getOption(\"Ncpus\", 1L), verbose = getOption(\"verbose\"), libs_only = FALSE, INSTALL_opts, quiet = FALSE, keep_outputs = FALSE, ...)"},{"p":"utils","o":".S3methods","f":"hp_.S3methods","d":"List all available methods for a S3 and S4 generic function, or all\nmethods for an S3 or S4 class.\n","ec":".S3methods(generic.function, class, envir = parent.frame(), all.names = FALSE, dropPath = FALSE)"},{"p":"utils","o":"argsAnywhere","f":"hp_argsAnywhere","d":"These functions locate all objects with name matching their argument,\nwhether visible on the search path, registered as an S3 method or in a\nnamespace but not exported.  getAnywhere() returns the objects\nand argsAnywhere() returns the arguments of any objects that\nare functions.\n","ec":"argsAnywhere(x)"},{"p":"utils","o":"help.search","f":"hp_help.search","d":"Allows for searching the help system for documentation matching a\ngiven character string in the (file) name, alias, title, concept or\nkeyword entries (or any combination thereof), using either\nfuzzy matching or regular expression matching.  Names\nand titles of the matched help entries are displayed nicely formatted.\n","ec":"help.search(pattern, fields = c(\"alias\", \"concept\", \"title\"), apropos, keyword, whatis, ignore.case = TRUE, package = NULL, lib.loc = NULL, help.db = getOption(\"help.db\"), verbose = getOption(\"verbose\"), rebuild = FALSE, agrep = NULL, use_UTF8 = FALSE, types = getOption(\"help.search.types\"))"},{"p":"utils","o":"getSrcref","f":"hp_getSrcref","d":"These functions extract information from source references.\n","ec":"getSrcref(x)"},{"p":"utils","o":"makeRweaveLatexCodeRunner","f":"hp_makeRweaveLatexCodeRunner","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"makeRweaveLatexCodeRunner(evalFunc = RweaveEvalWithOpt)"},{"p":"utils","o":"RweaveEvalWithOpt","f":"hp_RweaveEvalWithOpt","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RweaveEvalWithOpt(expr, options)"},{"p":"utils","o":"lsf.str","f":"hp_lsf.str","d":"ls.str and lsf.str are variations of ls\napplying str() to each matched name: see section Value.\n","ec":"lsf.str(pos = -1, envir, ...)"},{"p":"utils","o":"select.list","f":"hp_select.list","d":"Select item(s) from a character vector.\n","ec":"select.list(choices, preselect = NULL, multiple = FALSE, title = NULL, graphics = getOption(\"menu.graphics\"))"},{"p":"utils","o":"cite","f":"hp_cite","d":"Cite a bibentry object in text.  The cite() function\nuses the cite() function from the default\nbibstyle if present, or citeNatbib() if not.\nciteNatbib() uses a style similar to that used by the LaTeX\npackage natbib.\n","ec":"cite(keys, bib, ...)"},{"p":"utils","o":"recover","f":"hp_recover","d":"This function allows the user to browse directly on any of the\ncurrently active function calls, and is suitable as an error option.\nThe expression options(error = recover) will make this\nthe error option.\n","ec":"recover()"},{"p":"utils","o":"fix","f":"hp_fix","d":"fix invokes edit on x and then assigns the new\n(edited) version of x in the user's workspace.\n","ec":"fix(x, ...)"},{"p":"utils","o":"new.packages","f":"hp_new.packages","d":"old.packages indicates packages which have a (suitable) later\nversion on the repositories whereas update.packages offers to\ndownload and install such packages.\n","ec":"new.packages(lib.loc = NULL, repos = getOption(\"repos\"), contriburl = contrib.url(repos, type), instPkgs = installed.packages(lib.loc = lib.loc, ...), method, available = NULL, ask = FALSE, ..., type = getOption(\"pkgType\"))"},{"p":"utils","o":"aspell_package_Rd_files","f":"hp_aspell_package_Rd_files","d":"Utilities for spell checking packages via Aspell, Hunspell or Ispell.\n","ec":"aspell_package_Rd_files(dir, drop = c(\"\\\\abbr\", \"\\\\acronym\", \"\\\\author\", \"\\\\references\"), control = list(), program = NULL, dictionaries = character())"},{"p":"utils","o":"str","f":"hp_str","d":"Compactly display the internal structure of an R object, a\ndiagnostic function and an alternative to summary\n(and to some extent, dput).  Ideally, only one line for\neach <U+2018>basic<U+2019> structure is displayed.  It is especially well suited\nto compactly display the (abbreviated) contents of (possibly nested)\nlists.  The idea is to give reasonable output for any R\nobject.  It calls args for (non-primitive) function objects.\n","ec":"str(object, ...)"},{"p":"utils","o":"RtangleRuncode","f":"hp_RtangleRuncode","d":"These functions are handy for writing Sweave drivers and are\nconsidered internal and hence not documented.  Look at the source code\nof the Sweave LaTeX driver (in this\npackage) or the HTML driver (in the R2HTML package from CRAN) to see\nhow they can be used.\n","ec":"RtangleRuncode(object, chunk, options)"},{"p":"utils","o":"process.events","f":"hp_process.events","d":"R front ends like the Windows GUI handle key presses and mouse clicks\nthrough <U+201C>events<U+201D> generated by the OS. These are processed\nautomatically by R at intervals during computations, but in some cases\nit may be desirable to trigger immediate event handling.  The\nprocess.events function does that.\n","ec":"process.events()"},{"p":"utils","o":"example","f":"hp_example","d":"Run all the R code from the Examples part of R's online help\ntopic topic, with possible exceptions due to <U+2060>\\dontrun<U+2060>,\n<U+2060>\\dontshow<U+2060>, and <U+2060>\\donttest<U+2060> tags, see <U+2018>Details<U+2019> below.\n","ec":"example(topic, package = NULL, lib.loc = NULL, character.only = FALSE, give.lines = FALSE, local = FALSE, type = c(\"console\", \"html\"), echo = TRUE, verbose = getOption(\"verbose\"), setRNG = FALSE, ask = getOption(\"example.ask\"), prompt.prefix = abbreviate(topic, 6), catch.aborts = FALSE, run.dontrun = FALSE, run.donttest = interactive())"},{"p":"utils","o":"warnErrList","f":"hp_warnErrList","d":"Collect errors (class \"error\", typically from tryCatch)\nfrom a list x into a <U+201C>summary warning<U+201D>, by default\nproduce a warning and keep that message as\n\"warningMsg\" attribute.\n","ec":"warnErrList(x, warn = TRUE, errValue = NULL)"},{"p":"utils","o":"getSrcLocation","f":"hp_getSrcLocation","d":"These functions extract information from source references.\n","ec":"getSrcLocation(x, which = c(\"line\", \"column\", \"byte\", \"parse\"), first = TRUE)"},{"p":"utils","o":"flush.console","f":"hp_flush.console","d":"This does nothing except on console-based versions of R.\nOn the macOS and Windows GUIs, it ensures that the display of\noutput in the console is current, even if output buffering is on.\n","ec":"flush.console()"},{"p":"utils","o":"maphash","f":"hp_maphash","d":"Create and manipulate mutable hash tables.\n","ec":"maphash(h, FUN)"},{"p":"utils","o":"timestamp","f":"hp_timestamp","d":"Load or save or display the commands history.\n","ec":"timestamp(stamp = date(), prefix = \"##------ \", suffix = \" ------##\", quiet = FALSE)"},{"p":"utils","o":"make.packages.html","f":"hp_make.packages.html","d":"Re-create the HTML list of packages.\n","ec":"make.packages.html(lib.loc = .libPaths(), temp = FALSE, verbose = TRUE, docdir = R.home(\"doc\"))"},{"p":"utils","o":"rc.options","f":"hp_rc.options","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":"rc.options(...)"},{"p":"utils","o":"getFromNamespace","f":"hp_getFromNamespace","d":"Utility functions to access and replace the non-exported functions in\na namespace, for use in developing packages with namespaces.\n","ec":"getFromNamespace(x, ns, pos = -1, envir = as.environment(pos))"},{"p":"utils","o":"clrhash","f":"hp_clrhash","d":"Create and manipulate mutable hash tables.\n","ec":"clrhash(h)"},{"p":"utils","o":"adist","f":"hp_adist","d":"Compute the approximate string distance between character vectors.\nThe distance is a generalized Levenshtein (edit) distance, giving the\nminimal possibly weighted number of insertions, deletions and\nsubstitutions needed to transform one string into another.\n","ec":"adist(x, y = NULL, costs = NULL, counts = FALSE, fixed = TRUE, partial = !fixed, ignore.case = FALSE, useBytes = FALSE)"},{"p":"utils","o":"contrib.url","f":"hp_contrib.url","d":"contrib.url adds the appropriate type-specific path within a\nrepository to each URL in repos.\n","ec":"contrib.url(repos, type = getOption(\"pkgType\"))"},{"p":"utils","o":"URLencode","f":"hp_URLencode","d":"Functions to percent-encode or decode characters in URLs.\n","ec":"URLencode(URL, reserved = FALSE, repeated = FALSE)"},{"p":"utils","o":"rc.settings","f":"hp_rc.settings","d":"This page documents a mechanism to generate relevant completions\nfrom a partially completed command line.  It is not intended to be\nuseful by itself, but rather in conjunction with other mechanisms that\nuse it as a backend.  The functions listed in the usage section\nprovide a simple control and query mechanism.  The actual interface\nconsists of a few unexported functions described further down.\n","ec":"rc.settings(ops, ns, args, dots, func, ipck, S3, data, help, argdb, fuzzy, quotes, files, backtick)"},{"p":"utils","o":"help.start","f":"hp_help.start","d":"Start the hypertext (currently HTML) version of R's online\ndocumentation.\n","ec":"help.start(update = FALSE, gui = \"irrelevant\", browser = getOption(\"browser\"), remote = NULL)"},{"p":"utils","o":"unzip","f":"hp_unzip","d":"Extract files from or list a zip archive.\n","ec":"unzip(zipfile, files = NULL, list = FALSE, overwrite = TRUE, junkpaths = FALSE, exdir = \".\", unzip = \"internal\", setTimes = FALSE)"},{"p":"utils","o":"pico","f":"hp_pico","d":"Invoke a text editor on an R object.\n","ec":"pico(name = NULL, file = \"\")"},{"p":"vctrs","o":"vec_cast.list","f":"hp_vec_cast.list","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.list(x, to, ...)"},{"p":"vctrs","o":"vec_cast.logical","f":"hp_vec_cast.logical","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.logical(x, to, ...)"},{"p":"vctrs","o":"vec_ptype_abbr","f":"hp_vec_ptype_abbr","d":"vec_ptype_full() displays the full type of the vector. vec_ptype_abbr()\nprovides an abbreviated summary suitable for use in a column heading.\n","ec":"vec_ptype_abbr(x, ..., prefix_named = FALSE, suffix_shape = TRUE)"},{"p":"vctrs","o":"unspecified","f":"hp_unspecified","d":"This is a partial type used to represent logical vectors\nthat only contain NA. These require special handling because we want to\nallow NA to specify missingness without requiring a type.\n","ec":"unspecified(n = 0)"},{"p":"vctrs","o":"vec_set_names","f":"hp_vec_set_names","d":"These functions work like rlang::names2(), names() and names<-(),\nexcept that they return or modify the the rowwise names of the vector. These are:\n","ec":"vec_set_names(x, names)"},{"p":"vctrs","o":"vec_locate_sorted_groups","f":"hp_vec_locate_sorted_groups","d":"\n","ec":"vec_locate_sorted_groups(x, ..., direction = \"asc\", na_value = \"largest\", nan_distinct = FALSE, chr_proxy_collate = NULL)"},{"p":"vctrs","o":"vec_ptype_common","f":"hp_vec_ptype_common","d":"vec_ptype() returns the unfinalised prototype of a single vector.\nvec_ptype_common() finds the common type of multiple vectors.\nvec_ptype_show() nicely prints the common type of any number of\ninputs, and is designed for interactive exploration.\n","ec":"vec_ptype_common(..., .ptype = NULL, .arg = \"\", .call = caller_env())"},{"p":"vctrs","o":"vec_recycle_common","f":"hp_vec_recycle_common","d":"vec_recycle(x, size) recycles a single vector to a given size.\nvec_recycle_common(...) recycles multiple vectors to their common size. All\nfunctions obey the vctrs recycling rules, and will\nthrow an error if recycling is not possible. See vec_size() for the precise\ndefinition of size.\n","ec":"vec_recycle_common(..., .size = NULL, .arg = \"\", .call = caller_env())"},{"p":"vctrs","o":"vec_type","f":"hp_vec_type","d":"\n","ec":"vec_type(x)"},{"p":"vctrs","o":"vec_proxy_order","f":"hp_vec_proxy_order","d":"vec_proxy_compare() and vec_proxy_order() return proxy objects, i.e.\nan atomic vector or data frame of atomic vectors.\n","ec":"vec_proxy_order(x, ...)"},{"p":"vctrs","o":"vec_run_sizes","f":"hp_vec_run_sizes","d":"Unlike base::rle(), adjacent missing values are considered identical when\nconstructing runs. For example, vec_identify_runs(c(NA, NA)) will return\nc(1, 1), not c(1, 2).\n","ec":"vec_run_sizes(x)"},{"p":"vctrs","o":"vec_cast.ordered","f":"hp_vec_cast.ordered","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"vec_cast.ordered(x, to, ...)"},{"p":"vctrs","o":"vec_as_index","f":"hp_vec_as_index","d":"\n","ec":"vec_as_index(i, n, names = NULL)"},{"p":"vctrs","o":"vec_interleave","f":"hp_vec_interleave","d":"vec_interleave() combines multiple vectors together, much like vec_c(),\nbut does so in such a way that the elements of each vector are interleaved\ntogether.\n","ec":"vec_interleave(..., .ptype = NULL, .name_spec = NULL, .name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\", \"universal_quiet\"))"},{"p":"vctrs","o":"list_all_vectors","f":"hp_list_all_vectors","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"list_all_vectors(x)"},{"p":"vctrs","o":"vec_seq_along","f":"hp_vec_seq_along","d":"vec_seq_along() is equivalent to seq_along() but uses size, not length.\nvec_init_along() creates a vector of missing values with size matching\nan existing object.\n","ec":"vec_seq_along(x)"},{"p":"vctrs","o":"vec_names2","f":"hp_vec_names2","d":"These functions work like rlang::names2(), names() and names<-(),\nexcept that they return or modify the the rowwise names of the vector. These are:\n","ec":"vec_names2(x, ..., repair = c(\"minimal\", \"unique\", \"universal\", \"check_unique\", \"unique_quiet\", \"universal_quiet\"), quiet = FALSE)"},{"p":"vctrs","o":"vec_ptype2.list","f":"hp_vec_ptype2.list","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.list(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_ptype2.raw","f":"hp_vec_ptype2.raw","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.raw(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_unique","f":"hp_vec_unique","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_unique(x)"},{"p":"vctrs","o":"vec_ptype2.POSIXlt","f":"hp_vec_ptype2.POSIXlt","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_ptype2.POSIXlt(x, y, ...)"},{"p":"vctrs","o":"obj_print","f":"hp_obj_print","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_print(x, ...)"},{"p":"vctrs","o":"obj_str_footer","f":"hp_obj_str_footer","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_str_footer(x, ...)"},{"p":"vctrs","o":"vec_arith.logical","f":"hp_vec_arith.logical","d":"This generic provides a common double dispatch mechanism for all infix\noperators (+, -, /, *, ^, %%, %/%, !, &, |). It is used\nto power the default arithmetic and boolean operators for vctrs objects,\novercoming the limitations of the base Ops generic.\n","ec":"vec_arith.logical(op, x, y, ...)"},{"p":"vctrs","o":"vec_cast","f":"hp_vec_cast","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast(x, to, ..., x_arg = caller_arg(x), to_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_assert","f":"hp_vec_assert","d":"\n","ec":"vec_assert(x, ptype = NULL, size = NULL, arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"list_drop_empty","f":"hp_list_drop_empty","d":"list_drop_empty() removes empty elements from a list. This includes NULL\nelements along with empty vectors, like integer(0). This is equivalent to,\nbut faster than, vec_slice(x, list_sizes(x) != 0L).\n","ec":"list_drop_empty(x)"},{"p":"vctrs","o":"obj_check_vector","f":"hp_obj_check_vector","d":"Informally, a vector is a collection that makes sense to use as column in a\ndata frame. The following rules define whether or not x is considered a\nvector.\n","ec":"obj_check_vector(x, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"vec_ptype2.AsIs","f":"hp_vec_ptype2.AsIs","d":"These functions help the base AsIs class fit into the vctrs type system\nby providing coercion and casting functions.\n","ec":"vec_ptype2.AsIs(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_check_size","f":"hp_vec_check_size","d":"Informally, a vector is a collection that makes sense to use as column in a\ndata frame. The following rules define whether or not x is considered a\nvector.\n","ec":"vec_check_size(x, size, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"vec_init_along","f":"hp_vec_init_along","d":"vec_seq_along() is equivalent to seq_along() but uses size, not length.\nvec_init_along() creates a vector of missing values with size matching\nan existing object.\n","ec":"vec_init_along(x, y = x)"},{"p":"vctrs","o":"vec_cbind_frame_ptype","f":"hp_vec_cbind_frame_ptype","d":"\n","ec":"vec_cbind_frame_ptype(x, ...)"},{"p":"vctrs","o":"vec_as_subscript","f":"hp_vec_as_subscript","d":"\n","ec":"vec_as_subscript(i, ..., logical = c(\"cast\", \"error\"), numeric = c(\"cast\", \"error\"), character = c(\"cast\", \"error\"), arg = NULL, call = caller_env())"},{"p":"vctrs","o":"vec_cbind","f":"hp_vec_cbind","d":"This pair of functions binds together data frames (and vectors), either\nrow-wise or column-wise. Row-binding creates a data frame with common type\nacross all arguments. Column-binding creates a data frame with common length\nacross all arguments.\n","ec":"vec_cbind(..., .ptype = NULL, .size = NULL, .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\", \"unique_quiet\", \"universal_quiet\" ), .error_call = current_env())"},{"p":"vctrs","o":"s3_register","f":"hp_s3_register","d":"Generally, the recommend way to register an S3 method is to use the\nS3Method() namespace directive (often generated automatically by the\n<U+2060>@export<U+2060> roxygen2 tag). However, this technique requires that the generic\nbe in an imported package, and sometimes you want to suggest a package,\nand only provide a method when that package is loaded. s3_register()\ncan be called from your package's .onLoad() to dynamically register\na method only if the generic's package is loaded.\n","ec":"s3_register(generic, class, method = NULL)"},{"p":"vctrs","o":"vec_duplicate_detect","f":"hp_vec_duplicate_detect","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_duplicate_detect(x)"},{"p":"vctrs","o":"vec_data","f":"hp_vec_data","d":"\n","ec":"vec_data(x)"},{"p":"vctrs","o":"vec_equal_na","f":"hp_vec_equal_na","d":"\n","ec":"vec_equal_na(x)"},{"p":"vctrs","o":"stop_incompatible_op","f":"hp_stop_incompatible_op","d":"These functions are called for their side effect of raising\nerrors and warnings.\nThese conditions have custom classes and structures to make\ntesting easier.\n","ec":"stop_incompatible_op(op, x, y, details = NULL, ..., message = NULL, class = NULL, call = caller_env())"},{"p":"vctrs","o":"vec_locate_matches","f":"hp_vec_locate_matches","d":"\n","ec":"vec_locate_matches(needles, haystack, ..., condition = \"==\", filter = \"none\", incomplete = \"compare\", no_match = NA_integer_, remaining = \"drop\", multiple = \"all\", relationship = \"none\", nan_distinct = FALSE, chr_proxy_collate = NULL, needles_arg = \"needles\", haystack_arg = \"haystack\", error_call = current_env())"},{"p":"vctrs","o":"vec_unique_loc","f":"hp_vec_unique_loc","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_unique_loc(x)"},{"p":"vctrs","o":"n_fields","f":"hp_n_fields","d":"A rcrd behaves like a vector, so length(), names(), and $ can\nnot provide access to the fields of the underlying list. These helpers do:\nfields() is equivalent to names(); n_fields() is equivalent to\nlength(); field() is equivalent to $.\n","ec":"n_fields(x)"},{"p":"vctrs","o":"vec_math","f":"hp_vec_math","d":"This generic provides a common dispatch mechanism for all regular unary\nmathematical functions. It is used as a common wrapper around many of the\nSummary group generics, the Math group generics, and a handful of other\nmathematical functions like mean() (but not var() or sd()).\n","ec":"vec_math(.fn, .x, ...)"},{"p":"vctrs","o":"vec_empty","f":"hp_vec_empty","d":"\n","ec":"vec_empty(x)"},{"p":"vctrs","o":"vec_ptype_show","f":"hp_vec_ptype_show","d":"vec_ptype() returns the unfinalised prototype of a single vector.\nvec_ptype_common() finds the common type of multiple vectors.\nvec_ptype_show() nicely prints the common type of any number of\ninputs, and is designed for interactive exploration.\n","ec":"vec_ptype_show(...)"},{"p":"vctrs","o":"vec_ptype2.logical","f":"hp_vec_ptype2.logical","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.logical(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"new_rcrd","f":"hp_new_rcrd","d":"The rcrd class extends vctr. A rcrd is composed of 1 or more fields,\nwhich must be vectors of the same length. Is designed specifically for\nclasses that can naturally be decomposed into multiple vectors of the same\nlength, like POSIXlt, but where the organisation should be considered\nan implementation detail invisible to the user (unlike a data.frame).\n","ec":"new_rcrd(fields, ..., class = character())"},{"p":"vctrs","o":"obj_is_vector","f":"hp_obj_is_vector","d":"Informally, a vector is a collection that makes sense to use as column in a\ndata frame. The following rules define whether or not x is considered a\nvector.\n","ec":"obj_is_vector(x)"},{"p":"vctrs","o":"list_all_size","f":"hp_list_all_size","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"list_all_size(x, size)"},{"p":"vctrs","o":"vec_set_intersect","f":"hp_vec_set_intersect","d":"Because these are set operations, these functions only return unique values\nfrom x and y, returned in the order they first appeared in the original\ninput. Names of x and y are retained on the result, but names are always\ntaken from x if the value appears in both inputs.\n","ec":"vec_set_intersect(x, y, ..., ptype = NULL, x_arg = \"x\", y_arg = \"y\", error_call = current_env())"},{"p":"vctrs","o":"list_sizes","f":"hp_list_sizes","d":"vec_size(x) returns the size of a vector. vec_is_empty()\nreturns TRUE if the size is zero, FALSE otherwise.\n","ec":"list_sizes(x)"},{"p":"vctrs","o":"vec_size","f":"hp_vec_size","d":"vec_size(x) returns the size of a vector. vec_is_empty()\nreturns TRUE if the size is zero, FALSE otherwise.\n","ec":"vec_size(x)"},{"p":"vctrs","o":"vec_ptype2.integer","f":"hp_vec_ptype2.integer","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.integer(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"MISSING","f":"hp_MISSING","d":"This generic provides a common double dispatch mechanism for all infix\noperators (+, -, /, *, ^, %%, %/%, !, &, |). It is used\nto power the default arithmetic and boolean operators for vctrs objects,\novercoming the limitations of the base Ops generic.\n","ec":"MISSING()"},{"p":"vctrs","o":"vec_fill_missing","f":"hp_vec_fill_missing","d":"\n","ec":"vec_fill_missing(x, direction = c(\"down\", \"up\", \"downup\", \"updown\"), max_fill = NULL)"},{"p":"vctrs","o":"vec_ptype2.Date","f":"hp_vec_ptype2.Date","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_ptype2.Date(x, y, ...)"},{"p":"vctrs","o":"vec_cast.integer64","f":"hp_vec_cast.integer64","d":"A integer64 is a 64 bits integer vector, implemented in the bit64 package.\n","ec":"vec_cast.integer64(x, to, ...)"},{"p":"vctrs","o":"vec_recycle","f":"hp_vec_recycle","d":"vec_recycle(x, size) recycles a single vector to a given size.\nvec_recycle_common(...) recycles multiple vectors to their common size. All\nfunctions obey the vctrs recycling rules, and will\nthrow an error if recycling is not possible. See vec_size() for the precise\ndefinition of size.\n","ec":"vec_recycle(x, size, ..., x_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"field<-","f":"hp_field..","d":"A rcrd behaves like a vector, so length(), names(), and $ can\nnot provide access to the fields of the underlying list. These helpers do:\nfields() is equivalent to names(); n_fields() is equivalent to\nlength(); field() is equivalent to $.\n","ec":"field<-(x, i, value)"},{"p":"vctrs","o":"vec_equal","f":"hp_vec_equal","d":"vec_equal() tests if two vectors are equal.\n","ec":"vec_equal(x, y, na_equal = FALSE, .ptype = NULL)"},{"p":"vctrs","o":"vec_ptype2.POSIXct","f":"hp_vec_ptype2.POSIXct","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_ptype2.POSIXct(x, y, ...)"},{"p":"vctrs","o":"vec_ptype2","f":"hp_vec_ptype2","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2(x, y, ..., x_arg = caller_arg(x), y_arg = caller_arg(y), call = caller_env())"},{"p":"vctrs","o":"vec_as_subscript2","f":"hp_vec_as_subscript2","d":"\n","ec":"vec_as_subscript2(i, ..., numeric = c(\"cast\", \"error\"), character = c(\"cast\", \"error\"), arg = NULL, call = caller_env())"},{"p":"vctrs","o":"vec_restore","f":"hp_vec_restore","d":"\n","ec":"vec_restore(x, to, ...)"},{"p":"vctrs","o":"vec_rbind","f":"hp_vec_rbind","d":"This pair of functions binds together data frames (and vectors), either\nrow-wise or column-wise. Row-binding creates a data frame with common type\nacross all arguments. Column-binding creates a data frame with common length\nacross all arguments.\n","ec":"vec_rbind(..., .ptype = NULL, .names_to = rlang::zap(), .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"unique_quiet\", \"universal_quiet\" ), .name_spec = NULL, .error_call = current_env())"},{"p":"vctrs","o":"vec_names","f":"hp_vec_names","d":"These functions work like rlang::names2(), names() and names<-(),\nexcept that they return or modify the the rowwise names of the vector. These are:\n","ec":"vec_names(x)"},{"p":"vctrs","o":"new_data_frame","f":"hp_new_data_frame","d":"new_data_frame() constructs a new data frame from an existing list. It is\nmeant to be performant, and does not check the inputs for correctness in any\nway. It is only safe to use after a call to df_list(), which collects and\nvalidates the columns used to construct the data frame.\n","ec":"new_data_frame(x = list(), n = NULL, ..., class = NULL)"},{"p":"vctrs","o":"vec_cast.double","f":"hp_vec_cast.double","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.double(x, to, ...)"},{"p":"vctrs","o":"vec_repeat","f":"hp_vec_repeat","d":"\n","ec":"vec_repeat(x, each = 1L, times = 1L)"},{"p":"vctrs","o":"vec_cast.integer","f":"hp_vec_cast.integer","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.integer(x, to, ...)"},{"p":"vctrs","o":"obj_str_data","f":"hp_obj_str_data","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_str_data(x, ...)"},{"p":"vctrs","o":"vec_detect_complete","f":"hp_vec_detect_complete","d":"vec_detect_complete() detects \"complete\" observations. An observation is\nconsidered complete if it is non-missing. For most vectors, this implies that\nvec_detect_complete(x) == !vec_detect_missing(x).\n","ec":"vec_detect_complete(x)"},{"p":"vctrs","o":"vec_identify_runs","f":"hp_vec_identify_runs","d":"Unlike base::rle(), adjacent missing values are considered identical when\nconstructing runs. For example, vec_identify_runs(c(NA, NA)) will return\nc(1, 1), not c(1, 2).\n","ec":"vec_identify_runs(x)"},{"p":"vctrs","o":"vec_ptype2.data.frame","f":"hp_vec_ptype2.data.frame","d":"These functions help the base data.frame class fit into the vctrs type system\nby providing coercion and casting functions.\n","ec":"vec_ptype2.data.frame(x, y, ...)"},{"p":"vctrs","o":"vec_cast.difftime","f":"hp_vec_cast.difftime","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_cast.difftime(x, to, ...)"},{"p":"vctrs","o":"vec_compare","f":"hp_vec_compare","d":"Compare two vectors\n","ec":"vec_compare(x, y, na_equal = FALSE, .ptype = NULL)"},{"p":"vctrs","o":"vec_cast.vctrs_list_of","f":"hp_vec_cast.vctrs_list_of","d":"A list_of object is a list where each element has the same type.\nModifying the list with $, [, and [[ preserves the constraint\nby coercing all input items.\n","ec":"vec_cast.vctrs_list_of(x, to, ...)"},{"p":"vctrs","o":"vec_ptype2.vctrs_list_of","f":"hp_vec_ptype2.vctrs_list_of","d":"A list_of object is a list where each element has the same type.\nModifying the list with $, [, and [[ preserves the constraint\nby coercing all input items.\n","ec":"vec_ptype2.vctrs_list_of(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_set_symmetric_difference","f":"hp_vec_set_symmetric_difference","d":"Because these are set operations, these functions only return unique values\nfrom x and y, returned in the order they first appeared in the original\ninput. Names of x and y are retained on the result, but names are always\ntaken from x if the value appears in both inputs.\n","ec":"vec_set_symmetric_difference(x, y, ..., ptype = NULL, x_arg = \"x\", y_arg = \"y\", error_call = current_env())"},{"p":"vctrs","o":"fields","f":"hp_fields","d":"A rcrd behaves like a vector, so length(), names(), and $ can\nnot provide access to the fields of the underlying list. These helpers do:\nfields() is equivalent to names(); n_fields() is equivalent to\nlength(); field() is equivalent to $.\n","ec":"fields(x)"},{"p":"vctrs","o":"maybe_lossy_cast","f":"hp_maybe_lossy_cast","d":"\n","ec":"maybe_lossy_cast(result, x, to, lossy = NULL, locations = NULL, ..., loss_type = c(\"precision\", \"generality\"), x_arg, to_arg, call = caller_env(), details = NULL, message = NULL, class = NULL, .deprecation = FALSE)"},{"p":"vctrs","o":"vec_as_location","f":"hp_vec_as_location","d":"These helpers provide a means of standardizing common indexing\nmethods such as integer, character or logical indexing.\n","ec":"vec_as_location(i, n, names = NULL, ..., missing = c(\"propagate\", \"remove\", \"error\"), arg = caller_arg(i), call = caller_env())"},{"p":"vctrs","o":"new_partial","f":"hp_new_partial","d":"\n","ec":"new_partial(..., class = character())"},{"p":"vctrs","o":"obj_print_data","f":"hp_obj_print_data","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_print_data(x, ...)"},{"p":"vctrs","o":"vec_unrep","f":"hp_vec_unrep","d":"Using vec_unrep() and vec_rep_each() together is similar to using\nbase::rle() and base::inverse.rle(). The following invariant shows\nthe relationship between the two functions:\n","ec":"vec_unrep(x)"},{"p":"vctrs","o":"vec_sort","f":"hp_vec_sort","d":"Order and sort vectors\n","ec":"vec_sort(x, ..., direction = c(\"asc\", \"desc\"), na_value = c(\"largest\", \"smallest\"))"},{"p":"vctrs","o":"vec_slice","f":"hp_vec_slice","d":"This provides a common interface to extracting and modifying observations\nfor all vector types, regardless of dimensionality. It is an analog to [\nthat matches vec_size() instead of length().\n","ec":"vec_slice(x, i, ..., error_call = current_env())"},{"p":"vctrs","o":"vec_cast.factor","f":"hp_vec_cast.factor","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"vec_cast.factor(x, to, ...)"},{"p":"vctrs","o":"vec_set_union","f":"hp_vec_set_union","d":"Because these are set operations, these functions only return unique values\nfrom x and y, returned in the order they first appeared in the original\ninput. Names of x and y are retained on the result, but names are always\ntaken from x if the value appears in both inputs.\n","ec":"vec_set_union(x, y, ..., ptype = NULL, x_arg = \"x\", y_arg = \"y\", error_call = current_env())"},{"p":"vctrs","o":"vec_group_id","f":"hp_vec_group_id","d":"\n","ec":"vec_group_id(x)"},{"p":"vctrs","o":"vec_unchop","f":"hp_vec_unchop","d":"\n","ec":"vec_unchop(x, indices = NULL, ptype = NULL, name_spec = NULL, name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\"))"},{"p":"vctrs","o":"vec_ptype2.ordered","f":"hp_vec_ptype2.ordered","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"vec_ptype2.ordered(x, y, ...)"},{"p":"vctrs","o":"new_date","f":"hp_new_date","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"new_date(x = double())"},{"p":"vctrs","o":"new_ordered","f":"hp_new_ordered","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"new_ordered(x = integer(), levels = character())"},{"p":"vctrs","o":"allow_lossy_cast","f":"hp_allow_lossy_cast","d":"These functions are called for their side effect of raising\nerrors and warnings.\nThese conditions have custom classes and structures to make\ntesting easier.\n","ec":"allow_lossy_cast(expr, x_ptype = NULL, to_ptype = NULL)"},{"p":"vctrs","o":"vec_ptype2.factor","f":"hp_vec_ptype2.factor","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"vec_ptype2.factor(x, y, ...)"},{"p":"vctrs","o":"vec_c","f":"hp_vec_c","d":"Combine all arguments into a new vector of common type.\n","ec":"vec_c(..., .ptype = NULL, .name_spec = NULL, .name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\", \"universal_quiet\" ), .error_arg = \"\", .error_call = current_env())"},{"p":"vctrs","o":"vec_rank","f":"hp_vec_rank","d":"vec_rank() computes the sample ranks of a vector. For data frames, ranks\nare computed along the rows, using all columns after the first to break\nties.\n","ec":"vec_rank(x, ..., ties = c(\"min\", \"max\", \"sequential\", \"dense\"), incomplete = c(\"rank\", \"na\"), direction = \"asc\", na_value = \"largest\", nan_distinct = FALSE, chr_proxy_collate = NULL)"},{"p":"vctrs","o":"df_list","f":"hp_df_list","d":"df_list() constructs the data structure underlying a data\nframe, a named list of equal-length vectors. It is often used in\ncombination with new_data_frame() to safely and consistently create\na helper function for data frame subclasses.\n","ec":"df_list(..., .size = NULL, .unpack = TRUE, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\", \"universal_quiet\" ), .error_call = current_env())"},{"p":"vctrs","o":"vec_assign","f":"hp_vec_assign","d":"This provides a common interface to extracting and modifying observations\nfor all vector types, regardless of dimensionality. It is an analog to [\nthat matches vec_size() instead of length().\n","ec":"vec_assign(x, i, value, ..., x_arg = \"\", value_arg = \"\")"},{"p":"vctrs","o":"list_check_all_size","f":"hp_list_check_all_size","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"list_check_all_size(x, size, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"vec_any_missing","f":"hp_vec_any_missing","d":"Data frame rows are only considered missing if every element in the row is\nmissing. Similarly, record vector elements are only considered\nmissing if every field in the record is missing. Put another way, rows with\nany missing values are considered incomplete, but\nonly rows with all missing values are considered missing.\n","ec":"vec_any_missing(x)"},{"p":"vctrs","o":"vec_as_names","f":"hp_vec_as_names","d":"vec_as_names() takes a character vector of names and repairs it\naccording to the repair argument. It is the r-lib and tidyverse\nequivalent of base::make.names().\n","ec":"vec_as_names(names, ..., repair = c(\"minimal\", \"unique\", \"universal\", \"check_unique\", \"unique_quiet\", \"universal_quiet\"), repair_arg = NULL, quiet = FALSE, call = caller_env())"},{"p":"vctrs","o":"tib_cast","f":"hp_tib_cast","d":"df_ptype2() and df_cast() are the two functions you need to\ncall from vec_ptype2() and vec_cast() methods for data frame\nsubclasses. See ?howto-faq-coercion-data-frame.\nTheir main job is to determine the common type of two data frames,\nadding and coercing columns as needed, or throwing an incompatible\ntype error when the columns are not compatible.\n","ec":"tib_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_math_base","f":"hp_vec_math_base","d":"This generic provides a common dispatch mechanism for all regular unary\nmathematical functions. It is used as a common wrapper around many of the\nSummary group generics, the Math group generics, and a handful of other\nmathematical functions like mean() (but not var() or sd()).\n","ec":"vec_math_base(.fn, .x, ...)"},{"p":"vctrs","o":"vec_ptype_full","f":"hp_vec_ptype_full","d":"vec_ptype_full() displays the full type of the vector. vec_ptype_abbr()\nprovides an abbreviated summary suitable for use in a column heading.\n","ec":"vec_ptype_full(x, ...)"},{"p":"vctrs","o":"new_factor","f":"hp_new_factor","d":"A factor is an integer with attribute levels, a character vector. There\nshould be one level for each integer between 1 and max(x).\nAn ordered factor has the same properties as a factor, but possesses\nan extra class that marks levels as having a total ordering.\n","ec":"new_factor(x = integer(), levels = character(), ..., class = character())"},{"p":"vctrs","o":"vec_size_common","f":"hp_vec_size_common","d":"vec_size(x) returns the size of a vector. vec_is_empty()\nreturns TRUE if the size is zero, FALSE otherwise.\n","ec":"vec_size_common(..., .size = NULL, .absent = 0L, .arg = \"\", .call = caller_env())"},{"p":"vctrs","o":"vec_as_names_legacy","f":"hp_vec_as_names_legacy","d":"This standardises names with the legacy approach that was used in\ntidyverse packages (such as tibble, tidyr, and readxl) before\nvec_as_names() was implemented. This tool is meant to help\ntransitioning to the new name repairing standard and will be\ndeprecated and removed from the package some time in the future.\n","ec":"vec_as_names_legacy(names, prefix = \"V\", sep = \"\")"},{"p":"vctrs","o":"stop_incompatible_type","f":"hp_stop_incompatible_type","d":"These functions are called for their side effect of raising\nerrors and warnings.\nThese conditions have custom classes and structures to make\ntesting easier.\n","ec":"stop_incompatible_type(x, y, ..., x_arg, y_arg, action = c(\"combine\", \"convert\"), details = NULL, message = NULL, class = NULL, call = caller_env())"},{"p":"vctrs","o":"obj_str_header","f":"hp_obj_str_header","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_str_header(x, ...)"},{"p":"vctrs","o":"vec_count","f":"hp_vec_count","d":"Count the number of unique values in a vector. vec_count() has two\nimportant differences to table(): it returns a data frame, and when\ngiven multiple inputs (as a data frame), it only counts combinations that\nappear in the input.\n","ec":"vec_count(x, sort = c(\"count\", \"key\", \"location\", \"none\"))"},{"p":"vctrs","o":"vec_arith.difftime","f":"hp_vec_arith.difftime","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_arith.difftime(op, x, y, ...)"},{"p":"vctrs","o":"new_duration","f":"hp_new_duration","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"new_duration(x = double(), units = c(\"secs\", \"mins\", \"hours\", \"days\", \"weeks\"))"},{"p":"vctrs","o":"vec_ptype2.complex","f":"hp_vec_ptype2.complex","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.complex(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"obj_str","f":"hp_obj_str","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_str(x, ...)"},{"p":"vctrs","o":"vec_ptype_finalise","f":"hp_vec_ptype_finalise","d":"\n","ec":"vec_ptype_finalise(x, ...)"},{"p":"vctrs","o":"is_list_of","f":"hp_is_list_of","d":"A list_of object is a list where each element has the same type.\nModifying the list with $, [, and [[ preserves the constraint\nby coercing all input items.\n","ec":"is_list_of(x)"},{"p":"vctrs","o":"vec_cast.raw","f":"hp_vec_cast.raw","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.raw(x, to, ...)"},{"p":"vctrs","o":"vec_is_list","f":"hp_vec_is_list","d":"\n","ec":"vec_is_list(x)"},{"p":"vctrs","o":"vec_arith.POSIXlt","f":"hp_vec_arith.POSIXlt","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_arith.POSIXlt(op, x, y, ...)"},{"p":"vctrs","o":"vec_type2","f":"hp_vec_type2","d":"\n","ec":"vec_type2(x, y, ...)"},{"p":"vctrs","o":"vec_ptype2.character","f":"hp_vec_ptype2.character","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.character(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_duplicate_id","f":"hp_vec_duplicate_id","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_duplicate_id(x)"},{"p":"vctrs","o":"vec_expand_grid","f":"hp_vec_expand_grid","d":"vec_expand_grid() creates a new data frame by creating a grid of all\npossible combinations of the input vectors. It is inspired by\nexpand.grid(). Compared with expand.grid(), it:\n","ec":"vec_expand_grid(..., .vary = \"slowest\", .name_repair = \"check_unique\", .error_call = current_env())"},{"p":"vctrs","o":"list_unchop","f":"hp_list_unchop","d":"If indices selects every value in x exactly once, in any order, then\nlist_unchop() is the inverse of vec_chop() and the following invariant\nholds:\n","ec":"list_unchop(x, ..., indices = NULL, ptype = NULL, name_spec = NULL, name_repair = c(\"minimal\", \"unique\", \"check_unique\", \"universal\", \"unique_quiet\", \"universal_quiet\"), error_arg = \"x\", error_call = current_env())"},{"p":"vctrs","o":"field","f":"hp_field","d":"A rcrd behaves like a vector, so length(), names(), and $ can\nnot provide access to the fields of the underlying list. These helpers do:\nfields() is equivalent to names(); n_fields() is equivalent to\nlength(); field() is equivalent to $.\n","ec":"field(x, i)"},{"p":"vctrs","o":"obj_is_list","f":"hp_obj_is_list","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"obj_is_list(x)"},{"p":"vctrs","o":"data_frame","f":"hp_data_frame","d":"data_frame() constructs a data frame. It is similar to\nbase::data.frame(), but there are a few notable differences that make it\nmore in line with vctrs principles. The Properties section outlines these.\n","ec":"data_frame(..., .size = NULL, .name_repair = c(\"check_unique\", \"unique\", \"universal\", \"minimal\", \"unique_quiet\", \"universal_quiet\" ), .error_call = current_env())"},{"p":"vctrs","o":"obj_print_footer","f":"hp_obj_print_footer","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_print_footer(x, ...)"},{"p":"vctrs","o":"vec_unique_count","f":"hp_vec_unique_count","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_unique_count(x)"},{"p":"vctrs","o":"vec_default_cast","f":"hp_vec_default_cast","d":"These functions are automatically called when no vec_ptype2() or\nvec_cast() method is implemented for a pair of types.\n","ec":"vec_default_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_in","f":"hp_vec_in","d":"vec_in() returns a logical vector based on whether needle is found in\nhaystack. vec_match() returns an integer vector giving location of\nneedle in haystack, or NA if it's not found.\n","ec":"vec_in(needles, haystack, ..., na_equal = TRUE, needles_arg = \"\", haystack_arg = \"\")"},{"p":"vctrs","o":"vec_proxy","f":"hp_vec_proxy","d":"\n","ec":"vec_proxy(x, ...)"},{"p":"vctrs","o":"vec_split","f":"hp_vec_split","d":"This is a generalisation of split() that can split by any type of vector,\nnot just factors. Instead of returning the keys in the character names,\nthe are returned in a separate parallel vector.\n","ec":"vec_split(x, by)"},{"p":"vctrs","o":"vec_order","f":"hp_vec_order","d":"Order and sort vectors\n","ec":"vec_order(x, ..., direction = c(\"asc\", \"desc\"), na_value = c(\"largest\", \"smallest\"))"},{"p":"vctrs","o":"vec_arith.Date","f":"hp_vec_arith.Date","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_arith.Date(op, x, y, ...)"},{"p":"vctrs","o":"vec_proxy_compare","f":"hp_vec_proxy_compare","d":"vec_proxy_compare() and vec_proxy_order() return proxy objects, i.e.\nan atomic vector or data frame of atomic vectors.\n","ec":"vec_proxy_compare(x, ...)"},{"p":"vctrs","o":"partial_factor","f":"hp_partial_factor","d":"\n","ec":"partial_factor(levels = character())"},{"p":"vctrs","o":"vec_ptype","f":"hp_vec_ptype","d":"vec_ptype() returns the unfinalised prototype of a single vector.\nvec_ptype_common() finds the common type of multiple vectors.\nvec_ptype_show() nicely prints the common type of any number of\ninputs, and is designed for interactive exploration.\n","ec":"vec_ptype(x, ..., x_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_is","f":"hp_vec_is","d":"\n","ec":"vec_is(x, ptype = NULL, size = NULL)"},{"p":"vctrs","o":"vec_rep","f":"hp_vec_rep","d":"Using vec_unrep() and vec_rep_each() together is similar to using\nbase::rle() and base::inverse.rle(). The following invariant shows\nthe relationship between the two functions:\n","ec":"vec_rep(x, times, ..., error_call = current_env(), x_arg = \"x\", times_arg = \"times\")"},{"p":"vctrs","o":"vec_is_empty","f":"hp_vec_is_empty","d":"vec_size(x) returns the size of a vector. vec_is_empty()\nreturns TRUE if the size is zero, FALSE otherwise.\n","ec":"vec_is_empty(x)"},{"p":"vctrs","o":"vec_arith_base","f":"hp_vec_arith_base","d":"This generic provides a common double dispatch mechanism for all infix\noperators (+, -, /, *, ^, %%, %/%, !, &, |). It is used\nto power the default arithmetic and boolean operators for vctrs objects,\novercoming the limitations of the base Ops generic.\n","ec":"vec_arith_base(op, x, y)"},{"p":"vctrs","o":"vec_group_loc","f":"hp_vec_group_loc","d":"\n","ec":"vec_group_loc(x)"},{"p":"vctrs","o":"tib_ptype2","f":"hp_tib_ptype2","d":"df_ptype2() and df_cast() are the two functions you need to\ncall from vec_ptype2() and vec_cast() methods for data frame\nsubclasses. See ?howto-faq-coercion-data-frame.\nTheir main job is to determine the common type of two data frames,\nadding and coercing columns as needed, or throwing an incompatible\ntype error when the columns are not compatible.\n","ec":"tib_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"obj_print_header","f":"hp_obj_print_header","d":"These are constructed to be more easily extensible since you can override\nthe <U+2060>_header()<U+2060>, <U+2060>_data()<U+2060> or <U+2060>_footer()<U+2060> components individually. The\ndefault methods are built on top of format().\n","ec":"obj_print_header(x, ...)"},{"p":"vctrs","o":"df_ptype2","f":"hp_df_ptype2","d":"df_ptype2() and df_cast() are the two functions you need to\ncall from vec_ptype2() and vec_cast() methods for data frame\nsubclasses. See ?howto-faq-coercion-data-frame.\nTheir main job is to determine the common type of two data frames,\nadding and coercing columns as needed, or throwing an incompatible\ntype error when the columns are not compatible.\n","ec":"df_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"is_partial","f":"hp_is_partial","d":"\n","ec":"is_partial(x)"},{"p":"vctrs","o":"vec_ptype2.integer64","f":"hp_vec_ptype2.integer64","d":"A integer64 is a 64 bits integer vector, implemented in the bit64 package.\n","ec":"vec_ptype2.integer64(x, y, ...)"},{"p":"vctrs","o":"vec_cast.Date","f":"hp_vec_cast.Date","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_cast.Date(x, to, ...)"},{"p":"vctrs","o":"vec_ptype2.difftime","f":"hp_vec_ptype2.difftime","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_ptype2.difftime(x, y, ...)"},{"p":"vctrs","o":"vec_slice<-","f":"hp_vec_slice..","d":"This provides a common interface to extracting and modifying observations\nfor all vector types, regardless of dimensionality. It is an analog to [\nthat matches vec_size() instead of length().\n","ec":"vec_slice<-(x, i, value)"},{"p":"vctrs","o":"vec_rep_each","f":"hp_vec_rep_each","d":"Using vec_unrep() and vec_rep_each() together is similar to using\nbase::rle() and base::inverse.rle(). The following invariant shows\nthe relationship between the two functions:\n","ec":"vec_rep_each(x, times, ..., error_call = current_env(), x_arg = \"x\", times_arg = \"times\")"},{"p":"vctrs","o":"vec_cast.data.frame","f":"hp_vec_cast.data.frame","d":"These functions help the base data.frame class fit into the vctrs type system\nby providing coercion and casting functions.\n","ec":"vec_cast.data.frame(x, to, ...)"},{"p":"vctrs","o":"vec_chop","f":"hp_vec_chop","d":"If indices selects every value in x exactly once, in any order, then\nlist_unchop() is the inverse of vec_chop() and the following invariant\nholds:\n","ec":"vec_chop(x, ..., indices = NULL, sizes = NULL)"},{"p":"vctrs","o":"vec_default_ptype2","f":"hp_vec_default_ptype2","d":"These functions are automatically called when no vec_ptype2() or\nvec_cast() method is implemented for a pair of types.\n","ec":"vec_default_ptype2(x, y, ..., x_arg = \"\", y_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_cast.POSIXct","f":"hp_vec_cast.POSIXct","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_cast.POSIXct(x, to, ...)"},{"p":"vctrs","o":"vec_group_rle","f":"hp_vec_group_rle","d":"\n","ec":"vec_group_rle(x)"},{"p":"vctrs","o":"vec_proxy_equal","f":"hp_vec_proxy_equal","d":"Returns a proxy object (i.e. an atomic vector or data frame of atomic\nvectors). For vctrs, this determines the behaviour of == and\n!= (via vec_equal()); unique(), duplicated() (via\nvec_unique() and vec_duplicate_detect()); is.na() and anyNA()\n(via vec_detect_missing()).\n","ec":"vec_proxy_equal(x, ...)"},{"p":"vctrs","o":"stop_incompatible_size","f":"hp_stop_incompatible_size","d":"These functions are called for their side effect of raising\nerrors and warnings.\nThese conditions have custom classes and structures to make\ntesting easier.\n","ec":"stop_incompatible_size(x, y, x_size, y_size, ..., x_arg, y_arg, details = NULL, message = NULL, class = NULL, call = caller_env())"},{"p":"vctrs","o":"vec_set_difference","f":"hp_vec_set_difference","d":"Because these are set operations, these functions only return unique values\nfrom x and y, returned in the order they first appeared in the original\ninput. Names of x and y are retained on the result, but names are always\ntaken from x if the value appears in both inputs.\n","ec":"vec_set_difference(x, y, ..., ptype = NULL, x_arg = \"x\", y_arg = \"y\", error_call = current_env())"},{"p":"vctrs","o":"vec_cast.character","f":"hp_vec_cast.character","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.character(x, to, ...)"},{"p":"vctrs","o":"vec_ptype2.double","f":"hp_vec_ptype2.double","d":"vec_ptype2() defines the coercion hierarchy for a set of related\nvector types. Along with vec_cast(), this generic forms the\nfoundation of type coercions in vctrs.\n","ec":"vec_ptype2.double(x, y, ..., x_arg = \"\", y_arg = \"\")"},{"p":"vctrs","o":"vec_cast.complex","f":"hp_vec_cast.complex","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast.complex(x, to, ...)"},{"p":"vctrs","o":"list_of","f":"hp_list_of","d":"A list_of object is a list where each element has the same type.\nModifying the list with $, [, and [[ preserves the constraint\nby coercing all input items.\n","ec":"list_of(..., .ptype = NULL)"},{"p":"vctrs","o":"vec_cast_common","f":"hp_vec_cast_common","d":"vec_cast() provides directional conversions from one type of\nvector to another. Along with vec_ptype2(), this generic forms\nthe foundation of type coercions in vctrs.\n","ec":"vec_cast_common(..., .to = NULL, .arg = \"\", .call = caller_env())"},{"p":"vctrs","o":"vec_cast.POSIXlt","f":"hp_vec_cast.POSIXlt","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_cast.POSIXlt(x, to, ...)"},{"p":"vctrs","o":"vec_init","f":"hp_vec_init","d":"Initialize a vector\n","ec":"vec_init(x, n = 1L)"},{"p":"vctrs","o":"vec_arith","f":"hp_vec_arith","d":"This generic provides a common double dispatch mechanism for all infix\noperators (+, -, /, *, ^, %%, %/%, !, &, |). It is used\nto power the default arithmetic and boolean operators for vctrs objects,\novercoming the limitations of the base Ops generic.\n","ec":"vec_arith(op, x, y, ...)"},{"p":"vctrs","o":"vec_match","f":"hp_vec_match","d":"vec_in() returns a logical vector based on whether needle is found in\nhaystack. vec_match() returns an integer vector giving location of\nneedle in haystack, or NA if it's not found.\n","ec":"vec_match(needles, haystack, ..., na_equal = TRUE, needles_arg = \"\", haystack_arg = \"\")"},{"p":"vctrs","o":"partial_frame","f":"hp_partial_frame","d":"\n","ec":"partial_frame(...)"},{"p":"vctrs","o":"num_as_location2","f":"hp_num_as_location2","d":"These helpers provide a means of standardizing common indexing\nmethods such as integer, character or logical indexing.\n","ec":"num_as_location2(i, n, ..., negative = c(\"error\", \"ignore\"), missing = c(\"error\", \"propagate\"), arg = caller_arg(i), call = caller_env())"},{"p":"vctrs","o":"stop_incompatible_cast","f":"hp_stop_incompatible_cast","d":"These functions are called for their side effect of raising\nerrors and warnings.\nThese conditions have custom classes and structures to make\ntesting easier.\n","ec":"stop_incompatible_cast(x, to, ..., x_arg, to_arg, details = NULL, message = NULL, class = NULL, call = caller_env())"},{"p":"vctrs","o":"as_list_of","f":"hp_as_list_of","d":"A list_of object is a list where each element has the same type.\nModifying the list with $, [, and [[ preserves the constraint\nby coercing all input items.\n","ec":"as_list_of(x, ...)"},{"p":"vctrs","o":"vec_arith.POSIXct","f":"hp_vec_arith.POSIXct","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"vec_arith.POSIXct(op, x, y, ...)"},{"p":"vctrs","o":"vec_detect_missing","f":"hp_vec_detect_missing","d":"Data frame rows are only considered missing if every element in the row is\nmissing. Similarly, record vector elements are only considered\nmissing if every field in the record is missing. Put another way, rows with\nany missing values are considered incomplete, but\nonly rows with all missing values are considered missing.\n","ec":"vec_detect_missing(x)"},{"p":"vctrs","o":"vec_arith.numeric","f":"hp_vec_arith.numeric","d":"This generic provides a common double dispatch mechanism for all infix\noperators (+, -, /, *, ^, %%, %/%, !, &, |). It is used\nto power the default arithmetic and boolean operators for vctrs objects,\novercoming the limitations of the base Ops generic.\n","ec":"vec_arith.numeric(op, x, y, ...)"},{"p":"vctrs","o":"obj_check_list","f":"hp_obj_check_list","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"obj_check_list(x, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"new_datetime","f":"hp_new_datetime","d":"These function help the base Date, POSIXct, and difftime classes fit\ninto the vctrs type system by providing constructors, coercion functions,\nand casting functions.\n","ec":"new_datetime(x = double(), tzone = \"\")"},{"p":"vctrs","o":"vec_duplicate_any","f":"hp_vec_duplicate_any","d":"In most cases, missing values are not considered to be equal, i.e.\nNA == NA is not TRUE. This behaviour would be unappealing here,\nso these functions consider all NAs to be equal. (Similarly,\nall NaN are also considered to be equal.)\n","ec":"vec_duplicate_any(x)"},{"p":"vctrs","o":"vec_check_list","f":"hp_vec_check_list","d":"\n","ec":"vec_check_list(x, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"new_list_of","f":"hp_new_list_of","d":"Create list_of subclass\n","ec":"new_list_of(x = list(), ptype = logical(), ..., class = character())"},{"p":"vctrs","o":"list_check_all_vectors","f":"hp_list_check_all_vectors","d":"Notably, data frames and S3 record style classes like POSIXlt are not\nconsidered lists.\n","ec":"list_check_all_vectors(x, ..., arg = caller_arg(x), call = caller_env())"},{"p":"vctrs","o":"%0%","f":"hp_X.0.","d":"Use this inline operator when you need to provide a default value for\nempty (as defined by vec_is_empty()) vectors.\n","ec":"%0%(x, y)"},{"p":"vctrs","o":"num_as_location","f":"hp_num_as_location","d":"These helpers provide a means of standardizing common indexing\nmethods such as integer, character or logical indexing.\n","ec":"num_as_location(i, n, ..., missing = c(\"propagate\", \"remove\", \"error\"), negative = c(\"invert\", \"error\", \"ignore\"), oob = c(\"error\", \"remove\", \"extend\"), zero = c(\"remove\", \"error\", \"ignore\"), arg = caller_arg(i), call = caller_env())"},{"p":"vctrs","o":"df_cast","f":"hp_df_cast","d":"df_ptype2() and df_cast() are the two functions you need to\ncall from vec_ptype2() and vec_cast() methods for data frame\nsubclasses. See ?howto-faq-coercion-data-frame.\nTheir main job is to determine the common type of two data frames,\nadding and coercing columns as needed, or throwing an incompatible\ntype error when the columns are not compatible.\n","ec":"df_cast(x, to, ..., x_arg = \"\", to_arg = \"\", call = caller_env())"},{"p":"vctrs","o":"vec_as_location2","f":"hp_vec_as_location2","d":"These helpers provide a means of standardizing common indexing\nmethods such as integer, character or logical indexing.\n","ec":"vec_as_location2(i, n, names = NULL, ..., missing = c(\"error\", \"propagate\"), arg = caller_arg(i), call = caller_env())"},{"p":"vctrs","o":"vec_type_common","f":"hp_vec_type_common","d":"\n","ec":"vec_type_common(..., .ptype = NULL)"},{"p":"vctrs","o":"new_vctr","f":"hp_new_vctr","d":"This abstract class provides a set of useful default methods that makes it\nconsiderably easier to get started with a new S3 vector class. See\nvignette(\"s3-vector\") to learn how to use it to create your own S3\nvector classes.\n","ec":"new_vctr(.data, ..., class = character(), inherit_base_type = NULL)"},{"p":"viridisLite","o":"plasma","f":"hp_plasma","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"plasma(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"inferno","f":"hp_inferno","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"inferno(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"viridis.map","f":"hp_viridis.map","d":"A data set containing the RGB values of the color maps included\nin the package. These are:\n","ec":""},{"p":"viridisLite","o":"magma","f":"hp_magma","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"magma(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"viridisMap","f":"hp_viridisMap","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"viridisMap(n = 256, alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\")"},{"p":"viridisLite","o":"rocket","f":"hp_rocket","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"rocket(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"cividis","f":"hp_cividis","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"cividis(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"mako","f":"hp_mako","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"mako(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"turbo","f":"hp_turbo","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"turbo(n, alpha = 1, begin = 0, end = 1, direction = 1)"},{"p":"viridisLite","o":"viridis","f":"hp_viridis","d":"This function creates a vector of n equally spaced colors\nalong the selected color map.\n","ec":"viridis(n, alpha = 1, begin = 0, end = 1, direction = 1, option = \"D\")"},{"p":"vroom","o":"vroom_write","f":"hp_vroom_write","d":"Write a data frame to a delimited file\n","ec":"vroom_write(x, file, delim = \"\\t\", eol = \"\\n\", na = \"NA\", col_names = !append, append = FALSE, quote = c(\"needed\", \"all\", \"none\"), escape = c(\"double\", \"backslash\", \"none\"), bom = FALSE, num_threads = vroom_threads(), progress = vroom_progress(), path = deprecated())"},{"p":"vroom","o":"vroom_example","f":"hp_vroom_example","d":"vroom comes bundled with a number of sample files in\nits 'inst/extdata' directory. Use vroom_examples() to list all the\navailable examples and vroom_example() to retrieve the path to one\nexample.\n","ec":"vroom_example(path)"},{"p":"vroom","o":"gen_datetime","f":"hp_gen_datetime","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_datetime(n, min = as.POSIXct(\"2001-01-01\"), max = as.POSIXct(\"2021-01-01\"), tz = \"UTC\", ...)"},{"p":"vroom","o":"col_datetime","f":"hp_col_datetime","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_datetime(format = \"\", ...)"},{"p":"vroom","o":"gen_character","f":"hp_gen_character","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_character(n, min = 5, max = 25, values = c(letters, LETTERS, 0:9), ...)"},{"p":"vroom","o":"vroom_lines","f":"hp_vroom_lines","d":"vroom_lines() is similar to readLines(), however it reads the lines\nlazily like vroom(), so operations like length(), head(), tail() and sample()\ncan be done much more efficiently without reading all the data into R.\n","ec":"vroom_lines(file, n_max = Inf, skip = 0, na = character(), skip_empty_rows = FALSE, locale = default_locale(), altrep = TRUE, altrep_opts = deprecated(), num_threads = vroom_threads(), progress = vroom_progress())"},{"p":"vroom","o":"cols","f":"hp_cols","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"cols(..., .default = col_guess(), .delim = NULL)"},{"p":"vroom","o":"col_time","f":"hp_col_time","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_time(format = \"\", ...)"},{"p":"vroom","o":"cols_only","f":"hp_cols_only","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"cols_only(...)"},{"p":"vroom","o":"gen_time","f":"hp_gen_time","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_time(n, min = 0, max = hms::hms(days = 1), fractional = FALSE, ...)"},{"p":"vroom","o":"gen_name","f":"hp_gen_name","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_name(n)"},{"p":"vroom","o":"gen_double","f":"hp_gen_double","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_double(n, f = stats::rnorm, ...)"},{"p":"vroom","o":"cols_condense","f":"hp_cols_condense","d":"cols_condense() takes a spec object and condenses its definition by setting\nthe default column type to the most frequent type and only listing columns\nwith a different type.\n","ec":"cols_condense(x)"},{"p":"vroom","o":"vroom_write_lines","f":"hp_vroom_write_lines","d":"Write lines to a file\n","ec":"vroom_write_lines(x, file, eol = \"\\n\", na = \"NA\", append = FALSE, num_threads = vroom_threads())"},{"p":"vroom","o":"vroom_progress","f":"hp_vroom_progress","d":"By default, vroom shows progress bars. However, progress reporting is\nsuppressed if any of the following conditions hold:\n","ec":"vroom_progress()"},{"p":"vroom","o":"vroom_altrep","f":"hp_vroom_altrep","d":"vroom_altrep() can be used directly as input to the altrep\nargument of vroom().\n","ec":"vroom_altrep(which = NULL)"},{"p":"vroom","o":"fwf_empty","f":"hp_fwf_empty","d":"Read a fixed width file into a tibble\n","ec":"fwf_empty(file, skip = 0, col_names = NULL, comment = \"\", n = 100L)"},{"p":"vroom","o":"gen_date","f":"hp_gen_date","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_date(n, min = as.Date(\"2001-01-01\"), max = as.Date(\"2021-01-01\"), ...)"},{"p":"vroom","o":"fwf_cols","f":"hp_fwf_cols","d":"Read a fixed width file into a tibble\n","ec":"fwf_cols(...)"},{"p":"vroom","o":"fwf_widths","f":"hp_fwf_widths","d":"Read a fixed width file into a tibble\n","ec":"fwf_widths(widths, col_names = NULL)"},{"p":"vroom","o":"date_names","f":"hp_date_names","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>https://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c(\"AM\", \"PM\"))"},{"p":"vroom","o":"col_skip","f":"hp_col_skip","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_skip(...)"},{"p":"vroom","o":"col_factor","f":"hp_col_factor","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_factor(levels = NULL, ordered = FALSE, include_na = FALSE, ...)"},{"p":"vroom","o":"gen_number","f":"hp_gen_number","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_number(n, f = stats::rnorm, ...)"},{"p":"vroom","o":"vroom_examples","f":"hp_vroom_examples","d":"vroom comes bundled with a number of sample files in\nits 'inst/extdata' directory. Use vroom_examples() to list all the\navailable examples and vroom_example() to retrieve the path to one\nexample.\n","ec":"vroom_examples(pattern = NULL)"},{"p":"vroom","o":"date_names_lang","f":"hp_date_names_lang","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>https://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names_lang(language)"},{"p":"vroom","o":"col_character","f":"hp_col_character","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_character(...)"},{"p":"vroom","o":"vroom_altrep_opts","f":"hp_vroom_altrep_opts","d":"\nThis function is deprecated in favor of vroom_altrep().\n","ec":"vroom_altrep_opts(which = NULL)"},{"p":"vroom","o":"vroom_format","f":"hp_vroom_format","d":"This is equivalent to vroom_write(), but instead of writing to\ndisk, it returns a string. It is primarily useful for examples and for\ntesting.\n","ec":"vroom_format(x, delim = \"\\t\", eol = \"\\n\", na = \"NA\", col_names = TRUE, escape = c(\"double\", \"backslash\", \"none\"), quote = c(\"needed\", \"all\", \"none\"), bom = FALSE, num_threads = vroom_threads())"},{"p":"vroom","o":"gen_tbl","f":"hp_gen_tbl","d":"This is useful for benchmarking, but also for bug reports when you cannot\nshare the real dataset.\n","ec":"gen_tbl(rows, cols = NULL, col_types = NULL, locale = default_locale(), missing = 0)"},{"p":"vroom","o":"vroom","f":"hp_vroom","d":"Read a delimited file into a tibble\n","ec":"vroom(file, delim = NULL, col_names = TRUE, col_types = NULL, col_select = NULL, id = NULL, skip = 0, n_max = Inf, na = c(\"\", \"NA\"), quote = \"\\\"\", comment = \"\", skip_empty_rows = TRUE, trim_ws = TRUE, escape_double = TRUE, escape_backslash = FALSE, locale = default_locale(), guess_max = 100, altrep = TRUE, altrep_opts = deprecated(), num_threads = vroom_threads(), progress = vroom_progress(), show_col_types = NULL, .name_repair = \"unique\")"},{"p":"vroom","o":"locale","f":"hp_locale","d":"A locale object tries to capture all the defaults that can vary between\ncountries. You set the locale in once, and the details are automatically\npassed on down to the columns parsers. The defaults have been chosen to\nmatch R (i.e. US English) as closely as possible. See\nvignette(\"locales\") for more details.\n","ec":"locale(date_names = \"en\", date_format = \"%AD\", time_format = \"%AT\", decimal_mark = \".\", grouping_mark = \",\", tz = \"UTC\", encoding = \"UTF-8\")"},{"p":"vroom","o":"col_date","f":"hp_col_date","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_date(format = \"\", ...)"},{"p":"vroom","o":"col_double","f":"hp_col_double","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_double(...)"},{"p":"vroom","o":"col_integer","f":"hp_col_integer","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_integer(...)"},{"p":"vroom","o":"col_number","f":"hp_col_number","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_number(...)"},{"p":"vroom","o":"gen_factor","f":"hp_gen_factor","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_factor(n, levels = NULL, ordered = FALSE, num_levels = gen_integer(1L, 1L, 25L), ...)"},{"p":"vroom","o":"gen_integer","f":"hp_gen_integer","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_integer(n, min = 1L, max = .Machine$integer.max, prob = NULL, ...)"},{"p":"vroom","o":"col_guess","f":"hp_col_guess","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_guess(...)"},{"p":"vroom","o":"as.col_spec","f":"hp_as.col_spec","d":"This is most useful for generating a specification using the short form or coercing from a list.\n","ec":"as.col_spec(x)"},{"p":"vroom","o":"fwf_positions","f":"hp_fwf_positions","d":"Read a fixed width file into a tibble\n","ec":"fwf_positions(start, end = NULL, col_names = NULL)"},{"p":"vroom","o":"col_big_integer","f":"hp_col_big_integer","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_big_integer(...)"},{"p":"vroom","o":"problems","f":"hp_problems","d":"vroom will only fail to parse a file if the file is invalid in a way that is\nunrecoverable. However there are a number of non-fatal problems that you\nmight want to know about. You can retrieve a data frame of these problems\nwith this function.\n","ec":"problems(x = .Last.value, lazy = FALSE)"},{"p":"vroom","o":"date_names_langs","f":"hp_date_names_langs","d":"When parsing dates, you often need to know how weekdays of the week and\nmonths are represented as text. This pair of functions allows you to either\ncreate your own, or retrieve from a standard list. The standard list is\nderived from ICU (<U+2060>https://site.icu-project.org<U+2060>) via the stringi package.\n","ec":"date_names_langs()"},{"p":"vroom","o":"spec","f":"hp_spec","d":"cols_condense() takes a spec object and condenses its definition by setting\nthe default column type to the most frequent type and only listing columns\nwith a different type.\n","ec":"spec(x)"},{"p":"vroom","o":"col_logical","f":"hp_col_logical","d":"cols() includes all columns in the input data, guessing the column types\nas the default. cols_only() includes only the columns you explicitly\nspecify, skipping the rest.\n","ec":"col_logical(...)"},{"p":"vroom","o":"output_column","f":"hp_output_column","d":"This is a generic function that applied to each column before it is saved\nto disk. It provides a hook for S3 classes that need special handling.\n","ec":"output_column(x)"},{"p":"vroom","o":"gen_logical","f":"hp_gen_logical","d":"Generate individual vectors of the types supported by vroom\n","ec":"gen_logical(n, ...)"},{"p":"vroom","o":"guess_type","f":"hp_guess_type","d":"Guess the type of a vector\n","ec":"guess_type(x, na = c(\"\", \"NA\"), locale = default_locale(), guess_integer = FALSE)"},{"p":"vroom","o":"default_locale","f":"hp_default_locale","d":"A locale object tries to capture all the defaults that can vary between\ncountries. You set the locale in once, and the details are automatically\npassed on down to the columns parsers. The defaults have been chosen to\nmatch R (i.e. US English) as closely as possible. See\nvignette(\"locales\") for more details.\n","ec":"default_locale()"},{"p":"vroom","o":"vroom_str","f":"hp_vroom_str","d":"Similar to str() but with more information for Altrep objects.\n","ec":"vroom_str(x)"},{"p":"vroom","o":"vroom_fwf","f":"hp_vroom_fwf","d":"Read a fixed width file into a tibble\n","ec":"vroom_fwf(file, col_positions = fwf_empty(file, skip, n = guess_max), col_types = NULL, col_select = NULL, id = NULL, locale = default_locale(), na = c(\"\", \"NA\"), comment = \"\", skip_empty_rows = TRUE, trim_ws = TRUE, skip = 0, n_max = Inf, guess_max = 100, altrep = TRUE, altrep_opts = deprecated(), num_threads = vroom_threads(), progress = vroom_progress(), show_col_types = NULL, .name_repair = \"unique\")"},{"p":"waldo","o":"compare","f":"hp_compare","d":"This compares two R objects, identifying the key differences. It:\n","ec":"compare(x, y, ..., x_arg = \"old\", y_arg = \"new\", tolerance = NULL, max_diffs = if (in_ci()) Inf else 10, ignore_srcref = TRUE, ignore_attr = \"waldo_opts\", ignore_encoding = TRUE, ignore_function_env = FALSE, ignore_formula_env = FALSE, list_as_map = FALSE, quote_strings = TRUE)"},{"p":"waldo","o":"compare_proxy","f":"hp_compare_proxy","d":"Use this generic to override waldo's default comparison if you need to\noverride the defaults (typically because your object stores data in an\nexternal pointer).\n","ec":"compare_proxy(x, path = \"x\")"},{"p":"webr","o":"library_shim","f":"hp_library_shim","d":"When loading R packages using library_shim() or require_shim(), if a\npackage is missing an attempt will be made to download and install the\nmissing package from the default webR binary repo.\n","ec":"library_shim(pkg, ..., show_menu = getOption(\"webr.show_menu\"))"},{"p":"webr","o":"eval_js","f":"hp_eval_js","d":"This function evaluates the given character string as JavaScript code. The\nresult is returned as an integer.\n","ec":"eval_js(code)"},{"p":"webr","o":"syncfs","f":"hp_syncfs","d":"Uses the Emscripten filesystem API to synchronise all mounted virtual\nfilesystems with their backing storage, where it exists. The populate\nargument controls the direction of the synchronisation between Emscripten's\ninternal data and the file system's persistent store.\n","ec":"syncfs(populate)"},{"p":"webr","o":"mount","f":"hp_mount","d":"Uses the Emscripten filesystem API to mount a filesystem object onto a given\ndirectory in the virtual filesystem. The mountpoint will be created if it\ndoes not already exist.\n","ec":"mount(mountpoint, source, type = \"workerfs\")"},{"p":"webr","o":"unmount","f":"hp_unmount","d":"Uses the Emscripten filesystem API to mount a filesystem object onto a given\ndirectory in the virtual filesystem. The mountpoint will be created if it\ndoes not already exist.\n","ec":"unmount(mountpoint)"},{"p":"webr","o":"global_prompt_install","f":"hp_global_prompt_install","d":"When enabled, packageNotFoundError errors invoke a global handler to\ndownload missing R packages from the default webR binary repo.\n","ec":"global_prompt_install()"},{"p":"webr","o":"viewer_install","f":"hp_viewer_install","d":"When enabled, the R viewer option is set so that a request to display\na URL generates a webR output message. The request is forwarded to the main\nthread to be handled by the application loading webR.\n","ec":"viewer_install()"},{"p":"webr","o":"canvas_purge","f":"hp_canvas_purge","d":"canvas_cache() returns an integer vector containing the current canvas\ncache IDs.\n","ec":"canvas_purge()"},{"p":"webr","o":"pager_install","f":"hp_pager_install","d":"When enabled, the R pager function is replaced so that a request to display\na file's contents instead generates a webR output message. The request is\nforwarded to the main thread to be handled by the application loading webR.\n","ec":"pager_install()"},{"p":"webr","o":"canvas_install","f":"hp_canvas_install","d":"Set R options so that the webR canvas graphics device is used as the default\ngraphics device for new plots.\n","ec":"canvas_install(...)"},{"p":"webr","o":"install","f":"hp_install","d":"Install one or more packages from a webR binary package repo\n","ec":"install(packages, repos = NULL, info = NULL, lib = NULL, quiet = FALSE, mount = TRUE)"},{"p":"webr","o":"test_package","f":"hp_test_package","d":"This function runs R package examples and tests. The implementation is based\non tools::testInstalledPackage(), with modifications for webR where the\nsystem() function cannot be used.\n","ec":"test_package(pkg)"},{"p":"webr","o":"canvas_cache","f":"hp_canvas_cache","d":"canvas_cache() returns an integer vector containing the current canvas\ncache IDs.\n","ec":"canvas_cache()"},{"p":"webr","o":"canvas","f":"hp_canvas","d":"A graphics device that generates HTML canvas API calls and executes them on\nthe worker thread using a JavaScript OffscreenCanvas. Throughout plotting,\nand if capture is FALSE, JavaScript ImageBitmap objects are transmitted\nto the main webR thread for display.\n","ec":"canvas(width = 504, height = 504, pointsize = 12, bg = \"transparent\", capture = FALSE, ...)"},{"p":"webr","o":"shim_install","f":"hp_shim_install","d":"Replace base R functions with implementations\nthat work in the webR environment.\n","ec":"shim_install()"},{"p":"webr","o":"canvas_destroy","f":"hp_canvas_destroy","d":"canvas_cache() returns an integer vector containing the current canvas\ncache IDs.\n","ec":"canvas_destroy(ids)"},{"p":"webr","o":"require_shim","f":"hp_require_shim","d":"When loading R packages using library_shim() or require_shim(), if a\npackage is missing an attempt will be made to download and install the\nmissing package from the default webR binary repo.\n","ec":"require_shim(pkg, ..., show_menu = getOption(\"webr.show_menu\"))"},{"p":"webr","o":"eval_r","f":"hp_eval_r","d":"This function evaluates the provided R code, call, or expression with various\nsettings in place to configure behavior. The function is intended to be used\nby the webR evalR API, rather than invoked directly by the end user.\n","ec":"eval_r(expr, conditions = TRUE, streams = FALSE, autoprint = FALSE, handlers = TRUE, env = parent.frame())"},{"p":"withr","o":"with_makevars","f":"hp_with_makevars","d":"Temporarily change contents of an existing Makevars file.\n","ec":"with_makevars(new, code, path = makevars_user(), assignment = c(\"=\", \":=\", \"?=\", \"+=\"))"},{"p":"withr","o":"local_postscript","f":"hp_local_postscript","d":"Temporarily use a graphics device.\n","ec":"local_postscript(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_libpaths","f":"hp_local_libpaths","d":"Temporarily change library paths.\n","ec":"local_libpaths(new = list(), action = \"replace\", .local_envir = parent.frame())"},{"p":"withr","o":"local_package","f":"hp_local_package","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"local_package(package, pos = 2, lib.loc = NULL, character.only = TRUE, logical.return = FALSE, warn.conflicts = FALSE, quietly = TRUE, verbose = getOption(\"verbose\"), .local_envir = parent.frame())"},{"p":"withr","o":"with_png","f":"hp_with_png","d":"Temporarily use a graphics device.\n","ec":"with_png(new, code, ...)"},{"p":"withr","o":"with_jpeg","f":"hp_with_jpeg","d":"Temporarily use a graphics device.\n","ec":"with_jpeg(new, code, ...)"},{"p":"withr","o":"with_libpaths","f":"hp_with_libpaths","d":"Temporarily change library paths.\n","ec":"with_libpaths(new, code, action = \"replace\")"},{"p":"withr","o":"with_temp_libpaths","f":"hp_with_temp_libpaths","d":"Temporarily prepend a new temporary directory to the library paths.\n","ec":"with_temp_libpaths(code, action = \"prefix\")"},{"p":"withr","o":"set_makevars","f":"hp_set_makevars","d":"You probably want with_makevars() instead of this function.\n","ec":"set_makevars(variables, old_path = makevars_user(), new_path = tempfile(), assignment = c(\"=\", \":=\", \"?=\", \"+=\"))"},{"p":"withr","o":"local_rng_version","f":"hp_local_rng_version","d":"Change the RNG version and restore it afterwards.\n","ec":"local_rng_version(version, .local_envir = parent.frame())"},{"p":"withr","o":"makevars_user","f":"hp_makevars_user","d":"Shim for tools::makevars_user()\n","ec":"makevars_user()"},{"p":"withr","o":"local_seed","f":"hp_local_seed","d":"with_seed() runs code with a specific random seed and resets it afterwards.\n","ec":"local_seed(seed, .local_envir = parent.frame(), .rng_kind = NULL, .rng_normal_kind = NULL, .rng_sample_kind = NULL)"},{"p":"withr","o":"local_dir","f":"hp_local_dir","d":"Temporarily change the current working directory.\n","ec":"local_dir(new = list(), .local_envir = parent.frame())"},{"p":"withr","o":"local_svg","f":"hp_local_svg","d":"Temporarily use a graphics device.\n","ec":"local_svg(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_namespace","f":"hp_local_namespace","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"local_namespace(package, .local_envir = parent.frame(), warn.conflicts = FALSE)"},{"p":"withr","o":"with_collate","f":"hp_with_collate","d":"Temporarily change collation order by changing the value of the\nLC_COLLATE locale.\n","ec":"with_collate(new, code)"},{"p":"withr","o":"with_environment","f":"hp_with_environment","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"with_environment(env, code, pos = 2L, name = format(env), warn.conflicts = FALSE)"},{"p":"withr","o":"with_","f":"hp_with_","d":"These are constructors for with_... or local_... functions.\nThey are only needed if you want to alter some global state which is not\ncovered by the existing with_... functions, see withr\nfor an overview.\n","ec":"with_(set, reset = set, get = NULL, ..., envir = parent.frame(), new = TRUE)"},{"p":"withr","o":"local_options","f":"hp_local_options","d":"Temporarily change global options.\n","ec":"local_options(.new = list(), ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_collate","f":"hp_local_collate","d":"Temporarily change collation order by changing the value of the\nLC_COLLATE locale.\n","ec":"local_collate(new = list(), .local_envir = parent.frame())"},{"p":"withr","o":"local_cairo_pdf","f":"hp_local_cairo_pdf","d":"Temporarily use a graphics device.\n","ec":"local_cairo_pdf(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_bmp","f":"hp_local_bmp","d":"Temporarily use a graphics device.\n","ec":"local_bmp(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"with_file","f":"hp_with_file","d":"Create files, which are then automatically removed afterwards.\n","ec":"with_file(file, code)"},{"p":"withr","o":"deferred_run","f":"hp_deferred_run","d":"Similar to on.exit(), but allows one to attach\nan expression to be evaluated when exiting any frame currently\non the stack. This provides a nice mechanism for scoping side\neffects for the duration of a function's execution.\n","ec":"deferred_run(envir = parent.frame())"},{"p":"withr","o":"local_message_sink","f":"hp_local_message_sink","d":"Temporarily divert output to a file via sink().  For\nsinks of type message, an error is raised if such a sink is already\nactive.\n","ec":"local_message_sink(new = list(), append = FALSE, .local_envir = parent.frame())"},{"p":"withr","o":"local_locale","f":"hp_local_locale","d":"Temporarily change locale settings.\n","ec":"local_locale(.new = list(), ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_path","f":"hp_local_path","d":"Temporarily change the system search path.\n","ec":"local_path(new = list(), action = c(\"prefix\", \"suffix\", \"replace\"), .local_envir = parent.frame())"},{"p":"withr","o":"with_preserve_seed","f":"hp_with_preserve_seed","d":"with_seed() runs code with a specific random seed and resets it afterwards.\n","ec":"with_preserve_seed(code)"},{"p":"withr","o":"local_pdf","f":"hp_local_pdf","d":"Temporarily use a graphics device.\n","ec":"local_pdf(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"with_locale","f":"hp_with_locale","d":"Temporarily change locale settings.\n","ec":"with_locale(new, code)"},{"p":"withr","o":"with_pdf","f":"hp_with_pdf","d":"Temporarily use a graphics device.\n","ec":"with_pdf(new, code, ...)"},{"p":"withr","o":"defer_parent","f":"hp_defer_parent","d":"Similar to on.exit(), but allows one to attach\nan expression to be evaluated when exiting any frame currently\non the stack. This provides a nice mechanism for scoping side\neffects for the duration of a function's execution.\n","ec":"defer_parent(expr, priority = c(\"first\", \"last\"))"},{"p":"withr","o":"local_tempdir","f":"hp_local_tempdir","d":"Temporarily create a file or directory, which will automatically deleted\nonce you're finished with it.\n","ec":"local_tempdir(pattern = \"file\", tmpdir = tempdir(), fileext = \"\", .local_envir = parent.frame(), clean = TRUE)"},{"p":"withr","o":"local_envvar","f":"hp_local_envvar","d":"Temporarily change system environment variables.\n","ec":"local_envvar(.new = list(), ..., action = \"replace\", .local_envir = parent.frame())"},{"p":"withr","o":"with_db_connection","f":"hp_with_db_connection","d":"Connections to Database Management Systems which automatically disconnect. In\nparticular connections which are created with DBI::dbConnect() and closed\nwith DBI::dbDisconnect().\n","ec":"with_db_connection(con, code)"},{"p":"withr","o":"with_message_sink","f":"hp_with_message_sink","d":"Temporarily divert output to a file via sink().  For\nsinks of type message, an error is raised if such a sink is already\nactive.\n","ec":"with_message_sink(new, code, append = FALSE)"},{"p":"withr","o":"with_namespace","f":"hp_with_namespace","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"with_namespace(package, code, warn.conflicts = FALSE)"},{"p":"withr","o":"local_environment","f":"hp_local_environment","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"local_environment(env, pos = 2L, name = format(env), warn.conflicts = FALSE, .local_envir = parent.frame())"},{"p":"withr","o":"local_output_sink","f":"hp_local_output_sink","d":"Temporarily divert output to a file via sink().  For\nsinks of type message, an error is raised if such a sink is already\nactive.\n","ec":"local_output_sink(new = list(), append = FALSE, split = FALSE, .local_envir = parent.frame())"},{"p":"withr","o":"with_postscript","f":"hp_with_postscript","d":"Temporarily use a graphics device.\n","ec":"with_postscript(new, code, ...)"},{"p":"withr","o":"local_file","f":"hp_local_file","d":"Create files, which are then automatically removed afterwards.\n","ec":"local_file(.file, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_temp_libpaths","f":"hp_local_temp_libpaths","d":"Temporarily prepend a new temporary directory to the library paths.\n","ec":"local_temp_libpaths(action = \"prefix\", .local_envir = parent.frame())"},{"p":"withr","o":"local_cairo_ps","f":"hp_local_cairo_ps","d":"Temporarily use a graphics device.\n","ec":"local_cairo_ps(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_db_connection","f":"hp_local_db_connection","d":"Connections to Database Management Systems which automatically disconnect. In\nparticular connections which are created with DBI::dbConnect() and closed\nwith DBI::dbDisconnect().\n","ec":"local_db_connection(con, .local_envir = parent.frame())"},{"p":"withr","o":"with_cairo_ps","f":"hp_with_cairo_ps","d":"Temporarily use a graphics device.\n","ec":"with_cairo_ps(new, code, ...)"},{"p":"withr","o":"with_cairo_pdf","f":"hp_with_cairo_pdf","d":"Temporarily use a graphics device.\n","ec":"with_cairo_pdf(new, code, ...)"},{"p":"withr","o":"global_defer","f":"hp_global_defer","d":"This function is mostly internal. It is exported to be called in\nstandalone defer() implementations to defer expressions from the\nglobal environment.\n","ec":"global_defer(expr, priority = c(\"first\", \"last\"))"},{"p":"withr","o":"with_path","f":"hp_with_path","d":"Temporarily change the system search path.\n","ec":"with_path(new, code, action = c(\"prefix\", \"suffix\", \"replace\"))"},{"p":"withr","o":"local_tiff","f":"hp_local_tiff","d":"Temporarily use a graphics device.\n","ec":"local_tiff(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"with_tempdir","f":"hp_with_tempdir","d":"Temporarily create a file or directory, which will automatically deleted\nonce you're finished with it.\n","ec":"with_tempdir(code, clean = TRUE, pattern = \"file\", tmpdir = tempdir(), fileext = \"\")"},{"p":"withr","o":"local_tempfile","f":"hp_local_tempfile","d":"Temporarily create a file or directory, which will automatically deleted\nonce you're finished with it.\n","ec":"local_tempfile(new = NULL, lines = NULL, envir = parent.frame(), .local_envir = parent.frame(), pattern = \"file\", tmpdir = tempdir(), fileext = \"\")"},{"p":"withr","o":"local_preserve_seed","f":"hp_local_preserve_seed","d":"with_seed() runs code with a specific random seed and resets it afterwards.\n","ec":"local_preserve_seed(.local_envir = parent.frame())"},{"p":"withr","o":"with_language","f":"hp_with_language","d":"Temporarily change the language used for translations.\n","ec":"with_language(lang, code)"},{"p":"withr","o":"local_","f":"hp_local_","d":"These are constructors for with_... or local_... functions.\nThey are only needed if you want to alter some global state which is not\ncovered by the existing with_... functions, see withr\nfor an overview.\n","ec":"local_(set, reset = set, get = NULL, ..., envir = parent.frame(), new = TRUE, dots = FALSE)"},{"p":"withr","o":"with_svg","f":"hp_with_svg","d":"Temporarily use a graphics device.\n","ec":"with_svg(new, code, ...)"},{"p":"withr","o":"with_dir","f":"hp_with_dir","d":"Temporarily change the current working directory.\n","ec":"with_dir(new, code)"},{"p":"withr","o":"with_package","f":"hp_with_package","d":"with_package() attaches a package to the search path, executes the code, then\nremoves the package from the search path. The package namespace is not\nunloaded however. with_namespace() does the same thing, but attaches the\npackage namespace to the search path, so all objects (even unexported ones) are also\navailable on the search path.\n","ec":"with_package(package, code, pos = 2, lib.loc = NULL, character.only = TRUE, logical.return = FALSE, warn.conflicts = FALSE, quietly = TRUE, verbose = getOption(\"verbose\"))"},{"p":"withr","o":"with_xfig","f":"hp_with_xfig","d":"Temporarily use a graphics device.\n","ec":"with_xfig(new, code, ...)"},{"p":"withr","o":"with_rng_version","f":"hp_with_rng_version","d":"Change the RNG version and restore it afterwards.\n","ec":"with_rng_version(version, code)"},{"p":"withr","o":"with_output_sink","f":"hp_with_output_sink","d":"Temporarily divert output to a file via sink().  For\nsinks of type message, an error is raised if such a sink is already\nactive.\n","ec":"with_output_sink(new, code, append = FALSE, split = FALSE)"},{"p":"withr","o":"local_connection","f":"hp_local_connection","d":"R file connections which are automatically closed.\n","ec":"local_connection(con, .local_envir = parent.frame())"},{"p":"withr","o":"with_options","f":"hp_with_options","d":"Temporarily change global options.\n","ec":"with_options(new, code)"},{"p":"withr","o":"local_makevars","f":"hp_local_makevars","d":"Temporarily change contents of an existing Makevars file.\n","ec":"local_makevars(.new = list(), ..., .path = makevars_user(), .assignment = c(\"=\", \":=\", \"?=\", \"+=\"), .local_envir = parent.frame())"},{"p":"withr","o":"local_par","f":"hp_local_par","d":"Temporarily change graphics parameters.\n","ec":"local_par(.new = list(), ..., no.readonly = FALSE, .local_envir = parent.frame())"},{"p":"withr","o":"local_timezone","f":"hp_local_timezone","d":"Change the time zone, and restore it afterwards.\n","ec":"local_timezone(tz, .local_envir = parent.frame())"},{"p":"withr","o":"with_bmp","f":"hp_with_bmp","d":"Temporarily use a graphics device.\n","ec":"with_bmp(new, code, ...)"},{"p":"withr","o":"with_envvar","f":"hp_with_envvar","d":"Temporarily change system environment variables.\n","ec":"with_envvar(new, code, action = \"replace\")"},{"p":"withr","o":"with_timezone","f":"hp_with_timezone","d":"Change the time zone, and restore it afterwards.\n","ec":"with_timezone(tz, code)"},{"p":"withr","o":"local_jpeg","f":"hp_local_jpeg","d":"Temporarily use a graphics device.\n","ec":"local_jpeg(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"with_par","f":"hp_with_par","d":"Temporarily change graphics parameters.\n","ec":"with_par(new, code, no.readonly = FALSE)"},{"p":"withr","o":"with_connection","f":"hp_with_connection","d":"R file connections which are automatically closed.\n","ec":"with_connection(con, code)"},{"p":"withr","o":"local_png","f":"hp_local_png","d":"Temporarily use a graphics device.\n","ec":"local_png(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_xfig","f":"hp_local_xfig","d":"Temporarily use a graphics device.\n","ec":"local_xfig(new, ..., .local_envir = parent.frame())"},{"p":"withr","o":"local_language","f":"hp_local_language","d":"Temporarily change the language used for translations.\n","ec":"local_language(lang, .local_envir = parent.frame())"},{"p":"withr","o":"defer","f":"hp_defer","d":"Similar to on.exit(), but allows one to attach\nan expression to be evaluated when exiting any frame currently\non the stack. This provides a nice mechanism for scoping side\neffects for the duration of a function's execution.\n","ec":"defer(expr, envir = parent.frame(), priority = c(\"first\", \"last\"))"},{"p":"withr","o":"with_tempfile","f":"hp_with_tempfile","d":"Temporarily create a file or directory, which will automatically deleted\nonce you're finished with it.\n","ec":"with_tempfile(new, code, envir = parent.frame(), .local_envir = parent.frame(), pattern = \"file\", tmpdir = tempdir(), fileext = \"\")"},{"p":"withr","o":"deferred_clear","f":"hp_deferred_clear","d":"Similar to on.exit(), but allows one to attach\nan expression to be evaluated when exiting any frame currently\non the stack. This provides a nice mechanism for scoping side\neffects for the duration of a function's execution.\n","ec":"deferred_clear(envir = parent.frame())"},{"p":"withr","o":"with_seed","f":"hp_with_seed","d":"with_seed() runs code with a specific random seed and resets it afterwards.\n","ec":"with_seed(seed, code, .rng_kind = NULL, .rng_normal_kind = NULL, .rng_sample_kind = NULL)"},{"p":"withr","o":"with_tiff","f":"hp_with_tiff","d":"Temporarily use a graphics device.\n","ec":"with_tiff(new, code, ...)"},{"p":"yaml","o":"as.yaml","f":"hp_as.yaml","d":"Convert an R object into a YAML string\n","ec":"as.yaml(x, line.sep = c(\"\\n\", \"\\r\\n\", \"\\r\"), indent = 2, omap = FALSE, column.major = TRUE, unicode = TRUE, precision = getOption(\"digits\"), indent.mapping.sequence = FALSE, handlers = NULL)"},{"p":"yaml","o":"write_yaml","f":"hp_write_yaml","d":"Write the YAML representation of an R object to a file\n","ec":"write_yaml(x, file, fileEncoding = \"UTF-8\", ...)"},{"p":"yaml","o":"yaml.load","f":"hp_yaml.load","d":"Parse a YAML string and return R objects.\n","ec":"yaml.load(string, as.named.list = TRUE, handlers = NULL, error.label = NULL, eval.expr = getOption(\"yaml.eval.expr\", FALSE), merge.precedence = c(\"order\", \"override\"), merge.warning = FALSE)"},{"p":"yaml","o":"yaml.load_file","f":"hp_yaml.load_file","d":"Parse a YAML string and return R objects.\n","ec":"yaml.load_file(input, error.label, readLines.warn = TRUE, ...)"},{"p":"yaml","o":"verbatim_logical","f":"hp_verbatim_logical","d":"A yaml handler function that causes logical vectors to emit \ntrue/false instead of yes/no values.\n","ec":"verbatim_logical(x)"},{"p":"yaml","o":"read_yaml","f":"hp_read_yaml","d":"Read a YAML document from a file and create an R object from it\n","ec":"read_yaml(file, fileEncoding = \"UTF-8\", text, error.label, readLines.warn = TRUE, ...)"},{"p":"zip","o":"zipr","f":"hp_zipr","d":"zip() creates a new zip archive file.\n","ec":"zipr(zipfile, files, recurse = TRUE, compression_level = 9, include_directories = TRUE, root = \".\", mode = c(\"cherry-pick\", \"mirror\"))"},{"p":"zip","o":"unzip","f":"hp_unzip","d":"unzip() always restores modification times of the extracted files and\ndirectories.\n","ec":"unzip(zipfile, files = NULL, overwrite = TRUE, junkpaths = FALSE, exdir = \".\")"},{"p":"zip","o":"zip_process","f":"hp_zip_process","d":"zip_process() returns an R6 class that represents a zip process.\nIt is implemented as a subclass of processx::process.\n","ec":"zip_process()"},{"p":"zip","o":"zip_list","f":"hp_zip_list","d":"List Files in a 'zip' Archive\n","ec":"zip_list(zipfile)"},{"p":"zip","o":"unzip_process","f":"hp_unzip_process","d":"unzip_process() returns an R6 class that represents an unzip process.\nIt is implemented as a subclass of processx::process.\n","ec":"unzip_process()"},{"p":"zip","o":"zipr_append","f":"hp_zipr_append","d":"zip() creates a new zip archive file.\n","ec":"zipr_append(zipfile, files, recurse = TRUE, compression_level = 9, include_directories = TRUE, root = \".\", mode = c(\"cherry-pick\", \"mirror\"))"},{"p":"zip","o":"zip_append","f":"hp_zip_append","d":"zip() creates a new zip archive file.\n","ec":"zip_append(zipfile, files, recurse = TRUE, compression_level = 9, include_directories = TRUE, root = \".\", mode = c(\"mirror\", \"cherry-pick\"))"},{"p":"zip","o":"deflate","f":"hp_deflate","d":"Compress a raw GZIP stream\n","ec":"deflate(buffer, level = 6L, pos = 1L, size = NULL)"},{"p":"zip","o":"zip","f":"hp_zip","d":"zip() creates a new zip archive file.\n","ec":"zip(zipfile, files, recurse = TRUE, compression_level = 9, include_directories = TRUE, root = \".\", mode = c(\"mirror\", \"cherry-pick\"))"},{"p":"zip","o":"inflate","f":"hp_inflate","d":"Uncompress a raw GZIP stream\n","ec":"inflate(buffer, pos = 1L, size = NULL)"}]